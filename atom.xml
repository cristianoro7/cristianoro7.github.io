<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Desperado</title>
  <subtitle>Desperado</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-05T03:13:54.711Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Desperado</name>
    <email>424494431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大话数据结构-线性表</title>
    <link href="http://yoursite.com/2017/03/05/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/03/05/大话数据结构-线性表/</id>
    <published>2017-03-05T03:13:54.711Z</published>
    <updated>2017-03-05T03:13:54.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><ul>
<li>零个或多个数据元素的有限序列</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>顺序储存结构</li>
<li>链式储存结构<ul>
<li>单链表</li>
<li>静态链表</li>
<li>循环链表</li>
<li>双向链表</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="顺序储存结构"><a href="#顺序储存结构" class="headerlink" title="顺序储存结构"></a>顺序储存结构</h3><ul>
<li>宏定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></div><div class="line"><span class="comment">//静态链表的最大空间</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_MAXSIZE 1000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</div></pre></td></tr></table></figure>
<ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 顺序储存结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">&#125; SqList;</div></pre></td></tr></table></figure>
<h4 id="获得元素"><a href="#获得元素" class="headerlink" title="获得元素"></a>获得元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">getElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length || L.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = L.data[i - <span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><h5 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h5><ul>
<li>如果插入位置不合理，抛出异常</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或者动态扩容</li>
<li>从最后一个元素开始向前遍历到第ｉ的位置，分别将他们向后移动一个位置</li>
<li>将要插入的元素填入到位置i处</li>
<li>表长 + 1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">insert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (L.length == MAXSIZE) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (L.length &gt;= i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--) &#123;</div><div class="line">            L.data[j + <span class="number">1</span>] = L.data[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    L.data[i - <span class="number">1</span>] = e;</div><div class="line">    L.length++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>如果删除的位置不合理，抛出异常</li>
<li>去出删除的元素</li>
<li>从删除的元素开始遍历到最后一个元素，分别将他们都向前移动一个位置<br>*表长 - 1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">deleteElem</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    e = L.data[i - <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(i &lt; L.length) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &lt;= L.length; ++j) &#123;</div><div class="line">            L.data[j] = L.data[j + <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    L.length--;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最好情况下，如果插入的元素是最后一个，或者删除的元素是最后一个，意味着元素不用移动，那么时间复杂度为O(1)。</li>
<li>最坏情况，如果插入的元素在第一个，或者删除的元素在第一个，那么意味着全部元素将要向前或者向后移动，时间复杂度为O(n)。</li>
<li>平均情况： 时间复杂度为O(n)</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>快速存取表中的任一元素</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>插入和删除需要大量移动元素</li>
<li>当线性表长度变化较大时，难以确定储存空间</li>
</ul>
<h3 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h3><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 链式储存结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ElemType e;</div><div class="line">    <span class="keyword">struct</span> Node *next;</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">&#125; Node, *LinkList;</div></pre></td></tr></table></figure>
<h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><h5 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一个指针ｐ指向链表第一个结点，初始化ｊ从１开始 </li>
<li>当ｊ&lt;ｉ时，就遍历链表，让ｐ的指针向后移动，不断指向下一个结点，ｊ累加１</li>
<li>若到链表末尾ｐ为空，则说明第ｉ个结点不存在</li>
<li>否则查找成功，返回结点ｐ的数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lGetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    LinkList p;</div><div class="line">    p = L-&gt;next;</div><div class="line">    j = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!p || j &gt; i) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = p-&gt;e;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line">```　</div><div class="line"></div><div class="line">#### 单链表的插入</div><div class="line"></div><div class="line">##### 算法思路：</div><div class="line">* 声明一指针指向链表头结点，初始化ｊ从１开始</div><div class="line">* 当ｊ&lt;ｉ时，遍历链表，让ｐ的指针向后移动，不断指向下一个结点，ｊ累加１</div><div class="line">* 若到链表末尾为空，则说明第ｉ的结点不存在</div><div class="line">* 否则查找成功，在系统中生成一个空的结点ｓ</div><div class="line">* 将数据元素ｅ赋值给ｓ－&gt;data</div><div class="line">* 进行单链表插入操作</div><div class="line"></div><div class="line">```<span class="function">c</span></div><div class="line">status <span class="title">lInsertElem</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> &#123;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">    LinkList p;</div><div class="line">    p = L-&gt;next;</div><div class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//第i个结点不存在</span></div><div class="line">    <span class="keyword">if</span>(!p || j &gt; i) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    LinkList s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    s-&gt;e = e;</div><div class="line">    s-&gt;next = p-&gt;next;</div><div class="line">    p-&gt;next = s;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><h5 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一指针指向链表头结点，初始化ｊ从１开始</li>
<li>当ｊ&lt;ｉ时，遍历链表，让ｐ的指针向后移动，不断指向下一个结点，ｊ累加１</li>
<li>若到链表末尾为空，则说明第ｉ的结点不存在</li>
<li>若查找成功，将欲删除的结点p-&gt;next赋值给ｑ</li>
<li>删除结点</li>
<li>将ｑ结点中的数据赋值给ｅ并返回</li>
<li>释放ｑ结点</li>
<li>返回成功</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lDeleteElem</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">    LinkList p, q;</div><div class="line"></div><div class="line">    p = L;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i) &#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j &gt; i) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    q = p-&gt;next;</div><div class="line">    p-&gt;next = q-&gt;next;</div><div class="line">    e = q-&gt;e;</div><div class="line">    <span class="built_in">free</span>(q);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建单链表"><a href="#创建单链表" class="headerlink" title="创建单链表"></a>创建单链表</h4><h5 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一指针ｐ和计数器变量ｉ</li>
<li>初始化空链表Ｌ</li>
<li>让空链表的头结点指向ＮＵＬＬ，即建立头结点</li>
<li>循环创建结点</li>
<li>头插法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lCreateLinkListHead</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    LinkList p;</div><div class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == L) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    L-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</div><div class="line">        p = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == p) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        p-&gt;e = <span class="number">0</span>;</div><div class="line">        <span class="comment">//插到表头</span></div><div class="line">        p-&gt;next = L-&gt;next;</div><div class="line">        L-&gt;next = p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>尾插法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lCreateLinkListTail</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    LinkList p,r;</div><div class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    L-&gt;next;</div><div class="line">    r = L; <span class="comment">//表尾</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        p = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        r-&gt;next = p;</div><div class="line">        r = p;</div><div class="line">    &#125;</div><div class="line">    r-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表的整体删除"><a href="#单链表的整体删除" class="headerlink" title="单链表的整体删除"></a>单链表的整体删除</h4><h5 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一个结点ｐ和ｑ</li>
<li>将第一个结点赋值给ｐ</li>
<li>循环<ul>
<li>将下一个结点赋值给ｑ</li>
<li>释放ｑ</li>
<li>将ｑ赋值给ｐ</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lClearLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</div><div class="line">    LinkList p, q;</div><div class="line">    p = L-&gt;next;</div><div class="line">    <span class="keyword">while</span>(p) &#123;</div><div class="line">        q = p-&gt;next;</div><div class="line">        <span class="built_in">free</span>(p);</div><div class="line">        p = q;</div><div class="line">    &#125;</div><div class="line">    L-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h4><ul>
<li>顺序储存结构用一端连续的储存单元储存元素</li>
<li>单链表用链式储存元素</li>
</ul>
<h4 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li>顺序结构：O(1)</li>
<li>链式储存结构O(n)</li>
</ul>
<h5 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h5><ul>
<li>顺序储存结构需要平均移动毕表长的一半，时间为O(n)</li>
<li>单链表在线出某个位置指针后，插入和删除为O(1)</li>
</ul>
<h5 id="空间性能"><a href="#空间性能" class="headerlink" title="空间性能"></a>空间性能</h5><ul>
<li>顺序结构需要预分配储存空间，分大了浪费，分小了溢出</li>
<li>单链表可以实时分配空间</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><ul>
<li>用数组描述的链表，是为了解决一个语言中没有指针的问题</li>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用数组实现的静态链表</div><div class="line"> */</div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">     ElemType data;</div><div class="line">     <span class="keyword">int</span> cur; <span class="comment">//游标,为0时表示无指向</span></div><div class="line">     <span class="keyword">int</span> length;</div><div class="line"> &#125; StaticLinkList[STATIC_MAXSIZE];</div></pre></td></tr></table></figure>
<ul>
<li>通常把未被使用的数组称为备用链表</li>
<li>数组的第一个元素的cur存放备用链表的第一个结点下标</li>
<li>数组最后一个元素的cur存放第一个元素的下标，相当与头结点</li>
<li>初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">initStaticLinkList</span><span class="params">(StaticLinkList &amp;L)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; STATIC_MAXSIZE - <span class="number">1</span>; ++i) &#123;</div><div class="line">        L[i].cur = i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    L[STATIC_MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;</div><div class="line">    L-&gt;length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">freeIndex</span><span class="params">(StaticLinkList &amp;L, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    L[k].cur = L[<span class="number">0</span>].cur; <span class="comment">//把第一个元素从cur赋值给要删除的cur分量</span></div><div class="line">    L[<span class="number">0</span>].cur = k;</div><div class="line">&#125;</div><div class="line"><span class="function">status <span class="title">staticDelete</span><span class="params">(StaticLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> k = STATIC_MAXSIZE - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; ++j) &#123;</div><div class="line">        k = L[k].cur;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    j = L[k].cur;</div><div class="line">    L[k].cur = L[j].cur;</div><div class="line">    freeIndex(L, j);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">staticInsert</span><span class="params">(StaticLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = STATIC_MAXSIZE - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> j = mallocFreeIndex(L);</div><div class="line">    <span class="keyword">if</span>(j) &#123;</div><div class="line">        L[j].data = e;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; ++l) &#123;</div><div class="line">            k = L[k].cur;</div><div class="line">        &#125;</div><div class="line">        L[j].cur = L[k].cur;</div><div class="line">        L[k].cur = j;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">status <span class="title">mallocFreeIndex</span><span class="params">(StaticLinkList &amp;L)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = L[<span class="number">0</span>].cur; <span class="comment">//当前数组第一个元素的cur值，就是返回第一个备用空闲下表</span></div><div class="line">    <span class="keyword">if</span>(L[<span class="number">0</span>].cur) &#123;</div><div class="line">        L[<span class="number">0</span>].cur = L[i].cur; <span class="comment">//设置下一个空闲下表分量</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>在插入和删除元素时，只需移动修改下标，从而改进顺序储存结构中插入和删除元素需要大量移动元素的缺点</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没有解决难以确定表长的缺点</li>
<li>失去了顺序储存结构中随机存取元素的特性</li>
</ul>
<blockquote>
<p>以上笔记来源《大话数据结构》中<br><a href="https://github.com/cristianoro7/data-structure-practice" target="_blank" rel="external">源码</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性表的定义&quot;&gt;&lt;a href=&quot;#线性表的定义&quot; class=&quot;headerlink&quot; title=&quot;线性表的定义&quot;&gt;&lt;/a&gt;线性表的定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;零个或多个数据元素的有限序列&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;顺序储存结构&lt;/li&gt;
&lt;li&gt;链式储存结构&lt;ul&gt;
&lt;li&gt;单链表&lt;/li&gt;
&lt;li&gt;静态链表&lt;/li&gt;
&lt;li&gt;循环链表&lt;/li&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="http://yoursite.com/2017/03/03/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/03/03/java基础/</id>
    <published>2017-03-03T15:20:56.338Z</published>
    <updated>2017-03-03T15:20:56.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="使用-连接字符串"><a href="#使用-连接字符串" class="headerlink" title="使用+连接字符串"></a>使用+连接字符串</h4><ul>
<li>使用+连接字符串每次都会构建一个新的对象，在需要频繁拼接字符串的场景时，会比较耗时和浪费空间，因为String创建后就不可以再改变，因此+ 操作是线程安全的</li>
</ul>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><ul>
<li>该类可以解决String拼接字符串时出现的问题，但是StringBuilder线程不安全。</li>
</ul>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><ul>
<li>StringBuilder可以保证线程安全，但是也因此效率变得低</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>如果只需要简单的拼接字符串的话，可以直接使用+号拼接</li>
<li>如果需要频繁拼接而且无需考虑线程安全的，可以使用StringBuilder</li>
<li>如果需要频繁拼接但要考虑到线程安全的话，可以使用StringBuffer<a id="more"></a>
<h3 id="对象与克隆"><a href="#对象与克隆" class="headerlink" title="对象与克隆"></a>对象与克隆</h3></li>
</ul>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul>
<li>只能对类中的基本数据进行拷贝，类中的对象还是引用原对象</li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul>
<li>通过重写clone使得类中的子对象也能进行克隆</li>
<li>深拷贝步骤：<ul>
<li>实现Cloneable接口（该接口只是拷贝的标记接口）</li>
<li>使用public访问修饰符重新定义clone方法</li>
</ul>
</li>
</ul>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><ul>
<li>异常对象都派生于Throwable类</li>
<li>Throwable分为Error和Exception</li>
</ul>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ul>
<li>Error层次结构描述了java运行时系统内部错误和资源耗尽错误，这种情况很少出现</li>
</ul>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><ul>
<li>Exception派生出两个分支，一个是RuntimeException，另外一个是其他异常</li>
<li>划分规则：由程序导致的是RuntimeExeption；而程序本身没有问题，但由像I/O错误这类问题导致的异常属于其他异常</li>
</ul>
<h4 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h4><ul>
<li>java语言规范：将派生于Error或者RuntimeException类的所有异常称为未检查异常，所有其他异常称为已检查异常。</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>final通常指的是不可改变的, 不想改变的原因往往出于两种原因：设计和效率</li>
<li>final可能使用到的情况：数据、方法和类</li>
</ul>
<h4 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h4><ul>
<li>一个既是static又是final的数据只占一段不能改变的内存空间，如果final定义的变量是引用类型的话，表明该引用一定被初始化指向一个对象后，就不能再更改引用，但是可以对象自身是可以被修改的</li>
</ul>
<h4 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h4><ul>
<li>当参数被声明为final时，意味着你不能修改其值，只能读取，这一特性主要用来向匿名内部类传递数据</li>
</ul>
<h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><ul>
<li>使用final方法有两个原因：<ul>
<li>把方法锁定，以防止任何继承类来修改它的含义，这是处于设计的考虑</li>
</ul>
</li>
<li>出于效率的考虑（由于虚拟机的优化，通常已经不需要final来进行优化）</li>
</ul>
<h4 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a>final和private关键字</h4><ul>
<li>类中所有private方法都隐式地指定为final。由于无法取用private，也就无法覆盖它</li>
</ul>
<h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><ul>
<li>当一个类被定义为final时，就表明你不打算继承该类了，这是出于设计或者安全的考虑<blockquote>
<p>参考资料：java核心技术，java编程思想</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;h4 id=&quot;使用-连接字符串&quot;&gt;&lt;a href=&quot;#使用-连接字符串&quot; class=&quot;headerlink&quot; title=&quot;使用+连接字符串&quot;&gt;&lt;/a&gt;使用+连接字符串&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用+连接字符串每次都会构建一个新的对象，在需要频繁拼接字符串的场景时，会比较耗时和浪费空间，因为String创建后就不可以再改变，因此+ 操作是线程安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;StringBuilder&quot;&gt;&lt;a href=&quot;#StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;StringBuilder&quot;&gt;&lt;/a&gt;StringBuilder&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;该类可以解决String拼接字符串时出现的问题，但是StringBuilder线程不安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;StringBuffer&quot;&gt;&lt;a href=&quot;#StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer&quot;&gt;&lt;/a&gt;StringBuffer&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;StringBuilder可以保证线程安全，但是也因此效率变得低&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果只需要简单的拼接字符串的话，可以直接使用+号拼接&lt;/li&gt;
&lt;li&gt;如果需要频繁拼接而且无需考虑线程安全的，可以使用StringBuilder&lt;/li&gt;
&lt;li&gt;如果需要频繁拼接但要考虑到线程安全的话，可以使用StringBuffer
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-确认访问用户的身份-笔记</title>
    <link href="http://yoursite.com/2017/02/21/%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E7%9A%84%E8%BA%AB%E4%BB%BD-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/02/21/确认访问用户的身份-笔记/</id>
    <published>2017-02-21T07:31:23.465Z</published>
    <updated>2017-02-21T07:31:23.465Z</updated>
    
    <content type="html"><![CDATA[<p>﻿### HTTP使用的认证方式</p>
<ul>
<li>BASIC认证(基本认证)</li>
<li>DIGEST(摘要认证)</li>
<li>SSL客户端认证</li>
<li>FormBase认证(基于表单认证)</li>
</ul>
<h4 id="BASIC认证步骤"><a href="#BASIC认证步骤" class="headerlink" title="BASIC认证步骤"></a>BASIC认证步骤</h4><p><img src="/uploads/图解HTTP/确保Web安全的HTTPS01.jpg" alt=""></p>
<a id="more"></a>
<p>步骤1:当请求的资源需要 BASIC 认证时,服务器会随状态码 401Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式(BASIC) 及 Request-URI 安全域字符串(realm)。</p>
<p>步骤2:接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成,两者中间以冒号(:)连接后,再经过 Base64 编码处理。</p>
<p>步骤3:接收到包含首部字段 Authorization 请求的服务器,会对认证信息的正确性进行验证。如验证通过,则返回一条包含 Request-URI资源的响应。</p>
<ul>
<li>BASIC 认证虽然采用 Base64 编码方式,但这不是加密处理。不需要任何附加信息即可对其解码。换言之,由于明文解码后就是用户 ID和密码,在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中,如果被人窃听,被盗的可能性极高。</li>
<li>另外,除此之外想再进行一次 BASIC 认证时,一般的浏览器却无法实现认证注销操作,这也是问题之一。</li>
<li>BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用</li>
</ul>
<h4 id="DIGEST-认证"><a href="#DIGEST-认证" class="headerlink" title="DIGEST 认证"></a>DIGEST 认证</h4><ul>
<li>DIGEST 认证同样使用质询 / 响应的方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS02.jpg" alt=""></p>
<ul>
<li>DIGEST 认证的认证步骤</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS03.jpg" alt=""></p>
<p>步骤 1: 请求需认证的资源时,服务器会随着状态码 401Authorization Required,返 回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码(随机数,nonce)。首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式,但实际内容依赖服务器的具体实现。</p>
<p>步骤 2: 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。</p>
<p>步骤 3: 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。</p>
<h4 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a>SSL 客户端认证</h4><ul>
<li>如果用户 ID 和密码被盗,就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。</li>
<li>为达到 SSL 客户端认证的目的,需要事先将客户端证书分发给客户端,且客户端必须安装此证书。</li>
</ul>
<p>步骤1: 接收到需要认证资源的请求,服务器会发送 CertificateRequest 报文,要求客户端提供客户端证书。</p>
<p>步骤 2: 用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p>
<p>步骤 3: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通信。</p>
<ul>
<li>SSL客户端认证一般会结合表单一起认证</li>
</ul>
<h4 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h4><ul>
<li>基于表单认证的标准规范尚未有定论,一般会使用 Cookie 来管理Session(会话)。</li>
<li>为了弥补 HTTP 协议中不存在的状态管理功能,我们会使用 Cookie 来管理 Session</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS04.jpg" alt=""></p>
<p>步骤1: 客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务器。而这时,会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。</p>
<p>步骤 2: 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证,然后把用户的认证状态与Session ID 绑定后记录在服务器端。</p>
<p>另外,为减轻跨站脚本攻击(XSS)造成的损失,建议事先在 Cookie内加上 httponly 属性。</p>
<p>步骤 3: 客户端接收到从服务器端发来的 Session ID 后,会将其作为Cookie 保存在本地。下次向服务器发送请求时,浏览器会自动发送Cookie,所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</p>
<ul>
<li>由于服务端没有如何保存用户的密码,因此,一种安全的保存方法是,先利用给密码加盐(salt) 1 的方式增加额外信息,再使用散列(hash)函数计算出散列值后保存。</li>
<li>salt 其实就是由服务器随机生成的一个字符串,但是要保证长度足够长,并且是真正随机生成的。然后把它和密码字符串相连接(前后都可以)生成散列值。当两个用户使用了同一个密码时,由于随机生成的 salt 值不同,对应的散列值也将是不同的。这样一来,很大程度上减少了密码特征,攻击者也就很难利用自己手中的密码特征库进行破解。</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;﻿### HTTP使用的认证方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BASIC认证(基本认证)&lt;/li&gt;
&lt;li&gt;DIGEST(摘要认证)&lt;/li&gt;
&lt;li&gt;SSL客户端认证&lt;/li&gt;
&lt;li&gt;FormBase认证(基于表单认证)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;BASIC认证步骤&quot;&gt;&lt;a href=&quot;#BASIC认证步骤&quot; class=&quot;headerlink&quot; title=&quot;BASIC认证步骤&quot;&gt;&lt;/a&gt;BASIC认证步骤&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/uploads/图解HTTP/确保Web安全的HTTPS01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-报文信息-笔记</title>
    <link href="http://yoursite.com/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E6%8A%A5%E6%96%87%E4%BF%A1%E6%81%AF-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/02/17/图解HTTP-报文信息-笔记/</id>
    <published>2017-02-17T14:21:11.008Z</published>
    <updated>2017-02-17T14:21:11.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h3><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><ul>
<li>用于HTTP协议交互的信息被称为报文</li>
<li>请求端（客户端）的HTTP报文称为请求报文</li>
<li>相应端（服务器端）的HTTP报文称为响应报文</li>
<li>HTTP报文分为报文首部和报文主体（不一定有报文主体）</li>
</ul>
<h5 id="HTTP报文结构："><a href="#HTTP报文结构：" class="headerlink" title="HTTP报文结构："></a>HTTP报文结构：</h5><p><img src="/uploads/图解HTTP/ 01.jpg" alt=""></p>
<a id="more"></a>
<h4 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h4><h5 id="请求报文和响应报文结构："><a href="#请求报文和响应报文结构：" class="headerlink" title="请求报文和响应报文结构："></a>请求报文和响应报文结构：</h5><p><img src="/uploads/图解HTTP/02.jpg" alt=""></p>
<h5 id="响应的实例"><a href="#响应的实例" class="headerlink" title="响应的实例"></a>响应的实例</h5><p><img src="/uploads/图解HTTP/03.jpg" alt=""></p>
<h4 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h4><ul>
<li>HTT在传输数据时可以直接将数据原貌传输，但也可以在传输的过程中通过编码来提升传输效率。虽然编码传输可以提升传输效率，但是编码的过程是由计算机来完成，所以会比较消耗计算机的ｃｐｕ资源</li>
</ul>
<h5 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h5><ul>
<li>报文（Message）：是 HTTP 通信中的基本单位,由 8 位组字节流(octet sequence,其中 octet 为 8 个比特)组成,通过 HTTP 通信传输。</li>
<li>实体（entity）：作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成。</li>
<li>通常情况下，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化时，才导致它和报文主体产生差异。</li>
</ul>
<h5 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h5><ul>
<li>内容编码指明应用在实体内容上的编码，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</li>
</ul>
<p><img src="/uploads/图解HTTP/04.jpg" alt=""></p>
<ul>
<li>内容编码的常用格式：<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>ide ntity（不进行编码）</li>
</ul>
</li>
</ul>
<h5 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h5><ul>
<li>把实体分块的功能称为分块传输功能（Chunked Transfer Coding）。该功能适应于大数据量传输时，可以逐步的显示内容，不必让用户等待太久</li>
</ul>
<p><img src="/uploads/图解HTTP/05.jpg" alt=""></p>
<h5 id="发送多种数据的多部分集合"><a href="#发送多种数据的多部分集合" class="headerlink" title="发送多种数据的多部分集合"></a>发送多种数据的多部分集合</h5><ul>
<li>发送报文的主体内包含多类型实体</li>
<li>多部分对象集合包含的对象如下：<ul>
<li>multipart/form-data:在 Web 表单文件上传时使用。</li>
<li>multipart/byteranges:状态码 206(Partial Content,部分内容)响应报文包含了多个范围的内容时使用。</li>
</ul>
</li>
</ul>
<h5 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h5><ul>
<li>范围请求指的是对一份字节资源，进行部分范围内的请求</li>
</ul>
<p><img src="/uploads/图解HTTP/06.jpg" alt=""></p>
<ul>
<li>执行请求时可以根据Range首部字段来指定字节的范围：<ul>
<li>5001~10 000 字节<br><code>Range: bytes=5001-10000</code></li>
</ul>
</li>
<li>请求范围的返回状态码为206 Partial Content的响应报文。</li>
<li>另外,对于多重范围的范围请求,响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</li>
<li>如果服务器端无法响应范围请求,则会返回状态码 200 OK 和完整的实体内容。</li>
</ul>
<h5 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h5><ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP报文内的HTTP信息&quot;&gt;&lt;a href=&quot;#HTTP报文内的HTTP信息&quot; class=&quot;headerlink&quot; title=&quot;HTTP报文内的HTTP信息&quot;&gt;&lt;/a&gt;HTTP报文内的HTTP信息&lt;/h3&gt;&lt;h4 id=&quot;HTTP报文&quot;&gt;&lt;a href=&quot;#HTTP报文&quot; class=&quot;headerlink&quot; title=&quot;HTTP报文&quot;&gt;&lt;/a&gt;HTTP报文&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;用于HTTP协议交互的信息被称为报文&lt;/li&gt;
&lt;li&gt;请求端（客户端）的HTTP报文称为请求报文&lt;/li&gt;
&lt;li&gt;相应端（服务器端）的HTTP报文称为响应报文&lt;/li&gt;
&lt;li&gt;HTTP报文分为报文首部和报文主体（不一定有报文主体）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;HTTP报文结构：&quot;&gt;&lt;a href=&quot;#HTTP报文结构：&quot; class=&quot;headerlink&quot; title=&quot;HTTP报文结构：&quot;&gt;&lt;/a&gt;HTTP报文结构：&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/uploads/图解HTTP/ 01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Picasso中值得学习的技巧</title>
    <link href="http://yoursite.com/2017/02/17/Picasso%E4%B8%AD%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/02/17/Picasso中值得学习的技巧/</id>
    <published>2017-02-17T14:12:33.277Z</published>
    <updated>2017-02-17T14:12:33.277Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Picasso中的线程池"><a href="#Picasso中的线程池" class="headerlink" title="Picasso中的线程池"></a>Picasso中的线程池</h4><ul>
<li>Picasso中的线程池主要是对对网络状态进行了监听,并且包装了一个FutureTask实现请求的优先级比较。</li>
</ul>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h5><ul>
<li>首先在Picasso中,定义了一个优先级枚举类型:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * The priority of a request.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@see</span> RequestCreator#priority(Priority)</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</div><div class="line">    LOW,</div><div class="line">    NORMAL,</div><div class="line">    HIGH</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<a id="more"></a> 
<ul>
<li>上面的priority就是请求优先级的类型。</li>
<li><p>有了优先级,我们就可以在创建Request的时候这只设置优先等级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Set the priority of this request.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * This will affect the order in which the requests execute but does not guarantee it.</div><div class="line">   * By default, all requests have &#123;<span class="doctag">@link</span> Priority#NORMAL&#125; priority, except for</div><div class="line">   * &#123;<span class="doctag">@link</span> #fetch()&#125; requests, which have &#123;<span class="doctag">@link</span> Priority#LOW&#125; priority by default.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> RequestCreator <span class="title">priority</span><span class="params">(Priority priority)</span> </span>&#123;</div><div class="line">    data.priority(priority);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过阅读上面的代码,我们知道可以这样来设置请求的优先等级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(url)</div><div class="line">                .priority(Picasso.Priority.HIGH)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>需要主要的是,虽然设置了优先等级,但是并不是绝对的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hunter.future = service.submit(hunter);</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到,BitmapHunter被提交到了Picasso的线程池,我们进去其中的sumbit(BitmapHunter)方法中看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">    PicassoFutureTask ftask = <span class="keyword">new</span> PicassoFutureTask((BitmapHunter) task);</div><div class="line">    execute(ftask);</div><div class="line">    <span class="keyword">return</span> ftask;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>传进来的BitmapHunter被包装成了一个PicassoFutureTask,在PicassoFutureTask中重写compareTo(PicassoFutureTask other)实现优先级的比较:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PicassoFutureTask other)</span> </span>&#123;</div><div class="line">      Picasso.Priority p1 = hunter.getPriority();</div><div class="line">      Picasso.Priority p2 = other.hunter.getPriority();</div><div class="line">      <span class="comment">/* High-priority requests are "lesser" so they are sorted to the front.*/</span></div><div class="line">      <span class="comment">/* Equal priorities are sorted by sequence number to provide FIFO ordering.*/</span></div><div class="line">      <span class="keyword">return</span> (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们再看看线程池中对网络状态的监听:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustThreadCount</span><span class="params">(NetworkInfo info)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span> || !info.isConnectedOrConnecting()) &#123;</div><div class="line">      setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span> (info.getType()) &#123;</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_WIFI:</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_WIMAX:</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_ETHERNET:</div><div class="line">        setThreadCount(<span class="number">4</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_MOBILE:</div><div class="line">        <span class="keyword">switch</span> (info.getSubtype()) &#123;</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_LTE:  <span class="comment">/* 4G*/</span></div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_HSPAP:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EHRPD:</div><div class="line">            setThreadCount(<span class="number">3</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_UMTS: <span class="comment">/*3G*/</span></div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_CDMA:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_0:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_A:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_B:</div><div class="line">            setThreadCount(<span class="number">2</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_GPRS: <span class="comment">/* 2G*/</span></div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EDGE:</div><div class="line">            setThreadCount(<span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">default</span>:</div><div class="line">            setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>adjustThreadCount方法中根据传进来的NetworkInfo来判断当前手机网络的状态,分别在4G,3G,2G的情况下调整线程数</p>
</li>
<li>传进来的网络状态是在创建分发器的时候注册的广播:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);</div><div class="line">   <span class="keyword">this</span>.receiver = <span class="keyword">new</span> NetworkBroadcastReceiver(<span class="keyword">this</span>);</div><div class="line">   receiver.register();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Picasso中加载适应图片的宽高"><a href="#Picasso中加载适应图片的宽高" class="headerlink" title="Picasso中加载适应图片的宽高"></a>Picasso中加载适应图片的宽高</h4><ul>
<li><p>我们知道,当我们加载图片时,如果图片的大小与我们ImageView的规格不符合的时候,加载出来的图片的效果是很差的。因此,Picasso也提供了方法给我们调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(url)</div><div class="line">               .fit()</div><div class="line">                .priority(Picasso.Priority.HIGH)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>我们只要添加fit方法时,就能够实现宽高自适应。接下来我们看看Picasso是怎么实现这个功能。</p>
</li>
<li><p>既然是添加了fit()方法,那么我们先进入fit方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Internal use only. Used by &#123;<span class="doctag">@link</span> DeferredRequestCreator&#125;. */</span></div><div class="line">  <span class="function">RequestCreator <span class="title">fit</span><span class="params">()</span> </span>&#123;</div><div class="line">    deferred = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中仅仅只是对deferred = true; 在上一篇的源码分析中,在into(ImageView)中,有deferred出现的身影,我们来看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (deferred) &#123;</div><div class="line">      <span class="keyword">if</span> (data.hasSize()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with resize."</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> width = target.getWidth();</div><div class="line">      <span class="keyword">int</span> height = target.getHeight();</div><div class="line">      <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">          setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">        &#125;</div><div class="line">        picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      data.resize(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = createRequest(started);</div><div class="line">    String requestKey = createKey(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        picasso.cancelRequest(target);</div><div class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">"from "</span> + MEMORY);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">          callback.onSuccess();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">      setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Action action =</div><div class="line">        <span class="keyword">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</div><div class="line">            errorDrawable, requestKey, tag, callback, noFade);</div><div class="line">    picasso.enqueueAndSubmit(action);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面的代码节选自 into(ImageView)方法,deferred默认值是false,因此默认情况下是不会进入if语句块的,但是当我们调用了fit()后,deferred被设置为true,所以当我们调用into是时候,会进入if语句块。接着,调用了<code>picasso.defer(target, new DeferredRequestCreator(this, target, callback));</code></p>
</li>
<li><p>我们进入DeferredRequestCreator对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeferredRequestCreator</span> <span class="keyword">implements</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnPreDrawListener</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">final</span> RequestCreator creator;</div><div class="line">  <span class="keyword">final</span> WeakReference&lt;ImageView&gt; target;</div><div class="line">  Callback callback;</div><div class="line"></div><div class="line">  <span class="meta">@TestOnly</span> DeferredRequestCreator(RequestCreator creator, ImageView target) &#123;</div><div class="line">    <span class="keyword">this</span>(creator, target, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  DeferredRequestCreator(RequestCreator creator, ImageView target, Callback callback) &#123;</div><div class="line">    <span class="keyword">this</span>.creator = creator;</div><div class="line">    <span class="keyword">this</span>.target = <span class="keyword">new</span> WeakReference&lt;ImageView&gt;(target);</div><div class="line">    <span class="keyword">this</span>.callback = callback;</div><div class="line">    target.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    ViewTreeObserver vto = target.getViewTreeObserver();</div><div class="line">    <span class="keyword">if</span> (!vto.isAlive()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> width = target.getWidth();</div><div class="line">    <span class="keyword">int</span> height = target.getHeight();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vto.removeOnPreDrawListener(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>.creator.unfit().resize(width, height).into(target, callback);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    ViewTreeObserver vto = target.getViewTreeObserver();</div><div class="line">    <span class="keyword">if</span> (!vto.isAlive()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    vto.removeOnPreDrawListener(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>DeferredRequestCreator实现了ViewTreeObserver.OnPreDrawListener接口,拿到ImageView宽高后,再接调用<code>this.creator.unfit().resize(width, height).into(target, callback);</code></p>
</li>
<li>unfit()方法中仅仅对deferred设置为false,当再次调用into的方法时,也就不会进入if语句块,接着调用了resize(width, height)将得到ImageView的宽高设置到请求中,最后调用into进行重新加载。</li>
</ul>
<h4 id="Picasso中-通过设置Tag对图片进行生命周期的管理"><a href="#Picasso中-通过设置Tag对图片进行生命周期的管理" class="headerlink" title="Picasso中,通过设置Tag对图片进行生命周期的管理"></a>Picasso中,通过设置Tag对图片进行生命周期的管理</h4><ul>
<li><p>通过上一篇源码分析知道,我们可以通过设置tag来管理图片的生命周期,接下来我们来分析其中的实现,先点进入tag(Object)来看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Assign a tag to this request. Tags are an easy way to logically associate</div><div class="line">   * related requests that can be managed together e.g. paused, resumed,</div><div class="line">   * or canceled.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * You can either use simple &#123;<span class="doctag">@link</span> String&#125; tags or objects that naturally</div><div class="line">   * define the scope of your requests within your app such as a</div><div class="line">   * &#123;<span class="doctag">@link</span> android.content.Context&#125;, an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, or a</div><div class="line">   * &#123;<span class="doctag">@link</span> android.app.Fragment&#125;.</div><div class="line">   *</div><div class="line">   * &lt;strong&gt;WARNING:&lt;/strong&gt;: Picasso will keep a reference to the tag for</div><div class="line">   * as long as this tag is paused and/or has active requests. Look out for</div><div class="line">   * potential leaks.</div><div class="line"></div><div class="line">   *</div><div class="line">   * <span class="doctag">@see</span> Picasso#cancelTag(Object)</div><div class="line">   * <span class="doctag">@see</span> Picasso#pauseTag(Object)</div><div class="line">   * <span class="doctag">@see</span> Picasso#resumeTag(Object)</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> RequestCreator <span class="title">tag</span><span class="params">(Object tag)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tag == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Tag invalid."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tag != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Tag already set."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.tag = tag;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中的tag最好是Activity和Fragment,因为Fragment和Activity的生命周期系统自动帮我们管理好了,把tag设置为它们的话,我们只要根据它们的生命周期来调用Picasso#cancelTag(Object)、Picasso#pauseTag(Object)、Picasso#resumeTag(Object)</p>
</li>
<li><p>设置玩tag后,当我们要暂停加载时,可以调用Picasso#pauseTag(Object),接着Picasso再调用分发器的<code>dispatcher.dispatchPauseTag(tag);</code>,dispatchPauseTag(tag)中又通过Handler发送一条<code>TAG_PAUSE</code>的消息,Handler接受到消息后,回调分发器的<code>dispatcher.performResumeTag(tag);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performPauseTag</span><span class="params">(Object tag)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Trying to pause a tag that is already paused.*/</span></div><div class="line">    <span class="keyword">if</span> (!pausedTags.add(tag)) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Go through all active hunters and detach/pause the requests*/</span></div><div class="line">    <span class="comment">/* that have the paused tag.*/</span></div><div class="line">    <span class="keyword">for</span> (Iterator&lt;BitmapHunter&gt; it = hunterMap.values().iterator(); it.hasNext();) &#123;</div><div class="line">      BitmapHunter hunter = it.next();</div><div class="line">      <span class="keyword">boolean</span> loggingEnabled = hunter.getPicasso().loggingEnabled;</div><div class="line"></div><div class="line">      Action single = hunter.getAction();</div><div class="line">      List&lt;Action&gt; joined = hunter.getActions();</div><div class="line">      <span class="keyword">boolean</span> hasMultiple = joined != <span class="keyword">null</span> &amp;&amp; !joined.isEmpty();</div><div class="line">      <span class="comment">/* Hunter has no requests, bail early.*/</span></div><div class="line">      <span class="keyword">if</span> (single == <span class="keyword">null</span> &amp;&amp; !hasMultiple) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (single != <span class="keyword">null</span> &amp;&amp; single.getTag().equals(tag)) &#123;</div><div class="line">        hunter.detach(single);</div><div class="line">        pausedActions.put(single.getTarget(), single);</div><div class="line">        <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">          log(OWNER_DISPATCHER, VERB_PAUSED, single.request.logId(),</div><div class="line">              <span class="string">"because tag '"</span> + tag + <span class="string">"' was paused"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (hasMultiple) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = joined.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">          Action action = joined.get(i);</div><div class="line">          <span class="keyword">if</span> (!action.getTag().equals(tag)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          hunter.detach(action);</div><div class="line">          pausedActions.put(action.getTarget(), action);</div><div class="line">          <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">                <span class="string">"because tag '"</span> + tag + <span class="string">"' was paused"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/*/ Check if the hunter can be cancelled in case all its requests*/</span></div><div class="line">      <span class="comment">/* had the tag being paused here.*/</span></div><div class="line">      <span class="keyword">if</span> (hunter.cancel()) &#123;</div><div class="line">        it.remove();</div><div class="line">        <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">          log(OWNER_DISPATCHER, VERB_CANCELED, getLogIdsForHunter(hunter), <span class="string">"all actions paused"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中将Tag缓存在pausedActions这个Map中</p>
</li>
<li><p>设置了暂停后,如果请求在加载过程中,会被停止。我们可以看<code>performSubmit</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</div><div class="line">      pausedActions.put(action.getTarget(), action);</div><div class="line">      <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">            <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最先判断pausedTags中是否存在Action携带的tag,如果存在的话,把Action缓存到pausedActions中,便于恢复,接着就直接return;从而实现了不加载图片。</p>
</li>
<li>暂停的Action被缓存到了pausedActions中,因此当我们要恢复的时候,就可以去该map中拿去。</li>
<li><p>恢复tag的调用路程的跟暂停基本是同一个套路,最后<code>performResumeTag(Object tag)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performResumeTag</span><span class="params">(Object tag)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Trying to resume a tag that is not paused.*/</span></div><div class="line">    <span class="keyword">if</span> (!pausedTags.remove(tag)) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Action&gt; batch = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (Iterator&lt;Action&gt; i = pausedActions.values().iterator(); i.hasNext();) &#123;</div><div class="line">      Action action = i.next();</div><div class="line">      <span class="keyword">if</span> (action.getTag().equals(tag)) &#123;</div><div class="line">        <span class="keyword">if</span> (batch == <span class="keyword">null</span>) &#123;</div><div class="line">          batch = <span class="keyword">new</span> ArrayList&lt;Action&gt;();</div><div class="line">        &#125;</div><div class="line">        batch.add(action);</div><div class="line">        i.remove();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (batch != <span class="keyword">null</span>) &#123;</div><div class="line">      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过遍历从<code>pausedActions</code>中取出Actions,再发送一条恢复的消息,最后会调用到<code>resumeAction(Action action)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resumeAction</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(action.memoryPolicy)) &#123;</div><div class="line">      bitmap = quickMemoryCacheCheck(action.getKey());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">/* Resumed action is cached, complete immediately.*/</span></div><div class="line">      deliverAction(bitmap, MEMORY, action);</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), <span class="string">"from "</span> + MEMORY);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/* Re-submit the action to the executor.*/</span></div><div class="line">      enqueueAndSubmit(action);</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_RESUMED, action.request.logId());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先会尝试从内存缓存中读取Bitmap,不存在的话,再调用<code>enqueueAndSubmit(action);</code>去排队加载图片,过程在上一篇中已经分析了,这里不多介绍。</p>
</li>
<li>值得注意的是,当图片正在加载和暂停加载图片时,Picasso会持有tag,如果我们设置的tag是Activity或者Fragment的话,如果不Activity或者Fragment销毁时,如果不取消tag的话,就会造成内存泄露。</li>
<li>总结:<ul>
<li>如果我们要设置tag的话,最好就是设置为Activity或者Fragment,因为系统管理了它们的声明周期,我们只要跟随它们的生命周期来调用暂停、恢复、取消操作就行。</li>
<li>在Activity或者Fragment暂停时,应当调用pauseTag,位于前台的时候再resumeTag,当Activity或者Fragment销毁时调用cancelTag释放持有的tag对象等一系列操作。</li>
</ul>
</li>
</ul>
<h4 id="Picasso中对不同类型的请求的处理"><a href="#Picasso中对不同类型的请求的处理" class="headerlink" title="Picasso中对不同类型的请求的处理"></a>Picasso中对不同类型的请求的处理</h4><ul>
<li>我们知道Picasso不仅支持从网络上加载图片,还支持从Drawable,Asset,File等中加载图片。</li>
<li>那么Picasso是如何处理?</li>
</ul>
<h5 id="定义基类RequestHandler"><a href="#定义基类RequestHandler" class="headerlink" title="定义基类RequestHandler"></a>定义基类RequestHandler</h5><ul>
<li>Picasso中定义了抽象类RequestHandler,也就是请求处理器来。在请求处理器中,定义了canHandleRequest(Request data)方法让子类实现,同时也定义了loadload(Request request, int networkPolicy)让子类实现。</li>
<li><p>请求处理器派生而来的有七种处理器,这里只分析网络请求处理器,主要分析<code>canHandleRequest(Request data)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleRequest</span><span class="params">(Request data)</span> </span>&#123;</div><div class="line">    String scheme = data.uri.getScheme();</div><div class="line">    <span class="keyword">return</span> (SCHEME_HTTP.equals(scheme) || SCHEME_HTTPS.equals(scheme));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过判断URI的scheme是不是HTTP或者HTTPS,是的话,返回true,证明,该类型的请求在网络处理器的处理范围内。</p>
</li>
<li><p>接下来,我们来看看Picasso是如何进行请求处理器的筛选的,通过上一篇分析,我们知道,请求处理器的筛选是在forRequest方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> BitmapHunter <span class="title">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span></span></div><div class="line">      Action action) &#123;</div><div class="line">    Request request = action.getRequest();</div><div class="line">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</div><div class="line">    <span class="comment">/* Index-based loop to avoid allocating an iterator.*/</span></div><div class="line">    <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</div><div class="line">      RequestHandler requestHandler = requestHandlers.get(i);</div><div class="line">      <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码中的逻辑是这样的:先通过Picasso拿到预先实例化好的请求处理器集合,接着通过遍历来拿到请求处理器,拿到后再调用其<code>canHandleRequest(request)</code>方法,从而筛选出能处理这条请求的请求处理器。</p>
</li>
</ul>
<h4 id="Picasso中的BitmapHunter队列控制"><a href="#Picasso中的BitmapHunter队列控制" class="headerlink" title="Picasso中的BitmapHunter队列控制"></a>Picasso中的BitmapHunter队列控制</h4><ul>
<li>Picasso中的是在BitmapBunter将存放在List集合的基础上来控制队列的</li>
<li><p>在BitmapHunter的run方法中会将BitmapHunter通过分发器回调回分发器中,接着还是按照之前的老套路,通过Handler发送消息,最后来到<code>batch(BitmapHunter)</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    batch.add(hunter);</div><div class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</div><div class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中将BitmapHunter存放入List,接着通过通过Handler发送消息</p>
</li>
<li>if()语句的判断和句内的发送消息是整个队列的控制精华。为什么这么说?handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)如果返回false的话,证明没有请求在处理,所以直接发送一条延迟消息,如果返回true,那么不会进入if语句之内,也就不会被分发出去,只是被添加到了List集合内,等带下次有BitmapHunter进来是,且没有图片正在加载,才一起发送出去。而且发送的消息是发送延迟消息,这样也给了执行请求的一定的缓冲时间。</li>
<li><p>List<bitmaphunter>最终会被发送到Picasso中运行在主线程的Handler</bitmaphunter></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> HUNTER_BATCH_COMPLETE: &#123;</div><div class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</div><div class="line">         <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class="line">           BitmapHunter hunter = batch.get(i);</div><div class="line">           hunter.picasso.complete(hunter);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后通过遍历每个BitmapHunter来设置到Target上。</p>
</li>
</ul>
<h4 id="Picasso中的设计"><a href="#Picasso中的设计" class="headerlink" title="Picasso中的设计"></a>Picasso中的设计</h4><ul>
<li>Picasso中的设计思路是将加载图片这个任务细分出来许多个小任务,分配给对应的对象,比如:请求处理器,内存缓存器,下载器。</li>
<li>既然有这么对人干活,Picasso设计了分发器来指挥这些人干活。</li>
<li>分发器听谁的指令去指挥别人? 答案是Picasso,Picasso观察大局,有什么情况出现再分发器,分发器听到命令后,指挥对应的人员去工作,对应人员都干好各自的任务后,再告诉Dispatcher,最后Dispatcher汇报给Picasso。</li>
<li>整个框架能够井然有序的运行起来的关键是Handler,可以说Handler是整个框架能运行起来的能源。</li>
<li>Picasso中,将Handler的作用发挥得淋漓尽致。是Handler运用的典例。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Picasso中的线程池&quot;&gt;&lt;a href=&quot;#Picasso中的线程池&quot; class=&quot;headerlink&quot; title=&quot;Picasso中的线程池&quot;&gt;&lt;/a&gt;Picasso中的线程池&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Picasso中的线程池主要是对对网络状态进行了监听,并且包装了一个FutureTask实现请求的优先级比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析:&quot;&gt;&lt;/a&gt;分析:&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;首先在Picasso中,定义了一个优先级枚举类型:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   * The priority of a request.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   * &lt;span class=&quot;doctag&quot;&gt;@see&lt;/span&gt; RequestCreator#priority(Priority)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Priority &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    LOW,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NORMAL,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    HIGH&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="图片加载框架#Picasso" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6-Picasso/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-简单的HTTP协议-笔记</title>
    <link href="http://yoursite.com/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/02/17/图解HTTP-简单的HTTP协议-笔记/</id>
    <published>2017-02-17T14:05:49.619Z</published>
    <updated>2017-02-17T14:05:49.619Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通过请求和响应来交换信息"><a href="#通过请求和响应来交换信息" class="headerlink" title="通过请求和响应来交换信息"></a>通过请求和响应来交换信息</h4><p><img src="/uploads/图解HTTP/简单的HTTP协议01.jpg" alt=""><br><a id="more"></a></p>
<ul>
<li>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</li>
<li>请求报文的构成</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议02.jpg" alt=""></p>
<ul>
<li>响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议03.jpg" alt=""></p>
<h4 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h4><ul>
<li>HTTP协议自身不对请求和响应之间的状态进行保存, 也就是HTTP不对请求和响应做持久化处理</li>
<li>不保存状态这种设计的优点:更快的处理大量事物</li>
</ul>
<h4 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h4><ul>
<li>GET:获取资源</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议04.png" alt=""></p>
<ul>
<li>POST:传输实体主体</li>
<li>PUT:PUT 方法用来传输文件。就像 FTP 协议的文件上传一样,要求在请求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置。36但是,鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制,任何人都可以上传文件 , 存在安全性问题,因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制,或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web 网站,就可能会开放使用 PUT 方法。</li>
<li>HEAD:获得报文首部, 返回的不包含主体部分,常用于URI的有效期以及更新日期</li>
<li>OPTIONS:询问支持的方法, OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li>
<li>CONNECT:要求用隧道协议连接代理。CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP通信。主要使用 SSL(Secure Sockets Layer,安全套接层)和 TLS(Transport Layer Security,传输层安全)协议把通信内容加 密后经网络隧道传输。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议05.jpg" alt=""></p>
<h4 id="持久连接减少通信量"><a href="#持久连接减少通信量" class="headerlink" title="持久连接减少通信量"></a>持久连接减少通信量</h4><p>在HTTP协议初始的几个版本中, 每次HTTP请求都得断开一次, 这样TCP频繁的连接和断开会增加通信量的开销</p>
<p><img src="/uploads/图解HTTP/简单的HTTP协议06.jpg" alt=""></p>
<ul>
<li>为了解决该问题, 在HTTP1.1和部分HTTP1.0中想出了持久连接(HTTP Persistent Connections,也称为 HTTP keep-alive 或<br>HTTP connection reuse)的方法。该方法的特点是:只要任意一端没有明确提出断开连接,则保持 TCP 连接状态。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议07.jpg" alt=""></p>
<ul>
<li>线管化技术<br>在之前的HTTP请求都是要一个请求完另外一个才能继续,但是持久化连接使得请求线管化成为了可能。即一次性可以请求多个</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议08.jpg" alt=""></p>
<h4 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h4><ul>
<li>HTTP是无状态协议,无状态指的是它不对之前发生的请求和响应进行管理。例如:一个需要登录的Web网站,无法对是否登录进行状态管理,每次跳转页面不是要重新登录就是要在报文中添加附加的数据来进行登录状态管理</li>
<li>无协议状态的优点:减少服务器的CPU及内存消耗</li>
<li>为了解决这一矛盾,由此引进了Cookie技术来进行状态管理</li>
</ul>
<h5 id="Cookie技术简介"><a href="#Cookie技术简介" class="headerlink" title="Cookie技术简介"></a>Cookie技术简介</h5><ul>
<li><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>
</li>
<li><p>服务器端发现客户端发送过来的Cookie后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息。</p>
</li>
<li>没有Cookie下的请求:</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议09.jpg" alt=""></p>
<ul>
<li>第 2 次以后(存有 Cookie 信息状态)的请求</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议10.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;通过请求和响应来交换信息&quot;&gt;&lt;a href=&quot;#通过请求和响应来交换信息&quot; class=&quot;headerlink&quot; title=&quot;通过请求和响应来交换信息&quot;&gt;&lt;/a&gt;通过请求和响应来交换信息&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/uploads/图解HTTP/简单的HTTP协议01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-确保Web安全的HTTPS-笔记</title>
    <link href="http://yoursite.com/2017/02/17/%E7%A1%AE%E4%BF%9DWeb%E5%AE%89%E5%85%A8%E7%9A%84HTTPS/"/>
    <id>http://yoursite.com/2017/02/17/确保Web安全的HTTPS/</id>
    <published>2017-02-17T13:45:23.687Z</published>
    <updated>2017-02-17T13:45:23.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP存在的不足"><a href="#HTTP存在的不足" class="headerlink" title="HTTP存在的不足"></a>HTTP存在的不足</h3><ul>
<li>通信使用明文(不加密), 内容可能会被窃听</li>
<li>不验证对方身份,因此有可能遭遇伪装</li>
<li>无法证明报文的完整性,所以有可能遭到篡改</li>
</ul>
<h4 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h4><ul>
<li>HTTP本身是不具备加密的功能的,因此在发送报文时是采用明文传输.</li>
<li>如何采用明文进行传输的话,内容可以通过抓取传输时的数据包,再由工具进行解析,就可以得到通信的内容</li>
</ul>
<a id="more"></a>
<h4 id="不验证通信对方就有可能在遇到伪装"><a href="#不验证通信对方就有可能在遇到伪装" class="headerlink" title="不验证通信对方就有可能在遇到伪装"></a>不验证通信对方就有可能在遇到伪装</h4><ul>
<li>HTTP 协议的实现本身非常简单,不论是谁发送过来的请求都会返回响应,因此不确认通信方,会存在以下各种隐患。<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息,只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service,拒绝服务攻击)。</li>
</ul>
</li>
<li>查明对手的证书<ul>
<li>虽然使用 HTTP 协议无法确定通信方,但如果使用 SSL 则可以。SSL 不仅提供加密处理,而且还使用了一种被称为证书的手段,可用于确定方。</li>
</ul>
</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS01.jpg" alt=""></p>
<h4 id="无法证明报文完整性-可能已遭篡改"><a href="#无法证明报文完整性-可能已遭篡改" class="headerlink" title="无法证明报文完整性,可能已遭篡改"></a>无法证明报文完整性,可能已遭篡改</h4><h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3><h4 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h4><ul>
<li>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已。</li>
<li>通常,HTTP 直接和 TCP 通信。当使用 SSL 时,则演变成先和 SSL 通信,再由 SSL 和 TCP 通信了。简言之,所谓 HTTPS,其实就是身披SSL 协议这层外壳的 HTTP。</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS02.jpg" alt=""></p>
<h4 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h4><h5 id="共享密钥加密的困境"><a href="#共享密钥加密的困境" class="headerlink" title="共享密钥加密的困境"></a>共享密钥加密的困境</h5><ul>
<li>加密和解密同用一个密钥的方式称为共享密钥加密(Common keycrypto system),也被叫做对称密钥加密。</li>
<li>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交?在互联网上转发密钥时,如果通信被监听那么密钥就可会落入攻击者之手,同时也就失去了加密的意<br>义。另外还得设法安全地保管接收到的密钥。</li>
</ul>
<h5 id="使用两把密钥的公开密钥加密"><a href="#使用两把密钥的公开密钥加密" class="headerlink" title="使用两把密钥的公开密钥加密"></a>使用两把密钥的公开密钥加密</h5><ul>
<li>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)。顾名思义,私有密钥不能让其他任何人知道,而公开密钥则可以随意发<br>布,任何人都可以获得。</li>
<li>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密。利用这种方式,不需要发送用来解密的私有密钥,也<br>不必担心密钥被攻击者窃听而盗走。</li>
</ul>
<h5 id="HTTPS-采用混合加密机制"><a href="#HTTPS-采用混合加密机制" class="headerlink" title="HTTPS 采用混合加密机制"></a>HTTPS 采用混合加密机制</h5><ul>
<li>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</li>
<li>采用混合加密的机制是因为公开密钥加密的速度慢</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS03.jpg" alt=""></p>
<h4 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h4><ul>
<li>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。</li>
<li>为了解决这个问题,可以使用由数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密钥证书</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS04.jpg" alt=""></p>
<h4 id="HTTPS-的安全通信机制"><a href="#HTTPS-的安全通信机制" class="headerlink" title="HTTPS 的安全通信机制"></a>HTTPS 的安全通信机制</h4><p><img src="/uploads/图解HTTP/确保Web安全的HTTPS05.jpg" alt=""></p>
<ul>
<li><p>步骤 1: 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。</p>
</li>
<li><p>步骤 2: 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应154答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>
</li>
<li><p>步骤 3: 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
</li>
<li><p>步骤 4: 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。</p>
</li>
<li><p>步骤 5: SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>
</li>
<li><p>步骤 6: 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>
</li>
<li><p>步骤 7: 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。</p>
</li>
<li><p>步骤 8: 服务器同样发送 Change Cipher Spec 报文。</p>
</li>
<li><p>步骤 9: 服务器同样发送 Finished 报文。</p>
</li>
<li><p>步骤 10: 服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。</p>
</li>
<li><p>步骤 11: 应用层协议通信,即发送 HTTP 响应。</p>
</li>
<li><p>步骤 12: 最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</p>
</li>
</ul>
<h4 id="HTTPS存在的不足"><a href="#HTTPS存在的不足" class="headerlink" title="HTTPS存在的不足"></a>HTTPS存在的不足</h4><ul>
<li>HTTPS使用了SSL,因此速度会变慢</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS06.jpg" alt=""></p>
<ul>
<li>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源,导致处理速度变慢。<ul>
<li>和使用 HTTP 相比,网络负载可能会变慢 2 到 100 倍。除去和TCP 连接、发送 HTTP 请求 • 响应以外,还必须进行 SSL 通信,因此整体上处理通信量不可避免会增加。</li>
</ul>
</li>
<li>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲,比起 HTTP 会更多地消耗服务器和客户端的硬件资源,导致负载增强。</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP存在的不足&quot;&gt;&lt;a href=&quot;#HTTP存在的不足&quot; class=&quot;headerlink&quot; title=&quot;HTTP存在的不足&quot;&gt;&lt;/a&gt;HTTP存在的不足&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文(不加密), 内容可能会被窃听&lt;/li&gt;
&lt;li&gt;不验证对方身份,因此有可能遭遇伪装&lt;/li&gt;
&lt;li&gt;无法证明报文的完整性,所以有可能遭到篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;通信使用明文可能会被窃听&quot;&gt;&lt;a href=&quot;#通信使用明文可能会被窃听&quot; class=&quot;headerlink&quot; title=&quot;通信使用明文可能会被窃听&quot;&gt;&lt;/a&gt;通信使用明文可能会被窃听&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;HTTP本身是不具备加密的功能的,因此在发送报文时是采用明文传输.&lt;/li&gt;
&lt;li&gt;如何采用明文进行传输的话,内容可以通过抓取传输时的数据包,再由工具进行解析,就可以得到通信的内容&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-与HTTP协议的Web服务器-笔记</title>
    <link href="http://yoursite.com/2017/02/17/%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2017/02/17/与HTTP协议的Web服务器/</id>
    <published>2017-02-17T13:40:15.798Z</published>
    <updated>2017-02-17T13:40:15.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h3><h4 id="通信数据转发程序-代理、网关、隧道"><a href="#通信数据转发程序-代理、网关、隧道" class="headerlink" title="通信数据转发程序:代理、网关、隧道"></a>通信数据转发程序:代理、网关、隧道</h4><ul>
<li>在HTTP通信时,代理、网关和隧道是用于通信数据的转发的应用程序,他们可以配合服务器进行工作</li>
<li>代理就像一个中介,他接收客户端发来的信息继而转发给服务器,同时也可以接受服务器的信息转发给客户端</li>
<li>网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。</li>
<li>隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。</li>
</ul>
<h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器01.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>每次通过代理服务器转发请求或响应时,会追加写入 Via 首部信息</li>
<li>利用代理的作用:<ul>
<li>利用缓存技术减少宽带流量</li>
<li>对特定网站的控制访问,以获取访问日志为主要目的</li>
</ul>
</li>
<li>代理的分类:<ul>
<li>缓存代理(Caching Proxy):代理转发响应时,缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。</li>
<li>透明代理:转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理(TransparentProxy)。反之,对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
</li>
</ul>
<h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器02.jpg" alt=""></p>
<ul>
<li>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</li>
<li>利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如,网关可以连接数据库,使用SQL 语句查询数据。另外,在 Web 购物网站上进行信用卡结算时,网关可以和信用卡结算系统联动。</li>
</ul>
<h5 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h5><ul>
<li>隧道可按要求建立起一条与其他服务器的通信线路,届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
</ul>
<h4 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h4><ul>
<li>利用缓存技术可以减少对服务器的访问,以及通信流量和通信时间。</li>
</ul>
<h5 id="缓存的有限期限"><a href="#缓存的有限期限" class="headerlink" title="缓存的有限期限"></a>缓存的有限期限</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器03.jpg" alt=""></p>
<h5 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器04.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源与图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与HTTP协作的Web服务器&quot;&gt;&lt;a href=&quot;#与HTTP协作的Web服务器&quot; class=&quot;headerlink&quot; title=&quot;与HTTP协作的Web服务器&quot;&gt;&lt;/a&gt;与HTTP协作的Web服务器&lt;/h3&gt;&lt;h4 id=&quot;通信数据转发程序-代理、网关、隧道&quot;&gt;&lt;a href=&quot;#通信数据转发程序-代理、网关、隧道&quot; class=&quot;headerlink&quot; title=&quot;通信数据转发程序:代理、网关、隧道&quot;&gt;&lt;/a&gt;通信数据转发程序:代理、网关、隧道&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在HTTP通信时,代理、网关和隧道是用于通信数据的转发的应用程序,他们可以配合服务器进行工作&lt;/li&gt;
&lt;li&gt;代理就像一个中介,他接收客户端发来的信息继而转发给服务器,同时也可以接受服务器的信息转发给客户端&lt;/li&gt;
&lt;li&gt;网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。&lt;/li&gt;
&lt;li&gt;隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/uploads/图解HTTP/与HTTP协议的Web服务器01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-返回结果的状态码-笔记</title>
    <link href="http://yoursite.com/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/02/17/图解HTTP-返回结果的状态码-笔记/</id>
    <published>2017-02-17T13:35:17.757Z</published>
    <updated>2017-02-17T13:35:17.757Z</updated>
    
    <content type="html"><![CDATA[<h4 id="状态码类别："><a href="#状态码类别：" class="headerlink" title="状态码类别："></a>状态码类别：</h4><p>类别    原因短语<br>1XX    Informational(信息性状态码)    接收的请求正在处理<br>2XX    Success(成功状态码)    请求正常处理完毕<br>3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求<br>4XX    Client Error(客户端错误状态码)    服务器无法处理请求<br>5XX    Server Error(服务器错误状态码)    服务器处理请求出错</p>
<a id="more"></a>
<h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h5><ul>
<li>200 OK：表示客户端的请求被服务器成功处理</li>
<li><p>204 No Content：该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</p>
</li>
<li><p>206 Partial Content：该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h5><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<ul>
<li><p>301 Moved Permanently:永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</p>
</li>
<li><p>302 Found:临时性重定向：该状态码表示请求的资源已被分配了新的URI，希望用户本次请求能使用新的URI。302和301很相似，302表示的URI并不是永久性移动，换句话说就是URI还有可能发生变化。</p>
</li>
<li><p>303 See Other：该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。303和302有着相似的功能，他们之间的区别是303状态码表示明确客户端采用GET请求获取资源</p>
</li>
<li><p>304 Not Modified  </p>
</li>
</ul>
<h5 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h5><p>4XX响应结果表示错误发生在客户端</p>
<ul>
<li><p>400 Bad Request:该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。</p>
</li>
<li><p>403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。</p>
</li>
<li><p>404 Not Found：该状态码表明服务器上无法找到请求的资源。</p>
</li>
</ul>
<h5 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h5><p>5XX 的响应结果表明服务器本身发生错误。</p>
<ul>
<li><p>500 Internal Server Error:该状态码表明服务器端在执行请求时发生了错误。</p>
</li>
<li><p>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。</p>
</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;状态码类别：&quot;&gt;&lt;a href=&quot;#状态码类别：&quot; class=&quot;headerlink&quot; title=&quot;状态码类别：&quot;&gt;&lt;/a&gt;状态码类别：&lt;/h4&gt;&lt;p&gt;类别    原因短语&lt;br&gt;1XX    Informational(信息性状态码)    接收的请求正在处理&lt;br&gt;2XX    Success(成功状态码)    请求正常处理完毕&lt;br&gt;3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求&lt;br&gt;4XX    Client Error(客户端错误状态码)    服务器无法处理请求&lt;br&gt;5XX    Server Error(服务器错误状态码)    服务器处理请求出错&lt;/p&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Picasso基本用法及源码浅析</title>
    <link href="http://yoursite.com/2017/02/17/Picasso%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%8F%8A%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2017/02/17/Picasso基本用法及源码浅析/</id>
    <published>2017-02-17T13:33:48.997Z</published>
    <updated>2017-02-17T13:33:48.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><h4 id="加载图片："><a href="#加载图片：" class="headerlink" title="加载图片："></a>加载图片：</h4><ul>
<li><p>picasso支持从Resource，MediaStore，content，contacts，url 加载图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(uri)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>以上是最简单的通用加载图片的方法</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>添加加载错误以及加载中的展示图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(uri)</div><div class="line">                .error(R.drawable.error)</div><div class="line">                .placeholder(R.drawable.placeholder)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>如果加载得到的Bitmap的大小不符合我们设置的ImageView的大小，我们可以调用以下代码来调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(uri)</div><div class="line">                .fit()</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>与fit()相似的是resize（int，int），两者都可以调整图片的大小，但是fit()只能用在ImageView上。需要注意的是两者不能同时使用。</p>
</li>
<li>我们还可以制定ImageView的模式<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(R.drawable.cangjinyou)</div><div class="line">                .resize(<span class="number">150</span>, <span class="number">150</span>)</div><div class="line">                .centerCrop()</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">        .load(R.drawable.cangjinyou)</div><div class="line">        .resize(<span class="number">150</span>, <span class="number">150</span>)</div><div class="line">        .centerInside()</div><div class="line">        .into(mImageView);</div></pre></td></tr></table></figure>
<ul>
<li>需要注意的是centerInside()和centerCrop()不能同时设置。</li>
</ul>
<h4 id="设置Tag"><a href="#设置Tag" class="headerlink" title="设置Tag"></a>设置Tag</h4><ul>
<li>加载图片的同时设置tag来为图片添加生命周期</li>
<li><p>添加tag</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(R.drawable.cangjinyou)</div><div class="line">                .fit()</div><div class="line">                .centerInside()</div><div class="line">                .tag(<span class="keyword">this</span>)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>设置tag可以为图片设置生命周期，通常这个tag可以为Activity或者Fragment，设置tag的好处就是可以根据tag的生命周期来管理图片的生命周期。在设置tag的同时需要避免内存泄露，因为当图片正在加载或者暂停加载的时候，Picasso会持有这个tag。</p>
</li>
<li>设置tag后，我们可以调用Picasso中的cancelTag（Object）,pauseTag（Object）和resumeTag（Object）来管理图片的生命周期。</li>
</ul>
<h4 id="开启Debug模式和指示模式"><a href="#开启Debug模式和指示模式" class="headerlink" title="开启Debug模式和指示模式"></a>开启Debug模式和指示模式</h4><ul>
<li>开启后会在image左上方绘制一个小小小的三角形，三角形的颜色代表图片是从哪里加载得来的，绿色，蓝色，红色分别表示从内存，硬盘，网络加载得来<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDebug</span><span class="params">()</span> </span>&#123;</div><div class="line">       Picasso.with(<span class="keyword">this</span>)</div><div class="line">               .setLoggingEnabled(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openIndicator</span><span class="params">()</span> </span>&#123;</div><div class="line">       Picasso.with(<span class="keyword">this</span>).setIndicatorsEnabled(<span class="keyword">true</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="with-Context-创建Picasso全局单例"><a href="#with-Context-创建Picasso全局单例" class="headerlink" title="with(Context)创建Picasso全局单例"></a>with(Context)创建Picasso全局单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (Picasso.class) &#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">          singleton = <span class="keyword">new</span> Builder(context).build();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> singleton;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>很明显上面的代码逻辑是使用DCL模式创建一个Picasso单例,但是创建对象的方式是使用建造者模式,这样做的好处就是可以让我们自己来配置Picasso。那么怎么配置Picasso?<br>1.使用Picasso.Builder创建配置;<br>2.设置配置完的Picasso: setSingletonInstance(Picasso picasso).</li>
<li><p>回到with()中,我们来看看 singleton = new Builder(context).build();中做了哪些初始化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> Picasso&#125; instance. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">this</span>.context;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</div><div class="line">        downloader = Utils.createDefaultDownloader(context); <span class="comment">/*创建下载器*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</div><div class="line">        cache = <span class="keyword">new</span> LruCache(context); <span class="comment">/*创建内存缓存器*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">        service = <span class="keyword">new</span> PicassoExecutorService(); <span class="comment">/*创建Picasso优化后的线程池*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (transformer == <span class="keyword">null</span>) &#123;</div><div class="line">        transformer = RequestTransformer.IDENTITY; <span class="comment">/*创建请求转换器*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Stats stats = <span class="keyword">new</span> Stats(cache); <span class="comment">/*创建状态管理器*/</span></div><div class="line"></div><div class="line">      Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats); <span class="comment">/*创建分发器*/</span></div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled); <span class="comment">/*创建Picasso实例*/</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从上面注释可以看到,Picasso将每个任务分派给不同的对象去处理,最后再指挥这些一系列的’器’去工作。那么下面,我们先来简单介绍以下他们。</p>
</li>
</ul>
<h5 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h5><ul>
<li>我们先来看看下载器的基础接口: Downloader</li>
<li>下载器内部提供两个方法,分别是load(Uri uri, int networkPolicy)和shutdown();load(Uri uri, int networkPolicy)方法是从网络上加载图片,返回内部类Response对象,该对象主要是储存着下载来的Bitmap或者字节流。</li>
<li><p>介绍完下载器基础接口,我们回到创建默认下载器的方法内部:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Downloader <span class="title">createDefaultDownloader</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class.forName(<span class="string">"com.squareup.okhttp.OkHttpClient"</span>); <span class="comment">/*检查是不是存在OkHttpClient,*/</span></div><div class="line">      <span class="keyword">return</span> OkHttpLoaderCreator.create(context);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UrlConnectionDownloader(context);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先检查环境中是不是存在Okhttp,存在的话证明已经添加了Okhttp依赖,因而直接使用Okhttp来创建下载器</p>
</li>
<li>如果不存直接创建UrlConnectionDownloader下载器</li>
</ul>
<h5 id="内存缓存器"><a href="#内存缓存器" class="headerlink" title="内存缓存器"></a>内存缓存器</h5><ul>
<li>内存内存缓存器使用的是Lru,最大的缓存大小是堆内存的最大数的7分之一</li>
</ul>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><ul>
<li>线程池中根据网络状态动态调整了线程数量,以及包装了一个FutureTask来进行实现优先级的比较</li>
</ul>
<h5 id="请求转换器"><a href="#请求转换器" class="headerlink" title="请求转换器"></a>请求转换器</h5><ul>
<li>Picasso里面并没有进行特殊的请求转换,只是原封不动返回了一个请求</li>
</ul>
<h5 id="状态管理器"><a href="#状态管理器" class="headerlink" title="状态管理器"></a>状态管理器</h5><ul>
<li>对Picasso运转的情况做了记录,便于当发生oom时,打印出Picasso的运行情况</li>
</ul>
<h5 id="分发器"><a href="#分发器" class="headerlink" title="分发器"></a>分发器</h5><ul>
<li>上面几个’器’最终都是在分发器中被其指挥调度</li>
</ul>
<h5 id="Picasso实例"><a href="#Picasso实例" class="headerlink" title="Picasso实例"></a>Picasso实例</h5><ul>
<li>分发器指挥调度各个’器’去工作.那么分发器什么时候进行调度? 发送这个命令是就是Picasso, Picasso-&gt;Dispatcher-&gt;各个’器’</li>
</ul>
<h4 id="调用load方法创建RequestCreator"><a href="#调用load方法创建RequestCreator" class="headerlink" title="调用load方法创建RequestCreator"></a>调用load方法创建RequestCreator</h4><ul>
<li>load方法有四个重载方法,用于加载不同的资源。但是最终目的都是创建一个RequestCreator</li>
<li>在介绍RequestCreator之前,我们先来看看Request,</li>
</ul>
<h5 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h5><ul>
<li>顾名思义,就是一条请求,Picasso中会将要加载的图片包装成一条请求</li>
</ul>
<h5 id="RequestCreator"><a href="#RequestCreator" class="headerlink" title="RequestCreator"></a>RequestCreator</h5><ul>
<li>请求的创建任务是交给RequestCreator</li>
<li>RequestCreator可以在创建完请求后,把该请求设置到目标Target中</li>
</ul>
<h4 id="into"><a href="#into" class="headerlink" title="into"></a>into</h4><ul>
<li>into方法有五个重载方法,支持将加载得到的图片设置到ImageView,RemoteViews, Target(自定义View)</li>
<li><p>几个重载方法原理都是相同的,这里我只分析ImageView。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target, Callback callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> started = System.nanoTime();</div><div class="line">    checkMain(); <span class="comment">/*保证into方法是在主线程中被调用的*/</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123; <span class="comment">/*如果在load()方法中有传入ResId或者uri的话,是不会进入if语句中的*/</span></div><div class="line">      picasso.cancelRequest(target);</div><div class="line">      <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">        setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (deferred) &#123; <span class="comment">/*deferred默认值为false,只有再调用了fit方法后deferred才为true,才会进入该方法*/</span></div><div class="line">      <span class="keyword">if</span> (data.hasSize()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with resize."</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> width = target.getWidth();</div><div class="line">      <span class="keyword">int</span> height = target.getHeight();</div><div class="line">      <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">          setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      data.resize(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = createRequest(started);</div><div class="line">    String requestKey = createKey(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        picasso.cancelRequest(target);</div><div class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">"from "</span> + MEMORY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">          callback.onSuccess();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">      setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Action action =</div><div class="line">        <span class="keyword">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</div><div class="line">            errorDrawable, requestKey, tag, callback, noFade);</div><div class="line"></div><div class="line">    picasso.enqueueAndSubmit(action);</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中的Callback接口可以不传入,如果要传入的话,要注意内存泄露。</p>
</li>
<li>结合代码中的注释,首先先创建根据当前时间戳来创建一个请求,接着再拼接请求的key</li>
<li>拼接完key之后,会判断是不是要从内存缓存中读取Bitmap,有的话,直接从内存拿走最后设置到target中;</li>
<li>如果设置了placeholder的话,会显示一张预加载的图片</li>
<li>最后实例化一个ImageViewAction并把这个action提交给picasso对象去处理。</li>
<li>Action是一个对一个请求进行包装,里面对target进行弱引用包装,是的我们不必关心内存泄露.</li>
<li><p>我们接着看看看Picasso对传入的action进行了什么操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueAndSubmit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    Object target = action.getTarget();</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</div><div class="line">      <span class="comment">/* This will also check we are on the main thread.*/</span></div><div class="line">      cancelExistingRequest(target);</div><div class="line">      targetToAction.put(target, action);</div><div class="line">    &#125;</div><div class="line">    submit(action);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面逻辑很简单,这里不多说,我们直接看看submit:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    dispatcher.dispatchSubmit(action);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>前面说过了,Picassso是一个总指挥,既然有action来了,Picasso肯定会给他的直接下属Dispatcher发命令,我们看看dispatcher对Picasso交给它的action怎么分派:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchSubmit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们看到,在dispatchSubmit中,通过Handler发送一个REQUEST_SUBMIT消息,该Handler是Dispatcher的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        <span class="keyword">case</span> REQUEST_SUBMIT: &#123;</div><div class="line">          Action action = (Action) msg.obj;</div><div class="line">          dispatcher.performSubmit(action);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接收到消息时,又调用了performSubmit(action)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123; <span class="comment">/*判断action对应的tag是不是被设置为暂停了, 如果设置了暂停,直接去取消加载图片*/</span></div><div class="line">      pausedActions.put(action.getTarget(), action);</div><div class="line">      <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">            <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BitmapHunter hunter = hunterMap.get(action.getKey());</div><div class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</div><div class="line">      hunter.attach(action);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (service.isShutdown()) &#123;</div><div class="line">      <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class="string">"because shut down"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</div><div class="line">    hunter.future = service.submit(hunter);</div><div class="line">    hunterMap.put(action.getKey(), hunter);</div><div class="line">    <span class="keyword">if</span> (dismissFailed) &#123;</div><div class="line">      failedActions.remove(action.getTarget());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>结合上面注释,我们直接来看看<code>hunter = forRequest(action.getPicasso(), this, cache, stats, action);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> BitmapHunter <span class="title">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span></span></div><div class="line">      Action action) &#123;</div><div class="line">    Request request = action.getRequest();</div><div class="line">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</div><div class="line"></div><div class="line">    <span class="comment">/* Index-based loop to avoid allocating an iterator.*/</span></div><div class="line">    <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</div><div class="line">      RequestHandler requestHandler = requestHandlers.get(i);</div><div class="line">      <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>既然有了请求,dispatcher就得来指挥对应的’人’来处理</p>
</li>
<li>接下来,通过遍历取得RequestHandler来能够处理该请求的RequestHandler来处理</li>
<li>那么这些RequestHandler怎么来的?</li>
<li><p>其实这些RequestHandler是创建Picasso的时候,就已经实例化了,我们暂且回到Picasso来看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">List&lt;RequestHandler&gt; allRequestHandlers =</div><div class="line">        <span class="keyword">new</span> ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount);</div><div class="line"></div><div class="line">    <span class="comment">/* ResourceRequestHandler needs to be the first in the list to avoid*/</span></div><div class="line">    <span class="comment">/* forcing other RequestHandlers to perform null checks on request.uri*/</span></div><div class="line">    <span class="comment">/* to cover the (request.resourceId != 0) case.*/</span></div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> ResourceRequestHandler(context));</div><div class="line">    <span class="keyword">if</span> (extraRequestHandlers != <span class="keyword">null</span>) &#123;</div><div class="line">      allRequestHandlers.addAll(extraRequestHandlers);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> ContactsPhotoRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> MediaStoreRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> ContentStreamRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> AssetRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> FileRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> NetworkRequestHandler(dispatcher.downloader, stats));</div><div class="line">    requestHandlers = Collections.unmodifiableList(allRequestHandlers);</div></pre></td></tr></table></figure>
</li>
<li><p>Picasso默认帮我们创建了7个请求处理器,这些处理器,分别对应响应的不同的请求类型,当然,Picasso也考虑到了这7中可能会不够我们使用,如果是这样的话,我们可以继承RequestHandler,并且调用Picasso.Builder.addRequestHandler(RequestHandler)}来扩展RequestHandler。</p>
</li>
</ul>
<h5 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h5><ul>
<li>请求处理器,其中预留了<code>canHandleRequest(Request data)</code>和<code>load(Request request, int networkPolicy)</code>给具体子类去实现。</li>
<li>继承RequestHandler的子类,<code>canHandleRequest(Request data)</code>判断该请求是不是在自己的处理范围内,是的话返回true,而load则是加载图片</li>
<li>RequestHandler内部的Result是由load完的数据进行包装而成的对象。</li>
<li>介绍完RequestHandler,我们回到forResquest方法中:在for循环中,找到能处理该请求的RequestHandler并实例化返回一个BitmapHunter,</li>
<li><p>得到BitmapHunter,提交给线程池,得到一个Future,所以此时,我们得去PicassoExecutorService去看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoFutureTask</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">BitmapHunter</span>&gt;</span></div><div class="line">      <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">PicassoFutureTask</span>&gt; &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitmapHunter hunter;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PicassoFutureTask</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(hunter, <span class="keyword">null</span>);</div><div class="line">      <span class="keyword">this</span>.hunter = hunter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PicassoFutureTask other)</span> </span>&#123;</div><div class="line">      Picasso.Priority p1 = hunter.getPriority();</div><div class="line">      Picasso.Priority p2 = other.hunter.getPriority();</div><div class="line"></div><div class="line">      <span class="comment">/* High-priority requests are "lesser" so they are sorted to the front.*/</span></div><div class="line">      <span class="comment">/* Equal priorities are sorted by sequence number to provide FIFO ordering.*/</span></div><div class="line">      <span class="keyword">return</span> (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>将提交的BitmapHunter包装成一个PicassoFutureTask,主要的操作就是进行优先级的比较</p>
</li>
<li><p>提交完后,我们自然要去BitmapHunter中,因为BitmapHunter是继承自Runnable对象,提交的BitmapHunter会在其Run函数中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     updateThreadName(data);</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">       log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>));</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     result = hunt();</div><div class="line">     <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">       dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       dispatcher.dispatchComplete(<span class="keyword">this</span>);</div><div class="line">     &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Downloader.ResponseException e) &#123;</div><div class="line">     <span class="keyword">if</span> (!e.localCacheOnly || e.responseCode != <span class="number">504</span>) &#123;</div><div class="line">       exception = e;</div><div class="line">     &#125;</div><div class="line">     dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (NetworkRequestHandler.ContentLengthException e) &#123;</div><div class="line">     exception = e;</div><div class="line">     dispatcher.dispatchRetry(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">     exception = e;</div><div class="line">     dispatcher.dispatchRetry(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</div><div class="line">     StringWriter writer = <span class="keyword">new</span> StringWriter();</div><div class="line">     stats.createSnapshot().dump(<span class="keyword">new</span> PrintWriter(writer));</div><div class="line">     exception = <span class="keyword">new</span> RuntimeException(writer.toString(), e);</div><div class="line">     dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">     exception = e;</div><div class="line">     dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">     Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面代码中主要调用了hunt()方法得到Bitmap对象,现在,我们直接进入该方法看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function">Bitmap <span class="title">hunt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">      bitmap = cache.get(key);</div><div class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        stats.dispatchCacheHit();</div><div class="line">        loadedFrom = MEMORY;</div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), <span class="string">"from cache"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data.networkPolicy = retryCount == <span class="number">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</div><div class="line">    RequestHandler.Result result = requestHandler.load(data, networkPolicy);</div><div class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">      loadedFrom = result.getLoadedFrom();</div><div class="line">      exifRotation = result.getExifOrientation();</div><div class="line">      bitmap = result.getBitmap();</div><div class="line"></div><div class="line">      <span class="comment">/* If there was no Bitmap then we need to decode it from the stream.*/</span></div><div class="line">      <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">        InputStream is = result.getStream();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          bitmap = decodeStream(is, data);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          Utils.closeQuietly(is);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      stats.dispatchBitmapDecoded(bitmap);</div><div class="line">      <span class="keyword">if</span> (data.needsTransformation() || exifRotation != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (DECODE_LOCK) &#123;</div><div class="line">          <span class="keyword">if</span> (data.needsMatrixTransform() || exifRotation != <span class="number">0</span>) &#123;</div><div class="line">            bitmap = transformResult(data, bitmap, exifRotation);</div><div class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (data.hasCustomTransformations()) &#123;</div><div class="line">            bitmap = applyCustomTransformations(data.transformations, bitmap);</div><div class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), <span class="string">"from custom transformations"</span>);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">          stats.dispatchBitmapTransformed(bitmap);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> bitmap;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先判断内存缓存是不是存在该Bitmap,存在的话返回Bitmap对象</p>
</li>
<li>不存在的话,进行网络加载,进行网络加载时,会先判断硬盘缓存中是不是存在,不存在的话再从网络上下载</li>
<li>如果是从网络上下载的话,会得到字节流,接着解析字节流,最后返回该Bitmap。</li>
<li><p>得到Bitmap后,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dispatcher.dispatchComplete(<span class="keyword">this</span>);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>是分发器出场把BitmapHunter对象回调出去</p>
</li>
<li><p>回调的套路跟之前一样,通过Handler发送一条加载完成的消息,再会回调加载完成的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</div><div class="line">      cache.set(hunter.getKey(), hunter.getResult());</div><div class="line">    &#125;</div><div class="line">    hunterMap.remove(hunter.getKey());</div><div class="line">    batch(hunter);</div><div class="line">    <span class="keyword">if</span> (hunter.getPicasso().loggingEnabled) &#123;</div><div class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), <span class="string">"for completion"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后会回调上面的方法,主要操作是缓存该Bitmap</p>
</li>
<li><p>缓存完Bitmap后,调用batch(hunter)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    batch.add(hunter);</div><div class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</div><div class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中,通过Hnadler发送一条消息,我们跟踪一下这条信息,最后会调用以下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBatchComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</div><div class="line">   batch.clear();</div><div class="line">   mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</div><div class="line">   logBatch(copy);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中也是通过Hnadler发送一条消息,而这次发送的消息是发送到运行在主线程的Hnadler,该Handler是实例化Picasso的时候传入Dispatcher的,因而我们自然来到Picasso中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    Action single = hunter.getAction();</div><div class="line">    List&lt;Action&gt; joined = hunter.getActions();</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> hasMultiple = joined != <span class="keyword">null</span> &amp;&amp; !joined.isEmpty();</div><div class="line">    <span class="keyword">boolean</span> shouldDeliver = single != <span class="keyword">null</span> || hasMultiple;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!shouldDeliver) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Uri uri = hunter.getData().uri;</div><div class="line">    Exception exception = hunter.getException();</div><div class="line">    Bitmap result = hunter.getResult();</div><div class="line">    LoadedFrom from = hunter.getLoadedFrom();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (single != <span class="keyword">null</span>) &#123;</div><div class="line">      deliverAction(result, from, single);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasMultiple) &#123;</div><div class="line">      <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = joined.size(); i &lt; n; i++) &#123;</div><div class="line">        Action join = joined.get(i);</div><div class="line">        deliverAction(result, from, join);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span> &amp;&amp; exception != <span class="keyword">null</span>) &#123;</div><div class="line">      listener.onImageLoadFailed(<span class="keyword">this</span>, uri, exception);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过分析,最终会回调Picasso的complete方法:方法中我们只分析单一的Action,也就是会调用<code>deliverAction(result, from, single);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverAction</span><span class="params">(Bitmap result, LoadedFrom from, Action action)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (action.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!action.willReplay()) &#123;</div><div class="line">      targetToAction.remove(action.getTarget());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (from == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LoadedFrom cannot be null."</span>);</div><div class="line">      &#125;</div><div class="line">      action.complete(result, from);</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), <span class="string">"from "</span> + from);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      action.error();</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面代码,我们可以看到最后会调用<code>action.complete(result, from);</code>,因为我们实例化Action的时候是实例化ImageView,因此,我们来看看ImageViewAction中的complete:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</div><div class="line">          String.format(<span class="string">"Attempted to complete action with no result!\n%s"</span>, <span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Context context = picasso.context;</div><div class="line">    <span class="keyword">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</div><div class="line">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">      callback.onSuccess();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>很明显,上面代码中调用了PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);设置来Bitmap,也就是说设置到ImageView中,有趣的是,PicassoDrawable是继承自BitmapDrawable的,并重写了onDraw方法,根据是否开启指示器模式,来判断是否要在图片的左上角画一个小小的三角形,其中不同颜色的三角形代表从Image的来源,这里具体不多说了。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>总体来说,Picasso的设计是将不同的任务分派给不同的’器’,再有分发器调度,而分发器直接接受Picasso的命令,也就是说整个加载的过程中,Picasso始终存在</li>
<li>Picasso内部的实现还是有很多地方值得学习,比如Action队列的控制,请求处理器的分类,线程池的优化,图片生命周期的管理等。既然Picasso有这么多值得学习的地方,所以打算专门写一篇来分析其中的技巧。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本用法：&quot;&gt;&lt;a href=&quot;#基本用法：&quot; class=&quot;headerlink&quot; title=&quot;基本用法：&quot;&gt;&lt;/a&gt;基本用法：&lt;/h3&gt;&lt;h4 id=&quot;加载图片：&quot;&gt;&lt;a href=&quot;#加载图片：&quot; class=&quot;headerlink&quot; title=&quot;加载图片：&quot;&gt;&lt;/a&gt;加载图片：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;picasso支持从Resource，MediaStore，content，contacts，url 加载图片。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Picasso.with(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                .load(uri)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                .into(mImageView);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以上是最简单的通用加载图片的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="图片加载框架#Picasso" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6-Picasso/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-网络基础-笔记</title>
    <link href="http://yoursite.com/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/02/17/图解HTTP-网络基础/</id>
    <published>2017-02-17T12:25:00.852Z</published>
    <updated>2017-02-17T12:25:00.852Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h4><h5 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h5><ul>
<li>我们通常使用到的网络是在<strong>TCP/IP</strong>协议族的基础上运作的。而HTTP属于它内部的一个子集。</li>
<li>TCP/IP是互联网各类协议族的总称, 如图:<br><img src="/uploads/图解HTTP/网络基础01.jpg" alt=""><a id="more"></a></li>
<li>协议中存在各式各样的内容,从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序,以及 Web 页面显示需要处理的步骤,等等。像这样把互联网通信的相关协议集合起来的协议族就叫做TCP/IP协议</li>
</ul>
<h5 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h5><ul>
<li>TCP/IP中一个重要的点就是分层设计。</li>
<li>层次: 应用层,传输层,网路层,链路层</li>
<li>分层设计的好处:<ul>
<li>利于修改:这样不会因某些地方要修改而导致整个协议都得修改,只需要各层把借口规范好,需要改动的时候就在相应的层次改动</li>
<li>各层只需完成自己的任务,无需关注其他层次。比如:应用层不需知道怎么传输和接收方在哪里</li>
</ul>
</li>
<li><strong>TCP/IP协议族各层的作用</strong><ul>
<li>应用层: 该层决定了想用户提供服务时的通信活动。TCP/IP协议族中预存了各类通用的应用服务,比如, FTP(File Transfer Protocol, 文件传输协议) 和 DNS (Domain Name System, 域名解析系统), HTTP协议处于应用层。</li>
<li>传输层: 该层对上层应用层, 提供处于网络连接中的两台计算机之间的数据传输。传输层中有两个性质不同的协议:<strong>TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User Data Protocol, 用户数据报协议)</strong></li>
<li>网络层(网路互连层): 该层用来处理在网络上流动的数据包, 数据包是在网络传输时的最小数据单位, 网络层规定了通过怎么样的路径到达对方的计算机,并把数据包发给对方</li>
<li>链路层(有名:数据链路层, 网络接口层):用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card,网络适配器,即网卡),及光纤等物理可见部分(还包括连接器等一切传输媒介)。硬件上的范畴均在<br>链路层的作用范围之内。</li>
</ul>
</li>
</ul>
<h5 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h5><p><img src="/uploads/图解HTTP/网络基础02.jpg" alt=""></p>
<ul>
<li>从上图,我们可以清楚:使用TCP/IP协议进行网络通信时,发送端是从应用层往下走,接收端是往应用层上走</li>
<li>我们用 HTTP 举例来说明,首先作为发送端的客户端在应用层(HTTP 协议)发出一个想看某个 Web 页面的 HTTP 请求。接着,为了传输方便,在传输层(TCP 协议)把从应用层处收到的数据(HTTP 请求报文)进行分割,并在各个报文上打上标记序号及端口号后转发给网络层。在网络层(IP 协议),增加作为通信目的地的 MAC地址后转发给链路层。这样一来,发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据,按序往上层发送,一直到应用层。当传输到应用层,才能算真正接收到由客户端发送过来的 HTTP请求。</li>
</ul>
<p><img src="/uploads/图解HTTP/网络基础03.jpg" alt=""></p>
<ul>
<li>发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息。反之,接收端在层与层传输数据时,经过一层时会把对应的首部消去。</li>
</ul>
<h5 id="与HTTP关系密切的协议-TCP-IP-DNS"><a href="#与HTTP关系密切的协议-TCP-IP-DNS" class="headerlink" title="与HTTP关系密切的协议: TCP IP DNS"></a>与HTTP关系密切的协议: TCP IP DNS</h5><ul>
<li>负责传输的IP协议:<br>1.按层次分,IP(Internet Protocol)网际协议位于网络层。<br>2.IP协议的作用是把各种数据包发送给对方,其中发送成功的;两个重要条件时:IP地址和MAC地址(Media Access Control Address)<br>3.MAC地址所指的是网卡地址,不可以改变,而IP地址则可以变换<br>4.在网络条通信中,双方同时位于同一个局域网内的情况是很少的,通常是是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时,会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时,会采用 ARP 协议(AddressResolution Protocol)。ARP 是一种用以解析地址的协议,根据通信方的 IP 地址就可以反查出对应的 MAC 地址。<br>5.无论哪台计算机、哪台网络设备,它们都无法全面掌握互联网中的细节。</li>
</ul>
<p><img src="/uploads/图解HTTP/网络基础04.jpg" alt=""></p>
<ul>
<li>确保可靠性的TCP协议</li>
</ul>
<ol>
<li>按层次分,TCP 位于传输层,提供可靠的字节流服务。所谓的字节流服务(Byte Stream Service)是指,为了方便传输,将大<br>块数据分割成以报文段(segment)为单位的数据包进行管理。而可靠的传输服务是指,能够把数据准确可靠地传给对方。一言以蔽之,TCP 协议为了更容易传送大数据才把数据分割,而且 TCP 协议能够确认数据最终是否送达到对方。</li>
<li>TCP协议采用三次握手(three-way-handshaking)策略来保证数据能准确无误的送达</li>
<li>握手过程中使用了 TCP 的标志(flag) —— SYN(synchronize) 和ACK(acknowledgement)。</li>
<li>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后,回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后,发送端再回传一个带ACK标志的数据包,代表“握手”结束。若在握手过程中某个阶段莫名中断,TCP协议会再次以相同的顺序发送相同的数据包。</li>
<li>除了上面的三次握手,TCP协议还有其他的协议来保证通信的可靠。</li>
</ol>
<p><img src="/uploads/图解HTTP/网络基础05.jpg" alt=""></p>
<ul>
<li>DNS:</li>
</ul>
<ol>
<li>DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址,或逆向从 IP 地址反查域名的服务。</li>
</ol>
<p><img src="/uploads/图解HTTP/网络基础06.jpg" alt=""></p>
<h5 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h5><p><img src="/uploads/图解HTTP/网络基础07.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络基础-TCP-IP&quot;&gt;&lt;a href=&quot;#网络基础-TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;网络基础 TCP/IP&quot;&gt;&lt;/a&gt;网络基础 TCP/IP&lt;/h4&gt;&lt;h5 id=&quot;TCP-IP协议族&quot;&gt;&lt;a href=&quot;#TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议族&quot;&gt;&lt;/a&gt;TCP/IP协议族&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;我们通常使用到的网络是在&lt;strong&gt;TCP/IP&lt;/strong&gt;协议族的基础上运作的。而HTTP属于它内部的一个子集。&lt;/li&gt;
&lt;li&gt;TCP/IP是互联网各类协议族的总称, 如图:&lt;br&gt;&lt;img src=&quot;/uploads/图解HTTP/网络基础01.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>创建MD应用</title>
    <link href="http://yoursite.com/2017/01/13/%E5%88%9B%E5%BB%BAMD%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/01/13/创建MD应用/</id>
    <published>2017-01-13T09:39:19.026Z</published>
    <updated>2017-01-13T09:39:19.014Z</updated>
    
    <content type="html"><![CDATA[<h4 id="快速创建MD风格的应用步骤"><a href="#快速创建MD风格的应用步骤" class="headerlink" title="快速创建MD风格的应用步骤:"></a>快速创建MD风格的应用步骤:</h4><ul>
<li>遵循MD设计规范</li>
<li>使用MD设计的主题</li>
<li>根据MD设计规范来设计布局, 通过设置阴影来体现各个元素之间的层次</li>
<li>多使用Design包中的MD风格控件</li>
<li>使用动画时遵循MD设计规范<a id="more"></a>
</li>
</ul>
<h5 id="使用材料主题"><a href="#使用材料主题" class="headerlink" title="使用材料主题:"></a>使用材料主题:</h5><p>材料主题的定义:</p>
<ul>
<li>@android:style/Theme.Material（深色版本）</li>
<li>@android:style/Theme.Material.Light（浅色版本）</li>
<li>@android:style/Theme.Material.Light.DarkActionBar</li>
</ul>
<p>与之对应的 Compat Theme（兼容包中提供）：</p>
<ul>
<li>Teme.AppCompat</li>
<li>Theme.AppCompat.Light</li>
<li>Theme.AppCompat.Light.DarkActionBar</li>
</ul>
<p>定制符合你应用风格的配色</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- inherit from the material theme --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="xml"></span></div><div class="line">    <span class="comment">&lt;!-- Main theme colors --&gt;</span></div><div class="line">    <span class="comment">&lt;!--   your app branding color for the app bar --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimary"</span>&gt;</span>@color/primary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--   darker variant for the status bar and contextual app bars --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimaryDark"</span>&gt;</span>@color/primary_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--   theme UI controls like checkboxes and text fields --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorAccent"</span>&gt;</span>@color/accent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>
<p>resources上的item对应应用上的配色位置</p>
<p><img src="https://developer.android.com/training/material/images/ThemeColors.png" alt=""></p>
<h5 id="多使用design包中的MD风格控件-常用的有如下"><a href="#多使用design包中的MD风格控件-常用的有如下" class="headerlink" title="多使用design包中的MD风格控件, 常用的有如下:"></a>多使用design包中的MD风格控件, 常用的有如下:</h5><ul>
<li>RecyclerView配合CardView展示列表</li>
<li>文本域: TextInputLayout, 该控件很适合应用在登录等需要输入账号密码的页面</li>
<li>FloatingActionButton, BottomSheet来与用户进行交互</li>
<li>使用SnakeBar来提醒用户</li>
<li>CoordinatorLayout + AppBarLayout + 折叠式Toolbar 三者配合来展示主页</li>
</ul>
<h5 id="使用MD风格的动画"><a href="#使用MD风格的动画" class="headerlink" title="使用MD风格的动画"></a>使用MD风格的动画</h5><ul>
<li>使用5.X新增的Activity动画,: 进入 退出 共享</li>
<li>使用元素的揭露效果动画</li>
<li>在定义动画的时候要注意遵循MD设计规范</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;快速创建MD风格的应用步骤&quot;&gt;&lt;a href=&quot;#快速创建MD风格的应用步骤&quot; class=&quot;headerlink&quot; title=&quot;快速创建MD风格的应用步骤:&quot;&gt;&lt;/a&gt;快速创建MD风格的应用步骤:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;遵循MD设计规范&lt;/li&gt;
&lt;li&gt;使用MD设计的主题&lt;/li&gt;
&lt;li&gt;根据MD设计规范来设计布局, 通过设置阴影来体现各个元素之间的层次&lt;/li&gt;
&lt;li&gt;多使用Design包中的MD风格控件&lt;/li&gt;
&lt;li&gt;使用动画时遵循MD设计规范
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="UI#MD" scheme="http://yoursite.com/tags/UI-MD/"/>
    
  </entry>
  
  <entry>
    <title>MD简单的设计规范</title>
    <link href="http://yoursite.com/2017/01/13/MD%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2017/01/13/MD简单的设计规范/</id>
    <published>2017-01-13T08:36:08.141Z</published>
    <updated>2017-01-13T08:36:08.129Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.xlgps.com/upload/6/7e/67e5abaf6fc4ba80830f9e0f6a00f9cc_thumb.png" alt=""><br><a id="more"></a></p>
<h3 id="styles规范"><a href="#styles规范" class="headerlink" title="styles规范"></a>styles规范</h3><h5 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h5><ul>
<li>根据MD的调色板,再选择适合你应用风格的配色板,选择你的应用主要的颜色,一般选三种,还有加一种强调色。</li>
<li>例如:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0Bzhp5Z4wHba3eHpqenBOaGxjRTA/style_color_colorscheme_palette1.png" alt=""></p>
<ul>
<li>上图的配色方案中,选择了紫色作为应用的主色调(饱和度不同的三种紫色), 一种绿色作为强调色</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0Bzhp5Z4wHba3VjVncGdNZ2RKUzQ/style_color_colorscheme_palette1_example.png" alt=""></p>
<ul>
<li>关于配色中的主色调: 该色调应该被广泛的应用来你的app中</li>
<li>关于配色中的强调色: 该色调应该用在fab等交互式的元素中, 例如: 文本域, 游标, 进度条, 链接等元素, 其作用是用来突出交互 </li>
</ul>
<h5 id="文字颜色和背景颜色的协调"><a href="#文字颜色和背景颜色的协调" class="headerlink" title="文字颜色和背景颜色的协调"></a>文字颜色和背景颜色的协调</h5><ul>
<li>文字的不透明值应该根据背景颜色是亮色还是暗色来调节</li>
<li><p>黑字亮色背景:</p>
<ul>
<li>最重要的文字不透明度87%</li>
<li>第二重要的文字不透明度54%</li>
<li>一些提示性的文本(editText的提示, 标签)的不透明度38%</li>
</ul>
</li>
<li><p>白字暗色背景</p>
<ul>
<li>最重要的文字不透明度100%</li>
<li>第二重要的文字不透明度70%</li>
<li>一些提示性的文本(editText的提示, 标签)的不透明度50%</li>
</ul>
</li>
</ul>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h5 id="基线与间隔"><a href="#基线与间隔" class="headerlink" title="基线与间隔:"></a>基线与间隔:</h5><ul>
<li>列表类型例子:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0B6Okdz75tqQseWRUbzJuUnpkNHM/layout_metrics_keyline_mobile2.png" alt=""></p>
<ul>
<li>水平布局的基线和间距</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0B6Okdz75tqQsWFRSRjhiV2t2WEE/layout_metrics_keyline_mobile3.png" alt=""></p>
<ul>
<li>垂直布局:其中</li>
</ul>
<p>1.Status bar: 24dp<br>2.Toolbar: 56dp<br>3.Subtitle: 48dp<br>4.List item: 72dp</p>
<ul>
<li>水平布局:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0B6Okdz75tqQsMldpS1Bzc2R0NVk/layout_metrics_keyline_mobile5.png" alt=""></p>
<ul>
<li>垂直布局:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0B6Okdz75tqQsUXV2Z1gwVjdFS0E/layout_metrics_keyline_mobile6.png" alt=""></p>
<p>Status bar: 24dp<br>Toolbar: 56dp<br>Title and list items: 72dp<br>Subtitle: 48dp<br>Space between content areas: 8dp</p>
<ul>
<li>详细布局类型例子:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0B6Okdz75tqQsNVlYYkdnMktUVmc/layout_metrics_keyline_mobile8.png" alt=""></p>
<ul>
<li>水平布局</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0B6Okdz75tqQsN0hFU2wxOHNNU3M/layout_metrics_keyline_mobile9.png" alt=""></p>
<ul>
<li>垂直布局:其中</li>
</ul>
<p>1.Status bar: 24dp<br>2.Toolbar: 56dp<br>3.Space between content areas: 8dp<br>4.List item: 72dp</p>
<ul>
<li>Navigation drawer例子</li>
<li>水平布局:</li>
</ul>
<p><img src="http://image.xlgps.com/upload/6/7e/67e5abaf6fc4ba80830f9e0f6a00f9cc_thumb.png" alt=""></p>
<ul>
<li>垂直布局</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0Bzhp5Z4wHba3a2M3SVNnRWlWUFE/layout_metrics_keyline_mobile15.png" alt=""></p>
<p>1.Account menu and list items: 48dp<br>2.Space between content areas: 8dp<br>3.Navigation right margin: 56dp</p>
<h5 id="比例边框"><a href="#比例边框" class="headerlink" title="比例边框"></a>比例边框</h5><ul>
<li>比例推荐:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0Bx4BSt6jniD7ZjBCVzdPOENpT28/layout_metrics_ratiokeylines1.png" alt=""></p>
<ul>
<li>例子:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0B9msDEx00QXmR1RZZndvR2lNUDQ/layout_metrics_ratiokeylines2.png" alt=""></p>
<h5 id="可触摸空间的大小"><a href="#可触摸空间的大小" class="headerlink" title="可触摸空间的大小"></a>可触摸空间的大小</h5><ul>
<li>大小: 最少48 * 48 dp, 大多数情况下可触摸空间之间的间隔要大于8dp</li>
<li>例子:</li>
</ul>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0Bx4BSt6jniD7eEVhSW1nVjBrZnM/layout_metrics_touchtarget1.png" alt=""></p>
<p><img src="https://storage.googleapis.com/material-design/publish/material_v_10/assets/0Bx4BSt6jniD7dlN4cEMwWm9Tc28/layout_metrics_touchtarget3.png" alt=""></p>
<blockquote>
<p>参考资料: <a href="https://material.io/guidelines/motion/material-motion.html#material-motion-how-does-material-move" target="_blank" rel="external">https://material.io/guidelines/motion/material-motion.html#material-motion-how-does-material-move</a><br>图片来源: www.xlgps.com</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.xlgps.com/upload/6/7e/67e5abaf6fc4ba80830f9e0f6a00f9cc_thumb.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="design" scheme="http://yoursite.com/categories/design/"/>
    
    
      <category term="设计#MD设计" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1-MD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>universal-image-loader缓存策略</title>
    <link href="http://yoursite.com/2017/01/13/universal-image-loader%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2017/01/13/universal-image-loader内存缓存策略/</id>
    <published>2017-01-13T04:43:01.347Z</published>
    <updated>2016-11-26T14:39:39.651Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>有看过UIL源码的人都应该知道，库中缓存使用了策略模式来对bitmap进行缓存。这次来单独来分析其中的内存缓存策略<br><a id="more"></a></p>
<h5 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h5><p>接口：</p>
<ul>
<li>MemoryCacheAware：底层接口，里面定义了基本的缓存操作方法</li>
<li>MemoryCache：单纯继承了MemoryCacheAware接口</li>
</ul>
<p>抽象类：</p>
<ul>
<li>BaseMemoryCache：实现了MemoryCahce，运用弱引用包装Bitmap后缓存存在HashMap中。同时也实现了MemoryCacheAware中的接口的方法</li>
<li>LimitedMemoryCache：这个类继承BaseMemoryCahce，并在类中扩展了一级强引用缓存，也就是说LimitedMemoryCache是拥有双级缓存的（强引用缓存，弱引用缓存）。<ul>
<li>LimitedMemoryCache会限制内存的缓存大小，当达到缓存达到最大的内存缓存时，会移除缓存，至于移除的策略，库中有提供几个实现策略。</li>
</ul>
</li>
</ul>
<p>具体实现类：</p>
<ul>
<li>WeakMeoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakMemoryCache</span> <span class="keyword">extends</span> <span class="title">BaseMemoryCache</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WeakMemoryCache是继承自BaseMemoryCache，并且只是重写了createReference，所有WeakMemoryCache只有弱引用的缓存。</p>
<ul>
<li>LruMemoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Bitmap&gt; map;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</div><div class="line">    <span class="comment">/** Size of this cache in bytes */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@param</span> maxSize Maximum sum of the sizes of the Bitmaps in this cache */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruMemoryCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;String, Bitmap&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the Bitmap for &#123;<span class="doctag">@code</span> key&#125; if it exists in the cache. If a Bitmap was returned, it is moved to the head</div><div class="line">     * of the queue. This returns null if a Bitmap is not cached.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">return</span> map.get(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Caches &#123;<span class="doctag">@code</span> Bitmap&#125; for &#123;<span class="doctag">@code</span> key&#125;. The Bitmap is moved to the head of the queue. */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            size += sizeOf(key, value);</div><div class="line">            Bitmap previous = map.put(key, value);</div><div class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                size -= sizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        trimToSize(maxSize);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove the eldest entries until the total of remaining entries is at or below the requested size.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1 to evict even 0-sized elements.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            String key;</div><div class="line">            Bitmap value;</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName() + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Map.Entry&lt;String, Bitmap&gt; toEvict = map.entrySet().iterator().next();</div><div class="line">                <span class="keyword">if</span> (toEvict == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                key = toEvict.getKey();</div><div class="line">                value = toEvict.getValue();</div><div class="line">                map.remove(key);</div><div class="line">                size -= sizeOf(key, value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists. */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Bitmap previous = map.remove(key);</div><div class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                size -= sizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> previous;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;String&gt;(map.keySet());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        trimToSize(-<span class="number">1</span>); <span class="comment">// -1 will evict 0-sized elements</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the size &#123;<span class="doctag">@code</span> Bitmap&#125; in bytes.</div><div class="line">     * &lt;p/&gt;</div><div class="line">     * An entry's size must not change while it is in the cache.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(<span class="string">"LruCache[maxSize=%d]"</span>, maxSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LruMemoryCache继承自MemoryCache，因此只有强引用的缓存，LruMemoryCache移除缓存的策略是使用最近最少使用算法，即每次通过get得到的Bitmap都会放在队列头，移除的时候就会先从队列尾移除，这样就保证了最少使用的最先被移除</p>
<ul>
<li>LimitedAgeMemoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedAgeMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxAge;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Long&gt; loadingDates = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Long&gt;());</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> cache  Wrapped memory cache</div><div class="line">     * <span class="doctag">@param</span> maxAge Max object age &lt;b&gt;(in seconds)&lt;/b&gt;. If object age will exceed this value then it'll be removed from</div><div class="line">     *               cache on next treatment (and therefore be reloaded).</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitedAgeMemoryCache</span><span class="params">(MemoryCache cache, <span class="keyword">long</span> maxAge)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.cache = cache;</div><div class="line">        <span class="keyword">this</span>.maxAge = maxAge * <span class="number">1000</span>; <span class="comment">// to milliseconds</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> putSuccesfully = cache.put(key, value);</div><div class="line">        <span class="keyword">if</span> (putSuccesfully) &#123;</div><div class="line">            loadingDates.put(key, System.currentTimeMillis());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> putSuccesfully;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Long loadingDate = loadingDates.get(key);</div><div class="line">        <span class="keyword">if</span> (loadingDate != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() - loadingDate &gt; maxAge) &#123;</div><div class="line">            cache.remove(key);</div><div class="line">            loadingDates.remove(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        loadingDates.remove(key);</div><div class="line">        <span class="keyword">return</span> cache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.keys();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        cache.clear();</div><div class="line">        loadingDates.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>LimitedAgeMemoryCache是MemoryCache的装饰类，也就是说LimitedAgeMemoryCache可以装饰实现了MemoryCache接口的类，比如LruMemoryCache。那么装饰的新功能是什么？</li>
<li><p>通过上面源码，可以清楚的得出，LimitedAgeMemoryCache是通过判断Bitmap的缓存时间是否超过在初始化传入时的缓存最大时间。超过的话就从内存中移除。</p>
</li>
<li><p>FuzzyKeyMemoryCache：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuzzyKeyMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;String&gt; keyComparator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FuzzyKeyMemoryCache</span><span class="params">(MemoryCache cache, Comparator&lt;String&gt; keyComparator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.cache = cache;</div><div class="line">        <span class="keyword">this</span>.keyComparator = keyComparator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Search equal key and remove this entry</span></div><div class="line">        <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line">            String keyToRemove = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (String cacheKey : cache.keys()) &#123;</div><div class="line">                <span class="keyword">if</span> (keyComparator.compare(key, cacheKey) == <span class="number">0</span>) &#123;</div><div class="line">                    keyToRemove = cacheKey;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (keyToRemove != <span class="keyword">null</span>) &#123;</div><div class="line">                cache.remove(keyToRemove);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cache.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        cache.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.keys();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FuzzyKeyMemoryCache也是继承自MemoryCache，同时也是MemoryCache的装饰类，装饰的新功能是：</li>
<li><p>当添加Bitmap进缓存时，如果添加进去的key跟之前添加过的key值相同的话，从内存移除之前key值对应的Bitmap，添加新传进来的Bitmap到内存。至于key相同的标准是什么,这个得根据自身的需求在重写Comparator对象并在初始化的时候传入。</p>
</li>
<li><p><strong>UsingFreqLimitedMemoryCache</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingFreqLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Contains strong references to stored objects (keys) and last object usage date (in milliseconds). If hard cache</div><div class="line">     * size will exceed limit then object with the least frequently usage is deleted (but it continue exist at</div><div class="line">     * &#123;<span class="doctag">@link</span> #softMap&#125; and can be collected by GC at any time)</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, Integer&gt; usingCounts = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Bitmap, Integer&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsingFreqLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            usingCounts.put(value, <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="comment">// Increment usage count for value if value is contained in hardCahe</span></div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            Integer usageCount = usingCounts.get(value);</div><div class="line">            <span class="keyword">if</span> (usageCount != <span class="keyword">null</span>) &#123;</div><div class="line">                usingCounts.put(value, usageCount + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            usingCounts.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        usingCounts.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer minUsageCount = <span class="keyword">null</span>;</div><div class="line">        Bitmap leastUsedValue = <span class="keyword">null</span>;</div><div class="line">        Set&lt;Entry&lt;Bitmap, Integer&gt;&gt; entries = usingCounts.entrySet();</div><div class="line">        <span class="keyword">synchronized</span> (usingCounts) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;Bitmap, Integer&gt; entry : entries) &#123;</div><div class="line">                <span class="keyword">if</span> (leastUsedValue == <span class="keyword">null</span>) &#123;</div><div class="line">                    leastUsedValue = entry.getKey();</div><div class="line">                    minUsageCount = entry.getValue();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Integer lastValueUsage = entry.getValue();</div><div class="line">                    <span class="keyword">if</span> (lastValueUsage &lt; minUsageCount) &#123;</div><div class="line">                        minUsageCount = lastValueUsage;</div><div class="line">                        leastUsedValue = entry.getKey();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        usingCounts.remove(leastUsedValue);</div><div class="line">        <span class="keyword">return</span> leastUsedValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>UsingFreqLimitedMemoryCache继承自LimitedMemoryCache，所以他拥有双级缓存用能（强弱引用缓存）。</li>
<li><p>UsingFreqLimitedMemoryCache的移除缓存的策略：每次使用get获得Bitmap时都会记录Bitmap使用的次数。要移除时，移除使用最少的次数的Bitmap，移除的只是强引用的缓存，弱引用中的缓存并不一定有被移除</p>
</li>
<li><p><strong>LRULimit</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">1.1f</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** Cache providing Least-Recently-Used logic */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Bitmap&gt; lruCache = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap&lt;String, Bitmap&gt;(INITIAL_CAPACITY, LOAD_FACTOR, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@param</span> maxSize Maximum sum of the sizes of the Bitmaps in this cache */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(maxSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            lruCache.put(key, value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        lruCache.get(key); <span class="comment">// call "get" for LRU logic</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        lruCache.remove(key);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        lruCache.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Bitmap mostLongUsedValue = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (lruCache) &#123;</div><div class="line">            Iterator&lt;Entry&lt;String, Bitmap&gt;&gt; it = lruCache.entrySet().iterator();</div><div class="line">            <span class="keyword">if</span> (it.hasNext()) &#123;</div><div class="line">                Entry&lt;String, Bitmap&gt; entry = it.next();</div><div class="line">                mostLongUsedValue = entry.getValue();</div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mostLongUsedValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>LRULimitedMemoryCache继承自LimitedMemoryCache，同样也是具有两级缓存。而移除的策略是lru算法，这里不多分析。</p>
</li>
<li><p><strong>LargestLimitedMemoryCache</strong> </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Contains strong references to stored objects (keys) and sizes of the objects. If hard cache</div><div class="line">     * size will exceed limit then object with the largest size is deleted (but it continue exist at</div><div class="line">     * &#123;<span class="doctag">@link</span> #softMap&#125; and can be collected by GC at any time)</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, Integer&gt; valueSizes = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Bitmap, Integer&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LargestLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            valueSizes.put(value, getSize(value));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            valueSizes.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        valueSizes.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer maxSize = <span class="keyword">null</span>;</div><div class="line">        Bitmap largestValue = <span class="keyword">null</span>;</div><div class="line">        Set&lt;Entry&lt;Bitmap, Integer&gt;&gt; entries = valueSizes.entrySet();</div><div class="line">        <span class="keyword">synchronized</span> (valueSizes) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;Bitmap, Integer&gt; entry : entries) &#123;</div><div class="line">                <span class="keyword">if</span> (largestValue == <span class="keyword">null</span>) &#123;</div><div class="line">                    largestValue = entry.getKey();</div><div class="line">                    maxSize = entry.getValue();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Integer size = entry.getValue();</div><div class="line">                    <span class="keyword">if</span> (size &gt; maxSize) &#123;</div><div class="line">                        maxSize = size;</div><div class="line">                        largestValue = entry.getKey();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        valueSizes.remove(largestValue);</div><div class="line">        <span class="keyword">return</span> largestValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LargestLimitedMemoryCache继承自LimitedMemoryCache，拥有双级缓存。移除缓存的策略是移除占内存最大的Bitmap</p>
<ul>
<li><strong>FIFOLimitedMemoryCache</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FIFOLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Bitmap&gt; queue = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;Bitmap&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            queue.add(value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            queue.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.remove(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理也是具有双级缓存功能，移除缓存的策略是移除头部的Bitmap</p>
<h5 id="内存缓存策略总结："><a href="#内存缓存策略总结：" class="headerlink" title="内存缓存策略总结："></a>内存缓存策略总结：</h5><ul>
<li><p>类库中提供的三个接口：</p>
<ul>
<li>MemoryCache：实现该接口的类只有强引用的缓存功能</li>
<li>BaseMemoryCache：实现该接口的类只有弱引用的缓存功能</li>
<li>LimitedMemoryCache：实现该类的拥有两级缓存功能（强弱引用功能）</li>
</ul>
</li>
<li><p>库中针对这三个接口，都给出了具体的实现类，我们可以根据自己的需求来设置缓存策略，默认的是LruMemoryCache</p>
</li>
<li>关于双级缓存：实现了LimitMemoryCache的类都具有双级缓存，但是为什么要使用双级缓存？<ul>
<li>理解：缓存内存的最大值是固定的，超过这个值后，我们就得从内存中移除Bitmap，但是我们有时不是想要移除，只是内存不足了，我们被迫移除了Bitmap，所以增加了一级强引用的缓存，当内存不足 时，首先移除强引用的Bitmap，弱引用并没有被移除。这样下次如果请求相同的Bitmap时，就可以从弱引用的缓存中取出。但是这样做也有缺点，牺牲了内存。</li>
<li>总体说就是双级缓存就是通过牺牲内存来提高响应速度。</li>
</ul>
</li>
<li>如果觉得库中提供给我们的策略不符合自己的业务需求的话，可以根据自己的业务需求来定制缓存策略。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;有看过UIL源码的人都应该知道，库中缓存使用了策略模式来对bitmap进行缓存。这次来单独来分析其中的内存缓存策略&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="图片加载框架#universal-image-loader" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6-universal-image-loader/"/>
    
  </entry>
  
  <entry>
    <title>universal-image-loader源码浅读</title>
    <link href="http://yoursite.com/2017/01/13/universal-image-loader%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2017/01/13/universal-image-loader源码浅析/</id>
    <published>2017-01-13T04:43:01.335Z</published>
    <updated>2016-11-26T14:39:47.107Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul>
<li>UIL是一款经典的图片加载框架，该类库的设计运用了多种设计模式，使得它的可拓展性增加，比如缓存的策略，如果默认的缓存策略不能够满足你的需求的话，你完全可以自己定制自己的缓存策略。</li>
<li>使用者不必关心加载图片时会发生OOM，其中发生的概率还是很小的，因为类库中对图片进行了三级缓存，其中的内存缓存使用了双级缓存（强引用和弱引用）。</li>
<li>库中考虑到用户可能会使用ListView，GridView或者RecyclerView来展示图片，因此在库中提供了一个PauseOnScrollListener来控制滑动时是否要加载图片。</li>
<li>这次，简单来分析类库的使用流程<a id="more"></a>
</li>
</ul>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul>
<li>使用过UIL的都知道，需要先在Application中初始化：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建默认的ImageLoader配置参数  </span></div><div class="line">       ImageLoaderConfiguration configuration = ImageLoaderConfiguration  </div><div class="line">               .createDefault(<span class="keyword">this</span>);  </div><div class="line">         </div><div class="line">       <span class="comment">//Initialize ImageLoader with configuration.  </span></div><div class="line">       ImageLoader.getInstance().init(configuration);</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码是在Application中初始化UIL，ImageLoaderConfiguration.createDefault(this)是创建默认的参数配置</li>
<li>点入该方法中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoaderConfiguration <span class="title">createDefault</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder(context).build();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以看到，在方法中，new了一个Builder，也就是说用建造者模式来初始化默认配置</li>
<li>再进入build()中，发现其中会调initEmptyFieldsWithDefaultValues()来初始化默认配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEmptyFieldsWithDefaultValues</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (taskExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">                taskExecutor = DefaultConfigurationFactory</div><div class="line">                        .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                customExecutor = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (taskExecutorForCachedImages == <span class="keyword">null</span>) &#123;</div><div class="line">                taskExecutorForCachedImages = DefaultConfigurationFactory</div><div class="line">                        .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                customExecutorForCachedImages = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (diskCacheFileNameGenerator == <span class="keyword">null</span>) &#123;</div><div class="line">                    diskCacheFileNameGenerator = DefaultConfigurationFactory.createFileNameGenerator();</div><div class="line">                &#125;</div><div class="line">                diskCache = DefaultConfigurationFactory</div><div class="line">                        .createDiskCache(context, diskCacheFileNameGenerator, diskCacheSize, diskCacheFileCount);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</div><div class="line">                memoryCache = DefaultConfigurationFactory.createMemoryCache(memoryCacheSize);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (denyCacheImageMultipleSizesInMemory) &#123;</div><div class="line">                memoryCache = <span class="keyword">new</span> FuzzyKeyMemoryCache(memoryCache, MemoryCacheUtils.createFuzzyKeyComparator());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</div><div class="line">                downloader = DefaultConfigurationFactory.createImageDownloader(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (decoder == <span class="keyword">null</span>) &#123;</div><div class="line">                decoder = DefaultConfigurationFactory.createImageDecoder(writeLogs);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (defaultDisplayImageOptions == <span class="keyword">null</span>) &#123;</div><div class="line">                defaultDisplayImageOptions = DisplayImageOptions.createSimple();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>该方法内会判断使用者是否有自定义的参数，没有的话，就在默认的参数工厂DefaultConfigurationFactory中创建对应的配置实例</li>
<li><p>至于配置参数是什么，这里就不详细讲</p>
</li>
<li><p>初始化完配置参数后，会调用Image Loader的init方法来初始化imageLoader，下面来看看init中做了那些初始化操作：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ImageLoaderConfiguration configuration)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (configuration == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ERROR_INIT_CONFIG_WITH_NULL);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configuration == <span class="keyword">null</span>) &#123;</div><div class="line">            L.d(LOG_INIT_CONFIG);</div><div class="line">            engine = <span class="keyword">new</span> ImageLoaderEngine(configuration);</div><div class="line">            <span class="keyword">this</span>.configuration = configuration;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            L.w(WARNING_RE_INIT_CONFIG);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>init方法中实例化了ImageLoaderEngine对象，该类的作用主要是用来控制任务的执行</li>
</ul>
<h5 id="displayImage"><a href="#displayImage" class="headerlink" title="displayImage"></a>displayImage</h5><ul>
<li>初始化完成后，我们就可以调用displayImage来展示图片，该方法有多个重载方法，不过最后都会调用到一下的重载方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String uri, ImageAware imageAware, DisplayImageOptions options,</span></span></div><div class="line">            ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</div><div class="line">        checkConfiguration();</div><div class="line">        <span class="keyword">if</span> (imageAware == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ERROR_WRONG_ARGUMENTS);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</div><div class="line">            listener = emptyListener;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (options == <span class="keyword">null</span>) &#123;</div><div class="line">            options = configuration.defaultDisplayImageOptions;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(uri)) &#123;</div><div class="line">            engine.cancelDisplayTaskFor(imageAware);</div><div class="line">            listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line">            <span class="keyword">if</span> (options.shouldShowImageForEmptyUri()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ImageSize targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</div><div class="line">        String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);</div><div class="line">        engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</div><div class="line"></div><div class="line">        listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line"></div><div class="line">        Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);</div><div class="line">        <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; !bmp.isRecycled()) &#123;</div><div class="line">            L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (options.shouldPostProcess()) &#123;</div><div class="line">                ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                        options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">                ProcessAndDisplayImageTask displayTask = <span class="keyword">new</span> ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</div><div class="line">                        defineHandler(options));</div><div class="line">                <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                    displayTask.run();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    engine.submit(displayTask);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</div><div class="line">                listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (options.shouldShowImageOnLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.isResetViewBeforeLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">            LoadAndDisplayImageTask displayTask = <span class="keyword">new</span> LoadAndDisplayImageTask(engine, imageLoadingInfo,</div><div class="line">                    defineHandler(options));</div><div class="line">            <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                displayTask.run();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                engine.submit(displayTask);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在看方法的代码之前，先来看看其中的参数</li>
<li>uri：图片的路径</li>
<li>ImageAware：该接口的具体实现类会将ImageView包装成弱引用，这样使得GC能够及时回收ImageView，具体的实现类这里也不做多分析</li>
<li>DisplayImageOptions：展示图片时的参数配置，比如：默认的加载图片，加载失败展示的图片，是否开启内存缓存，磁盘缓存等</li>
<li>ImageLoadingListener：加载图片过程中的监听接口，类库中有提供缺省的类，方便我们重写其中的任何一个方法</li>
<li><p>ImageLoadingProgressListener：加载的进度监听接口</p>
</li>
<li><p>OK，解释完上面的参数，我们来看看方法：</p>
</li>
<li>首先会先调用checkConfiguration来见检查Configuration是否已经初始化，没有的话，抛出异常</li>
</ul>
<h5 id="传入的uri为空时的操作"><a href="#传入的uri为空时的操作" class="headerlink" title="传入的uri为空时的操作"></a>传入的uri为空时的操作</h5><ul>
<li>接着我们来分步剖析该方法，先来看下面的一段代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (TextUtils.isEmpty(uri)) &#123;</div><div class="line">            engine.cancelDisplayTaskFor(imageAware);</div><div class="line">            listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line">            <span class="keyword">if</span> (options.shouldShowImageForEmptyUri()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码的逻辑是对传入的uri为null时的处理</li>
<li><p>首先调用engine将缓存的imageAware的key值取消掉，接着如果有设置默认展示的图片的话，就展示，没有的话就直接调用回调接口的onLoadingComplte来表示展示完图片</p>
</li>
<li><p>下面来看看传入uri不为空的处理：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ImageSize targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</div><div class="line">    String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);</div><div class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</div><div class="line"></div><div class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line"></div><div class="line">    Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);</div></pre></td></tr></table></figure>
<ul>
<li><p>先获得Image的大小，接着生成image的缓存key值，最后调用engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);将image的key缓存在map中（在执行完后会被移除出缓存），最后从缓存中取出bitmap。</p>
</li>
<li><p>接下来，对该bitmap进行分情况的处理：存在缓存和不存在缓存</p>
</li>
</ul>
<h5 id="从内存中取出的Bitmap为空的操作"><a href="#从内存中取出的Bitmap为空的操作" class="headerlink" title="从内存中取出的Bitmap为空的操作"></a>从内存中取出的Bitmap为空的操作</h5><ul>
<li>不存在缓存中，也就是bitmap为null：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (options.shouldShowImageOnLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.isResetViewBeforeLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">            LoadAndDisplayImageTask displayTask = <span class="keyword">new</span> LoadAndDisplayImageTask(engine, imageLoadingInfo,</div><div class="line">                    defineHandler(options));</div><div class="line">            <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                displayTask.run();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                engine.submit(displayTask);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在这种情况下，会先判断是否有设置加载图片过程中要展示的图片和图片在加载的过程中是否有被重新设置，有的话分别做相应的操作</li>
<li>接着将展示图片需要用到的配置参数包装成一个ImageLoadingInfo对象</li>
<li>再紧接着实例化LoadAndDisplayImageTask，该类的作用主要是从网络上或者文件系统中加载图片</li>
<li><p>最后判断是否需要同步加载，是的话在当前线程中run，否则调用engine中的submit提交一个任务</p>
</li>
<li><p>下面我们来分别对同步和异步加载两种情况进行分析：</p>
<h5 id="同步展示图片："><a href="#同步展示图片：" class="headerlink" title="同步展示图片："></a>同步展示图片：</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (waitIfPaused()) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (delayIfNeed()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        ReentrantLock loadFromUriLock = imageLoadingInfo.loadFromUriLock;</div><div class="line">        L.d(LOG_START_DISPLAY_IMAGE_TASK, memoryCacheKey);</div><div class="line">        <span class="keyword">if</span> (loadFromUriLock.isLocked()) &#123;</div><div class="line">            L.d(LOG_WAITING_FOR_IMAGE_LOADED, memoryCacheKey);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        loadFromUriLock.lock();</div><div class="line">        Bitmap bmp;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            checkTaskNotActual();</div><div class="line"></div><div class="line">            bmp = configuration.memoryCache.get(memoryCacheKey);</div><div class="line">            <span class="keyword">if</span> (bmp == <span class="keyword">null</span> || bmp.isRecycled()) &#123;</div><div class="line">                bmp = tryLoadBitmap();</div><div class="line">                <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// listener callback already was fired</span></div><div class="line"></div><div class="line">                checkTaskNotActual();</div><div class="line">                checkTaskInterrupted();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (options.shouldPreProcess()) &#123;</div><div class="line">                    L.d(LOG_PREPROCESS_IMAGE, memoryCacheKey);</div><div class="line">                    bmp = options.getPreProcessor().process(bmp);</div><div class="line">                    <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">                        L.e(ERROR_PRE_PROCESSOR_NULL, memoryCacheKey);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.isCacheInMemory()) &#123;</div><div class="line">                    L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</div><div class="line">                    configuration.memoryCache.put(memoryCacheKey, bmp);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                loadedFrom = LoadedFrom.MEMORY_CACHE;</div><div class="line">                L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.shouldPostProcess()) &#123;</div><div class="line">                L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</div><div class="line">                bmp = options.getPostProcessor().process(bmp);</div><div class="line">                <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">                    L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            checkTaskNotActual();</div><div class="line">            checkTaskInterrupted();</div><div class="line">        &#125; <span class="keyword">catch</span> (TaskCancelledException e) &#123;</div><div class="line">            fireCancelEvent();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            loadFromUriLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</div><div class="line">        runTask(displayBitmapTask, syncLoading, handler, engine);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先会做出两种判断：一种是是否暂停加载（库中有一个PauseOnScrollListener来控制是否要暂停加载图片）和是否要延迟进行</li>
<li>接下来尝试从内存内存缓存中取出Bitmap，如果Bitmap为null或者被回收了的话调用tryLoadBitmap</li>
<li>在tryLoadBitmap中会先尝试从硬盘缓存中取出存放Bitmap流的文件，如果存在的话返回获得的Bitmap，否则尝试从网络上加载图片，加载完成后顺便写进硬盘（如果设置了硬盘缓存的话）</li>
<li><p>再得到Bitmap以后回到run方法中，将bitmap写进内存缓存</p>
</li>
<li><p>如果bitmap存在缓存中的话，就直接使用该Bitmap</p>
</li>
<li><p>最后：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</div><div class="line">runTask(displayBitmapTask, syncLoading, handler, engine);</div></pre></td></tr></table></figure>
<ul>
<li><p>包装成一个展示Bitmap的Task，并调用runTask来执行展示Image的Task</p>
</li>
<li><p>以上的就是同步时，展示Image的操作，下面我们来分析异步展示图片</p>
</li>
</ul>
<h5 id="异步展示图片："><a href="#异步展示图片：" class="headerlink" title="异步展示图片："></a>异步展示图片：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Submits task to execution pool */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(<span class="keyword">final</span> LoadAndDisplayImageTask task)</span> </span>&#123;</div><div class="line">        taskDistributor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                File image = configuration.diskCache.get(task.getLoadingUri());</div><div class="line">                <span class="keyword">boolean</span> isImageCachedOnDisk = image != <span class="keyword">null</span> &amp;&amp; image.exists();</div><div class="line">                initExecutorsIfNeed();</div><div class="line">                <span class="keyword">if</span> (isImageCachedOnDisk) &#123;</div><div class="line">                    taskExecutorForCachedImages.execute(task);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    taskExecutor.execute(task);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法中有三个线程池：一：taskDistributor：任务分派线程池；二：taskExecutorForCachedImages缓存执行线程池；三：taskExecutor普通执行线程池</li>
<li>主要逻辑：通过从硬盘缓存中取出存放bitmap流的文件，如果该文件存在的话，在taskExecutorForCachedImages中执行传入的task，否则在普通线程池中执行task，至于怎么执行，我们在刚刚已经分析了。</li>
</ul>
<h5 id="取出的Bitmap不为空的操作"><a href="#取出的Bitmap不为空的操作" class="headerlink" title="取出的Bitmap不为空的操作"></a>取出的Bitmap不为空的操作</h5><ul>
<li><p>回到displayImage中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; !bmp.isRecycled()) &#123;</div><div class="line">            L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (options.shouldPostProcess()) &#123;</div><div class="line">                ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                        options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">                ProcessAndDisplayImageTask displayTask = <span class="keyword">new</span> ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</div><div class="line">                        defineHandler(options));</div><div class="line">                <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                    displayTask.run();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    engine.submit(displayTask);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</div><div class="line">                listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面代码中一开始包装了ProcessAndDisplayImageTask对象，该对象主要是Bitmap存在缓存中的Task对象，接着判断是要异步执行还是同步执行，最后的操作跟前面分析的逻辑差不多，这里也不做分析了</p>
</li>
</ul>
<h5 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h5><ul>
<li>上面主要分析了常用的一个displayImage而已，并且只是分析了一个调用流程，并没有分析其中的缓存策略还有其他的细节</li>
<li>在上面分析的流程中，我们可以清楚得体会ImageLoader中的分层思想。比如：对Bitmap存在内存与否分了两个展示图片的Task，执行不同类型的任务的线程池等。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;UIL是一款经典的图片加载框架，该类库的设计运用了多种设计模式，使得它的可拓展性增加，比如缓存的策略，如果默认的缓存策略不能够满足你的需求的话，你完全可以自己定制自己的缓存策略。&lt;/li&gt;
&lt;li&gt;使用者不必关心加载图片时会发生OOM，其中发生的概率还是很小的，因为类库中对图片进行了三级缓存，其中的内存缓存使用了双级缓存（强引用和弱引用）。&lt;/li&gt;
&lt;li&gt;库中考虑到用户可能会使用ListView，GridView或者RecyclerView来展示图片，因此在库中提供了一个PauseOnScrollListener来控制滑动时是否要加载图片。&lt;/li&gt;
&lt;li&gt;这次，简单来分析类库的使用流程
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="图片加载框架#universal-image-loader" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6-universal-image-loader/"/>
    
  </entry>
  
  <entry>
    <title>Volley--网络优化和缓存</title>
    <link href="http://yoursite.com/2017/01/13/Volley--%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E5%92%8C%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/01/13/Volley--网络优化和缓存/</id>
    <published>2017-01-13T04:43:01.315Z</published>
    <updated>2016-11-01T10:42:47.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>volley的特点都大家很清楚，volley适合数据量小且通信频繁的请求，但是不适合数据量大的请求。volley有这样的特点是由其内部网络优化和缓存所决定的，这次分析其中的原理。<br><a id="more"></a></p>
<h4 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h4><h5 id="ByteArrayPool"><a href="#ByteArrayPool" class="headerlink" title="ByteArrayPool"></a>ByteArrayPool</h5><ul>
<li>首先Volley网络优化跟两个类息息相关，他们分别是ByteArrayPool和PoolingByteArrayOutputStream。接下来首先分析前者。</li>
<li>进入该类中，可以看到该类很长的文档注释。主要的意思是为了减少堆内存的压力而在将该类作为一个字节缓冲池。</li>
<li><p>首先看看该类中的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** The buffer pool, arranged both by last use and by buffer size */</span></div><div class="line">  <span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersByLastUse = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">byte</span>[]&gt;();</div><div class="line">  <span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersBySize = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(<span class="number">64</span>);</div><div class="line"></div><div class="line">  <span class="comment">/** The total size of the buffers in the pool */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> mCurrentSize = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay</div><div class="line">   * under this limit.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mSizeLimit;</div></pre></td></tr></table></figure>
</li>
<li><p>两个List集合都是存放byte数组，也就是字节缓冲。mCurrentSize是记录当前缓冲池的大小。mSizeLimit是缓冲池的大小。</p>
</li>
<li><p>了解完成员变量的作用后，我们来看看其中的核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns a buffer from the pool if one is available in the requested size, or allocates a new</div><div class="line">     * one if a pooled one is not available.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> len the minimum size, in bytes, of the requested buffer. The returned buffer may be</div><div class="line">     *        larger.</div><div class="line">     * <span class="doctag">@return</span> a byte[] buffer is always returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] getBuf(<span class="keyword">int</span> len) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class="line">            <span class="keyword">byte</span>[] buf = mBuffersBySize.get(i);</div><div class="line">            <span class="keyword">if</span> (buf.length &gt;= len) &#123;</div><div class="line">                mCurrentSize -= buf.length;</div><div class="line">                mBuffersBySize.remove(i);</div><div class="line">                mBuffersByLastUse.remove(buf);</div><div class="line">                <span class="keyword">return</span> buf;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[len];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法的作用是向字节数组缓冲池中取出大于或者等于len长度的字节数组，取完后字节数组缓冲池的大小会减小。如果一直取的话，字节数组池肯定会被取完，所以也就有了向缓冲池中添加字节数组的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted</div><div class="line">    * size.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> buf the buffer to return to the pool.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnBuf</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (buf == <span class="keyword">null</span> || buf.length &gt; mSizeLimit) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       mBuffersByLastUse.add(buf);</div><div class="line">       <span class="keyword">int</span> pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class="line">       <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</div><div class="line">           pos = -pos - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">       mBuffersBySize.add(pos, buf);</div><div class="line">       mCurrentSize += buf.length;</div><div class="line">       trim();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Removes buffers from the pool until it is under its size limit.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">while</span> (mCurrentSize &gt; mSizeLimit) &#123;</div><div class="line">           <span class="keyword">byte</span>[] buf = mBuffersByLastUse.remove(<span class="number">0</span>);</div><div class="line">           mBuffersBySize.remove(buf);</div><div class="line">           mCurrentSize -= buf.length;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法的逻辑是向字节数组缓冲池中添加字节数组，并且当添加后，当前的缓冲池大小大于缓冲池的最大大小时，会控制其大小不超出规定的范围。</p>
</li>
<li>分析到里，为什么要用两个集合来存放Byte数组？</li>
<li>个人理解：<br>1.首先问题，我觉得在returnBuf中可用得到答案。因为在这个方法的最后，调用了trim（），该方法的作用是确保字节数组缓冲池的大小不超过最大限度。其中的移除思想是移除LastUseList的0号位的byte[]对象，然后也在BufSizeList中移除该Byte[]对象，直到字节数组缓冲池的大小不超过最大限度。<br>2.从移除LastUseList中的0号位，这使我想到的LinkList的特点，LinkList是用链表来实现的，链表的插入的话是直接插入到链表尾部的，换句话说，越晚插入的在List的越尾部，也就是越新的缓存，移除0号位的缓存是移除比较旧的缓存<br>3.因此，我觉得LastUseList的作用是来配合BufSiseList移除比较旧的缓存区</li>
</ul>
<hr>
<h5 id="PoolingByteArrayOutputStream"><a href="#PoolingByteArrayOutputStream" class="headerlink" title="PoolingByteArrayOutputStream"></a>PoolingByteArrayOutputStream</h5><p>接下来，我们来看看和ByteArrayPool配合使PoolingByteArrayOutputStream。</p>
<ul>
<li>该类继承了ByteArrayOutputStream，ByteArrayOutputStream的作用是在将数据源输入到其中的Byte数组中，也就是内存缓冲区。</li>
<li>该类的就是通过向字节数组缓冲池拿字节数组和添加字节数组。</li>
</ul>
<h5 id="BasicNetwork"><a href="#BasicNetwork" class="headerlink" title="BasicNetwork"></a>BasicNetwork</h5><ul>
<li>在BasicNetwork的performRequest方法中进行网络时，得到httpResponse后，再调用了：<br>  responseContents = entityToBytes(httpResponse.getEntity());</li>
<li><p>我们来看看entityToBytes方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Reads the contents of HttpEntity into a byte[]. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException, ServerError &#123;</div><div class="line">        PoolingByteArrayOutputStream bytes =</div><div class="line">                <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</div><div class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream in = entity.getContent();</div><div class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</div><div class="line">            &#125;</div><div class="line">            buffer = mPool.getBuf(<span class="number">1024</span>);</div><div class="line">            <span class="keyword">int</span> count;</div><div class="line">            <span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">                bytes.write(buffer, <span class="number">0</span>, count);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> bytes.toByteArray();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Close the InputStream and release the resources by "consuming the content".</span></div><div class="line">                entity.consumeContent();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="comment">// This can happen if there was an exception above that left the entity in</span></div><div class="line">                <span class="comment">// an invalid state.</span></div><div class="line">                VolleyLog.v(<span class="string">"Error occured when calling consumingContent"</span>);</div><div class="line">            &#125;</div><div class="line">            mPool.returnBuf(buffer);</div><div class="line">            bytes.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该类主要就是进行输入流的读取，但是它的读取不同于一般的读取，它内部的通过实例化PoolingByteArrayOutputStream，将读取的流都读到内部的字节数组，而字节数组的来源是字节数组缓冲池。这样做的好处是：由于不用再频繁给byte[]分配内部，而是通过从回收和利用字节数组，减少了堆的开销，将读取的数据全都读到缓冲中后，再一次性送出去。这样就大大提高了效率。</p>
</li>
</ul>
<hr>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>上面分析了ByteArrayPool和PoolByteArrayOutputStream的配合使用，<br>接着来分析缓存。缓存的操作主要是在DiskBaseCache中。</p>
<ul>
<li>现在我需要先来分析该类中的内部类CacheHeaher和CountingInputStream</li>
<li>在CacheHeader主要是对响应头进行缓存，其中readHeader和WriteHeader是将响应头读取和写进文件中</li>
<li>而CountingInputStream继承于FileInputStream中，主要扩展了记录读取的数据的长度</li>
<li>介绍完这两个内部类，我们来切入正题：</li>
<li><p>先看看类中初始化的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Initializes the DiskBasedCache by scanning for all files currently in the</div><div class="line">     * specified root directory. Creates the root directory if necessary.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mRootDirectory.exists()) &#123;</div><div class="line">            <span class="keyword">if</span> (!mRootDirectory.mkdirs()) &#123;</div><div class="line">                VolleyLog.e(<span class="string">"Unable to create cache dir %s"</span>, mRootDirectory.getAbsolutePath());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        File[] files = mRootDirectory.listFiles();</div><div class="line">        <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">            FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                fis = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">                CacheHeader entry = CacheHeader.readHeader(fis);</div><div class="line">                entry.size = file.length();</div><div class="line">                putEntry(entry.key, entry);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</div><div class="line">                   file.delete();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</div><div class="line">                        fis.close();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法的逻辑主要是如果读取文件中内容到内存中保存缓存头的map，该方法会在缓存线程总的run方法中的调用</p>
</li>
<li><p>接着看将数据写进文件的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Puts the entry with the specified key into the cache.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span> </span>&#123;</div><div class="line">        pruneIfNeeded(entry.data.length);</div><div class="line">        File file = getFileForKey(key);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">            CacheHeader e = <span class="keyword">new</span> CacheHeader(key, entry);</div><div class="line">            e.writeHeader(fos);</div><div class="line">            fos.write(entry.data);</div><div class="line">            fos.close();</div><div class="line">            putEntry(key, e);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> deleted = file.delete();</div><div class="line">        <span class="keyword">if</span> (!deleted) &#123;</div><div class="line">            VolleyLog.d(<span class="string">"Could not clean up file %s"</span>, file.getAbsolutePath());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>pruneIfNeeded（int）该方法会判断内存缓存的大小是不是够用，不够的话，就通过遍历删除，直到增加后的内存小于内存缓存最大的90%。</p>
</li>
<li>接着就是实例化CacheHeader对象，再将缓存头和数据一起写进文件，最后将缓存头添加进map中</li>
<li><p>再来看看从文件中读取的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Entry <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        CacheHeader entry = mEntries.get(key);</div><div class="line">        <span class="comment">// if the entry does not exist, return.</span></div><div class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        File file = getFileForKey(key);</div><div class="line">        CountingInputStream cis = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            cis = <span class="keyword">new</span> CountingInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">            CacheHeader.readHeader(cis); <span class="comment">// eat header</span></div><div class="line">            <span class="keyword">byte</span>[] data = streamToBytes(cis, (<span class="keyword">int</span>) (file.length() - cis.bytesRead));</div><div class="line">            <span class="keyword">return</span> entry.toCacheEntry(data);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            VolleyLog.d(<span class="string">"%s: %s"</span>, file.getAbsolutePath(), e.toString());</div><div class="line">            remove(key);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (cis != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    cis.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>先读取数据再和缓存头包装成一个Entry对象返回</p>
</li>
</ul>
<hr>
<ul>
<li>通过上面的分析，对Volley的高效等特点总算有了一个全新的认识。Volley内部通过使用字节数组缓存池的利用与回收来减少堆内存的频繁分配，以及通过缓存响应头来控制是否从缓存中读取数据，这样适合一些小数据但通信频繁的操作，而至于为什么会不适合用于数据量大的操作主要是由于请求读取的结果都是一次性存在内存中，当数据量大时可能导致内存爆炸。</li>
<li>Volley总体来说是面向接口编程，再将这些接口功能组合起来，具体的封装交给具体类，这样扩展性会突出</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=&quot;概述：&quot;&gt;&lt;/a&gt;概述：&lt;/h4&gt;&lt;p&gt;volley的特点都大家很清楚，volley适合数据量小且通信频繁的请求，但是不适合数据量大的请求。volley有这样的特点是由其内部网络优化和缓存所决定的，这次分析其中的原理。&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="网络框架#Volley" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6-Volley/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask源码浅析</title>
    <link href="http://yoursite.com/2017/01/13/AsyncTask%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2017/01/13/AsyncTask源码浅析/</id>
    <published>2017-01-13T04:43:01.299Z</published>
    <updated>2016-11-13T02:57:22.709Z</updated>
    
    <content type="html"><![CDATA[<h5 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h5><ul>
<li>概述<br>AsyncTask是一个执行异步任务的小型框架，里面封装了Handler，使得使用者不必关心线程之间的切换，虽然现在执行异步任务都不会用AsyncTask，用得更多的是Bolt Tasks 和RxJava，但是AsyncTask中的设计思想还是很多值得学习的，比如：内部中，串行运行任务时的队列控制，handler的将结果回调回主线程，以及如何取消正在执行的任务等。。<a id="more"></a></li>
<li>我们知道，使用AsyncTask的要先实例化该类再调用其中的execute（）方法，那么自然先要来看其中的构造方法都初始化了哪些操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               Result result = doInBackground(mParams);</div><div class="line">               Binder.flushPendingCommands();</div><div class="line">               <span class="keyword">return</span> postResult(result);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面的代码中，分别实例化了WorkRunnable对象和FutureTask对象，其中，WorkRunnable是一个内部类，我们来看看该内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</div><div class="line">       Params[] mParams;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该类实现了Callable接口，其中保存了Params参数，也就是AsyncTask传入的参数</p>
</li>
<li><p>我们接下去看看execute（Params)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法返回AsyncTask本身，调用者可以根据需要保持对其的引用</p>
</li>
<li><p>execute（Params… params）executeOnExecutor(sDefaultExecutor, params)；我们点进该方法中看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">            Params... params) &#123;</div><div class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">            <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">                <span class="keyword">case</span> RUNNING:</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                            + <span class="string">" the task is already running."</span>);</div><div class="line">                <span class="keyword">case</span> FINISHED:</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                            + <span class="string">" the task has already been executed "</span></div><div class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">        onPreExecute();</div><div class="line"></div><div class="line">        mWorker.mParams = params;</div><div class="line">        exec.execute(mFuture);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Status是类中的枚举，作用是记录Task的运行状态。onPreExecute()，我们可以在该方法中做一些UI线程的初始化操作</p>
</li>
<li>接着将传进的参数赋值给mWork.parmas,也就是在构造函数初始化的WorkRunnable对象，保存了传入的参数</li>
<li>最后调用了传入的线程池的execute（Runnable）并且返回本身</li>
<li>传入的线程池是里面默认的线程池，该线程池是一个串行执行的</li>
<li><p>我们来看看该默认的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">        Runnable mActive;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        r.run();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        scheduleNext();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">                scheduleNext();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内部类中，将传入的Runnable对象添加到mTask队列中，并且在scheduleNext()方法中从mTask队列中拿出头元素，将该元素在后台线程池中执行</p>
</li>
<li>讲到这里，我们可以看出AsyncTask中的串行执行是通过在默认的线程池中进行队列控制，真正执行的是在后台线程池中执行，并且在执行完再安排下一个任务到后台线程池，这样就巧妙的完成了串行运行</li>
<li>我们回来execute（Runnable），传入的参数是mFutureTask，该对象是在之前构造函数实例化的，让我们回到构造函数：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               Result result = doInBackground(mParams);</div><div class="line">               Binder.flushPendingCommands();</div><div class="line">               <span class="keyword">return</span> postResult(result);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在FutureTask中，将callable对象出传入，现在看看mWorker其中的操作</p>
<ul>
<li>首先设置一个任务被调用的标记</li>
<li>接着调用doInBackground(mParams);该方法是我们重写的方法</li>
<li>最后将结果传入postResult(Result)中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">               <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">       message.sendToTarget();</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法中的逻主要是通过handler发送一条消息，该消息是包含结果对象的消息</li>
<li><p>我们先来看看内部类AsyncTaskResult<result>：</result></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">        <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">            mTask = task;</div><div class="line">            mData = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类中主要是保存了传入的结果以及AsyncTask自身</p>
</li>
<li>接着来看看InternalHandler()：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">           <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">               <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                   <span class="comment">// There is only one result</span></div><div class="line">                   result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                   result.mTask.onProgressUpdate(result.mData);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该内部类重写的Handler是运行在线程的handler，在handleMessage中接收处理消息</p>
</li>
<li><p>分析完了这两个内部类，我们回到postResult中发送消息，消息到达的是InternalHandler的 handleMessage，</p>
</li>
<li>result.mTask.finish(result.mData[0])，该语句调用了finish。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">           onCancelled(result);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           onPostExecute(result);</div><div class="line">       &#125;</div><div class="line">       mStatus = Status.FINISHED;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法中会先判断任务是不是被取消，如果没有的话，就地调用onPostExecute(result);也就是我们重写的结果方法</p>
</li>
<li><p>以上就是AsyncTask的执行流程。publishProgress方法的执行跟postResult差不多，这里不分析</p>
</li>
<li><p>关于AsyncTask现在支持并行运行，如果想要并且并行运行的话，可以调用executeOnExecutor(THREAD_POOL_EXECUTOR,<br>Params… params)。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;源码浅析&quot;&gt;&lt;a href=&quot;#源码浅析&quot; class=&quot;headerlink&quot; title=&quot;源码浅析&quot;&gt;&lt;/a&gt;源码浅析&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;概述&lt;br&gt;AsyncTask是一个执行异步任务的小型框架，里面封装了Handler，使得使用者不必关心线程之间的切换，虽然现在执行异步任务都不会用AsyncTask，用得更多的是Bolt Tasks 和RxJava，但是AsyncTask中的设计思想还是很多值得学习的，比如：内部中，串行运行任务时的队列控制，handler的将结果回调回主线程，以及如何取消正在执行的任务等。。
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="异步框架#AsyncTask" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6-AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>Volley--队列控制</title>
    <link href="http://yoursite.com/2017/01/13/Volley--%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/01/13/Volley--队列控制/</id>
    <published>2017-01-13T04:43:01.279Z</published>
    <updated>2016-11-01T01:57:47.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Volley之四个队列的配合使用"><a href="#Volley之四个队列的配合使用" class="headerlink" title="Volley之四个队列的配合使用"></a>Volley之四个队列的配合使用</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>在Volley中，存在这四个重要的队列，这次想单独来分析一下这四个队列的配合使用。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><ul>
<li><p>先看看源码中的四个队列，这四个队列在RequestQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Staging area for requests that already have a duplicate request in flight.</div><div class="line"> *</div><div class="line"> * &lt;ul&gt;</div><div class="line"> *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache</div><div class="line"> *          key.&lt;/li&gt;</div><div class="line"> *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request</div><div class="line"> *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The set of all requests currently being processed by this RequestQueue. A Request</div><div class="line"> * will be in this set if it is waiting in any queue or currently being processed by</div><div class="line"> * any dispatcher.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** The cache triage queue. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mCacheQueue =</div><div class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** The queue of requests that are actually going out to the network. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mNetworkQueue =</div><div class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</div></pre></td></tr></table></figure>
</li>
<li><p>上面的四个队列中，有两个队列的类型是一样的，都是无界阻塞队列，而剩下的一个是HashSet队列，另一个则是Hashmap。</p>
</li>
<li>Set集合最大的一个特点就是集合中的元素是不能重复的，如果向其中添加重复的元素的话，就出现返回false来表示添加失败。</li>
<li><p>在分析队列之前，我们先来看看start方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">       stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></div><div class="line">       <span class="comment">// Create the cache dispatcher and start it.</span></div><div class="line">       mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">       mCacheDispatcher.start();</div><div class="line"></div><div class="line">       <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">           NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                   mCache, mDelivery);</div><div class="line">           mDispatchers[i] = networkDispatcher;</div><div class="line">           networkDispatcher.start();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在实例化缓存线程和网络线程的时候将对应的队列都传入构造方法中，也就是缓存线程和网路线程中的对应的队列都是引用指向该类中实例化的队列，这样在向队列添加元素的时候，对应的线程就能处理，换句话说，所有添加队列元素的操作都在该类中的一个add方法中。那么，接下来自然要看看add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Adds a Request to the dispatch queue.</div><div class="line">     * <span class="doctag">@param</span> request The request to service</div><div class="line">     * <span class="doctag">@return</span> The passed-in request</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></div><div class="line">        request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">            mCurrentRequests.add(request);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Process requests in the order they are added.</span></div><div class="line">        request.setSequence(getSequenceNumber());</div><div class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></div><div class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span></div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">                <span class="comment">// There is already a request in flight. Queue up.</span></div><div class="line">                Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">                <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                    stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</div><div class="line">                &#125;</div><div class="line">                stagedRequests.add(request);</div><div class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></div><div class="line">                <span class="comment">// flight.</span></div><div class="line">                mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">                mCacheQueue.add(request);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>一开始就向mCurrentRequest中添加请求，由于set集合的特点，添加相同的元素是不能成功添加的，所以该队列的作用是记录所有不同的网络请求。</p>
</li>
<li>接下来的逻辑是这样的：先判断mWaitingRequests中是不是存在该请求的key值，不存在的话在mWaitingRequests中添加key-value：cacheKey-null，这样的操纵是为了下一次有相同的请求添加进来的情况作准备，如果下次有相同的请求添加进来，mWaitingRequests中已经有了该关键子，所以会进入if语句中，在if中，主要的操作就是将该相同的请求放进一个Queue中，该Queue对应一个key值，放进mWaitingRequest中，</li>
<li>现在我们来梳理一下这个方法：总的来说mWaitingRequest中存放的是相同的请求的队列，而mCurrentRequest则是存放所有的不同的请求的队列。</li>
<li><p>我们在add方法中看到，添加进来的请求会有两个去向（假设该请求是第一次发送，也就是说缓存队列中没有该请求），一是被放进网络队列，二是被添加进缓存队列，这样的话，我们先来看看网络线程中的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">       Request request;</div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// Take a request from the queue.</span></div><div class="line">               request = mQueue.take();</div><div class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">               <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">               <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// If the request was cancelled already, do not perform the</span></div><div class="line">               <span class="comment">// network request.</span></div><div class="line">               <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                   request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Tag the request (if API &gt;= 14)</span></div><div class="line">               <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class="line">                   TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Perform the network request.</span></div><div class="line">               NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">               request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// If the server returned 304 AND we delivered a response already,</span></div><div class="line">               <span class="comment">// we're done -- don't deliver a second identical response.</span></div><div class="line">               <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Parse the response here on the worker thread.</span></div><div class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">               request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// Write to cache if applicable.</span></div><div class="line">               <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></div><div class="line">               <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                   mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                   request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Post the response back.</span></div><div class="line">               request.markDelivered();</div><div class="line">               mDelivery.postResponse(request, response);</div><div class="line">           &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">               parseAndDeliverNetworkError(request, volleyError);</div><div class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">               VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">               mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在while循环中，从网络队列拿出了一条请求，也就是我们之前放的（当网络队列为空时，该线程会出现阻塞情况），接着就是网络访问，我们这里先不讨论网路访问的细节，我们来看看请求完得到Response对象后的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mDelivery.postResponse(request, response);</div></pre></td></tr></table></figure>
</li>
<li><p>这句话的意思就是把得到的请求通过Delivery post出去，这时候我们就得来看看该类的具体实现类中的方法了的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Deliver a normal response or error, depending.</span></div><div class="line">           <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">               mRequest.deliverResponse(mResponse.result);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               mRequest.deliverError(mResponse.error);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class="line">           <span class="comment">// and the request can be finished.</span></div><div class="line">           <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">               mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               mRequest.finish(<span class="string">"done"</span>);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果isSuccess的话，就deliverResponse，该方法是我们具体的请求实现类中重写的方法，也就是我们在客户端的网络请求回掉</p>
</li>
<li><p>接着我们看到还调用了Request的finish，而finish又是调用了Request中的finish，我们来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">       <span class="comment">// Remove from the set of requests currently being processed.</span></div><div class="line">       <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">           mCurrentRequests.remove(request);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">               String cacheKey = request.getCacheKey();</div><div class="line">               Queue&lt;Request&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">               <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                       VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                               waitingRequests.size(), cacheKey);</div><div class="line">                   &#125;</div><div class="line">                   <span class="comment">// Process all queued up requests. They won't be considered as in flight, but</span></div><div class="line">                   <span class="comment">// that's not a problem as the cache has been primed by 'request'.</span></div><div class="line">                   mCacheQueue.addAll(waitingRequests);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先在mCurrentRequest中移除已经成功访问的请求</p>
</li>
<li>接着判断该请求是不是该缓存（默认是缓存的），再移除mWaitingRequests中持有该请求key的相同请求，最后添加进缓存队列</li>
<li>我们来小结：在finish方法中主要是在mWaitingQueue中移除成功响应的请求，接着如果mWaitingQueue中有相同的请求的话，就把这相同的请求添加进缓存队列。</li>
<li><p>最后，我们来分析分析缓存线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"></div><div class="line">       <span class="comment">// Make a blocking call to initialize the cache.</span></div><div class="line">       mCache.initialize();</div><div class="line"></div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// Get a request from the cache triage queue, blocking until</span></div><div class="line">               <span class="comment">// at least one is available.</span></div><div class="line">               <span class="keyword">final</span> Request request = mCacheQueue.take();</div><div class="line">               request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></div><div class="line">               <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                   request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Attempt to retrieve this item from cache.</span></div><div class="line">               Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">               <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                   request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                   <span class="comment">// Cache miss; send off to the network dispatcher.</span></div><div class="line">                   mNetworkQueue.put(request);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// If it is completely expired, just send it to the network.</span></div><div class="line">               <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                   request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                   request.setCacheEntry(entry);</div><div class="line">                   mNetworkQueue.put(request);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></div><div class="line">               request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                       <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">               request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                   <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></div><div class="line">                   mDelivery.postResponse(request, response);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></div><div class="line">                   <span class="comment">// but we need to also send the request to the network for</span></div><div class="line">                   <span class="comment">// refreshing.</span></div><div class="line">                   request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                   request.setCacheEntry(entry);</div><div class="line"></div><div class="line">                   <span class="comment">// Mark the response as intermediate.</span></div><div class="line">                   response.intermediate = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                   <span class="comment">// Post the intermediate response back to the user and have</span></div><div class="line">                   <span class="comment">// the delivery then forward the request along to the network.</span></div><div class="line">                   mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                       <span class="meta">@Override</span></div><div class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                           <span class="keyword">try</span> &#123;</div><div class="line">                               mNetworkQueue.put(request);</div><div class="line">                           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                               <span class="comment">// Not much we can do about this.</span></div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">               <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">               <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>第一步的操作跟网络线程中差不多，先从缓存队列中拿出请求，接着判断该缓存请求的结果是不是有被写进缓存和是不是完全过期。如果没有被写进缓存的话，就添加进网络队列（也就是让网路线程处理该请求）；如果完全过期的话，也添加进网络队列。</p>
</li>
<li>接下来判断从缓存中拿出的请求是不是需要更新，需要的话，就post到线程池中，将请求添加网络队列，接下来的处理跟上面分析网络线程一样。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>从上面的分析，可以看出来，mCurrentRequests中保存的是所有不同的网络请求，该唯一性是有set集合的特点来保证的；mWaitingRequests则是暂存相同的请求，缓存队列和网络队列就不用说都明白了。</li>
<li>至于他们之间的配合，看看下面这张图的话，会更清晰：<br><img src="/uploads/Volley队列配合.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Volley之四个队列的配合使用&quot;&gt;&lt;a href=&quot;#Volley之四个队列的配合使用&quot; class=&quot;headerlink&quot; title=&quot;Volley之四个队列的配合使用&quot;&gt;&lt;/a&gt;Volley之四个队列的配合使用&lt;/h4&gt;&lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;在Volley中，存在这四个重要的队列，这次想单独来分析一下这四个队列的配合使用。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="网络框架#Volley" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6-Volley/"/>
    
  </entry>
  
  <entry>
    <title>3月9日</title>
    <link href="http://yoursite.com/2017/01/13/3%E6%9C%889%E6%97%A5/"/>
    <id>http://yoursite.com/2017/01/13/3月9日/</id>
    <published>2017-01-13T04:43:01.259Z</published>
    <updated>2016-10-14T00:33:35.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在流动的季节里，忽然感觉到时间的长度，匆匆忙忙流逝的每一天—–3月9日<br><a id="more"></a></p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=805204&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在流动的季节里，忽然感觉到时间的长度，匆匆忙忙流逝的每一天—–3月9日&lt;br&gt;
    
    </summary>
    
      <category term="music" scheme="http://yoursite.com/categories/music/"/>
    
    
      <category term="music" scheme="http://yoursite.com/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发艺术探索-View的工作原理（一）-笔记</title>
    <link href="http://yoursite.com/2017/01/13/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://yoursite.com/2017/01/13/安卓开发艺术探索-第四章笔记(一)/</id>
    <published>2017-01-13T04:43:01.259Z</published>
    <updated>2016-10-12T13:57:13.401Z</updated>
    
    <content type="html"><![CDATA[<h4 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h4><h5 id="初始ViewRoot和DecorView"><a href="#初始ViewRoot和DecorView" class="headerlink" title="初始ViewRoot和DecorView"></a>初始ViewRoot和DecorView</h5><a id="more"></a>
<ul>
<li><p>ViewRoot对应的实体类是ViewRootImpl类，它时连接WindowManager和DecorView的纽带</p>
</li>
<li><p>View的三大流程都是通过ViewRoot完成的</p>
</li>
<li><p>在ActivityThread中，当Activity对象被创建后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewImpl对象和DecorView建立关联：</p>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext, display);</div><div class="line">root.setView(view, wparams, panelParentView);</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>View的绘制流程是从ViewRoot的performTraversals中开始的，它经过measure，layout，draw三个过程。</p>
</li>
<li><p>performTraversals大致流程：</p>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>childLayoutParams\parentSpecMode</th>
<th>ECACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp/px</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><p>DecorView作为顶级View，本质是一个LinearLayout，该layout中一般情况下包含标题栏和内容栏。</p>
</li>
<li><p>在Activity中，我们setContentView所设置的布局，其实就是被加到内容栏中的</p>
</li>
</ul>
<hr>
<h5 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h5><p>MeasureSpec很大程度上决定了一个View的尺寸规格，之所以说很大程度，其实时因为在这个过程中还受父容器的影响，父容器回影响View的MeasureSpec的创建。</p>
<ul>
<li><p>MeasureSpec代表一个32位的int值，高2位代表SpecMode：测量模式，低30位表示SpecSize：在某种模式下的测量规格。</p>
</li>
<li><p>在下面的源码中，MeasureSpec将SpecMode和SpecSize打包成一个int值来避免过多对象内存的分配。为了方便操作提供了打包和解包的方法</p>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has not imposed any constraint</div><div class="line">         * on the child. It can be whatever size it wants.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has determined an exact size</div><div class="line">         * for the child. The child is going to be given those bounds regardless</div><div class="line">         * of how big it wants to be.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The child can be as large as it wants up</div><div class="line">         * to the specified size.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Like &#123;<span class="doctag">@link</span> #makeMeasureSpec(int, int)&#125;, but any spec with a mode of UNSPECIFIED</div><div class="line">         * will automatically get a size of 0. Older apps expect this.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@hide</span> internal use only for compatibility with system widgets and older apps</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the mode from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the mode from</div><div class="line">         * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#UNSPECIFIED&#125;,</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#AT_MOST&#125; or</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#EXACTLY&#125;</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the size from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the size from</div><div class="line">         * <span class="doctag">@return</span> the size in pixels defined in the supplied measure specification</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</div><div class="line">            <span class="keyword">int</span> size = getSize(measureSpec);</div><div class="line">            <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="comment">// No need to adjust size for UNSPECIFIED mode.</span></div><div class="line">                <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            size += delta;</div><div class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">                Log.e(VIEW_LOG_TAG, <span class="string">"MeasureSpec.adjust: new size would be negative! ("</span> + size +</div><div class="line">                        <span class="string">") spec: "</span> + toString(measureSpec) + <span class="string">" delta: "</span> + delta);</div><div class="line">                size = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>SpecMode有三类：</p>
<ul>
<li><p>UNSPECIFIED：父容器不对View有限制，这种情况一般用于系统内部，表示一种测量的状态</p>
</li>
<li><p>EXACTLY：父容器已经检验出View所需要的大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式</p>
</li>
<li><p>AT_MOST:父容器指定了一个可用的大小，即SpecSize，View的大小不能大于这个值。它对应于LayoutParams中的wrap_content</p>
</li>
</ul>
</li>
<li><p>MeasureSpec和LayoutParams的对应关系</p>
<ul>
<li><p>正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParams。在View测量的时候，系统会将LayoutParams在父容器的约束下转为对应的MeasureSpec，然后再根据这个MeasureSpec来确定View的宽高</p>
</li>
<li><p>LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽高</p>
</li>
<li><p>对于顶级View（DecorView）和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定</p>
</li>
<li><p>DecorView的MeasureSpec创建过程是在ViewRootImpl中的measureHierarchy方法创建的：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>接着看看getRootMeasureSpec：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;pre style="background-color:#21282d;color:#e0e2e4;font-family:'Courier New';font-size:15.0pt;"&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class="line"> int measureSpec;</div><div class="line"> switch (rootDimension) &#123;</div><div class="line"></div><div class="line"> case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line"> // Window can't resize. Force root view to be windowSize.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line"> case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line"> // Window can resize. Set max size for root view.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line"> break;</div><div class="line"> default:</div><div class="line"> // Window wants to be an exact size. Force root view to be that size.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line">&#125;  return measureSpec;&lt;/pre&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>LayoutParams.MATCH_PARENT:精确模式，大小就是窗口的大小；</p>
</li>
<li><p>LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小</p>
</li>
<li><p>固定大小：精确模式，大小为LayoutParams中指定的大小。</p>
</li>
</ul>
<hr>
<ul>
<li>对于普通View来说（指的时我们布局中的View），它的measure过程是由ViewGroup传递过来的，下面看看ViewGroup中的measureChildWithMargins：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">           <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">       <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                       + widthUsed, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                       + heightUsed, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>从上面代码来看，子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，此外还有与View的margin和padding有关，下面再看看ViewGroup的getChildMeasureSpec：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">      <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">      <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">      <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">              <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">              <span class="comment">// be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">              <span class="comment">// big it should be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>从上面的方法来看，它的主要作用时结合父容器发MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，参数中的padding指的是父容器中已被占用的空间大小。</p>
</li>
<li><p>下面的表是对getChildMeasureSpec的工作原理的梳理，其中parentSize指的是父容器中目前可以使用的大小。</p>
</li>
</ul>
<hr>
<p><img src="index_files/f78c4596-e57c-41be-a3ca-a75bdcd06778.jpg" alt=""></p>
<h4 id="View的工作过程"><a href="#View的工作过程" class="headerlink" title="View的工作过程"></a>View的工作过程</h4><h5 id="View的measure过程："><a href="#View的measure过程：" class="headerlink" title="View的measure过程："></a>View的measure过程：</h5><ul>
<li>measure方法时一个final方法，则意味着不能重写该方法，在该方法中会调用View的onMeasure方法（真正测量的方法）， 下面我们看看onMeasure的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">  getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setMeasureDimension方法中会设置View的宽高的测量值，因此，我们来看看getDefaultSize方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = size;</div><div class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">  result = size;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">  <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">  result = specSize;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"> &#125;  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于我我们来说，我们只看AT_MOST和EXACTLY这两种情况。简单的理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，这个specSize就是测量后View的大小，这里说时是测量后，是因为View的最终大小是在layout阶段确定的，除了特殊情况外，View的测量大小和最终大小是相等的。</p>
<ul>
<li>对于UNSPECIFIED来说，一般用于系统内部测量，在这种情况下，View的大小为getDefaultSize第一个参数size，即分别为getSuggestedMinimumWidth/Height：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果View没有设置背景，那么View的高度为mMinHeight，而该属性对应于aandroid：minWidth，如果这个属性不指定的话，默认为0。如果设置了背景则返回minHeight和背景的最小高度中的最大值</p>
<ul>
<li><p>从getDefaultSize的实现来看，我们可以得到以下小结：</p>
<ul>
<li><p>直接继承View的自定义控件需要重写onMeasure方法设置wrap_content时的自身大小，否则在布局中使用就相当于match_parent</p>
</li>
<li><p>通过之前分析，如果View在布局中被设为wrap_content的话，它的specMode时AT_MOST模式，此时它的宽高等于specSize，而View的specSize是parentSize，parentSize是父容器目前所剩余的空间大小。这样这种效果就相当于match_parent</p>
</li>
<li><p>解决方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"> <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"> <span class="keyword">int</span> widthSpecMode = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> widthSpecSize = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecMode = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecSize = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, mHeight);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, heightSpecSize);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(heightSpecMode == View.MeasureSpec.AT_MOST)&#123;</div><div class="line"> setMeasureDimension(widthSpecSize, mHeight);</div><div class="line"></div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于wrap_content的情形，我们直接设置我们默认的大小就可以</p>
<hr>
<h5 id="ViewGroup的measure过程："><a href="#ViewGroup的measure过程：" class="headerlink" title="ViewGroup的measure过程："></a>ViewGroup的measure过程：</h5><ul>
<li><p>ViewGroup除了测量自身的大小外，还会遍历所有的子元素的measure方法，各个子元素再递归去执行这个过程</p>
</li>
<li><p>ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但是提供了一个measureChildren的方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码来看，ViewGroup在meaure的时候，会对每个子元素进行measure，下面来看看measureChild：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>meaureChild中，就是取出子元素的LayoutParams，然后通过getChildMeasureSpec来创建子元素的MeasureSpec。将MeaureSpec直接传递给View的meaure进行测量。</p>
<ul>
<li><p>我们知道ViewGroup是一个抽象类，并没有实现具体的测量过程，所以，我们来看看它子类中的实现，下面用LinearLayout来当例子</p>
</li>
<li><p>首先先来看看其onMeasure方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面代码中，根据不同的布局方向来测量，我们选择来看竖直方向的测量过程中的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// See how tall everyone is. Also remember max width.</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">          <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">              mTotalLength += measureNullChild(i);</div><div class="line">              <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">             i += getChildrenSkipCount(child, i);</div><div class="line">             <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">              mTotalLength += mDividerHeight;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">          totalWeight += lp.weight;</div><div class="line">          </div><div class="line">          <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Optimization: don't bother measuring children who are going to use</span></div><div class="line">              <span class="comment">// leftover space. These views will get measured again down below if</span></div><div class="line">              <span class="comment">// there is any leftover space.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class="line">              skippedMeasure = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></div><div class="line">                  <span class="comment">// child wanted to stretch to fill available space.</span></div><div class="line">                  <span class="comment">// Translate that to WRAP_CONTENT so that it does not end up</span></div><div class="line">                  <span class="comment">// with a height of 0</span></div><div class="line">                  oldHeight = <span class="number">0</span>;</div><div class="line">                  lp.height = LayoutParams.WRAP_CONTENT;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// Determine how big this child would like to be. If this or</span></div><div class="line">              <span class="comment">// previous children have given a weight, then we allow it to</span></div><div class="line">              <span class="comment">// use all available space (and we will shrink things later</span></div><div class="line">              <span class="comment">// if needed).</span></div><div class="line">              measureChildBeforeLayout(</div><div class="line">                     child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</div><div class="line">                     totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">                 lp.height = oldHeight;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                     lp.bottomMargin + getNextLocationOffset(child));</div></pre></td></tr></table></figure>
<p>系统会遍历每个子元素，并且对每个子元素进行measureChildBeforeLayout，这个方法会调用子元素的measure，这样就开始了measure过程，并且系统会通过mToatalLength这个变量来保存LinearLayout在竖直方向上的初步高度，当测量完子元素时，LinearLauout会测量自己的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add in our padding</span></div><div class="line">       mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> heightSize = mTotalLength;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum height</span></div><div class="line">       heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line">       </div><div class="line">       <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></div><div class="line">       <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">       heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line">       </div><div class="line">       <span class="comment">// Either expand children with weight to take up available space or</span></div><div class="line">       <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></div><div class="line">       <span class="comment">// measurement on any children, we need to measure them now.</span></div><div class="line">       <span class="keyword">int</span> delta = heightSize - mTotalLength;</div><div class="line">       <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">           <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line"></div><div class="line">           mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">               <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line">               </div><div class="line">               LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">               </div><div class="line">               <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">               <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                   <span class="comment">// Child said it could absorb extra space -- give him his share</span></div><div class="line">                   <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">                   weightSum -= childExtra;</div><div class="line">                   delta -= share;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                           mPaddingLeft + mPaddingRight +</div><div class="line">                                   lp.leftMargin + lp.rightMargin, lp.width);</div><div class="line"></div><div class="line">                   <span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">                   <span class="comment">// child has been previously measured</span></div><div class="line">                   <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != MeasureSpec.EXACTLY)) &#123;</div><div class="line">                       <span class="comment">// child was measured once already above...</span></div><div class="line">                       <span class="comment">// base new measurement on stored values</span></div><div class="line">                       <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</div><div class="line">                       <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</div><div class="line">                           childHeight = <span class="number">0</span>;</div><div class="line">                       &#125;</div><div class="line">                       </div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// child was skipped in the loop above.</span></div><div class="line">                       <span class="comment">// Measure for this first time here      </span></div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// Child may now not fit in vertical dimension.</span></div><div class="line">                   childState = combineMeasuredStates(childState, child.getMeasuredState()</div><div class="line">                           &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</div><div class="line">               maxWidth = Math.max(maxWidth, measuredWidth);</div><div class="line"></div><div class="line">               <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</div><div class="line">                       lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                       matchWidthLocally ? margin : measuredWidth);</div><div class="line"></div><div class="line">               allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">               mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</div><div class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Add in our padding</span></div><div class="line">           mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">           <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                                          weightedMaxWidth);</div><div class="line"></div><div class="line"></div><div class="line">           <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></div><div class="line">           <span class="comment">// Children will have already been measured once.</span></div><div class="line">           <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                   <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">                       <span class="keyword">continue</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                           (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                   <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">                   <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                       child.measure(</div><div class="line">                               MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</div><div class="line">                                       MeasureSpec.EXACTLY),</div><div class="line">                               MeasureSpec.makeMeasureSpec(largestChildHeight,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">           maxWidth = alternativeMaxWidth;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       maxWidth += mPaddingLeft + mPaddingRight;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum width</span></div><div class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line">       </div><div class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">               heightSizeAndState);</div></pre></td></tr></table></figure>
<ul>
<li><p>分析到这里算是把measure分析完了，下面我们来看看需要注意的一些地方：</p>
<ul>
<li>如果要获取View的测量宽高或者最终宽高的话，比较好的做法是在onLayout中获取，因为在某些极端的情况下，measure可能会被多次调用，这样在onMeasure获取的宽高就不准确</li>
</ul>
</li>
<li><p>四种方法中的三种解决Activity启动时获取View的宽高</p>
<ul>
<li><p>在onWindowFocusChanged中获取： 该方法会在窗口的得到和失去焦点的时候被调用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</div><div class="line">    <span class="keyword">if</span>(hasFocus) &#123;</div><div class="line">        <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">        <span class="keyword">int</span> heigh = view.getMeasureHeight();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>view.post(runnable):将一个runnable投递到消息队列尾部，等待Looper调用此runnable的时候，View已经初始化完成了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        view.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ViewTreeObserver：使用其中的OnGlobalLayoutListener这个接口，当View状态或者View树内部的View可见性发现改变时，onGlobalLayout会被回调。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line"></div><div class="line">        ViewTreeObserver observer = view.getViewTreeObserver();</div><div class="line">        observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">                view.getViewTreeObserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h5><ul>
<li>先看看View的layout方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在layout中首先会通过setFrame方法来设定View的四个顶点位置，即初始化mLeft， mRight， mTop， mBottom，view的顶点确定后，那么View在ViewGroup中的位置也相应的确定；接着调用onLayout的方法，该方法的具体实现是在ViewGroup的子类中，我们来看看LinearLayout中是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           layoutVertical(l, t, r, b);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           layoutHorizontal(l, t, r, b);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们只拿竖直方向上的来分析：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> childTop;</div><div class="line">        <span class="keyword">int</span> childLeft;</div><div class="line">        </div><div class="line">        <span class="comment">// Where right end of child should go</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</div><div class="line">        <span class="keyword">int</span> childRight = width - mPaddingRight;</div><div class="line">        </div><div class="line">        <span class="comment">// Space available for child</span></div><div class="line">        <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</div><div class="line">        </div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (majorGravity) &#123;</div><div class="line">           <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">           <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">           <span class="keyword">case</span> Gravity.TOP:</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                childTop += measureNullChild(i);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">                </div><div class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> gravity = lp.gravity;</div><div class="line">                <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</div><div class="line">                    gravity = minorGravity;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</div><div class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</div><div class="line">                                + lp.leftMargin - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</div><div class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.LEFT:</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        childLeft = paddingLeft + lp.leftMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                    childTop += mDividerHeight;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                childTop += lp.topMargin;</div><div class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                        childWidth, childHeight);</div><div class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line"></div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此方法会遍历所有子元素并调用setChildFrame来为子元素指定相应的位置，该方法中调用了子元素的layout方法，这样就实现了View的一层层测量。</p>
<ul>
<li><p>分析完了layout，我们来看看哪些需要注意的地方：</p>
<ul>
<li>View的getMeasureWidth和getWidth有什么区别：我们首先来看看getWidth的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> mRight - mLeft;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在View的默认实现过程中，View的测量宽高和最终宽高时相等的，只不过两者的赋值时机不同而已，测量宽高是在measure，而最终宽高是在layout。</p>
</li>
</ul>
<hr>
<h5 id="draw过程："><a href="#draw过程：" class="headerlink" title="draw过程："></a>draw过程：</h5><ul>
<li><p>View的绘制过程遵循下面这几步：</p>
<ul>
<li>绘制自己的背景（bakcground.draw(canvas)）</li>
<li>绘制自己（onDraw）</li>
<li>绘制children（dispatchDraw）</li>
<li>绘制装饰（onDrawScrollBars）</li>
</ul>
</li>
<li><p>上面的这个步骤可以在draw源码中看出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">               (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">       <span class="comment">/*</span></div><div class="line">        * Draw traversal performs several drawing steps which must be executed</div><div class="line">        * in the appropriate order:</div><div class="line">        *</div><div class="line">        *      1. Draw the background</div><div class="line">        *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">        *      3. Draw view's content</div><div class="line">        *      4. Draw children</div><div class="line">        *      5. If necessary, draw the fading edges and restore layers</div><div class="line">        *      6. Draw decorations (scrollbars for instance)</div><div class="line">        */</div><div class="line"></div><div class="line">       <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">       <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">           drawBackground(canvas);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">       <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">           <span class="comment">// Step 3, draw the content</span></div><div class="line">           <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Step 4, draw the children</span></div><div class="line">           dispatchDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">           <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">               mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">           onDrawForeground(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// we're done...</span></div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>View的绘制过程的传递时通过dispatchDraw来实现的，该方法回遍历所有子元素的draw（具体的实现实在ViewGroup的子类中），这样draw就可以一层层传递下去。View中的一个特殊方法：setWillNotDraw:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</div><div class="line">       setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>如果一个View不需要绘制任何内容的话，我们就可以把这个标记设为true。默认情况下View没有启动这个标志，但是ViewGroup会默认启动。如果我们自定义控件的时候需要继承ViewGroup时，我们就可以开启这个标记来便于系统的后续优化。</p>
<blockquote>
<p>以上的笔记来源于安卓开发艺术探索</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;View的工作原理&quot;&gt;&lt;a href=&quot;#View的工作原理&quot; class=&quot;headerlink&quot; title=&quot;View的工作原理&quot;&gt;&lt;/a&gt;View的工作原理&lt;/h4&gt;&lt;h5 id=&quot;初始ViewRoot和DecorView&quot;&gt;&lt;a href=&quot;#初始ViewRoot和DecorView&quot; class=&quot;headerlink&quot; title=&quot;初始ViewRoot和DecorView&quot;&gt;&lt;/a&gt;初始ViewRoot和DecorView&lt;/h5&gt;
    
    </summary>
    
      <category term="booknote" scheme="http://yoursite.com/categories/booknote/"/>
    
    
      <category term="安卓开发艺术探索笔记" scheme="http://yoursite.com/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
