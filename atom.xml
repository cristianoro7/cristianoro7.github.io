<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Desperado</title>
  <subtitle>Do one thing every day that scares you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cristianoro7.github.io/"/>
  <updated>2017-10-01T08:17:58.032Z</updated>
  <id>http://cristianoro7.github.io/</id>
  
  <author>
    <name>Desperado</name>
    <email>424494431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CustomView总结</title>
    <link href="http://cristianoro7.github.io/2017/10/01/CustomView%E6%80%BB%E7%BB%93/"/>
    <id>http://cristianoro7.github.io/2017/10/01/CustomView总结/</id>
    <published>2017-10-01T08:17:58.032Z</published>
    <updated>2017-10-01T08:17:58.032Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fk2tf8bzggj30zk0nqtbj.jpg" alt=""></p>
<p><br></p>
<blockquote>
<h2 id="LayoutParams认知"><a href="#LayoutParams认知" class="headerlink" title="LayoutParams认知"></a>LayoutParams认知</h2></blockquote>
<h3 id="Q-什么是LayoutParams-它跟view的关系是什么"><a href="#Q-什么是LayoutParams-它跟view的关系是什么" class="headerlink" title="Q: 什么是LayoutParams? 它跟view的关系是什么?"></a>Q: 什么是LayoutParams? 它跟view的关系是什么?</h3><blockquote>
<h4 id="什么是LayoutParams"><a href="#什么是LayoutParams" class="headerlink" title="什么是LayoutParams?"></a>什么是LayoutParams?</h4></blockquote>
<p>我们在XML布局中定义的layout_xx属性,最终都会以Java代码的形式展现出来, 而LayoutParams就是这些layout_xx属性在Java层的映射, 也就是说LayoutParams是view在xml布局中layout_xx的属性容器.</p>
<p>可见, LayoutParams是子View跟父View进行协商的桥梁. 协商的内容可有: 子View宽高, 子View在父View中摆放的位置等.</p>
<blockquote>
<h4 id="LayoutParams的继承关系"><a href="#LayoutParams的继承关系" class="headerlink" title="LayoutParams的继承关系"></a>LayoutParams的继承关系</h4></blockquote>
<p>LayoutParams是作为内部类定义在ViewGroup中,下面是LayoutParams的继承关系:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik760lyaqj30s20l8dgp.jpg" alt=""></p>
<p>LayoutParams是定义在ViewGroup, LayoutParams只支持 height, width. ViewGroupn内部的一个默认实现是MarginLayoutParams, 该类继承LayoutParams, 扩展了margin属性.接下来, 各个VieGroup的子类内部都有LayoutParams的子类,扩展对应ViewGroup的属性.比如 LinearLayout.LayoutParams, 增加了weight属性.</p>
<blockquote>
<h4 id="在Java代码中获取view的LayoutParams"><a href="#在Java代码中获取view的LayoutParams" class="headerlink" title="在Java代码中获取view的LayoutParams"></a>在Java代码中获取view的LayoutParams</h4></blockquote>
<p>既然LayoutParms是View对自己在父布局中的属性设置, 那么父View在测量或者布局的时候, 肯定是需要拿到这个LayoutParams对象的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(deepExport = <span class="keyword">true</span>, prefix = <span class="string">"layout_"</span>)</div><div class="line">    <span class="keyword">public</span> ViewGroup.<span class="function">LayoutParams <span class="title">getLayoutParams</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mLayoutParams;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set the layout parameters associated with this view. These supply</div><div class="line">     * parameters to the &lt;i&gt;parent&lt;/i&gt; of this view specifying how it should be</div><div class="line">     * arranged. There are many subclasses of ViewGroup.LayoutParams, and these</div><div class="line">     * correspond to the different subclasses of ViewGroup that are responsible</div><div class="line">     * for arranging their children.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> params The layout parameters for this view, cannot be null</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(ViewGroup.LayoutParams params)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Layout parameters cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line">        mLayoutParams = params;</div><div class="line">        resolveLayoutParams();</div><div class="line">        <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">            ((ViewGroup) mParent).onSetLayoutParams(<span class="keyword">this</span>, params);</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是View提供的接口, 用于设置和获取View中的LayoutParams.父View在测量和布局时, 就是通过<code>view.getLayoutParams()</code>来获得子<code>View</code>设置的<code>LayoutParams</code>.</p>
<blockquote>
<h2 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h2></blockquote>
<h3 id="Q-什么是MeasureSpec-它的工作原理是什么"><a href="#Q-什么是MeasureSpec-它的工作原理是什么" class="headerlink" title="Q: 什么是MeasureSpec? 它的工作原理是什么?"></a>Q: 什么是MeasureSpec? 它的工作原理是什么?</h3><blockquote>
<h4 id="什么是MeasureSpec"><a href="#什么是MeasureSpec" class="headerlink" title="什么是MeasureSpec?"></a>什么是MeasureSpec?</h4></blockquote>
<p>我们都知道, Android体系中, View有三种测量模式,每种测量模式都有对应View的宽高.</p>
<p>一个View可能会被多次测量, 在运行时也可能被动态改变而导致重新测量,布局. Android团队为了减少多次测量带来的对象分配消耗, 将View的测量模式和View的大小打包成一个int类型的值,从而减少了对象分配带来的消耗.</p>
<p>MeasureSpec这个类就是提供了打包和解包方法, 将测量模式和大小打包或者解包成int值.</p>
<blockquote>
<h4 id="MeasureSpec的工作原理"><a href="#MeasureSpec的工作原理" class="headerlink" title="MeasureSpec的工作原理"></a>MeasureSpec的工作原理</h4></blockquote>
<p>在Java中, int类型固定占4字节, 也就是32位.</p>
<p>由于三种测量模式用2位就能够表示, 可分别表示为:<code>00(UNSPECIFIED)</code>, <code>01(EXACTLY)</code>, <code>10(AT_MOST)</code>.</p>
<p>既然三种测量模式用2位表示就够, 那么剩下的低30位用来表示大小.</p>
<p>问题来了? 如何将2位的测量模式和30位的大小打包成一个int后, 能够无差错的解包成测量模式和View的大小?</p>
<p>答案: 使用掩码和逻辑或,与运算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has not imposed any constraint</div><div class="line"> * on the child. It can be whatever size it wants.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has determined an exact size</div><div class="line"> * for the child. The child is going to be given those bounds regardless</div><div class="line"> * of how big it wants to be.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The child can be as large as it wants up</div><div class="line"> * to the specified size.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div></pre></td></tr></table></figure>
<p>MODE_SHIFT为移多少位, MODE_MASK为掩码. 现在我们来算算掩码:3表示为二进制为:11, 所以0x3 &lt;&lt; 30 表示为: 1100000000(30个0). 这个掩码的作用就是配合逻辑与,或操作来进行打包和解包的操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>上面是打包操作, 在<code>size &amp; ~MODE_MASK</code>中, ~MODE_MASK为: 0011111(30个1),由于低30为全为1, 那么与size进行&amp;操作时, 低30位就由szie的低三十为决定, 而高2位则为00, <code>size &amp; ~MODE_MASK</code>这个操作就是将size的高2为设置为00, 同理:<code>(mode &amp; MODE_MASK)</code>这个操作是将mode低30位设置为0. 最后再进行 | 操作, 这样就得到了高2位为测量模式, 低30位为大小的int.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>getMode方法将一个打包的measureSpec解包为mode, 原理是通过&amp;获取measureSpec的高2位. 同理getSize(int measureSpec)也是同种道理.</p>
<blockquote>
<h2 id="LayoutParams和MeasureSpec的关系"><a href="#LayoutParams和MeasureSpec的关系" class="headerlink" title="LayoutParams和MeasureSpec的关系"></a>LayoutParams和MeasureSpec的关系</h2></blockquote>
<ul>
<li><p>MeasureSpec是由父容器中LayoutParams和本身的LayoutParams这两个因素决定的.</p>
</li>
<li><p>但是对于顶级View(DecorView),他的MeasureSpec是由屏幕的大小和自身的LayoutParams所决定的.</p>
</li>
<li><p>以上两点在阅读源码就可以看出来.</p>
</li>
</ul>
<h2 id="从源码角度来理解测量和布局"><a href="#从源码角度来理解测量和布局" class="headerlink" title="从源码角度来理解测量和布局"></a>从源码角度来理解测量和布局</h2><blockquote>
<h3 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h3></blockquote>
<p>为了更好的理解测量过程, 我们需要理解清楚MeasureSpec和LayoutParams的关系, 看MeasureSpec是怎么在LayoutParams的约束下生成的.</p>
<p>测量过程的工作是确定View的宽高.我们先从ViewRootImpl这个类来分析顶级View类是如何开始测量的.</p>
<p>测量,布局,绘制,这三个步骤将View显示到屏幕上,而触发这三个流程的地方是在<code>performTraversals()</code>方法中.</p>
<p>在<code>performTraversals()</code>方法中,除了测量,布局,绘制这三个阶段外, 其实在存在另外的两个阶段:预测量和窗口布局.</p>
<blockquote>
<h4 id="预测量"><a href="#预测量" class="headerlink" title="预测量"></a>预测量</h4></blockquote>
<p>ViewRootImpl在进行测量时,会预先进行一次测量,而这次预测量是在<code>measureHierarchy</code>方法中进行的. 预测量的目的就是为了在大屏幕的设备上将View更优雅的显示出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></div><div class="line">            <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight) &#123;</div><div class="line">        <span class="keyword">int</span> childWidthMeasureSpec;</div><div class="line">        <span class="keyword">int</span> childHeightMeasureSpec;</div><div class="line">        <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(TAG,</div><div class="line">                <span class="string">"Measuring "</span> + host + <span class="string">" in display "</span> + desiredWindowWidth</div><div class="line">                + <span class="string">"x"</span> + desiredWindowHeight + <span class="string">"..."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; <span class="comment">//为了让dialog显示得更好, 先根据预先定义好的dialog尺寸, 以此测量出一个包裹dialog的宽度.</span></div><div class="line">            <span class="comment">// On large screens, we don't want to allow dialogs to just</span></div><div class="line">            <span class="comment">// stretch to fill the entire width of the screen to display</span></div><div class="line">            <span class="comment">// one line of text.  First try doing the layout at a smaller</span></div><div class="line">            <span class="comment">// size to see if it will fit.</span></div><div class="line">            <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</div><div class="line">            res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">int</span> baseSize = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</div><div class="line">                baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": baseSize="</span> + baseSize);</div><div class="line">            <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</div><div class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//打包成MeasureSpec</span></div><div class="line">                childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//开始第一次测量</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                        + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123; <span class="comment">//如果测量出来的大小太小的话, 会再进行测量</span></div><div class="line">                    goodMeasure = <span class="keyword">true</span>; <span class="comment">//对测量结果满意</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Didn't fit in that size... try expanding a bit.</span></div><div class="line">                    baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": next baseSize="</span></div><div class="line">                            + baseSize); <span class="comment">//需要的话, 扩大宽度,进行二次测量</span></div><div class="line">                    childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//再次打包成MeasureSpec</span></div><div class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//第二次测量</span></div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                            + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                    <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Good!"</span>);</div><div class="line">                        goodMeasure = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!goodMeasure) &#123; <span class="comment">//最后还是太小的话, 只能妥协,返回窗口的可能改变的标记</span></div><div class="line">            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">            <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</div><div class="line">                windowSizeMayChange = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DBG) &#123;</div><div class="line">            System.out.println(<span class="string">"======================================"</span>);</div><div class="line">            System.out.println(<span class="string">"performTraversals -- after measure"</span>);</div><div class="line">            host.debug();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> windowSizeMayChange;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>为了让View更优雅的显示出来, 比如dialog在大屏幕的情况下, 如果其内容太大并且测量模式为WRAP_CONTENT的话,有可能会出现这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7l94nxgj30hi0br3yi.jpg" alt=""></p>
<ul>
<li>考虑到上面dialog的宽度有可能太小,会出现下面这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7n6wvkcj30c809ka9y.jpg" alt=""></p>
<ul>
<li><p>所以在预测量阶段,每次测量后都会根据一个标记<code>(MEASURED_STATE_TOO_SMALL)</code>来判断是否要进行二次测量来扩大宽度.</p>
</li>
<li><p>如果进行了二次测量的话, 宽度还是大小,就只能妥协,放弃预测量.</p>
</li>
<li><p>预测量是针对悬浮窗口而言, 也就是对于非悬浮窗口而言, 是没有预测量阶段的.</p>
</li>
</ul>
<blockquote>
<h4 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h4></blockquote>
<p>一般测量阶段都会伴随一个布局阶段, 预测量也是如此, 窗口布局就是根据预测量阶段得出的结果来进行布局.</p>
<blockquote>
<h4 id="开始测量"><a href="#开始测量" class="headerlink" title="开始测量"></a>开始测量</h4></blockquote>
<p>分析完预测量和预布局, 我们来分析<code>&quot;真正&quot;</code>的测量阶段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG, <span class="string">"Ooops, something changed!  mWidth="</span></div><div class="line">                            + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</div><div class="line">                            + <span class="string">" mHeight="</span> + mHeight</div><div class="line">                            + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</div><div class="line">                            + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</div><div class="line"></div><div class="line"><span class="comment">// Ask host how big it wants to be</span></div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
<ul>
<li>在View的测量机制中, 是通过给子View传递MeasureSpec来进行的, 因此, 测量阶段会首先进行获取测量规格, 并传递给子View, 我们先来看看顶级View如何进行获取MeasureSpec.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码通过调用<code>getRootMeasureSpec(mWidth, lp.width)</code>来获取宽度的MeasureSpec, 传递给方法的参数分别为屏幕的窗口大小和顶级View的LayoutParams封装的宽度信息.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> measureSpec;</div><div class="line">        <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>如果宽度为<code>ViewGroup.LayoutParams.MATCH_PARENT</code>, 直接把将窗口的大小和<code>MeasureSpec.EXACTLY</code>打包成一个MeasureSpec; 当宽度为<code>ViewGroup.LayoutParams.WRAP_CONTENT</code>情况也是如此.</p>
</li>
<li><p>至于<code>getRootMeasureSpec(mHeight, lp.height)</code>跟上面的基本一致,这里不多说.</p>
</li>
<li><p>分析到这里, 也验证了,<code>顶级View的MeasureSpec是由窗口的大小和自身的LayoutParams所决定的</code></p>
</li>
</ul>
<p>我们接着继续分析<code>performMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个方法中只是简单的调用了View的measure(int, int)方法, 也就是从RootViewImppl调到了View中. 方法中的参数刚刚生成的两个测量规格.可见,测量规格是在父View中生成并传递给子View的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            <span class="keyword">int</span> oWidth  = insets.left + insets.right;</div><div class="line">            <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</div><div class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></div><div class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</div><div class="line">        <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// first clears the measured dimension flag</span></div><div class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">            resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</div><div class="line">                    mMeasureCache.indexOfKey(key);</div><div class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</div><div class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></div><div class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">                <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></div><div class="line">                setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</div><div class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></div><div class="line">            <span class="comment">// an exception to warn the developer</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></div><div class="line">                        + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></div><div class="line">                        + <span class="string">" measured dimension by calling"</span></div><div class="line">                        + <span class="string">" setMeasuredDimension()"</span>);</div><div class="line">            &#125;</div><div class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">        mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</div><div class="line">                (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法略长, 但是核心思路只有两个, 第一: 判断传入的大小和前一次测量的大小是否一样, 如果一样的话, 不进行测量, 如果不一样的话, 就开始测量. 第二:如果传入的大小和前一次测量的大小不一样的话, 会调用onMeasure(int, int),开始测量.</p>
</li>
<li><p>对于<code>onMeasure(int, int)</code>而言, View和ViewGroup的测量职责是不一样的. <code>对于View, 它只需测量自身的大小, 而对于ViewGroup, 它需要测量自己和测量自己的孩子, 一般都是先测量孩子,然后根据孩子的大小来设置自己的大小.</code></p>
</li>
<li><p>由于<code>measure()</code>方法是被final修饰的, 所以<code>measure(int, int)</code>是不允许被重写的, 需要我们重写的是onMeasure(int, int). 这样做的优点是:开发者无需关心View测量的其他细节, 只需关心测量View的大小就行, 减轻了开发者的开发难度.</p>
</li>
<li><p>既然View和ViewGroup的测量职责不一样, 那么View和ViewGroup中的onMeasure(int, int)的实现肯定不一样, 所以我们开始分情况来讨论</p>
</li>
</ul>
<blockquote>
<h5 id="View-onMeasure-int-int"><a href="#View-onMeasure-int-int" class="headerlink" title="View#onMeasure(int, int)"></a>View#onMeasure(int, int)</h5></blockquote>
<p>我们先从简单的View入手, 进入View的onMeasure(int, int):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>View的onMeasure(int, int)只是简单调用了setMeasureDimension(int size, int measureSpec),这个是保存测量得到的宽高.</p>
</li>
<li><p>setMeasureDimension(int, int), 其中的宽高是通过<code>getDefaultSize(int size, int measureSpec)</code>来获取的.我们进入该方法看看:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = size;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先根据传入的measureSpec来获得测量模式和测量大小, 如果测量模式是<code>AT_MOST</code>或者<code>EXACTLY</code>的话, 直接返回测量得到的大小.</p>
</li>
<li><p>从这个方法我们知道, View的onMeasure(int, int)的默认实现是根据传入的MeasureSpec来获取测量结果.那么这个MeasureSpec是怎么产生的? 前面我们说过, ViewGroup的onMeasure(int, int)中, 是需要测量孩子的, 这个MeasureSpec就是ViewGroup在测量子View时传递给子View的, 换句话说, 这个MeasureSpec是从ViewGroup传递下来的, 通过解包操作, 可以得到MeasureSpec中的大小, 这个大小究竟是ViewGroup的总体大小还是剩余大小? 这个得看具体的ViewGroup的具体实现.</p>
</li>
<li><p>上面的分析可能有点难以理解, 不过接下来分析完ViewGroup后, 自然会解开你的迷惑.</p>
</li>
</ul>
<blockquote>
<h5 id="ViewGroup-onMeasure-int-int"><a href="#ViewGroup-onMeasure-int-int" class="headerlink" title="ViewGroup#onMeasure(int, int)"></a>ViewGroup#onMeasure(int, int)</h5></blockquote>
<p>由于ViewGroup的子类对测量都有不同的策略, 因此, ViewGroup并没有重写onMeasure(int, int), 而是让其子类去重写.我们拿比较简单的FrameLayout来分析吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</div><div class="line">                MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</div><div class="line">                MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</div><div class="line">        mMatchParentChildren.clear();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> childState = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">            <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</div><div class="line">                measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">                maxWidth = Math.max(maxWidth,</div><div class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</div><div class="line">                maxHeight = Math.max(maxHeight,</div><div class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</div><div class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class="line">                <span class="keyword">if</span> (measureMatchParentChildren) &#123;</div><div class="line">                    <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</div><div class="line">                            lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                        mMatchParentChildren.add(child);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Account for padding too</span></div><div class="line">        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</div><div class="line">        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</div><div class="line"></div><div class="line">        <span class="comment">// Check against our minimum height and width</span></div><div class="line">        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</div><div class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line"></div><div class="line">        <span class="comment">// Check against our foreground's minimum height and width</span></div><div class="line">        <span class="keyword">final</span> Drawable drawable = getForeground();</div><div class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</div><div class="line">            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</div><div class="line">            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</div><div class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</div></pre></td></tr></table></figure>
<ul>
<li>我抽取了FrameLayout中onMeasure(int, int)的核心代码, 主要思路: 遍历子View,让子View测量自己,也就是触发子View的测量. 接着再根据子View的大小来计算自己的大小.我们先来看看measureChildrenWithMargins(View, int, int).</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该方法是ViewGroup提供的工具类, 关于View和ViewGroup提供的测量工具类, 后面的专门分析.</p>
</li>
<li><p>首先拿到View的LayoutParams, 然后调用getChildMeasureSpec来得到子View的MeasureSpec, 我们看看它是怎么得到的.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">                <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">                <span class="comment">// be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">                <span class="comment">// big it should be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先进行解包操作, 拿到父View传递下来的测量模式和测量大小, 在xml布局中的顶级View的MeasureSpec是由RootViewImpl传递下来的, 而对于顶级View(DecorView)来说, 其MeasureSpec是由窗口大小和自身的LayoutParams决定的.</p>
</li>
<li><p>接着进入switch语句:</p>
<ul>
<li><p>当父View的mode为<code>MeasureSpec.EXACTLY</code>时, 再根据子View的LayoutParams(也就是子View在xml文件中声明的layout_xx属性的容器), 又分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽(用宽来举例子)为确定的值, 那么resultSize为子View在xml文件中声明的宽度(也就是xxdp),resultMode为<code>MeasureSpec.EXACTLY</code>,然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占满父View的宽度, 因此, resultSize设置为父View的大小size, reslutMode为<code>MeasureSpec.EXACTLY</code></li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.WRAP_CONTENT)</code>时, 表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为<code>MeasureSpec.AT_MOST</code></li>
</ol>
</li>
<li><p>当父View的mode为<code>MeasureSpec.AT_MOST</code>时, 根据子View的LayoutParams, 分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽为确定的值时, resultSize为子View在xml文件中声明的宽度(也就是xxdp), resultMode为<code>MeasureSpec.EXACTLY</code>, 然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占有父View的宽度, 但是由于父View的测量模式为<figure class="highlight plain"><figcaption><span>所以resultMode只能为```MeasureSpec.AT_MOST``(因为父View自身也不知道自己多大), resultSize设置为父Viw的大小.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">   3. 当子View在xml文件中声明的宽为``LayoutParams.AT_MOST``时表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为``MeasureSpec.AT_MOST``.</div><div class="line"></div><div class="line">* 分析到这里, 我们可以总结出View的MeasureSpec是由哪些因素决定的</div><div class="line"> * 对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以会看之前分析的代码)</div><div class="line"> * 对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</div><div class="line"></div><div class="line">* 上面我们针对宽度来进行了分析, 对于高度而言, 过程跟宽度一样</div><div class="line"></div><div class="line">* 最后调用子View的``measure(int, int)``, 将在``getChildMeasureSpec``中得到的宽和高对应的MeasureSpec(也就是我们上面以宽度为例子来分析的情况),传递给子View,接下去的过程跟我们前面在分析子View的情况一样.</div><div class="line"></div><div class="line">* 现在我们可以更加确定了这样一个事实: View的onMeasure(int, int)中的widthMeasureSpec和heightMeasureSpec是由父View根据自身的MeasureSpec和子View的LayoutParams产生并传递给子View的.</div><div class="line"></div><div class="line">* 如果你仔细总结的话,会发现:只要子View的的宽或高设置为``LayoutParams``设置为WRAP_CONTENT时, 生成MeasureSpec中的size都是父View的size(一般是父View剩下的size),而mode为AT_MOST.</div><div class="line"></div><div class="line">* 我们现在继续调到子View的measure方法中的onMeasure(), 我们再来看看getDefaultSize()这个方法:</div><div class="line"></div><div class="line">```java</div><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">        int result = size;</div><div class="line">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>首先解包出由父View传递下来的MeasureSpec, 通过上面的分析, 当子View在xml文件中将layout_width设置为WRAP_CONTENT时, 对应的SpecMode为AT_MOST, 此时进入switch语句, 得到的大小其实是父View的大小, 这也解释了,在自定义View(继承View)时,如果没有重写onMeasure(int, int)时,当这个自定义View的宽度或者高度设置为<code>WRAP_CONTENT</code>时,会变成占有父View的全部高度和宽度.</p>
</li>
<li><p>分析到这里, 已经基本分析完了测量过程,我们还是总结一下,再进入下一个流程.</p>
</li>
</ul>
<blockquote>
<h4 id="测量过程总结"><a href="#测量过程总结" class="headerlink" title="测量过程总结"></a>测量过程总结</h4></blockquote>
<ul>
<li><p>onMeasure(int widthSpec, int heightSpec)中的这两个MeasureSpec是由父View传递下来的.MeasureSpec一旦确定了, 在这个方法中就可以确定View的测量宽高了.</p>
</li>
<li><p>如何确定MeasureSpec?</p>
<ul>
<li>对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以回看之前分析的代码)</li>
<li>对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</li>
</ul>
</li>
<li><p>父View的MeasureSpec和子View的LayoutParams如何确定MeasureSpec?</p>
<ul>
<li>在View测量的时候, 系统会将View的LayoutParams在父View的SpecMode的约束下再次打包为一个传递给子View的MeasureSpec.</li>
</ul>
</li>
<li><p>EXACTLY,AT_MOST和LayoutParams的关系</p>
<ul>
<li>EXACTLY: 父View已经检测出子View所需要的大小(通常是子View在xml文件中声明为精确的值,比如20dp),它对应于LayoutParams中的match_parent和具体的数值</li>
<li>AT_MOST: 子View不能超过父View给定的大小, 它对应与LayoutParams中的wrap_content.</li>
</ul>
</li>
<li><p>最后来看看流程图加深印象:</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8aodsxyj30nq0i2ta8.jpg" alt=""></p>
<blockquote>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3></blockquote>
<p>经过测量阶段后, View已经知道自己的宽和高, 接着就需要在布局阶段确定应该显示在哪个区域,也就是屏幕上的四个点.那我们回到VewiRootImpl中的performLayout()方法, 该方法是触发布局的起点, 在里面调用了View的layout方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</div></pre></td></tr></table></figure>
<ul>
<li><p>layout方法中的四个参数分别为屏幕上的四个点, 也就是整个屏幕的区域</p>
</li>
<li><p>我们进入View的layout方法:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们主要分析上面的两个核心操作:<ul>
<li>setFrame(left, top, right, bottom)这个方法主要是保存四个点的位置, 并且判断传入的位置跟之前的是不是一样, 不一样的话,会回调onSizeChange接口</li>
<li>调用onLayout(left, top, right, bottom), 但是这个方法View是一个空方法, 对于ViewGroup来说,具体的子类有其具体的实现方法.因此, <code>layout方法主要是view用于确定自己的位置的, 而onLayout是用于ViewGroup循环调用子类的layout方法来对子类进行布局的.</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>理解了上面的这两点, 其实布局过程就基本没什么了.</p>
</li>
<li><p>最后还是看看流程图, 加深理解.</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8dhsrxmj30kh0flwfa.jpg" alt=""></p>
<ul>
<li>分析到这里, 测量,布局都分析完了, 绘制流程就不讲了,</li>
</ul>
<h1 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h1><blockquote>
<h2 id="继承View重写onDraw方法和onMeasure方法"><a href="#继承View重写onDraw方法和onMeasure方法" class="headerlink" title="继承View重写onDraw方法和onMeasure方法"></a>继承View重写onDraw方法和onMeasure方法</h2></blockquote>
<p>这种方法一般用于实现基础控件和组合控件难以达到的效果. 所以需要重写onDraw方法来画出自己的图形, 重写onMeasure方法来支持wrap_content属性,和padding属性.</p>
<blockquote>
<h2 id="继承ViewGrroup派生特殊的Layout"><a href="#继承ViewGrroup派生特殊的Layout" class="headerlink" title="继承ViewGrroup派生特殊的Layout"></a>继承ViewGrroup派生特殊的Layout</h2></blockquote>
<p>当系统的基础布局容器不能满足我们的需求时, 我们可以继承ViewGroup来自定义一个布局容器. 这种方法需要合适处理ViewGroup的<code>测量(测量孩子和测量自己)</code>,布局这两个过程.</p>
<blockquote>
<h2 id="继承基础控件-如TextView"><a href="#继承基础控件-如TextView" class="headerlink" title="继承基础控件(如TextView)"></a>继承基础控件(如TextView)</h2></blockquote>
<p>这种方法一般用于扩展基础控件的功能,相对比较简单. 这种方法不需要自己处理wrap_content和padding.</p>
<blockquote>
<h2 id="继承基础容器-如LinearLayout"><a href="#继承基础容器-如LinearLayout" class="headerlink" title="继承基础容器(如LinearLayout)"></a>继承基础容器(如LinearLayout)</h2></blockquote>
<p>这种方法一般用于组合一些基础控件或者自定义View.</p>
<h1 id="自定义View的方法论"><a href="#自定义View的方法论" class="headerlink" title="自定义View的方法论"></a>自定义View的方法论</h1><blockquote>
<h2 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h2></blockquote>
<p>这种自定义方法,我们处理的主要有两个方法:</p>
<ul>
<li><p>在onMeasure(int, int)中处理wrap_content和padding</p>
</li>
<li><p>在onDraw(Canvas)中绘制你想要的UI和处理padding</p>
</li>
</ul>
<blockquote>
<h3 id="onMeasure-int-int-处理"><a href="#onMeasure-int-int-处理" class="headerlink" title="onMeasure(int, int)处理"></a>onMeasure(int, int)处理</h3></blockquote>
<p>在onMeasure(int, int)中需要处理的有两个: wrap_content和padding这两个属性.</p>
<blockquote>
<h4 id="支持wrap-content"><a href="#支持wrap-content" class="headerlink" title="支持wrap_content"></a>支持wrap_content</h4></blockquote>
<p>经过前面的分析, 我们知道对于一个继承View的控件, 如果没有重写onMeasure(int, int), 在xml布局中设置layout_width=”wrap_content”的时候, 会占满父View的宽度, 其中的原因前面已经分析了, 这里主要将如何支持wrap_content. 接下来我会讲解决这个问题的基本方法和另外一种快捷方法</p>
<ul>
<li>基本方法:</li>
</ul>
<p>当layout_width或者layout_height为wrap_content, 我们不用默认的高宽, 而是自己根据自己View的内容来决定View的高宽</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"><span class="comment">//1.首先拿到宽高的大小和测量模式</span></div><div class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">//2.接着判断宽高和mode是否为wrap_content, 如果是的话, 我们不用widthSize或者heightSize, 我们自己指定View的大小</span></div><div class="line">        <span class="comment">//wrap_content对应MeasureSpec.AT_MOST属性</span></div><div class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">  setMeasuredDimension(<span class="number">300</span>, <span class="number">300</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(<span class="number">300</span>, heightSize); <span class="comment">//只有width为wrap_content, 所以高直接用heightSize就行</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(widthSize, <span class="number">300</span>); <span class="comment">//只有height为wrap_content, 所以宽直接用widthSize就行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提供了解决wrap_content的基本思路.下面我们介绍另外一种快捷而且屏幕适配更好的方法.在介绍之前,我们先来看看View中的几个有用的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法返回一个建议的最小高度.如果View没有设置背景,那么返回值为mMinHeight(也就是在xml布局中声明的属性), 如果有的话, 会返回背景的Drawable对象的高度和mMinHeight中的最大值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法和前面的一样,这里不多说.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">                <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">                    result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    result = size;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">                result = specSize;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                result = size;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code>这个方法是View本身提供的一个支持wrap_content的一个方法(getDefaultSize()方法不支持wrap_content),这个方法除了支持wrap_content外, 还通过掩码操作添加了一些信息, 如果当size的大小大于父View的高度时, 会通过掩码操作将 MEASURED_STATE_TOO_SMALL和size打包成一个int值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resolveSizeAndState(size, measureSpec, <span class="number">0</span>) &amp; MEASURED_SIZE_MASK;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个是上个方法的重载版本, childMeasuredState属性传入0,表示不对标志做处理, 最后用MEASURED_SIZE_MASK这个掩码提取出想要是size值.</p>
<p>介绍完了上面的几个方法, 我们开始介绍另外一种快捷的适配wrap_content的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumWidth(), mTextSize); <span class="comment">//将默认的最小宽度和自己定义的字体大小比较, 取最大值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumHeight(), mTextSize); <span class="comment">//将默认的高度和自己定义的字体大小比较, 取最大值.</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们知道,支持wrap_content的实质就是根据内容来决定View的大小.那么我们可以利用<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>这个两个方法来获取最小的高度和宽度.当mode为wrap_content时, 怎么计算出最小的高度和宽度, 这个看你的自定View情况, 自己灵活选择.</p>
<blockquote>
<h4 id="支持padding"><a href="#支持padding" class="headerlink" title="支持padding"></a>支持padding</h4></blockquote>
<p>支持padding是需要在onDraw和onMeasure中实现, 思路都很简单, 在onMeasure中的宽高将padding考虑进去, 在onDraw中绘制图形时,除去padding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        maxWidth = maxWidth + getPaddingLeft() + getPaddingRight(); <span class="comment">//加上paddingLeft和paddingRight得到宽度</span></div><div class="line">        maxHeight = maxHeight + getPaddingBottom() + getPaddingTop(); <span class="comment">//加上paddingBottom和paddingTop得到高度</span></div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是onMeasure中支持padding, 下面看看onDraw中支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> wdith = getWidth() - getPaddingLeft() - getPaddingRight();</div><div class="line">        <span class="keyword">int</span> height = getHeight() - getPaddingTop() - getPaddingBottom();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在onDraw中, 用到宽高时, 先减去对应的padding就能支持padding了.</p>
<blockquote>
<h2 id="继承ViewGroup"><a href="#继承ViewGroup" class="headerlink" title="继承ViewGroup"></a>继承ViewGroup</h2></blockquote>
<p>继承ViewGroup的View, 相当于自定义一个布局容器, 需要我们处理的有两个:</p>
<ul>
<li><p>onMeaure(int, int)</p>
</li>
<li><p>onLayout(int, int, int, int)</p>
</li>
</ul>
<blockquote>
<h3 id="处理onMeasure-int-int"><a href="#处理onMeasure-int-int" class="headerlink" title="处理onMeasure(int, int)"></a>处理onMeasure(int, int)</h3></blockquote>
<p>自定义ViewGroup不同于自定义View, 自定义ViewGroup在onMeasure(int, int)中, 除了测量自己,还需要测量孩子, 通常是遍历孩子并触发孩子的测量方法, 然后根据孩子的宽高来决定自己的宽高. 我们下面来看看ViewGroup给我们提供的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过传入子View,父View的宽高测量规格, 该方法内部会帮我们调用view的measure方法去测量View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法内部遍历所有子View, 然后调用上一个方法测量View, 也就是帮我们测量了所有子View, 不用我们手动for循环去测量View. 你们可以根据自己的需要去调用其中的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法也是测量子View的方法, 不过这个方法把子View的margin考虑进去了.</p>
<p>下面说说ViewGroup测量的套路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxHeight = getPaddingTop() + getPaddingBottom(); <span class="comment">//支持padding</span></div><div class="line">    <span class="keyword">int</span> maxWidth = getPaddingLeft() + getPaddingRight(); <span class="comment">//支持padding</span></div><div class="line">    <span class="comment">//循环测量孩子</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>); <span class="comment">//考虑margin测量孩子</span></div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        maxHeight = maxHeight + child.getMeasuredHeight() + params.topMargin + params.bottomMargin; <span class="comment">//将支持margin</span></div><div class="line">        maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + params.leftMargin + params.rightMargin); <span class="comment">//将支持margin</span></div><div class="line">    &#125;</div><div class="line">    setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), resolveSize(maxHeight, heightMeasureSpec)); <span class="comment">//测量自己</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我模拟了LinearLayout中的vertical布局属性.注意记得考虑padding和margin.</p>
<p>首先考虑padding, 然后循环遍历子View并测量, 最后根据孩子测量得到的宽高和孩子的margin属性和自己的布局属性来进行测量自己的大小.</p>
<blockquote>
<h3 id="onLayout-int-int-int-int"><a href="#onLayout-int-int-int-int" class="headerlink" title="onLayout(int, int, int, int)"></a>onLayout(int, int, int, int)</h3></blockquote>
<p>onLayout的职责就是将根据子View测量得到的宽高将其摆放在合适的位置. 注意: 在onLayout阶段, 没有特殊情况的话, 子View的布局要根据其测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> i, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = getPaddingLeft(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> top = getPaddingTop(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> bottom;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; getChildCount(); j++) &#123;</div><div class="line">        View child = getChildAt(j);</div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        left = left + params.leftMargin;</div><div class="line">        top = top + params.topMargin;</div><div class="line">        bottom = params.bottomMargin;</div><div class="line">        <span class="keyword">int</span> width = child.getMeasuredWidth();</div><div class="line">        <span class="keyword">int</span> height = child.getMeasuredHeight();</div><div class="line">        child.layout(left, top, left + width, top + height + bottom);</div><div class="line">        top = top + height + bottom;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是简单的模仿LinearLayout的vertical布局属性, 思路: 遍历所有的子View, 然后确定四个点的位置, 一般都是确定left, top这两个点, 然后对应加上View的宽高再得到另外的right, bottom.注意:这里right和bottom这两个点的确定,如果没有特殊情况, 应该根据view的测量得到的宽高来确定, 不能随便指定特定的值, 这样会导致getMeasureXX和getXX不相等, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child.layout(left, top, left + width + <span class="number">100</span>, top + height + bottom + <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>如果你按照上面的操作, getWidth会比getMeasureWidth大100, getHeight会比getMeasureHeight大100. 原因就是你布局的时候没有根据测量阶段View的宽高来布局(也就是私自加多了100, 导致两个点相减时会多出100). 因此,如果没有特殊情况, 布局阶段请按照子View测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<blockquote>
<h3 id="定义你自己的LayoutParams"><a href="#定义你自己的LayoutParams" class="headerlink" title="定义你自己的LayoutParams"></a>定义你自己的LayoutParams</h3></blockquote>
<p>最后补充一个. 如果你的自定义ViewGroup需要自定义LayoutParams的话, 需要进行下面两个步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayoutParams</span> <span class="keyword">extends</span> <span class="title">MarginLayoutParams</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> attr;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(c, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(width, height);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(LayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在你的类中定义上面的内部类, 属性自己定义.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(LayoutParams p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(p);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后重载上面的方法.</p>
<p>如果理解了上面的方法轮, 那么自定义View也就没多大问题了, 最后剩下的就是绘制了.</p>
<p>剩下的两种情况都不怎么难, 这里多说了.</p>
<blockquote>
<h2 id="自定义View的步骤"><a href="#自定义View的步骤" class="headerlink" title="自定义View的步骤"></a>自定义View的步骤</h2></blockquote>
<p>1: 首先分析这个View是怎么绘制的? 哪些是需要抽象成参数</p>
<p>2: 将抽象出来的参数定义在attr资源文件</p>
<p>3: 重写onMeasure方法,并让你的View支持wrap_content,或者padding(如果有必要的话)</p>
<p>4: 重写onDraw方法, 主要在onDraw也是要处理padding(如果有必要的话)</p>
<p>5: 暴露接口给外部(例如监听接口, 动态改变属性的接口)</p>
<p>6: 如果存在滑动冲突的话, 需要解决滑动冲突</p>
<p>7: 根据实际情况优化你的View</p>
<blockquote>
<h2 id="自己的自定义View的习惯"><a href="#自己的自定义View的习惯" class="headerlink" title="自己的自定义View的习惯:"></a>自己的自定义View的习惯:</h2></blockquote>
<p>上面是标准的自定义View的步骤, 实际情况中, 不需要按照严格的顺序进行.下面说说我写的时候的套路:</p>
<p>1: 先分析这个自定义View是怎么话的?</p>
<p>2: 抽象出一些参数,定义在View中</p>
<p>3: 先在onDraw中把图形先画出来,</p>
<p>4: 图形出来后, 再重写onMeasure来支持wrap_content.padding等属性</p>
<p>5: 将抽象出来的参数定义在attr资源文件</p>
<p>6: 暴露接口给外部</p>
<p>7: 优化View</p>
<h2 id="自定义View的使用场景"><a href="#自定义View的使用场景" class="headerlink" title="自定义View的使用场景"></a>自定义View的使用场景</h2><blockquote>
<h3 id="优先考虑继承现有的空间来实现额外的功能"><a href="#优先考虑继承现有的空间来实现额外的功能" class="headerlink" title="优先考虑继承现有的空间来实现额外的功能"></a>优先考虑继承现有的空间来实现额外的功能</h3></blockquote>
<p>如果一些效果是继承现有控件能够实现的话, 那么优先继承现有的控件, 因为现有的控件都是经过官方多次的优化,性能肯定比我们自己写出来的好.</p>
<blockquote>
<h3 id="当一个View嵌套很多布局时-考虑自定义View的实现"><a href="#当一个View嵌套很多布局时-考虑自定义View的实现" class="headerlink" title="当一个View嵌套很多布局时, 考虑自定义View的实现."></a>当一个View嵌套很多布局时, 考虑自定义View的实现.</h3></blockquote>
<p>如果View嵌套太深, requesLayout触发时, 会导致整个布局都被测量和布局, 这样的消耗太大了, 更好的做法是,自定义一个View, 减少测量和布局阶段的消耗.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fk2tf8bzggj30zk0nqtbj.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;LayoutParams认知&quot;&gt;
    
    </summary>
    
      <category term="自定义View" scheme="http://cristianoro7.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="自定义View" scheme="http://cristianoro7.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-运输层</title>
    <link href="http://cristianoro7.github.io/2017/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://cristianoro7.github.io/2017/10/01/计算机网络-运输层/</id>
    <published>2017-10-01T08:03:05.601Z</published>
    <updated>2017-10-01T08:03:05.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-运输层"><a href="#计算机网络-运输层" class="headerlink" title="计算机网络-运输层"></a>计算机网络-运输层</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分用和复用</li>
<li>UDP协议</li>
<li>运输层梳理</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>当网络的边缘部分中的两个主机使用网络的核心部分功能进行通信时,只有主机的协议栈才有运输层,而网络的核心部分中的路由器在转发分组时都只用到下三层的功能.</p>
<p>网络层是为主机之间提供逻辑通信,而运输层为应用进程之间提供端到端的逻辑通信.</p>
<p>在网络层中, IP数据报首部的检验和字段只检验首部是否出现差错而不检查数据部分.而在运输层中, 应当进行首部和数据的差错检验.</p>
<blockquote>
<h3 id="分用和复用"><a href="#分用和复用" class="headerlink" title="分用和复用"></a>分用和复用</h3></blockquote>
<p>复用是指发送方不同的应用程序都可以使用同一个运输层协议传送数据.</p>
<p>分用是指接收方的运输层去掉报文的首部后能够把数据正确交付到目的进程中.</p>
<blockquote>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3></blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>UDP协议只在IP数据报服务上增加了很少的功能,这些功能是分用和复用还有差错检验.</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>UDP是无连接的,因此减少了开销和发送数据之前的时延</li>
<li>UDP使用尽最大努力交付,即不保证可靠交付.</li>
<li>UDP是面向报文的.应用层交给UDP多长的报文,UDP就照样发送,一次发一个报文.</li>
<li>UDP没有拥塞控制.</li>
<li>UDP支持1对1,1对多,多对1,多对多的交互通信.</li>
<li>UDP的首部开销小,只有8字节.</li>
</ol>
<blockquote>
<h3 id="运输层梳理"><a href="#运输层梳理" class="headerlink" title="运输层梳理"></a>运输层梳理</h3></blockquote>
<p>运输层主要有两个协议:</p>
<ol>
<li>UDP</li>
<li>TCP</li>
</ol>
<p>UDP是面向无连接的协议,只是在IP数据报上添加复用,分用和差错检验的功能,UDP协议本身比较简单.</p>
<p>TCP协议是面向连接的一种协议,在进程之间的通信中提供一种可靠交付的服务.相比于UDP协议, TCP协议比较复杂.</p>
<p>下面给出运输层的知识梳理图:</p>
<p><img src="/uploads/计网/运输层/运输层梳理.png" alt=""></p>
<p>其中TCP协议涉及的内容比较多,归纳起来可以分为:</p>
<p><a href="https://cristianoro7.github.io/2017/09/29/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">可靠传输的工作原理</a></p>
<p><a href="https://cristianoro7.github.io/2017/09/29/TCP%E9%A6%96%E9%83%A8/">TCP首部</a></p>
<p><a href="https://cristianoro7.github.io/2017/09/29/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">TCP滑动窗口</a></p>
<p><a href="https://cristianoro7.github.io/2017/09/29/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">TCP流量控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/09/29/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/09/29/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/">TCP连接管理</a></p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-运输层&quot;&gt;&lt;a href=&quot;#计算机网络-运输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-运输层&quot;&gt;&lt;/a&gt;计算机网络-运输层&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>重拾Dagger2</title>
    <link href="http://cristianoro7.github.io/2017/10/01/Dagger2%E7%9B%AE%E5%BD%95/"/>
    <id>http://cristianoro7.github.io/2017/10/01/Dagger2目录/</id>
    <published>2017-10-01T08:00:47.460Z</published>
    <updated>2017-10-01T08:00:47.460Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目没什么bug,也没什么新的需求, 闲得有点慌(其实一直很闲…), 既然那么闲, 那就重新深入学习Dagger2吧. 之前虽然有学过Dagger2, 但是并没研究其中的原理, 用起来总感觉很不踏实, 于是借此机会研究了一波Dagger2, 并准备分为三篇来讲, 分别为: 使用篇, 原理篇和组织篇. 本篇的目的就指在介绍Dagger2</p>
<h3 id="Dagger2是什么"><a href="#Dagger2是什么" class="headerlink" title="Dagger2是什么?"></a>Dagger2是什么?</h3><p>Dagger2是之前由Square公司开源的Dagger的分支, 它运行在Android或者Java上的编译时注入依赖的框架, 关于什么是依赖注入,这里就不多说啦</p>
<h3 id="为什么要使用Dagger2"><a href="#为什么要使用Dagger2" class="headerlink" title="为什么要使用Dagger2"></a>为什么要使用Dagger2</h3><p>回想一下, 在我们的项目中, 什么代码是有用的? 什么代码是没什么用但我们必须要写的? 这个问题真的值得思考.举个例子, 平常我们实现网络请求的功能, 我们为了解耦, 会写一堆工厂类将网络请求的各个组件连接起来, 在这个场景中,我们真正关注的是网络请求, 而那些将网络请求连接起来的工厂类我们其实对它并不感兴趣, 它只是我们实现网络请求的一个工具而已. 面对这样的问题, Dagger利用依赖注入的模式来替代工厂类, 将我们从编写一堆的工厂类中解放出来,从而让我们把精力放在我们感兴趣的代码</p>
<h3 id="使用Dagger2的好处"><a href="#使用Dagger2的好处" class="headerlink" title="使用Dagger2的好处"></a>使用Dagger2的好处</h3><p>利用Dagger2, 能让我们从一堆的引用模板代码中解放出来, 将更多的精力放在业务需求上; 由于Dagger2会帮我们自动生成需要依赖的代码, 这能极大的减少我们的工作量. 更有趣的是:Dagger2帮我们管理依被赖对象的生命周期, 比如使用Singleton注解就能实现单例, 不过这个单例实现是有条件的, 通过Dagger2管理被依赖的对象能让我们的项目结构更清晰</p>
<h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>接下来, 我会写一下系列的Dagger2文章</p>
<blockquote>
<p><a href="https://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E4%BD%BF%E7%94%A8Dagger2/">重拾Dagger2-使用Dagger2</a><br><a href="https://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E7%90%86%E8%A7%A3Dagger2/">重拾Dagger2-理解Dagger2</a><br><a href="https://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E7%BB%84%E7%BB%87/">重拾Dagger2-组织依赖注入</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      meet with dagger2
    
    </summary>
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/categories/Dagger2/"/>
    
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接管理</title>
    <link href="http://cristianoro7.github.io/2017/09/29/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/09/29/TCP连接管理/</id>
    <published>2017-09-29T15:40:12.994Z</published>
    <updated>2017-09-29T15:40:12.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>TCP连接</li>
<li>TCP连接释放</li>
</ul>
<blockquote>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3></blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdilnjr84mj30zk0lk788.jpg" alt=""></p>
<p>上图为TCP连接建立的过程</p>
<p>B的TCP服务器进程首先创建传输控制块,准备接收客户端进程的连接请求.</p>
<p>A的TCP客户端进程首先创建传输控制块, 然后向B发送连接请求的报文段,此时首部SYN = 1,同时选择一个seq = x. TCP规定,SYN报文段不能携带数据,但要也要消耗一个序号.这次TCP客户端进程进入SYN-SEND状态.</p>
<p>B收到连接请求后, 如同意连接, 则向A发送确认. 在确认的报文段中应把SYN和ACK都置为1,确认号ack = x + 1, 同时也为自己选定一个序号seq = y.注意:这个报文段也不能携带数据,但是要消耗一个序号.此时TCP服务器进入SYN-RCVD状态.</p>
<p>TCP客户端收到B的确认后, 还要向B确认.确认的报文段的ACK置1,确认号ack = y+1,而自己的序号seq = x + 1.注意:ACK报文可以携带数据.如果不携带数据就不用消耗序号.此时TCP连接已经建立.A进入ESTALISHED状态.</p>
<p>当B收到A的确认后, 也进入ESTABLISHED状态.</p>
<p>上面的连接建立过程叫做三次握手.</p>
<p>三次握手的原因是为了防止已失效的连接请求报文段突然又传送到B,因此产生错误.</p>
<p>现在假定A发送出去的第一个连接请求报文段在某些网络结点长时间滞留了,以致延误到连接释放后的某个时间才到达B.本来这个是一个已经失效的报文段.但是B收到此有效的报文段后, 就误认为A又发出了<br>一次连接请求.于是向A发送确认报文段,同意建立连接.如果假设不采用三次握手, 那么B发出确认,新的连接就建立了.由于A并没有发出建立连接的请求, 因此不理睬B的确认,也不会向B发送数据.但B却以为新的连接已经建立,一直等待A发送数据.这样B的许多资源就白白浪费了.</p>
<p>如果采用三次握手的话, A不会向B发出确认.B由于收不到确认,就不知道A并没有要求建立连接.</p>
<blockquote>
<h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3></blockquote>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdilpjw72ej31180ou43x.jpg" alt=""></p>
<p>上图为TCP连接释放过程</p>
<p>A的应用首先让其TCP发出连接释放的报文段, 并停止发送数据,主动关闭连接.A把连接释放报文段首部FIN置为1,其序号seq = u.这时A进入FIN-WAIT-1状态,等待B的确认.注意:FIN报文段即使不携带数据也要消耗一个序号.</p>
<p>B收到连接释放的请求后即发出确认,确认号为ack = u + 1,而这个报文段的序号为v.然后B进入CLOSE-WAIT状态.TCP服务器此时通知应用进程, 因此A到B的连接已经释放掉了.这时TCP连接处于半释放状态.即A已经没有要传送数据了.但A仍然接收数据,因为B到A的连接还没有释放.</p>
<p>A收到B的确认后.进入FIN-WAIT-2状态,等待B发送连接释放报文段.</p>
<p>若B已经没有数据要发送了, 其应用进程会通知TCP释放连接.这时B发出的来连接释放报文段必须时FIN = 1.这时B就进入了LAST-ACK状态,等待A的确认.</p>
<p>A收到B的连接释放报文后,必须对此报文发出确认.然后进入TIME-WAIT状态.现在TCP连接还没有释放.必须经过时间等待计时器设置的时间2MSL后, A才进入CLOSED状态.</p>
<p>TIME-WAIT必须等待两个MSL的原因:</p>
<ul>
<li>保证A的最后一个确认报文段能够到达B</li>
<li>防止已失效的连接请求报文段出现在本地连接中.</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
<p><a href="http://blog.csdn.net/lihao21/article/details/52095980" target="_blank" rel="external">http://blog.csdn.net/lihao21/article/details/52095980</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP连接管理&quot;&gt;&lt;a href=&quot;#TCP连接管理&quot; class=&quot;headerlink&quot; title=&quot;TCP连接管理&quot;&gt;&lt;/a&gt;TCP连接管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制</title>
    <link href="http://cristianoro7.github.io/2017/09/29/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://cristianoro7.github.io/2017/09/29/TCP拥塞控制/</id>
    <published>2017-09-29T15:40:09.014Z</published>
    <updated>2017-09-29T15:40:09.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>慢开始和拥塞避免</li>
<li>快重传和快恢复</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>在计算机网络中, 链路的容量,交换节点中的缓存和处理机等都是网络的资源.在某段时间内,若对网络中的某一资源的需求超过本身能提供的资源,这时网络性能就会变差.这种情况成为网络拥塞.</p>
<p>所谓拥塞控制就是要防止过多的数据注入到网络中,这样可以使网络的路由器或者链路不致于过载.拥塞控制是一个全局性的过程,涉及到所有主机,所有的链路,以及与降低网络传输性能有关的所有因素.</p>
<blockquote>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3></blockquote>
<p>发送方维护一个拥塞窗口的状态变量.拥塞窗口的大小取决于网络的拥塞程度,并且动态改变.发送方让自己的发送窗口等于拥塞窗口.</p>
<h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>主机在发送数据的时候,不是直接把大量的数据字节注入网络, 而是先探测一下网络,即由小到大逐渐增大发送窗口,也就是由小到大逐渐增大拥塞窗口.增大的原则是每经过一个传输轮次,拥塞窗口就加倍.而一个传输轮次指的是发送方连续发送报文段后到收到这些连续报文段的确认所经历的时间.</p>
<p>为了防止拥塞窗口增大过大引起网络拥塞,还需要设置一个慢开始门限状态变量.慢开始门限用法:</p>
<ul>
<li>当拥塞窗口 &lt; 慢开始门限时,使用慢开始算法.</li>
<li>当拥塞窗口 &gt; 慢开始门限时,停止使用慢开始算法,改用拥塞避免算法.</li>
<li>当拥塞窗口 = 慢开始门限时,可以使用慢开始算法或者拥塞避免算法.</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞避免算法让拥塞窗口缓慢增大,即每经过一个往返时间RTT就把发送窗口+1,而不是加倍.这样,拥塞窗口按线性规律缓慢增长.</p>
<h4 id="乘法减小"><a href="#乘法减小" class="headerlink" title="乘法减小"></a>乘法减小</h4><p>不论在慢开始阶段还是拥塞避免阶段,只要出现拥塞情况,就把慢开始门限设置为当前拥塞窗口的一半.</p>
<p>当网络频繁出现拥塞时, 慢开始门限的值就下降得很快, 这样可以大大减少注入到网络的分组数.</p>
<h4 id="加法增大"><a href="#加法增大" class="headerlink" title="加法增大"></a>加法增大</h4><p>是指拥塞避免算法后, 使拥塞窗口缓慢增大,防止网络过早出现拥塞.</p>
<blockquote>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3></blockquote>
<h4 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h4><p>快重传算法规定: 发送方连续收到三个重复确认就立即重传该确认对应的分组,不必等待重传计时器到期.</p>
<h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><p>由于发送方连续收到三个重复的确认,此时很可能不是因为网络拥塞,否则也不会连续收到三个重复的确认,因此,不执行慢开始算法,而是执行快恢复算法,即:把拥塞窗口设置为慢开始门限减半后的数值,然后执行拥塞避免算法.</p>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>计算机网路</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP拥塞控制&quot;&gt;&lt;a href=&quot;#TCP拥塞控制&quot; class=&quot;headerlink&quot; title=&quot;TCP拥塞控制&quot;&gt;&lt;/a&gt;TCP拥塞控制&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP滑动窗口</title>
    <link href="http://cristianoro7.github.io/2017/09/29/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://cristianoro7.github.io/2017/09/29/TCP滑动窗口/</id>
    <published>2017-09-29T15:40:02.158Z</published>
    <updated>2017-09-29T15:40:02.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>以字节流为单位的滑动窗口</li>
<li>TCP数据流的类别</li>
<li>接收窗口的确认机制</li>
<li>窗口缩放</li>
<li>缓冲区</li>
<li>超时重传时间的选择</li>
<li>选择确认SACK</li>
</ul>
<blockquote>
<h3 id="以字节流为单位的滑动窗口"><a href="#以字节流为单位的滑动窗口" class="headerlink" title="以字节流为单位的滑动窗口"></a>以字节流为单位的滑动窗口</h3></blockquote>
<p>现假定A收到B发来的确认报文,其中窗口是20,而确认号为31.根据这两个数据,A就构造出了自己的发送窗口:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/滑动窗口.png" alt=""></p>
<ul>
<li>在没有收到B的确认的情况下,A可以连续把窗口内的数据都发送出去.凡是已经发送过去的数据,在未收到确认之前都必须暂时保留,以便在超时重传时使用.</li>
<li>窗口后沿的后面部分表示已经确认接收.这些数据不需要再保留了.</li>
<li>窗口的前沿部分表示不允许发送,因为接收方都没有为这部分数据保留缓存空间.</li>
</ul>
<blockquote>
<h3 id="TCP数据流的类别"><a href="#TCP数据流的类别" class="headerlink" title="TCP数据流的类别"></a>TCP数据流的类别</h3></blockquote>
<p>现在假定A发送序号为31到41的数据.此时, 发送窗口位置并未改变,如图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/数据流分类.png" alt=""></p>
<p>从上图,可以得来的信息:</p>
<p>小于P1的是已经发送并已经收到确认的部分.而大于P3的是不允许发送的部分.<br>P3-P1 = A 的发送窗口.</p>
<p>P2-P1 = 已发送但尚未确认的字节数</p>
<p>P3-P2 = 允许发送但尚未发送的字节数.又称为可用窗口.</p>
<blockquote>
<h3 id="接收窗口的确认机制"><a href="#接收窗口的确认机制" class="headerlink" title="接收窗口的确认机制"></a>接收窗口的确认机制</h3></blockquote>
<p>B的接收窗口大小是20. 在接收窗口外面,到30号为止的数据是已经发送过确认.接收窗口内的序号31~50是允许接收的. 下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/接收窗口确认机制.png" alt=""></p>
<p>B收到了序号为32和33的数据.这些数据没有按序到达,因为序号31还没有到达.此时,B只能对按序到达的数据中的最高序号给出确认,因此B发送的确认报文段中的确认号仍然为31.</p>
<blockquote>
<h3 id="窗口缩放"><a href="#窗口缩放" class="headerlink" title="窗口缩放"></a>窗口缩放</h3></blockquote>
<p>现在假定B收到了序号为31的数据,并把序号为31~33的数据交付主机,然后B删除这些数据.接着把接收窗口向前移动3个序号,如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/B的接收窗口.png" alt=""></p>
<p>同时给A发送确认,其中窗口值为20,但确认号为34.我们注意到, B收到了序号为37,38,40的数据,但这些数据没有按序到达,只能暂时存放在接收窗口中.</p>
<p>A收到B的确认后,就可以把发送窗口向前移动3个序号,但指针P2不动.可以看出,现在A的可用窗口增大了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/A的可用窗口增大.png" alt=""></p>
<p>A在继续发送完序号42~53的数据后,指针P2和P3重合.发送窗口内的序号已经用完,但还没有收到确认.这时A必须停止发送.如果一段时间后,A还没有收到B发来的确认,那么A必须重传这部分数据.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/发送窗口满.png" alt=""></p>
<blockquote>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3></blockquote>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/sliding_window-900x358.jpg" alt=""></p>
<p>上图中，我们可以看到：</p>
<ul>
<li><p>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</p>
</li>
<li><p>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</p>
</li>
</ul>
<blockquote>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3></blockquote>
<p>由于TCP的下层是互联网环境, 发送的报文段可能经过一个高速率的局域网, 也可能经过多个低速率的网络.如果把超时重传时间设置得太短, 就会引起很多报文的不必要重传. 如果把超时重传的时间设置得过长, 则会使得网络的空闲时间太长,从而降低了传输效率.</p>
<p>TCP采用了一种自适应的算法, 它记录一个报文段的发出时间, 以及收到相应的确认时间.这两个时间之差就是报文段的往返时间 RTT. TCP保留了RTT的一个加权平均往返时间RTTs.每当第一次测量到样本RTT样本时,RTTs的值就取为所测量到的RTT样本值.但以后每测量到一个新的RTT样本时,就按照下面的公式计算RTTs:</p>
<p>新的RTTs = (1 - a) <em> (旧的RTTs) + a </em> (新的RTT样本)</p>
<p>RFC推荐a的值为1/8.用这种方法测出的加权平均往返时间RTTs会比测量的RTT值更加平滑.</p>
<p>显然超时重传时间应略大于RTTs. RCF推荐使用下面公式计算:</p>
<p>RTO = RTTs+= + 4 * RTTD</p>
<p>RTTD是RTT的偏差加权平均值,它与RTTs和新的RTT样本的差有关.当第一次测量时, RTTD取为测量到的RTT样本值的一半.在以后的测量中,可以使用下面的公式计算出RTTD</p>
<p>新的RTTD = (1 - B) <em> (旧的RTTD) + B </em> |RTTs - 新的RTT样本 |</p>
<blockquote>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3></blockquote>
<p>现在假设接收方收到的报文段无差错, 只是未按序号,中间还缺少一些序号的数据,通过选择确认SACK可以实现只传送缺少的数据而不重传已经正确到达接收方的数据.下面使用一个例子来理解SACK的工作原理.</p>
<p>TCP接收方在接收对方发送过来的数据字节流的序号不连续,结果就形成了不连续的字节块:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/SACK.png" alt=""></p>
<p>从上图可以看出, 序号1~1000收到了,但序号1001~1500没有收到,接下来的字节又收到了,但是缺少3001~3500.后面序号4501起也没有收到.换句话说,接收方收到了和前面的字节流不连续的两个字节块.如果这些字节块都在接收窗口的范围内,那么接收方就先收下这些数据,但要把这些信息发给发送方,防止发送方重传接收方已经接收到的数据.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">http://coolshell.cn/articles/11609.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP滑动窗口&quot;&gt;&lt;a href=&quot;#TCP滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;TCP滑动窗口&quot;&gt;&lt;/a&gt;TCP滑动窗口&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP流量控制</title>
    <link href="http://cristianoro7.github.io/2017/09/29/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://cristianoro7.github.io/2017/09/29/TCP流量控制/</id>
    <published>2017-09-29T15:39:42.398Z</published>
    <updated>2017-09-29T15:39:42.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>利用滑动窗口实现流量控制</li>
<li>零窗口</li>
<li>传输效率</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>一般来说,我们总希望数据传输得快一点, 但是如果发送方把数据发送得太快, 接收方就可能来不及接收,这就会造成数据的丢失.流量控制其实就是让发送方的发送速率不要太快, 要让接收方来得及接收.</p>
<blockquote>
<h3 id="利用TCP滑动窗口实现流量控制"><a href="#利用TCP滑动窗口实现流量控制" class="headerlink" title="利用TCP滑动窗口实现流量控制"></a>利用TCP滑动窗口实现流量控制</h3></blockquote>
<p>其实TCP流量控制本质上是利用滑动窗口机制来实现的.接下来,结合例子来解释TCP的流量控制.</p>
<p>如图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/流量控制.png" alt=""></p>
<p>现在假设A向B发送数据. 在连接建立时, B告诉A:我的接收窗口为400.因此A的发送窗口不能超过B的发送窗口不能超过接收方窗口的数值.现在假设每个报文段的字节为100, 而报文段的初始值为1.</p>
<p>仔细观察上图, 接收方B进行了3次的流量控制. 第一次吧窗口值缩小到了300.第二次又减到100.最后减到0.即不允许对方再发送数据了.</p>
<blockquote>
<h3 id="零窗口"><a href="#零窗口" class="headerlink" title="零窗口"></a>零窗口</h3></blockquote>
<p>现在考虑一种情况. B向A发送了0窗口报文段不久后, B的接收缓存又有了一些空间.于是B向A发送了rwnd = 400的报文段. 然而这个报文在传送的过程中丢失了. 于是A只能一直等待B发送非零窗口的通知,而B一直等待A发送数据.此时如果没有其他措施,这种相互等待的局面会一直持续下去.</p>
<p>为了解决这个问题, TCP为每个连接设有一个持续计时器.只要TCP连接接收到零窗口,就启动持续计时器.若持续计时器时间一到,就发送一个零窗口探测报文段.而对方就在确认这个探测报文段时给出现在的窗口值.如果窗口值不是零的话,那么死索界面将会被打破,否则就重新启动持续计时器.</p>
<blockquote>
<h3 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h3></blockquote>
<h4 id="发送效率"><a href="#发送效率" class="headerlink" title="发送效率"></a>发送效率</h4><p>应用程序把数据传送给TCP的发送缓存后, 剩下的任务就由TCP来控制了.此时,TCP可以采用不同的机制来控制发送的时机.例如:</p>
<ul>
<li>TCP维护一个变量,它等于最大报文长度MSS.只要缓存中存放的数据达到MSS字节时,就组装成一个报文发送出去.</li>
<li>由发送方的应用程序指明要求发送报文段,也就是TCP的PSH操作.</li>
<li><p>第三种机制是发送方的计时器期限到了,就把当前已缓存的数据组装成报文发送出去.</p>
<p>在TCP的实现中, 广泛是使用Nagle算法.该算法如下:若发送应用程序把要发送的数据逐个字节都送到TCP缓存中, 则发送方会把第一个字节先发送出去,把后面到达的字节缓存起来.当发送方收到对第一个数据的确认时,再把缓存的字节组装成报文段发送出去,同时继续对后来到达的数据进行缓存.这样做,可以有效的提高网络的吞吐量.</p>
</li>
</ul>
<h4 id="接收效率"><a href="#接收效率" class="headerlink" title="接收效率"></a>接收效率</h4><p>现在假设TCP接收方的缓存已经满了,而应用进程一次只从接收缓存中读取1个字节,然后向发送方发送确认, 并把窗口值设置为1.如此循环下去, 会使网络的效率很低.</p>
<p>要解决上面的问题,可以有下面两种方法:</p>
<ol>
<li>让接收方等待一段时间,使得接收缓存有足够空间容纳一个MSS再发送确认.</li>
<li>让接收方等待一段时间,使得接收缓存已有一半的空闲的空间.</li>
</ol>
<p>上面的两种方法可以交替使用.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP流量控制&quot;&gt;&lt;a href=&quot;#TCP流量控制&quot; class=&quot;headerlink&quot; title=&quot;TCP流量控制&quot;&gt;&lt;/a&gt;TCP流量控制&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP首部</title>
    <link href="http://cristianoro7.github.io/2017/09/29/TCP%E9%A6%96%E9%83%A8/"/>
    <id>http://cristianoro7.github.io/2017/09/29/TCP首部/</id>
    <published>2017-09-29T15:39:28.878Z</published>
    <updated>2017-09-29T15:39:28.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></blockquote>
<p>TCP的全部功能都体现在其首部中的各个字段的作用.因此, 只有弄清TCP首部各个字段的作用才能理解TCP的工作原理.</p>
<p>TCP首部的前20个字节是固定的,后面有4n字节是根据需要而增加的选项.因此,TCP首部的最小长度为20字节.</p>
<h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占2个字节, 分别写入源端口号和目的端口号. TCP的分用和复用功能是通过端口实现的.</p>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占4个字节.TCP是面向字节流的,在一个TCP连接中传送的字节流中的每一个字节都按顺序编号.序号字段值是用来指定本报文段所发送的数据的第一个字节的序号.</p>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占4字节.是接收方期望收到发送方下一个报文段的第一个数据字节序号.例如:B正确接收了A发送过来的一个报文段,其序号字段为501,数据长度为200字节,表明B正确接收了501~700的序号的数据.因此,B期望收到A的下一个数据序号是701, 于是B在发送给A的确认报文中把确认号置为701.</p>
<h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占4位, 它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远.这个字段实际上是指出TCP首部的长度.</p>
<h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占6位, 保留为今后使用, 但目前应置为0</p>
<h3 id="紧急URG"><a href="#紧急URG" class="headerlink" title="紧急URG"></a>紧急URG</h3><p>当URG = 1时, 表明紧急指针字段有效.它告诉系统,当前报文段有紧急数据,应当尽快传送.</p>
<h3 id="确认ACK"><a href="#确认ACK" class="headerlink" title="确认ACK"></a>确认ACK</h3><p>仅当ACK = 1时确认号字段才有效.当ACK = 0时,确认号无效. TCP规定,在连接建立后所有传送的报文段都必须把ACK置为1.</p>
<h3 id="推送PSH"><a href="#推送PSH" class="headerlink" title="推送PSH"></a>推送PSH</h3><p>当发送方将PSH置为1,并立即创建一个报文段发送出去.接收方TCP收到PSH = 1的报文段时,就尽快地交付接收应用程序,而不再等到整个缓存填满了再向上交付.</p>
<h3 id="复位-RST"><a href="#复位-RST" class="headerlink" title="复位(RST)"></a>复位(RST)</h3><p>当RST = 1 时, 表明TCP连接出现严重错误,必须释放连接,然后再重新建立连接.</p>
<h3 id="同步SYN"><a href="#同步SYN" class="headerlink" title="同步SYN"></a>同步SYN</h3><p>在连接建立时用来同步序号. 当SYN = 1 时而ACK = 0 时表示这是一个连接请求报文段.若对方同意连接后, 则应在响应报文中使SYN = 1和ACK = 1.实际上SYN = 1 时表示这是一个连接请求或接受报文.</p>
<h3 id="终止FIN"><a href="#终止FIN" class="headerlink" title="终止FIN"></a>终止FIN</h3><p>用来释放一个连接. 当FIN = 1 时, 表明此报文段的发送数据已发送完毕,并要求释放连接.</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占2字节.窗口指的是发送报文段一方的接收窗口.窗口值告诉对方:接收方目前允许对方发送的数据量.</p>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>检验和字段检验的范围包括首部和数据这两部分.</p>
<h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占2字节. 当URG = 1 时才有意义, 它指出本报文段中的紧急数据字节数.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP首部&quot;&gt;&lt;a href=&quot;#TCP首部&quot; class=&quot;headerlink&quot; title=&quot;TCP首部&quot;&gt;&lt;/a&gt;TCP首部&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>可靠传输的工作原理</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/09/29/可靠传输的工作原理/</id>
    <published>2017-09-29T15:39:05.762Z</published>
    <updated>2017-09-29T15:39:05.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>可靠运输的实现</li>
<li>停止等待协议</li>
<li>连续ARQ协议</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>TCP发送的报文段是交给IP层传送的, 但是IP层只能提供尽最大努力交付的服务,也就是说网络层提供的是不可靠的传输.因此,TCP必须采用适当的措施才能使得两个运输层之间的传输信道变得可靠.</p>
<blockquote>
<h3 id="可靠运输的实现"><a href="#可靠运输的实现" class="headerlink" title="可靠运输的实现"></a>可靠运输的实现</h3></blockquote>
<p>怎么样的运输才算是可靠运输? 要回答这个问题,可以从三方面入手:</p>
<ol>
<li>保证传输的分组无出错,也就是二进制比特流没有出现差错.</li>
<li>保证分组在传输的过程中没有丢失.</li>
<li>分组能够按序达到.</li>
</ol>
<p>既然知道了怎么样才能实现可靠运输,那么下面,我们来一步一步实现可靠运输原理.</p>
<h4 id="可靠运输1-0"><a href="#可靠运输1-0" class="headerlink" title="可靠运输1.0"></a>可靠运输1.0</h4><p>现在我们假设分组的传输是在一个可靠的信道上面传输的,也就是二进制比特流在这条通道上传输是不会出现比特流差错的.如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>但是,实际环境中,由于信道会受到声噪等因素影响,会使得传输的信道变得不可靠, 那么这时也就不能保证比特流的无差错.有没有什么办法能够解决这个问题?</p>
<h4 id="可靠运输2-0"><a href="#可靠运输2-0" class="headerlink" title="可靠运输2.0"></a>可靠运输2.0</h4><p>如何保证接收方接收到的比特流的无出错的? 关于这个问题,我们在可靠运输2.0版本中,通过使用一个比特流的检验和方法来检验接收方接收到的比特是否产生了差错.</p>
<p>我们引入了比特的差错检验来查看接收方收到的比特流的情况. 如果检验得比特流无差错,那么接收方可以直接接收.但是检验的结果是出现错误的话,那么这时接收方应该怎么做?</p>
<p>分析到这里, 我们需要引入另外的一种机制来解决这个问题. 这里我们引入确认机制,即接收方应该在接收到比特流后,应该向发送方确认,确认收到的比特流是否出现错误,可以使用ACK代表无差错,NACK代表有差错.</p>
<p>如果发送方接收到接收方发送的NACK,代表比特流出现了错误,那么发送方该怎么做?</p>
<p>这个时候,我们得引入重传机制, 也就是当发送方接收到NACK时,发送方应该重传分组.</p>
<p>整个过程如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/可靠运输2.0.png" alt=""></p>
<p>为了在不可靠的信道上实现比特无差错,我们引入了检验和,确认(ACK/NACK)和重传机制来保证.但是我们如何解决ACK或NACK出现错误?</p>
<h4 id="可靠运输2-1"><a href="#可靠运输2-1" class="headerlink" title="可靠运输2.1"></a>可靠运输2.1</h4><p>为了应对ACK/NACK被破坏的情况,我们可以在ACK/NACK增加检验和机制来保证ACK/NACK不出现差错.</p>
<p>我们在2.0中引入了重传机制.因此,有可能出现分组的重复.在2.1中,我们将每个分组进行编号,保证分组不会因为重传而出现重复.</p>
<h4 id="可靠运输2-2"><a href="#可靠运输2-2" class="headerlink" title="可靠运输2.2"></a>可靠运输2.2</h4><p>为了提高确认机制的效率,我们采用累计确认机制.</p>
<p>所谓的累计确认是这样的: 收到分组后,需要给发送方发送一个ACK来表示已经收到分组.在发送分组的同时,附加上该分组的编号,来表示小于该编号之前的分组都已经被成功接收了.</p>
<p>既然引入了累计确认机制,NACK也就显得有点多余,在2.2中,我们把NACK去掉.</p>
<h4 id="可靠传输3-0"><a href="#可靠传输3-0" class="headerlink" title="可靠传输3.0"></a>可靠传输3.0</h4><p>前面的2.0~2.2版本都是针对如何解决保证分组在传输的过程中不出错,在3.0中,我们来考虑如何保证传输的分组不丢失?</p>
<p>为了保证分组在传输的时候不丢失,我们可以为每个传输的分组设置一个定时器,如果在定时器期限到达之前,没有收到ACK的话,就认为分组在传输的过程中丢失了,于是我们就重传该分组.</p>
<p>现在,我们基本可以保证分组不丢失了.但是,我们仔细想一下,会发现传输的信道利用率很低,因为,每次发送完一个分组,都得等待收到接收方的ACK后才能发送另外一个分组.由此看来,信道大部分时间都是处于等待状态的.</p>
<h4 id="可靠运输3-1"><a href="#可靠运输3-1" class="headerlink" title="可靠运输3.1"></a>可靠运输3.1</h4><p>为了解决3.0中信道利用率低的问题.我们可以采用流水线机制.即:每次发送完一个分组不必等待接收方的ACK才发送下一个分组.也就是可以连续发送多个分组.</p>
<p>由于我们引入了连续发送分组的这种协议,我们不得不面临多一个问题:如何解决分组乱序到达的情况?</p>
<h4 id="可靠运输3-2"><a href="#可靠运输3-2" class="headerlink" title="可靠运输3.2"></a>可靠运输3.2</h4><p>我们可以使用回退N步或者选择重传这两种机制来解决分组乱序的问题.</p>
<p>回退N步,本文下面会讲到,这里不多说.<br>选择重传: 对于乱序到达的分组,选择重传机制会将它们缓存起来,等待失序的分组到达后再发送ACK.</p>
<blockquote>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3></blockquote>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>上图为最简单的无差错情况. A发送分组M1,发完就暂停发送,等待B确认.当B收到了M1就向A发送确认.A收到了M1的确认后,就再次发送M2分组.同样, 在收到B对M2的确认后, A再发送M3.</p>
<h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p><img src="/uploads/计网/运输层/TCP/出现差错.png" alt=""></p>
<p>上图为分组在传输的过程中出现差错的情况. B接收M1时检测出了差错, 就丢弃M1,其他什么都不做.也可能是M1在传输的过程中丢失了. 这两种情况下, B都不会发送任何信息. 可靠传输协议是这样设计: A只要超过一段时间仍然没有接收到确认, 就认为刚才发送的分组丢失了, 因此重传前面发送过的分组,这叫做超时重传.为了实现超时重传, 要在每发送完一个分组设置一个超时计时器. 如果在超时计时器到期之前收到了对方的确认, 就撤销计时器.</p>
<p>注意:</p>
<ol>
<li>A发送完一个分组后, 必须暂时保存已发送的分组的副本.只有在收到相应的确认后才能清除暂时保留的分组副本.</li>
<li>分组和确认分组都必须进行编号. 这样才能明确是哪一个发送出去的分组收到了确认, 而哪一个分组没收到确认.</li>
<li>超时计时器设置的重传时间应当比数据在分组传送的平均往返时间更长一些.</li>
</ol>
<h4 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h4><p><img src="/uploads/计网/运输层/TCP/确认丢失.png" alt=""></p>
<p>上图为B发送的确认分组丢失的情况. A在设定的超时重传时间内没有收到确认, 但无法知道是自己发送的分组出错,丢失,或者是B发送的确认丢失了. 此时A必须重传M1分组. 假定B收到了重传M1,此时应采取两个行动.</p>
<ol>
<li>丢弃这个重复的分组M1,不向上层交付.</li>
<li>向A发送确认.</li>
</ol>
<p><img src="/uploads/计网/运输层/TCP/确认迟到.png" alt=""></p>
<p>上图为确认迟到的情况. 传输过程没有出错, 但B对M1的确认迟到了. A会收到重复的确认. 这时, A只要收下后丢弃.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述的确认和重传机制, 可以在不可靠的传输网路上实现可靠的通信. 这种可靠传输协议称为自动重传请求ARQ(Automatic Repeat Request).ARQ协议的优点是简单, 但是缺点是信道利用率太低了.</p>
<blockquote>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3></blockquote>
<p>为了提高信道的利用率, 发送方可以采用流水线传输.流水线传输就是发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认.</p>
<p><img src="/uploads/计网/运输层/TCP/发送窗口.png" alt=""></p>
<p>上图为发送方维护的发送窗口, 它表示位于发送窗口内的3个分组都可以连续发送出去,而不需要对方等待. 这样信道利用率就提高了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口.png" alt=""></p>
<p>发送方每接收到一个确认,就把滑动窗口向前滑动一个分组的位置.接收方一般都是采取累计确认的方式.也就是说, 接收方不必对收到的分组逐个发送确认,而是在收到几个分组后,对按序到达的最后一个分组发送确认, 这就表示: 到这个分组为止的所有分组都已经正确收到.</p>
<p>累计确认的缺点是不能向发送方反映接收方已经正确接收的所有分组信息.例如,如果发送了5个分组,而中间的3个分组丢失了. 这时接收方只能前两个分组发出确认.发送方无法知道后面三个分组的下落, 只好把后面三个分组都再传一次, 这叫做回退N步(Go Back N).</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br>计算机网络-自顶向下</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;可靠传输的工作原理&quot;&gt;&lt;a href=&quot;#可靠传输的工作原理&quot; class=&quot;headerlink&quot; title=&quot;可靠传输的工作原理&quot;&gt;&lt;/a&gt;可靠传输的工作原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>路由器工作原理</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/09/29/路由器工作原理/</id>
    <published>2017-09-29T15:38:53.894Z</published>
    <updated>2017-09-29T15:38:53.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>输入端口</li>
<li>交换结构</li>
<li>输出端口</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>路由器是一种具有多个输入和输出端口的专用计算机,其任务是转发分组.路由器的转发分组是网络层的主要工作之一. 下面给出典型的路由器构成图:</p>
<p><img src="/uploads/计网/路由选择协议/路由器工作原理.png" alt=""></p>
<blockquote>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3></blockquote>
<p><img src="/uploads/计网/路由选择协议/输入端口.png" alt=""></p>
<ul>
<li>输入端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层.</li>
<li>路由器使用转发表来查找输出端口,使得到达的分组将能经过交换结构转发到输出端口.</li>
<li>转发表是由路由器处理和更新的,但转发表的一份影子副本通常会被存放在每个输入端口, 有了影子副本,转发决策能在每个输入端口本地做出,无须调用中央路由选择处理器, 因此也避免了集中式处理的瓶颈.</li>
</ul>
<blockquote>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3></blockquote>
<p>交换结构位于一台路由器的核心部位.正是通过这种交换结构,分组才能实际从一个输入端口交换到一个输出端口.交换可以由下面的三种交换技术完成.</p>
<p><img src="/uploads/计网/路由选择协议/内存交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/纵横式交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/总线交换结构.png" alt=""></p>
<h4 id="内存交换结构"><a href="#内存交换结构" class="headerlink" title="内存交换结构"></a>内存交换结构</h4><ul>
<li>在输入端口和输出之间交换是在CPU的直接控制下完成的.</li>
<li>一个分组到达一个输入端口时, 该端口会先通过中断方式向路由选择处理器发送信号.于是,该分组从输入端口处被复制到处理器内存中.路由器选择处理器从其首部提取目的地址,在转发表中找出合适的输出端口,并将该分组复制到输出端口的缓存中.需要注意的是:不能同时发送两个分组,即使他们有不同的端口,因为经过共享系统总线一次仅能执行一次内存读/写.</li>
</ul>
<h4 id="总线交换"><a href="#总线交换" class="headerlink" title="总线交换"></a>总线交换</h4><ul>
<li>输入端口经过一根共享总线将分组直接传送到输出端口,不需要路由选择处理器的干预.</li>
<li>当一个分组到达路由器时, 输入端口为分组预先计划一个交换机内部标签, 用于指示本地输出端口,是分组在总线上传送和传输到输出端口.该分组能由所有输出端口收到, 但只有与该标签匹配的端口才能保存该分组.</li>
<li>如果多个分组同时到达路由器,每个位于不同的输出端口,除了正在总线上传输的分组外,其他分组必须等待,因为一次只有一个分组能够跨越总线.</li>
</ul>
<h4 id="纵横式交换结构"><a href="#纵横式交换结构" class="headerlink" title="纵横式交换结构"></a>纵横式交换结构</h4><ul>
<li>纵横式交换机是一种由2N条总线组成的互联网络.网络互联使得它能克服单一,共享式总宽带限制的缺点.</li>
<li>当某个分组到达A端口时, 需要转发到端口Y,交换机控制器闭合总线A和Y交叉部位的叉点,然后端口A在其总线上发送该分组, 该分组仅由总线Y安排接收.注意:来自端口B的一个分组在同一时间能够转发到端口X,因为A到Y和B到X的分组使用不同的输入和输出总线.然而,如果来自不同端口的两个分组其目的地为相同的输出端口,那么其中一个分组必须等待, 因为在某个时刻,总线上仅有一个分组能被传送.</li>
</ul>
<blockquote>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3></blockquote>
<p>输出端口处理取出存放在输出端口内存中的分组并将其发送到输出链路上.这包括选择和取出排队的分组进行传输,执行所需的链路层和物理层传输功能.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络自顶向下<br>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由器工作原理&quot;&gt;&lt;a href=&quot;#路由器工作原理&quot; class=&quot;headerlink&quot; title=&quot;路由器工作原理&quot;&gt;&lt;/a&gt;路由器工作原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>路由选择协议</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
    <id>http://cristianoro7.github.io/2017/09/29/路由选择协议/</id>
    <published>2017-09-29T15:38:44.970Z</published>
    <updated>2017-09-29T15:38:44.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>内部网关协议RIP</li>
<li>内部网关协议OSPF</li>
<li>外部网关协议BGP</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>从路由算法能否随网络的通信或者拓扑自适应地进行调整变化来划分, 可将路由选择分为两大类:静态路由选择策略和动态路由选择策略.<ul>
<li>静态路由选择策略: 也叫做非自适应路由选择, 其特点是简单和开销较小, 但不能及时适应网络状态变化, 适用于小型网络.</li>
<li>动态路由选择协议: 也叫做自适应路由选择, 其特点是能较好地适应网络状态的变化, 但实现起来复杂, 开销也较大. 因此, 动态路由选择适合复杂的大型网络.</li>
</ul>
</li>
<li>因特网采用的路由选择协议主要是自适应的分布式路由选择协议.</li>
<li>因特网采用分层次的路由选择协议的两个原因:<ul>
<li>因特网的规模宏大. 如果让所有的路由器知道所有的网络应怎么样到达,则这种路由表非常大, 处理起来也花费很多时间.</li>
<li>许多单位不愿意让外界了解自己单位网络的布局细节和本部门所采用的路由选择协议,同时还希望能接上因特网.</li>
</ul>
</li>
<li>基于上面的两个原因, 因特网将整个互联网划分为许多较小的自治系统(autonomous system),一般称为AS.</li>
<li>一个AS对外表现出是一个单一的和一致的路由选择策略.</li>
<li>一个大的ISP就是一个自治系统, 因特网把路由选择协议分为两大类:<ul>
<li>内部网关协议IGP: 在一个自治系统内使用的路由选择协议,而这与互联网中的其他自治系统选用什么路由选择协议无关,目前用得最多的内部网关协议有:RIP, OSPF.</li>
<li>外部网关协议EGP: 若元源主机和目的主机处于两个不同的自治系统内, 当数据报传到一个自治系统的边界时, 就需要使用一种协议将路由选择信息传递到另外一个自治系统中. 目前使用得最多的外部网关协议: BGP</li>
</ul>
</li>
<li>自治系统之间的路由选择也叫做域间路由选择, 而在自治系统内的路由选择叫做域间内部选择.</li>
</ul>
<blockquote>
<h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3></blockquote>
<p>RIP是一种分布式,异步,收敛,迭代的基于距离向量的路由选择协议.</p>
<ol>
<li>分布: 每个节点将自己的路由表发给自己直接相邻的节点.</li>
<li>异步: 节点不需要在某个固定的时间同时发送和交换信息.</li>
<li>收敛: 在有限次的信息交换次数内, 不管初始值是多少, 路由表中的每一项一定会收敛成某个固定值, 也就是真正的最短路径.</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>从一个路由器到直接连接的网络距离定义为1.</li>
<li>从路由器到非直接连接的网络距离定义为所经过的路由器数+1,</li>
<li>RIP允许一条路径只能包含15个路由器,因此,当距离等于16时,相当于不可达.</li>
<li>RIP不能在两个网络之间同时使用多条路由, RIP只会选择一条具有最少路由器的路径.</li>
</ul>
<p>RIP协议下的路由器都需要不断和其他的路由器交换路由信息,那么,是和哪些路由器交换信息?交换什么信息?在什么时候交换信息?</p>
<h5 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点:"></a>RIP协议的特点:</h5><ul>
<li>仅和相邻路由器交换信息</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息,即自己的路由表.也就是,交换的信息是: 一个路由器到本自治系统内所有网络的最短距离,以及到每个网络应经过的下一个路由器.</li>
<li>按固定时间交换路由信息.路由表中的最主要信息:到某个网络的距离,以及经过的下一跳地址和下一跳路由的地址.</li>
</ul>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p>对每个相邻路由器发来的RIP报文, 将进行一下步骤:</p>
<ol>
<li>对地址为X的相邻路由器发送过来的RIP报文, 先修改此报文中的所有项目, 把下一跳字段中的地址改为X, 把所有距离都+1.每个项目都有三个关键数据:到目的网络N, 距离d, 下一跳路由器X.</li>
<li>对修改的RIP报文中的每一个项目,进行一下步骤:<br><br>若原来的路由表没有目的网络N, 则把该项目添加到路由表.<br><br>否则,若下一跳路由器地址为X, 则把收到项目替换掉原来路由表中的项目.否则什么也不做</li>
<li>若3分钟还没有收到相邻路由器的更新路由表,则把此相邻路由器记录为不可到达网络,即把距离设置为16.</li>
<li>返回.</li>
</ol>
<h5 id="“坏消息传得慢”"><a href="#“坏消息传得慢”" class="headerlink" title="“坏消息传得慢”"></a>“坏消息传得慢”</h5><p>RIP存在一个缺点是当网络发生故障时, 要经过比较长的时间才能将信息传送到所有的路由器.例如:</p>
<p><img src="/uploads/计网/路由选择协议/RIP缺点.png" alt=""></p>
<p>假定路由器1到网1的链路出了故障, R1无法到达网1. 于是路由器R1把到网1的距离设置为16, 因而在R1的路由表中相应的项目变为”1, 16, 直接”. 但是很可能要经过30秒后才能把更新信息发给R2.然而R2可能已经先把自己的路由信息”1, 2, R1”发给R1, R1收到这个报文后,误认为可以通过R2到达网1, 于是更新”1, 2, R1”修改为”1, 3, R2”,并发给R2.同理,R2接着又更新自己的路由表信息为”1, 4, R1”.这样的更新一直持续到R1,R2到网1的距离都增大到16,R1, R2才知道网1原来不可达.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>RIP最大的优点是实现简单,开销小.</li>
<li>RIP只能使用的最大距离为15, 这样限制了网络的规模.</li>
<li>路由器之间的路由交换信息是路由器中完整的路由表,因而随着网络规模的扩大, 开销也就增加.</li>
<li>坏消息传播得慢,使得更新过程的收敛时间过长.</li>
<li>对于较大规模的网络应该换用OSPF协议.</li>
</ul>
<blockquote>
<h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3></blockquote>
<p>OSPF最主要的特征是使用了分布式的链路状态协议.</p>
<h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><h5 id="向本自治系统中的所有路由器发送信息"><a href="#向本自治系统中的所有路由器发送信息" class="headerlink" title="向本自治系统中的所有路由器发送信息"></a>向本自治系统中的所有路由器发送信息</h5><p>路由器通过所有输出端口向所有相邻路由器发送信息,也就是端口洪泛.而每个相邻路由器又再将此信息发往其所有的相邻路由器.这样整个区域中所有路由器都得到了这个信息的一个副本.</p>
<h5 id="发送的信息"><a href="#发送的信息" class="headerlink" title="发送的信息"></a>发送的信息</h5><p>发送的信息是与本路由器相邻的所有路由器的链路状态.所谓”链路状态”是本路由器都和哪些路由器相邻,以及该链路的度量.</p>
<h5 id="何时发送信息"><a href="#何时发送信息" class="headerlink" title="何时发送信息"></a>何时发送信息</h5><p>只有当链路状态发生改变时,路由器才向所有路由器洪泛此信息.</p>
<h5 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h5><p>由于各个路由器之间频繁进行链路状态交换,因此所有路由器最终都能建立一个链路状态数据库.这个数据库实际上就是全网的拓扑结构.链路状态数据库能较快地进行更新,使各个路由器能及时更新路由表.</p>
<h5 id="链路状态更新"><a href="#链路状态更新" class="headerlink" title="链路状态更新"></a>链路状态更新</h5><p>只有当链路状态发生变化时, 路由器才向所有路由器用洪泛法发送此消息.</p>
<h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><p>OFPS将一个自治系统再划分为几个更小的范围,叫作区域.划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是一个完整的自治系统.</p>
<blockquote>
<h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3></blockquote>
<p>不同自治系统之间的路由选择不使用RIP或者OSPF的原因:</p>
<ol>
<li>因特网的规模太大,使得AS之间的路由变得非常困难.如果使用链路状态协议, 则每个路由器需要维持一个很大的链路状态数据库.另外,不同的自治系统各自运行着自己选定的内部路由选择协议, 并使用本AS指明的路径度量.因此当一条路径通过不同的自治系统时,路径的度量可能会出歧义.例如:对某AS来说, 代价为1000可能表示一条比较长的路由, 但对另外一AS代价为1000, 可能表示不可接受的坏路由.</li>
<li>AS之间的路由选择必须考虑策略. 由于相连的网络性能相差很大, 如果根据最少跳数找出来的路径, 可能并不合适.也有的代价啊很高或不安全.</li>
</ol>
<p>基于上述的情况, 边界网关协议BGP只能力求寻找一条能够到达目的网络比较好的路由,而非寻找一条最佳路由.BGP采用了路径向量路由选择协议.</p>
<h4 id="BGP发言人"><a href="#BGP发言人" class="headerlink" title="BGP发言人"></a>BGP发言人</h4><ul>
<li><p>在配置BGP时, 每个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人.一般来说,这两个BGP发言人都是通过一个网络共享连接在一起的,而BGP发言人往往是边界路由器.</p>
</li>
<li><p>一个BGP发言人与其他AS的BGP发言人要交换路由信息,就要先建立TCP连接,然后在此连接上交换BGP报文以建立BGP会话,利用BGP会话交换路由信息,如增加了新的路由,或者撤销过时的路由,以及报告差错等.使用TCP连接交换路由信息的两个BGP发言人,彼此成为对方的邻站或对等站.</p>
</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由选择协议&quot;&gt;&lt;a href=&quot;#路由选择协议&quot; class=&quot;headerlink&quot; title=&quot;路由选择协议&quot;&gt;&lt;/a&gt;路由选择协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网际控制报文协议ICMP</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP/"/>
    <id>http://cristianoro7.github.io/2017/09/29/网际控制报文协议ICMP/</id>
    <published>2017-09-29T15:38:21.034Z</published>
    <updated>2017-09-29T15:38:21.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>ICMP报文种类</li>
<li>ICMP应用举例</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>为了更有效地转发IP数据报和提高交付成功的机会, 在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol). ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告.ICMP报文作为IP层的数据报的数据.</p>
<blockquote>
<h3 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h3></blockquote>
<ul>
<li>网际报文的种类有两种, 即ICMP差错报告报文和ICMP询问报文.</li>
<li>几种常用的ICMP报文类型</li>
</ul>
<table>
<thead>
<tr>
<th>ICMP报文类型</th>
<th>类型的值</th>
<th>ICMP报文的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>差错报告报文</td>
<td>3</td>
<td>终点不可达</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>4</td>
<td>源点抑制</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>11</td>
<td>时间超过</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>12</td>
<td>参数问题</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>5</td>
<td>改变路由</td>
</tr>
<tr>
<td>询问报文</td>
<td>8或0</td>
<td>回送请求或回答</td>
</tr>
<tr>
<td>询问报文</td>
<td>13或14</td>
<td>时间戳请求或回答</td>
</tr>
</tbody>
</table>
<h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p>当路由器或者主机不能交付数据报时就向源点发送终点不可达报文</p>
<h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p>当路由器或者主机因拥塞而丢弃数据报时, 就向源点发送源点抑制报文, 使源点知道应当把数据报的发送速率放慢.</p>
<h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p>当路由器收到生存时间为0的数据报时, 除了丢弃数据报外, 还要向源点发送时间超过报文.</p>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p>当路由器或者目的主机收到的数据报的首部中有的字段的值不正确时, 就丢弃该数据报,并向源点发送参数问题报文.</p>
<h4 id="改变路由-路由重定向"><a href="#改变路由-路由重定向" class="headerlink" title="改变路由(路由重定向)"></a>改变路由(路由重定向)</h4><p>路由器把改变路由报文发送给主机, 让主机知道下次应该将数据报发送给另外的路由器.</p>
<h4 id="回送请求和回答"><a href="#回送请求和回答" class="headerlink" title="回送请求和回答"></a>回送请求和回答</h4><p>ICMP回送请求报文是由主机或者路由器向一个特定的目的主机发送询问. 收到此报文的主机必须给源主机或者路由发送ICMP回送回答报文.</p>
<h4 id="时间戳请求和回答"><a href="#时间戳请求和回答" class="headerlink" title="时间戳请求和回答"></a>时间戳请求和回答</h4><p>ICMP时间戳请求报文是请某个主机或者路由器回答当前的日期和时间.</p>
<blockquote>
<h3 id="ICMP的应用举例"><a href="#ICMP的应用举例" class="headerlink" title="ICMP的应用举例"></a>ICMP的应用举例</h3></blockquote>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><ul>
<li>ICMP一个重要应用就是分组网间探测PING, 用来测试两个主机之间的连通性.</li>
<li>PING使用了ICMP的回送请求和回送回答报文.</li>
<li>PING是应用层直接使用网络层ICMP的例子, 它没有通过运输层的TCP或UDP.</li>
</ul>
<h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><ul>
<li>traceroute是用来跟踪一个分组从源点到终点的路径.</li>
<li>traceroute从源主机向目的主机发送一连串IP数据报, 数据报中封装的是无法交付的UDP用户数据报.第一个数据报P1的生存时间为TTL设置为1.当P1到达路径上的第一个路由器R1时, 路由器R1先收下它, 接着把TTL的值减1.由于TTL等于0了, R1就把P1丢弃了, 并向源主机发送一个ICMP时间超过的差错报告报文.</li>
<li>如此循环下去, 当最后一个数据报刚刚达到目的主机时, 数据报的TTL是1, 主机不转发数据, 也不把TTL减1.但因IP数据报封装的是无法交付的运输层UDP用户数据报, 因此目的主机要向源主机发送ICMP终点不可达差错报告报文.</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网际控制报文协议ICMP&quot;&gt;&lt;a href=&quot;#网际控制报文协议ICMP&quot; class=&quot;headerlink&quot; title=&quot;网际控制报文协议ICMP&quot;&gt;&lt;/a&gt;网际控制报文协议ICMP&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>子网的划分和构成超网</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/"/>
    <id>http://cristianoro7.github.io/2017/09/29/子网的划分和构造超网/</id>
    <published>2017-09-29T15:38:05.846Z</published>
    <updated>2017-09-29T15:38:05.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子网的划分和构成超网"><a href="#子网的划分和构成超网" class="headerlink" title="子网的划分和构成超网"></a>子网的划分和构成超网</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>划分子网</li>
<li>使用子网时的分组转发</li>
<li>无分类编址CIDR</li>
</ul>
<blockquote>
<h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2></blockquote>
<h3 id="两级IP地址的不合理"><a href="#两级IP地址的不合理" class="headerlink" title="两级IP地址的不合理"></a>两级IP地址的不合理</h3><h4 id="IP空间利用率低"><a href="#IP空间利用率低" class="headerlink" title="IP空间利用率低"></a>IP空间利用率低</h4><p>一个A类网路可容纳的主机数超过1000W, 而B类网络可容纳主机超过6W.但是有些网络对连接在网络上的主机数量是有限制的, 这就导致了地址空间的利用率低下.</p>
<h4 id="路由表变大导致网络性能低下"><a href="#路由表变大导致网络性能低下" class="headerlink" title="路由表变大导致网络性能低下"></a>路由表变大导致网络性能低下</h4><p>给每个物理网络分配一个网络号的话, 会导致路由表中的项目大大增大, 同时查找路由的耗时也就变得更长.</p>
<p>为了解决二级IP带来的问题,从1985年起,将IP地址中增加了一个”子网号字段”, 使得二级IP地址变成三级IP地址.这种做法叫做划分子网.</p>
<blockquote>
<h3 id="划分子网的基本思路"><a href="#划分子网的基本思路" class="headerlink" title="划分子网的基本思路"></a>划分子网的基本思路</h3></blockquote>
<ul>
<li>一个拥有许多物理地址的单位, 可将所属的物理网络划分为多个子网.划分子网属于单位内部的事情,对外还是表现为一个网络.</li>
<li>划分子网的方法是从网路的主机号借用若干位作为子网号,于是二级IP地址在单位内部就变成了三级IP地址,即 network-id:subnet-id-host-id</li>
</ul>
<blockquote>
<h3 id="子网划分实例"><a href="#子网划分实例" class="headerlink" title="子网划分实例"></a>子网划分实例</h3></blockquote>
<p><img src="/uploads/计网/划分子网/子网.png" alt=""></p>
<p>上图的网络被划分为三个子网, 整个网络对外表现为一个网络, 其网络地址为145.13.0.0.但是网络145.13.0.0上的路由器R1在收到外来的数据报后, 再根据数据报的目的地址将它转发到对应的子网.</p>
<blockquote>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3></blockquote>
<p>我们知道, 从IP数据报的首部无法看出源主机或目的主机是否进行了子网的划分,路由器是如何将数据报转发到子网?使用子网掩码可以解决这个问题.</p>
<h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><ul>
<li>子网掩码是一个32位2进制数, 对应的网络地址全为1,主机地址全为0.</li>
<li>A类网络的默认子网掩码为:255.0.0.0, B类为255.255.0.0, C类为255.255.255.0</li>
</ul>
<h4 id="通过目的IP地址和子网掩码计算子网的网络地址"><a href="#通过目的IP地址和子网掩码计算子网的网络地址" class="headerlink" title="通过目的IP地址和子网掩码计算子网的网络地址"></a>通过目的IP地址和子网掩码计算子网的网络地址</h4><ul>
<li>将数据报的目的IP地址与子网掩码逐位相”与”.</li>
</ul>
<p>例如: IP地址为141.14.72.24, 子网掩码为255.255.192.0,求网络地址<br>解析: 子网掩码为11111111 11111111 11000000 00000000, 由于子网掩码的前两个字节的位全为1, 最后一个字节的位全为0,因此, 可暂时推断网络地址为: 141.14.X.0. 此时, 只需要将72对应的二进制数与11000000逐位相”与”,就可得出完整的网络地址: 141.14.64.0.</p>
<h4 id="利用子网数来计算子网掩码"><a href="#利用子网数来计算子网掩码" class="headerlink" title="利用子网数来计算子网掩码"></a>利用子网数来计算子网掩码</h4><p>在求子网掩码时, 必须弄清楚划分子网的数目,以及每个子网内所需的主机数目.<br><br><br>1)将子数目转为二进制<br><br>2)取得二进制的位数N<br><br>3)取得该IP地址的类子网掩码, 将其主机号的前N位置1,即可得该IP地址划分子网的子网掩码<br></p>
<p>eg: 将B类IP地址168.192.0.0划分为27个子网.<br><br>1) 27 = 11011<br><br>2) N = 5<br><br>3) B类子网掩码: 255.255.0.0<br><br>4) 该IP地址划分的子网掩码: 255.255.248.0.</p>
<h4 id="子网的划分选择"><a href="#子网的划分选择" class="headerlink" title="子网的划分选择"></a>子网的划分选择</h4><p>下面给出B类子网的划分选择(使用固定的长度子网)</p>
<table>
<thead>
<tr>
<th>子网号位数</th>
<th>子网掩码</th>
<th>子网数</th>
<th>每个子网的主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>255.255.192.0</td>
<td>2^2-2</td>
<td>2^14-2</td>
</tr>
<tr>
<td>3</td>
<td>255.255.224.0</td>
<td>2^3-2</td>
<td>2^13-2</td>
</tr>
<tr>
<td>4</td>
<td>255.255.240.0</td>
<td>2^4-2</td>
<td>2^12 -2</td>
</tr>
<tr>
<td>5</td>
<td>255.255.248.0</td>
<td>2^5-2</td>
<td>2^11-2</td>
</tr>
<tr>
<td>6</td>
<td>255.255.252.0</td>
<td>2^6-2</td>
<td>2^10-2</td>
</tr>
<tr>
<td>7</td>
<td>255.255.254.0</td>
<td>2^7-2</td>
<td>2^9-2</td>
</tr>
<tr>
<td>8</td>
<td>255.255.255.0</td>
<td>2^8-2</td>
<td>2^8-2</td>
</tr>
<tr>
<td>9</td>
<td>255.255.255.128</td>
<td>2^9-2</td>
<td>2^7-2</td>
</tr>
<tr>
<td>10</td>
<td>255.255.248.192</td>
<td>2^10-2</td>
<td>2^6-2</td>
</tr>
<tr>
<td>11</td>
<td>255.255.252.224</td>
<td>2^11-2</td>
<td>2^5-2</td>
</tr>
<tr>
<td>12</td>
<td>255.255.254.240</td>
<td>2^12-2</td>
<td>2^4-2</td>
</tr>
<tr>
<td>13</td>
<td>255.255.255.248</td>
<td>2^13-2</td>
<td>2^3-2</td>
</tr>
<tr>
<td>14</td>
<td>255.255.255.252</td>
<td>2^14-2</td>
<td>2^2-2</td>
</tr>
</tbody>
</table>
<p><br><br>上面-2是因为去掉全0和全1的情况, 子网号位数没有0,1,15,16这四种情况是因为这几种情况没有意义.</p>
<blockquote>
<h3 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h3></blockquote>
<p>使用子网划分后, 路由表必须包含这三项内容:目的网络地址,子网掩码和下一跳地址.</p>
<h4 id="路由转发算法"><a href="#路由转发算法" class="headerlink" title="路由转发算法"></a>路由转发算法</h4><ol>
<li>从收到的数据报的首部提取目的IP地址D.</li>
<li>先判断是否可以直接交付. 对路由器相连的网络逐个检查:用各个网络的子网掩码与D逐位相”与”, 看结果是否和相应的网络地址匹配.若匹配,则把分组直接交付, 否则执行(3).</li>
<li>若路由器表中有目的地址为D的特定主机路由, 则把数据报传送给下一跳的路由器,否则执行(4)</li>
<li>对路由表中的每一行,用其中的子网掩码和D逐位相”与”,若结果与目的网络地址匹配,把数据报传送下一跳的路由器, 否则执行(5).</li>
<li>若路由表中有一个默认的路由, 则把数据报传给默认路由, 否则执行(6)</li>
<li>报告转发分组时出错.</li>
</ol>
<h4 id="转发实例"><a href="#转发实例" class="headerlink" title="转发实例"></a>转发实例</h4><p><img src="/uploads/计网/划分子网/子网转发分组.png" alt=""></p>
<p>讨论R1收到H1向H2发送分组后,查找路由表的过程</p>
<ol>
<li>H1把本子网的子网掩码 255.255.255.128 与目的主机的ip地址逐位相”与”, 得出 128.30.33.128,它不等于H1的网络地址,说明H1与H2不在同一个子网内, 因此H1不能把分组直接交付给H2,必须交给子网上的默认路由器R1,由R1来进行转发</li>
<li>R1收到一个分组后, 就在路由表中寻找有无匹配的网络地址.(1)计算出目的网络地址为128.30.33.128, 与路由表中的第二行的目的网络地址匹配, 说明这个网络就是分组想要寻找的目的网络, 于是R1将分组从接口1,直接交付给主机H2.</li>
</ol>
<blockquote>
<h2 id="无分类编址CIDR-构成超网"><a href="#无分类编址CIDR-构成超网" class="headerlink" title="无分类编址CIDR(构成超网)"></a>无分类编址CIDR(构成超网)</h2></blockquote>
<p>无分类域间路由选择CIDR解决的问题:</p>
<ol>
<li>B类地址眼看就快要分配完了</li>
<li>因特网主干网上的路由表项目数急剧增长.</li>
</ol>
<blockquote>
<h3 id="CIDR的两个主要的特点"><a href="#CIDR的两个主要的特点" class="headerlink" title="CIDR的两个主要的特点"></a>CIDR的两个主要的特点</h3></blockquote>
<ul>
<li>CIDR消除了传统的A类,B类,C类地址以及子网的划分的概念,把32位的IP地址划分了两个部分.前一部分用来表示网络前缀,以表示网络. 后一部分则用来表主机.</li>
<li>CIDR把网络前缀相同的连续IP地址组成一块”CIDR地址块”.</li>
</ul>
<blockquote>
<h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3></blockquote>
<ul>
<li><strong>由于一个CIDR地址块中有很多地址,所以在路由表中就利用CIDR地址块来查找目的网络. 这种地址的聚合称为路由聚合.</strong></li>
<li>它使得一个路由表可以表示更多地址. 路由聚合也称为构成子网.</li>
</ul>
<blockquote>
<h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3></blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在使用CIDR时, 由于采用了网络前缀这种记法, 因此在路由表中的项目也要有相应的改变.在查找路由表时, 可能会得到不止一个匹配结果, 那么我们应该选择哪条结果?</p>
<h4 id="最长匹配"><a href="#最长匹配" class="headerlink" title="最长匹配"></a>最长匹配</h4><p>为了解决上述问题, 应该从匹配结果中选择具有最长网络前缀的路由, 这叫做最长前缀匹配.</p>
<h4 id="使用二叉线索查找路由表"><a href="#使用二叉线索查找路由表" class="headerlink" title="使用二叉线索查找路由表"></a>使用二叉线索查找路由表</h4><p>使用CIDR后, 由于要查找最长前缀匹配, 使路由表的查找过程变得更加复杂.为了更有效的查找, 通常是把无分类编址的路由表存放在一种层次的数据结构中, 然后,自上而下进行查找.这里最常用的是二叉线索.为了提高二叉线索的查找速度,可以使用压缩技术.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.360doc.com/content/10/0205/11/276520_15184122.shtml" target="_blank" rel="external">http://www.360doc.com/content/10/0205/11/276520_15184122.shtml</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;子网的划分和构成超网&quot;&gt;&lt;a href=&quot;#子网的划分和构成超网&quot; class=&quot;headerlink&quot; title=&quot;子网的划分和构成超网&quot;&gt;&lt;/a&gt;子网的划分和构成超网&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; cl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>IP地址分类</title>
    <link href="http://cristianoro7.github.io/2017/09/29/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/"/>
    <id>http://cristianoro7.github.io/2017/09/29/IP地址分类/</id>
    <published>2017-09-29T15:37:59.234Z</published>
    <updated>2017-09-29T15:37:59.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分类</li>
<li>特殊IP地址</li>
<li>共有IP地址</li>
<li>私有IP地址</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>IP地址是连接在因特网上的主机的唯一标识, 通过特定的IP地址能找到被该IP地址标识的主机.例如:我们的家地址可以看作一个IP地址, 通过这个地址,可以找到我们,也就是主机.</li>
<li>在TCP/IP协议中, IP地址是以二进制数字形式出现, 共32Bit, 1Bit就是二进制中的1位, 由于二进制的形式不适合人们阅读.因此换用一种”点分十进制法”表示IP地址.</li>
<li>例如:<br><br>点分十进制: 192.168.1.1<br><br>二进制: 11000000.10101000.00000001.00000001</li>
</ul>
<blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></blockquote>
<table>
<thead>
<tr>
<th></th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class A</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class B</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class C</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
</tr>
<tr>
<td>Class D</td>
<td>多播</td>
</tr>
<tr>
<td>Class E</td>
<td>科研用</td>
</tr>
</tbody>
</table>
<h4 id="Class-A"><a href="#Class-A" class="headerlink" title="Class A"></a>Class A</h4><ul>
<li>A类地址的第一个8 Bit 表示网络位, 且<code>网络位的第一个Bit为0</code>, 1-7Bit表示网络标识,格式为:0XXXXXXXX.</li>
<li>后3个8 Bit 表示主机位.</li>
<li>A类地址的网络范围:00000001~01111111, 用十进制表示: 1.0.0.0到126.0.0.0,一共有126个网络.</li>
<li>主机标识为2的24次幂-2个(去掉全0和全1的地址), 全0的主机号字段表示该IP地址是”本机”连接到的单个网络地址,而1的主机号表示该网络上的所有主机.每个网络可容纳的主机数为16777214个.</li>
<li>A类地址支持巨型网络,一般分给有大量主机的网络使用.</li>
</ul>
<h4 id="Class-B"><a href="#Class-B" class="headerlink" title="Class B"></a>Class B</h4><ul>
<li>B类地址的前两个8 Bit表示网络标位, 且网络位的前两个Bit总是10, 即格式为: 10XXXXXX XXXXXXXX.</li>
<li>B类地址可指派的网络数为: 2的14次幂-1, -1的原因是128.0.0.0是不指派的.</li>
<li>后两个8 Bit表示主机位.</li>
<li>B类的每个网络可容纳的主机数是2的16次幂-2, 即65534.</li>
</ul>
<h4 id="Class-C"><a href="#Class-C" class="headerlink" title="Class C"></a>Class C</h4><ul>
<li>C类地址的前3个字节表示网路号, 且开头必须为<code>110</code>, 可以指派的最小网络地址为:192.0.1.0, 指派的网络范围为2的21次幂-1, -1的原因是192.0.0.0是不指派的.</li>
<li>每个C类地址可容纳的主机数为:2的8次幂-2.</li>
</ul>
<blockquote>
<h3 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h3></blockquote>
<h4 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h4><ul>
<li>它表示所有不清楚的主机和目的网络.</li>
<li>不清楚的是意思是本机路由表中没有指定如何到达.</li>
<li>如果在网络设置中设置了缺省网关, 那么系统会自动生成一个目的地址为0.0.0.0的缺省路由,所有不清楚的目的网络和主机都会被送到这里.</li>
</ul>
<h4 id="255-255-255-255"><a href="#255-255-255-255" class="headerlink" title="255.255.255.255"></a>255.255.255.255</h4><ul>
<li>对本机来说, 这个地址指本网段内的所有主机. 这个地址不能被路由器所转发.</li>
</ul>
<h4 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h4><ul>
<li>A类网络中的127是一个保留地址, 用于网络软件测试和本机进程间的通信.</li>
<li>无论什么程序, 只要发送了该地址的数据, 就会被立刻发送回本机.</li>
<li>127网络号的分组不能出现在网络传输上.</li>
</ul>
<h4 id="局域网内的IP"><a href="#局域网内的IP" class="headerlink" title="局域网内的IP"></a>局域网内的IP</h4><ul>
<li>当主机号的全为0时,表示一个网络本身.</li>
<li>当主机号全为1时, 表示网络中的全部主机.</li>
<li>网络号代表一个网络本身, 同时也是一个网段的第一个地址. 广播地址是网段的最后一个地址,这两个地址是不能配在主机上的.</li>
</ul>
<blockquote>
<h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3></blockquote>
<ul>
<li>属于非注册地址, 专门为组织机构(学校,企业)内部使用, 简单来说私有地址不能直接上网.</li>
<li>私有IP的范围:<ul>
<li>A类私有IP地址: 10.0.0.0~10.255.255.255</li>
<li>B类私有IP地址: 172.16.0.0~172.31.255.255</li>
<li>C类私有地址: 192.168.0.0~192.168.255.255</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="公有IP"><a href="#公有IP" class="headerlink" title="公有IP"></a>公有IP</h3></blockquote>
<ul>
<li>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Internet NIC提出申请的组织机构。通过它直接访问因特网，它是广域网范围内的。</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45337405" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45337405</a></li>
<li><a href="http://blog.csdn.net/txx9010/article/details/7712438" target="_blank" rel="external">http://blog.csdn.net/txx9010/article/details/7712438</a></li>
<li><a href="https://www.zhihu.com/question/27714563" target="_blank" rel="external">https://www.zhihu.com/question/27714563</a></li>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45226275" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45226275</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP地址分类&quot;&gt;&lt;a href=&quot;#IP地址分类&quot; class=&quot;headerlink&quot; title=&quot;IP地址分类&quot;&gt;&lt;/a&gt;IP地址分类&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>重拾Dagger2-组织</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E7%BB%84%E7%BB%87/"/>
    <id>http://cristianoro7.github.io/2017/09/29/重拾Dagger2-组织/</id>
    <published>2017-09-29T15:35:58.510Z</published>
    <updated>2017-09-29T15:35:58.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在<a href="https://cristianoro7.github.io/2017/03/30/%E9%87%8D%E6%8B%BEDagger2-%E7%90%86%E8%A7%A3Dagger2/">上一篇</a>中, 我们从源码的角度分析了Dagger的工作原理, 在这一篇中, 我们来重点讲解Dagger2依赖组织的方式, 在讲解之前, 我们先来理解Component dependencies和SubComponent</p>
<h3 id="Component-dependencies-VS-SubComponent"><a href="#Component-dependencies-VS-SubComponent" class="headerlink" title="Component dependencies VS SubComponent"></a>Component dependencies VS SubComponent</h3><p>为了提高一个Component中代码的复用度, 我们可以利用 Component dependencies 和 SubComponent来获取Component中的依赖, 那么这两种方式有什么区别?</p>
<h4 id="Component-dependencies"><a href="#Component-dependencies" class="headerlink" title="Component dependencies"></a>Component dependencies</h4><p>我们还是用前两篇中的Demo来讲解, 首先我们定义一个AppComponent和AppModule, 并且在AppModule提供一个Student的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;AppModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Application <span class="title">providesApp</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Application application;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppModule</span><span class="params">(Application application)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.application = application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Application <span class="title">providesApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们有另外一个StudentComponent和StudentModule, 其中StudentModule需要Student实例, 由于我们在AppModule已经提供了Student实例, 我们可以在StudentComponent中定义dependencies, 这样就可以实现复用Student实例了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PerActivity</span></div><div class="line"><span class="meta">@Component</span>(dependencies = AppComponent.class, modules = StudentModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@PerActivity</span></div><div class="line">    <span class="function">Data <span class="title">providesData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是Component dependencies的使用</p>
<h4 id="SubComponent"><a href="#SubComponent" class="headerlink" title="SubComponent"></a>SubComponent</h4><p>SubComponent也可以实现Component的代码复用, 我们具体来看看怎么使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;AppModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">StudentComponent <span class="title">getComponent</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function">Application <span class="title">providesApp</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//    Student providesSyudent();</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PerActivity</span></div><div class="line"><span class="meta">@Subcomponent</span>(modules = StudentModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别?"></a>两者区别?</h4><p>既然两者都可以实现Component代码的复用, 那么他们的区别的是什么?</p>
<ul>
<li>Component dependencies方式的代码复用, 父Component必须显式暴露依赖给 dependencies的Component, 如上面的AppComponent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Student <span class="title">providesStudent</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>显式暴露了Student依赖给dependencies的Component, 而对于SubComponent不用显式暴露, 直接在父Component定义一个返回SubComponent的方法, 并在对应的类标注SubComponent注解</p>
<ul>
<li>从设计的角度来看, SubComponent是为了让两个Component更具有内聚性. 而Component dependencies则是让两个Component彼此独立</li>
</ul>
<h3 id="源码读解"><a href="#源码读解" class="headerlink" title="源码读解"></a>源码读解</h3><p>为什么 Component dependencies方式必须要显式暴露? 且听我道来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">providesApp</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> providesApplicationProvider.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">providesSyudent</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> providesStudentProvider.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面两个方法是AppComponent具体实现类的重写的两个方法, 在AppComponent暴露方法的主要目的是在对应的实现类提供依赖, 而在依赖于AppComponent的StudentComponent中,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Student&gt; providesSyudentProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Provider&lt;Data&gt; providesDataProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesSyudentProvider =</div><div class="line">        <span class="keyword">new</span> dagger.internal.Factory&lt;Student&gt;() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> AppComponent appComponent = builder.appComponent;</div><div class="line"></div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">                appComponent.providesSyudent(),</div><div class="line">                <span class="string">"Cannot return null from a non-@Nullable component method"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesDataProvider =</div><div class="line">        DoubleCheck.provider(StudentModule_ProvidesDataFactory.create(builder.studentModule));</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(providesSyudentProvider, providesDataProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> StudentModule studentModule;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AppComponent appComponent;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (studentModule == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (appComponent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(AppComponent.class.getCanonicalName() + <span class="string">" must be set"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">studentModule</span><span class="params">(StudentModule studentModule)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.studentModule = Preconditions.checkNotNull(studentModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">appComponent</span><span class="params">(AppComponent appComponent)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.appComponent = Preconditions.checkNotNull(appComponent);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看看内部类Builder中, 有AppComponent成员变量, 因为我们依赖了AppComponent, 所以在创建StudentComponent的实例时, Builder强制要求我们调用 appComponent(AppComponent)方法时把StudentComponent依赖的AppComponent实例传递进来, 接下来, Student实例会通过传递进来的appComponent实例, 进行赋值</p>
<p>我们来看看SubComponent为什么不用显式暴露</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComponentImpl</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StudentModule studentModule;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Provider&lt;Data&gt; providesDataProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StudentComponentImpl</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">    initialize();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesDataProvider =</div><div class="line">        DoubleCheck.provider(StudentModule_ProvidesDataFactory.create(studentModule));</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(</div><div class="line">            DaggerAppComponent.<span class="keyword">this</span>.providesStudentProvider, providesDataProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的StudentComponentImpl是StudentComponent具体实现类, 它是AppComponent实现类的内部类, 这样要实现复用就不用显式暴露接口了, 利用内部类的特性直接访问</p>
<p>经过我们上面分析, 我们也可以回答设计的区别了,  因为SubComponent对应的实现类会作为父Component的内部类, 这样两个Component的内聚性也就增强了, 而dependencies则会生成两个对应的分开的两个类, 通过暴露接口和传递实例进行沟通, 从而达到两个Component独立分离的目的</p>
<h3 id="两者的使用场景"><a href="#两者的使用场景" class="headerlink" title="两者的使用场景"></a>两者的使用场景</h3><ul>
<li>如果你想让两个Component的内聚性更强, 你应该用SubComponent</li>
<li>如果你想让两个Component彼此独立分离, 你应该用dependencies</li>
</ul>
<h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><h4 id="利用Singleton标注AppComponent"><a href="#利用Singleton标注AppComponent" class="headerlink" title="利用Singleton标注AppComponent"></a>利用Singleton标注AppComponent</h4><p>Singleton实现单例必须保证Component只会被初始化一次, 那么我们可以把需要定义成单例的类都定义在AppModule, 并且在AppComponent暴露对应单例给依赖的Component, 并在Application初始化AppComponent, 这样就保证了AppComponent只初始化一次</p>
<h4 id="自定义Scope标注Activity"><a href="#自定义Scope标注Activity" class="headerlink" title="自定义Scope标注Activity"></a>自定义Scope标注Activity</h4><p>为了更好的组织项目结构, 我们可以定义PerAc(名字随意)注解, 标注基类ActivityComponent并且依赖与AppComponent, 接下来, 每个Activity可以定义对应的XXActivityComponent, 都让每个XXXActivity继承基类ActivityComponent, 并且依赖于AppComponent</p>
<h4 id="SubComponent-1"><a href="#SubComponent-1" class="headerlink" title="SubComponent"></a>SubComponent</h4><p>我们的Activity可以能会有Fragment, 那Fragment对应的Component是要依赖于AppComponent还是做为对应ActivityComponent的SubComponent?<br>由于Fragment是包含在Activity中的, 更好的做法是将FragmentComponent作为对应的ActivtyComponent的SubComponent</p>
<h3 id="告别Dagger2"><a href="#告别Dagger2" class="headerlink" title="告别Dagger2"></a>告别Dagger2</h3><p>写了三篇Dagger2的文章, 总算对Dagger2了解多了, 现在用得了很踏实.  所以该暂时告别Dagger2的学习了, 不过, 最后我还准备了一个Dagger2的使用的Demo, 这个Demo准备用MVP + Dagger2 + RxJava实现一个知乎日报, 嘻嘻, 如果你喜欢的话, 手抖给个star咯,</p>
<p>Demo在项目地址的RxJava+MVP+Dagger2分支中</p>
<p><a href="https://github.com/cristianoro7/Daily/tree/RxJava+MVP+Dagger2" target="_blank" rel="external">项目地址</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p><a href="https://guides.codepath.com/android/Dependency-Injection-with-Dagger-2#setup" target="_blank" rel="external">https://guides.codepath.com/android/Dependency-Injection-with-Dagger-2#setup</a><br><a href="http://jellybeanssir.blogspot.jp/2015/05/component-dependency-vs-submodules-in.html" target="_blank" rel="external">http://jellybeanssir.blogspot.jp/2015/05/component-dependency-vs-submodules-in.html</a><br><a href="http://stackoverflow.com/questions/29587130/dagger-2-subcomponents-vs-component-dependencies" target="_blank" rel="external">http://stackoverflow.com/questions/29587130/dagger-2-subcomponents-vs-component-dependencies</a><br><a href="https://google.github.io/dagger/users-guide.html" target="_blank" rel="external">https://google.github.io/dagger/users-guide.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      goodbye  Dagger2
    
    </summary>
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/categories/Dagger2/"/>
    
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>重拾Dagger2-理解Dagger2</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E7%90%86%E8%A7%A3Dagger2/"/>
    <id>http://cristianoro7.github.io/2017/09/29/重拾Dagger2-理解Dagger2/</id>
    <published>2017-09-29T15:35:54.150Z</published>
    <updated>2017-09-29T15:35:54.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><a href="https://cristianoro7.github.io/2017/03/29/%E9%87%8D%E6%8B%BEDagger2-%E4%BD%BF%E7%94%A8Dagger2/">上一篇</a>我们主要介绍了如何用Dagger2在Android应用中进行依赖注入, 在这一篇中, 我们主要来理解Dagger2中的原理, 毕竟知己知彼后才用得踏实</p>
<h3 id="API关系"><a href="#API关系" class="headerlink" title="API关系"></a>API关系</h3><ul>
<li>Provider<t>: provider<t>是一个接口, 它的作用是包装被依赖的类</t></t></li>
<li>Factory<t>: 继承于Provider, 作用是创建依赖的对应实例</t></li>
<li>MembersInjector<t>:  也是一个接口, 作用是将依赖注入到需要依赖的地方, 其中的T为注入地点</t></li>
</ul>
<p>理解上面的接口的作用后, 我们来理解Dagger2不会太难啦</p>
<h3 id="Inject注入解读"><a href="#Inject注入解读" class="headerlink" title="Inject注入解读"></a>Inject注入解读</h3><p>我们利用上篇中的Demo来解读Inject注入. Dagger2生成的源代码可以在app目录下的build目录中的apt目录找到.</p>
<p>既然Component是注入依赖的桥梁, 那我们就先来看看它是怎么出入的吧. 回顾一下上次我们在StudentActivity注入的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">    DaggerStudentComponent.builder()</div><div class="line">            .build()</div><div class="line">            .inject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">    Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在onCreate方法中进行了注入, 仔细看注入的代码, 我们可以大概猜测是用Builder模式创建StudentComponenet实例, 既然这样, 我们先进入build()方法研究一波</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在build()中, 实例了DaggerStudentComponent, DaggerStudentComponent是StudentComponent具体的实现类, 我们顺着思路, 进入DaggerStudentComponent看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(Student_Factory.create());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>上面的代码中, 主要调用了initialize方法进行初始化, 在其中, 创建了StudentActivity_MemberInjector实例</p>
<p>还记得我们在StudentActivity中调用了build()方法后, 还会调用inject(this)吗?  调用该方法后, 会调用我们刚刚在initialize方法中创建出来的StudentActivity_MemberInjector的injectMembers(activity), 我们看看对应的方法都干了什么事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(StudentActivity instance)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</div><div class="line">  &#125;</div><div class="line">  instance.mStudent = mStudentProvider.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到上面的代码, 有没有一种熟悉的感觉? instance.mStudent正是我们在StudentActivity中需要注入的成员变量, 而给它赋值的又是谁?</p>
<p>mStudentProvider变量是我们实例化StudentActivity_MemberInjector传进来的, 我们自然进入对应的类探究探究</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student_Factory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Student_Factory INSTANCE = <span class="keyword">new</span> Student_Factory();</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Student&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> INSTANCE;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StudentFactory中的get()方法返回了对应的Student实例</p>
<p>分析到这里, Inject注解已经完成了一次依赖注入, 因此我们来串联一下各个步骤吧</p>
<p>首先提供依赖的是Stduent_Factory类, 它是Factory的具体实现类, 给我们需要依赖的地方new出实例,</p>
<p>StudentActivity_MemberInjector, 它是MemberInjector的具体实现类, 它在injectMembers(StudentActivity中, 拿到我们需要依赖的实例, 并给被Inject标注的成员变量赋值, 而实例的来源正是我们刚才分析的</p>
<p>讲到这里, 我想大家都对Component的作用加深了, Component就像一座桥梁, 将提供依赖的工厂类, 和需要依赖的地方联系起来, 从而完成依赖注入</p>
<h3 id="Moduley依赖注入"><a href="#Moduley依赖注入" class="headerlink" title="Moduley依赖注入"></a>Moduley依赖注入</h3><p>Module依赖注入的讲解, 我们也是用Student的Demo来讲解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">    DaggerStudentComponent.builder()</div><div class="line">            .build()</div><div class="line">            .inject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">    Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们按照来老套路, 进入build()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> StudentModule studentModule;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (studentModule == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Builder <span class="title">studentModule</span><span class="params">(StudentModule studentModule)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.studentModule = Preconditions.checkNotNull(studentModule);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是熟悉的套路, 只不过这次多了一个StduentModule变量, StudentModule是我们事先写好用于提供依赖的类, 我们可以看到在build()方法中, 实例化了StudentModule和DaggerStduentComponent, 又是老套路, 进入DaggerStduentComponent看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Student&gt; providesStudentProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesStudentProvider =</div><div class="line">        StudentModule_ProvidesStudentFactory.create(builder.studentModule);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(providesStudentProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>跟我们上面分析Inject的代码差不多, 不同的是这次在initialize中创建的是StudentModule_ProvidesStudentFactory, 接下来的流程和Inject都差不多, 我们现在主要来分析StudentModule_providesStduentFactory怎么拿到依赖实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">      <span class="keyword">module</span>.providesStudent(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在get()方法中, 利用module.providesStudent() 提供实例, 这个方法是我们事先在StudentModule中定义的</p>
<p>总体来说Module依赖注入的方式和Inject差不多, 只是提供依赖时生成的工厂方法不一样而已</p>
<p>分析完了Inject和Module注入, 我们来看看Name注解是如何解决依赖迷失,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student1"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student2"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">proStudnet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们make一下工程, 再到app-&gt;build-&gt;source-&gt;apt-&gt;debug目录下, 可以看看这两个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule_ProvidesStudentFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StudentModule <span class="keyword">module</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StudentModule_ProvidesStudentFactory</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> <span class="keyword">module</span> != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">        <span class="keyword">module</span>.providesStudent(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Student&gt; <span class="title">create</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StudentModule_ProvidesStudentFactory(<span class="keyword">module</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Proxies &#123;<span class="doctag">@link</span> StudentModule#providesStudent()&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">proxyProvidesStudent</span><span class="params">(StudentModule instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance.providesStudent();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule_ProStudnetFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StudentModule <span class="keyword">module</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StudentModule_ProStudnetFactory</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> <span class="keyword">module</span> != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">        <span class="keyword">module</span>.proStudnet(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Student&gt; <span class="title">create</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StudentModule_ProStudnetFactory(<span class="keyword">module</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Proxies &#123;<span class="doctag">@link</span> StudentModule#proStudnet()&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">proxyProStudnet</span><span class="params">(StudentModule instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance.proStudnet();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信聪明的你,已经知道Name注解解决的思路. 很简单, 就是每一个方法对应生成一个工厂类提供对应的依赖, 至于类的命名规则我就不说啦, 自己看</p>
<h3 id="迷之Scope"><a href="#迷之Scope" class="headerlink" title="迷之Scope"></a>迷之Scope</h3><p>Scope是作用域, Singleton是被Scope包装的一个注解, 在Dagger2中如果被Singleton标注的话, 该依赖可以在一定程度上实现单例 只不过这种单例是需要条件的, 这个条件是什么? 代码是最好的老师, 我们还是来看看被Sington标注的依赖会生成什么代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Student&gt; proStudnetProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.proStudnetProvider =</div><div class="line">        DoubleCheck.provider(StudentModule_ProStudnetFactory.create(builder.studentModule));</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(proStudnetProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> StudentModule studentModule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (studentModule == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">studentModule</span><span class="params">(StudentModule studentModule)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.studentModule = Preconditions.checkNotNull(studentModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仔细观察上面代码, 我们看到唯一不同的provider赋值的时候, 多了一个DoubleCheck, 其中的奥妙</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">T</span>&gt;, <span class="title">Lazy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNINITIALIZED = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Provider&lt;T&gt; provider;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Object instance = UNINITIALIZED;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">(Provider&lt;T&gt; provider)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> provider != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.provider = provider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// cast only happens when result comes from the provider</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Object result = instance;</div><div class="line">    <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        result = instance;</div><div class="line">        <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">          result = provider.get();</div><div class="line">          <span class="comment">/* Get the current instance and test to see if the call to provider.get() has resulted</span></div><div class="line">           * in a recursive call.  If it returns the same instance, we'll allow it, but if the</div><div class="line">           * instances differ, throw. */</div><div class="line">          Object currentInstance = instance;</div><div class="line">          <span class="keyword">if</span> (currentInstance != UNINITIALIZED &amp;&amp; currentInstance != result) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Scoped provider was invoked recursively returning "</span></div><div class="line">                + <span class="string">"different results: "</span> + currentInstance + <span class="string">" &amp; "</span> + result + <span class="string">". This is likely "</span></div><div class="line">                + <span class="string">"due to a circular dependency."</span>);</div><div class="line">          &#125;</div><div class="line">          instance = result;</div><div class="line">          <span class="comment">/* Null out the reference to the provider. We are never going to need it again, so we</span></div><div class="line">           * can make it eligible for GC. */</div><div class="line">          provider = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns a &#123;<span class="doctag">@link</span> Provider&#125; that caches the value from the given delegate provider. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Provider&lt;T&gt; <span class="title">provider</span><span class="params">(Provider&lt;T&gt; delegate)</span> </span>&#123;</div><div class="line">    checkNotNull(delegate);</div><div class="line">    <span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> DoubleCheck) &#123;</div><div class="line">      <span class="comment">/* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped</span></div><div class="line">       * binding, we shouldn't cache the value again. */</div><div class="line">      <span class="keyword">return</span> delegate;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DoubleCheck&lt;T&gt;(delegate);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns a &#123;<span class="doctag">@link</span> Lazy&#125; that caches the value from the given provider. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Lazy&lt;T&gt; <span class="title">lazy</span><span class="params">(Provider&lt;T&gt; provider)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (provider <span class="keyword">instanceof</span> Lazy) &#123;</div><div class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">      <span class="keyword">final</span> Lazy&lt;T&gt; lazy = (Lazy&lt;T&gt;) provider;</div><div class="line">      <span class="comment">// Avoids memoizing a value that is already memoized.</span></div><div class="line">      <span class="comment">// <span class="doctag">NOTE:</span> There is a pathological case where Provider&lt;P&gt; may implement Lazy&lt;L&gt;, but P and L</span></div><div class="line">      <span class="comment">// are different types using covariant return on get(). Right now this is used with</span></div><div class="line">      <span class="comment">// DoubleCheck&lt;T&gt; exclusively, which is implemented such that P and L are always</span></div><div class="line">      <span class="comment">// the same, so it will be fine for that case.</span></div><div class="line">      <span class="keyword">return</span> lazy;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DoubleCheck&lt;T&gt;(checkNotNull(provider));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DoubleCheck是Provider的具体体现类, 在provider方法中, 返回了DoubleCheck实例, DoubleCheck的精华主要是在get方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">SuppressWarnings(<span class="string">"unchecked"</span>) <span class="comment">// cast only happens when result comes from the provider</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  Object result = instance;</div><div class="line">  <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      result = instance;</div><div class="line">      <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">        result = provider.get();</div><div class="line">        <span class="comment">/* Get the current instance and test to see if the call to provider.get() has resulted</span></div><div class="line">         * in a recursive call.  If it returns the same instance, we'll allow it, but if the</div><div class="line">         * instances differ, throw. */</div><div class="line">        Object currentInstance = instance;</div><div class="line">        <span class="keyword">if</span> (currentInstance != UNINITIALIZED &amp;&amp; currentInstance != result) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Scoped provider was invoked recursively returning "</span></div><div class="line">              + <span class="string">"different results: "</span> + currentInstance + <span class="string">" &amp; "</span> + result + <span class="string">". This is likely "</span></div><div class="line">              + <span class="string">"due to a circular dependency."</span>);</div><div class="line">        &#125;</div><div class="line">        instance = result;</div><div class="line">        <span class="comment">/* Null out the reference to the provider. We are never going to need it again, so we</span></div><div class="line">         * can make it eligible for GC. */</div><div class="line">        provider = <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (T) result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法中的代码有没有很熟悉?? 咋一看, 我还以为是DCL单例模式, 其实不然, 它是利用DCL的思想, 将依赖对象缓存到DoubleCheck中, 下次提供依赖时, 直接从缓存拿. 说了这么多, 你可能会问: 究竟Singleton怎么实现单例啊? 其实这个问题在get()方法中已经体现出来了</p>
<p>既然后一次提供依赖时会从缓存拿, 那我们只要保证DoubleCheck之会被初始化一次, 那么每次用到这个依赖时, 都是从缓存拿的, 也就变相的实现了单例, 为了保证DoubleCheck只会被初始化一次, 我们可以在Appication中实现注入, 那就保证整个应用中DoubleCheck只会被初始化一次.  </p>
<p>细心的你可能会注意到, 有被Singleton标注的依赖都会在Component实例中被DoubleCheck包装, 而没有的依赖则会直接被工厂类创建出来. 那么我们可以自定义一个注解PerActivity, 那么它就可以管理依赖对象在需要注入依赖的Activity实现局部单例</p>
<p>看完Dagger2这个实现单例的思想瞬间膜拜.</p>
<p>总体来说, Scope注解还是很有用的, 利用它我们可以有效的管理依赖对象的生命周期, 让我们不用再去写一堆的单例类</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本篇主要讲了Dagger注入依赖的原理, 重点讲了Scope实现单例的原理, 对于Component和SubComponent我想留到下一篇讲, 下篇我会针对Component和SubComponent来分析, 并利用他们有效的组织依赖注入. 今天就到这里啦…</p>
]]></content>
    
    <summary type="html">
    
      Understanding  Dagger2
    
    </summary>
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/categories/Dagger2/"/>
    
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>重拾Dagger2-使用Dagger2</title>
    <link href="http://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E4%BD%BF%E7%94%A8Dagger2/"/>
    <id>http://cristianoro7.github.io/2017/09/29/重拾Dagger2-使用Dagger2/</id>
    <published>2017-09-29T15:35:43.430Z</published>
    <updated>2017-09-29T15:35:43.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用注解解释"><a href="#常用注解解释" class="headerlink" title="常用注解解释"></a>常用注解解释</h2><p>在学习Dagger2之前,我们最好就是将Dagger2中的常用的注解的含义捋清一遍, 这样上手Dagger2就不会显得那么难,所以下面我准备介绍Dagger2中常用的注解的含义,这些注解包括</p>
<ul>
<li>Inject</li>
<li>Provides</li>
<li>Module</li>
<li>Component</li>
<li>Qualifiers</li>
<li>Scope</li>
</ul>
<h3 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h3><p>Inject的中文意思是注射,在Dagger2中它在不同的地方代表不同的含义．当Inject是标注在类的属性域时,那么它代表Dagger会给我们提供被Inject标注的实例; 当Inject标注的是类的构造方法时,它表示Dagger会帮我们实例化这个类并提供给需要这个类的地方</p>
<h3 id="Provides"><a href="#Provides" class="headerlink" title="Provides"></a>Provides</h3><p>Provides提供一种通过注解方法来提供依赖的机制, 它主要是用来弥补Inject的缺陷, 如果类的方法被Provides标注后, 它相当于告诉Dagger, 通过方法可以提供项目中所需要的依赖</p>
<h3 id="Modue"><a href="#Modue" class="headerlink" title="Modue"></a>Modue</h3><p>Module的作用是来管理被Provides标注的方法, 有点类似工厂</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>通过上面介绍的三个注解, 我们可以归纳出: 在Dagger2中可以有两种方式进行依赖注入,一种是利用Inject来进行注解, 另一种是通过在被Module标注的类中,将Provides注解标注方法,并在方法中返回需要被依赖的实例．Component的作用就是将被依赖的对象提供给需要依赖的对象，也就是说Component其实就是连接依赖方和被依赖方的桥梁,只有通过Component，依赖方和被依赖方才能联系在一起．</p>
<h3 id="Qualifiers"><a href="#Qualifiers" class="headerlink" title="Qualifiers"></a>Qualifiers</h3><p>在Dagger2中, 如果在被Module标注的类中, 有两个方法都是返回相同类型的实例时，此时，Dagger并不知道要调用哪个方法才好，因此Dagger干脆就不干了，直接在编译时就报错．这种情况叫做依赖注入迷失．而Qualifiers的作用正是来解决依赖注入迷失的问题, 具体的看代码咯</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>Scope代表作用域，Scope常常用于管理依赖对象的生命周期，Dagger中提供的Singleton注解被Scope标注，用于实现单例，不过这个单例的实现跟我们平时所写的单例不一样,具体的我会在下篇中讲到．</p>
<p>其实只看上面的几个注解可能会让你很蒙, 那下面我们来结合代码开始来使用Dagger2</p>
<h3 id="Inject注入"><a href="#Inject注入" class="headerlink" title="Inject注入"></a>Inject注入</h3><p>我们先来看看如何用Inject实现注入</p>
<ul>
<li><p>首先新建Student类, 并在其构造方法添加Inject注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"xiaoming"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接着新建StudentComponent, 用于连接依赖方和被依赖方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>; <span class="comment">//表示需要被注入依赖的地方为StudentActivity</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后实现依赖注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">        DaggerStudentComponent.builder()</div><div class="line">                .build()</div><div class="line">                .inject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">        Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>经过这三个步骤我们就完成了一次 依赖注入．在StudentActivity中，我们需要用到Stduent类，因此我们用Inject注解标注Student属性域, 接着在Student的构造函数上标注Inject，表示当需要Student依赖时，Dagger会帮我们实例化出Student类, 现在依赖方和被依赖方都有了，就剩下最后连接彼此，而连接彼此需要在StudentComponent中添加需要注入到哪个类中,在这个例子中, 需要被注入的类是StudentActivity, 最后调用inject方法实现注入．</p>
<h3 id="Inject注入的缺陷"><a href="#Inject注入的缺陷" class="headerlink" title="Inject注入的缺陷"></a>Inject注入的缺陷</h3><p>使用Inject注入有一个缺点: 当我们需要注入的是第三方库的类时，我们无法直接在其构造方法标注Inject，最简单的解决办法就是新建一个类并继承我们需要的第三方库中的类．但是这种解决方法太笨拙了，如果我们需要注入的类有很多的话，我们岂不是要新建很多类? 显然这种体力活不适合程序员．关于这个问题，Dagger早就帮我们考虑好了，Dagger针对这种情况给我们提供了Provides注解来解决这种问题．</p>
<h3 id="Provides实现注入"><a href="#Provides实现注入" class="headerlink" title="Provides实现注入"></a>Provides实现注入</h3><p>我们来看看Provides怎么解决Inject的缺陷</p>
<ul>
<li><p>首先定义StudentModule类, 用来管理提供的依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接着在StudentComponent中添加moule = StudentModule.class, 相当于告诉Dagger. 可以到该类中找依赖</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(modules = StudentModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>最后连接彼此</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">        DaggerStudentComponent.builder()</div><div class="line">                .studentModule(<span class="keyword">new</span> StudentModule())</div><div class="line">                .build();</div><div class="line"></div><div class="line">        <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">        Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在StudentModule中, 我们通过Provides标注告诉Dagger, 这个方法返回的实例是被依赖的, 而我们在StudentComponent中添加modules = StudentModule.class, 相当于在StduentComponent注入StudentActivity时, 让Dagger去StudentModule类中找提供依赖的方法．</li>
</ul>
<h3 id="Qualifiers解决依赖迷失"><a href="#Qualifiers解决依赖迷失" class="headerlink" title="Qualifiers解决依赖迷失"></a>Qualifiers解决依赖迷失</h3><p>如果我们在StudentModule中提供两个返回类型相同的实例方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">proStudnet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码在编译时会报错, 原因是我们之前讲的依赖注入迷失. 为了解决这个问题, 我们可以用Qualifiers注解. Dagger2中已经给我们提供了一个Named注解, Named注解是被Qualifiers修饰的一个注解, 使用Named就可以解决依赖迷失, 我们先来看看Named源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Named &#123;</div><div class="line">    <span class="comment">/** The name. */</span></div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以根据我们业务需求仿照Named来自定义注解. 看完Named注解,  我们来瞧瞧怎么用, 由于使用比较简单, 我只贴代码咯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student1"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student2"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">proStudnet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student1"</span>)</div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student2"</span>)</div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent2;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">        DaggerStudentComponent.builder()</div><div class="line">                .studentModule(<span class="keyword">new</span> StudentModule())</div><div class="line">                .build();</div><div class="line"></div><div class="line">        <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">        Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="依赖注入优先级"><a href="#依赖注入优先级" class="headerlink" title="依赖注入优先级"></a>依赖注入优先级</h3><p>试想一下, 如果同时提供了Inject和Module依赖注入, Dagger会优先注入哪个? 答案是 Module. 在依赖注入时, Dagger会优先从Module查找, 如果没的话, 在从Inject构造函数, 两者只有其中一者会提供依赖</p>
<h3 id="Dagger依赖查找策略"><a href="#Dagger依赖查找策略" class="headerlink" title="Dagger依赖查找策略"></a>Dagger依赖查找策略</h3><p>当我们需要依赖注入时, Dagger会采取以下策略来查找依赖:</p>
<ol>
<li>首先从Module中查找, 如果查找得到的并且Provides方法中没有参数的话, 直接提供依赖返回, 如果Module中查找不到时, 如果被依赖的对象的构造函数有Inject标注并且没有参数的话, 提供依赖并且返回</li>
<li>步骤一的都是在Provides标注的方法或Inject标注的构造函数中没有参数的情况下,  现在讨论有参数的情况</li>
<li>首先先从Module查找, 如果Module有提供对应的依赖并且方法中有参数, Dagger会按照先Module后Inject的顺序去查找参数的依赖, 然后重复步骤一递归查找, 查不到的话再从Inject查, 如果Inject标注的构造函数有参数的话, 也是递归步骤1进行查找</li>
</ol>
<h3 id="Scope实现生命周期的管理"><a href="#Scope实现生命周期的管理" class="headerlink" title="Scope实现生命周期的管理"></a>Scope实现生命周期的管理</h3><p>Dagger中采用Scope来实现被依赖对象的生命周期管理, 最直接的一个标注就是Singleton. 被Singleton标注的对象可以实现单例, 但是这种单例跟我们平常写的不太一样, 具体实现下篇我会分析, 现在我们把重点放在怎么使用上</p>
<ul>
<li>首先在Component标注Singleton</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;AppModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>接着在Modue中的Provides方法中标注Singleton</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Application application;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppModule</span><span class="params">(Application application)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.application = application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Application <span class="title">providesApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Student <span class="title">providesData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>最后在Application实现注入就可以实现单例了, 具体代码不贴了.</li>
<li>Scope由于比较特殊, 关于它的实现原理和具体是使用, 准备留到源码篇和组织篇的时候再分析</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果Modue中的Provides有标注作用域的话, 必须和对应的Component标注的作用域相同, 不然编译时会报错.</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本篇文章主要讲Dagger2的最基本的使用, 目的指在熟悉Dagger2中的基本使用, 注入规则以及需要注意的地方, 关于Dagger2的实现原理和Dagger的组织方式, 准备开两篇来讲..嗯…今天就到这里了哈</p>
]]></content>
    
    <summary type="html">
    
      Hey, Dagger2
    
    </summary>
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/categories/Dagger2/"/>
    
    
      <category term="Dagger2" scheme="http://cristianoro7.github.io/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://cristianoro7.github.io/2017/09/29/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://cristianoro7.github.io/2017/09/29/Class类文件结构/</id>
    <published>2017-09-29T15:31:08.566Z</published>
    <updated>2017-09-29T15:31:08.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>Class类文件结构<ul>
<li>特殊字符串概念</li>
<li>魔数与Class文件的版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引,父类索引与接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="类文件结构-1"><a href="#类文件结构-1" class="headerlink" title="类文件结构"></a>类文件结构</h3></blockquote>
<p>Class文件结构只有两种数据类型:无符号和表.<br>无符号数属于基本的数据类型,以u1,u2,u4,u8分别代表1个字节,2个字节,4个字节和8个字节的无符号数,它用来描述数字,索引引用,数量值或者UTF-8编码构成字符串值.<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型,所有表都习惯以”_info” 结尾<br>整个class文件本质就是一张表:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count</td>
</tr>
<tr>
<td>u2</td>
<td>access_flag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface</td>
<td>interface_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h4 id="特殊字符串的概念"><a href="#特殊字符串的概念" class="headerlink" title="特殊字符串的概念"></a>特殊字符串的概念</h4><ul>
<li>全限定名: 把类的全名中的”.”替换成”/“,最后再加上”;”</li>
<li>简单名称: 没有类型和参数修饰的方法或者字段名称.</li>
<li>方法和字段的描述符: 描述符的作用是用来描述字段的数据类型,方法参数列表和返回值.</li>
<li>描述符标识字符含义:</li>
</ul>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>特殊类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型</td>
</tr>
</tbody>
</table>
<h4 id="魔数与Class文件版本"><a href="#魔数与Class文件版本" class="headerlink" title="魔数与Class文件版本"></a>魔数与Class文件版本</h4><ul>
<li>每个Class文件的头4个字节称为魔数,它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件.</li>
<li>紧接魔数后面的4个字节储存的是Class文件的版本号: 第5,6个字节是此版本号(Minor Version),第7和第8个字节是主版本号.JDK的版本号是从45开始的.</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li>常量池可以理解为Class文件之中的资源仓库,它同时是Class文件关联其他项目最多的数据类型,也是占用Class文件空间最大的数据项目之一.</li>
<li>由于常量池中的常量是不固定的,所以需要在常量池入口放置一项u2类型的数据,代表常量池容量计数值.</li>
<li>常量池中主要储存两大类常量:字面量和符号引用．字面量比较接近Java语言层面的常量概念,如字符串,声明为final常量值等. 而符号引用则属于编译原理方面的概念,主要包含了下面三类常量:<ul>
<li>类和接口的全称限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>常量池的项目类型:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或者方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标识方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeType_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><ul>
<li>access_flags用于识别一些类或者接口层次的访问信息.例如:这个class是类还是接口;是否定义为public类型;是否定义为abstract类型等. 具体标记:</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final,只有类可设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令心新语意</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstact类型, 对于接口或者抽象类来说, 这个标志为真,其他值为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识这个类并非由用户代码生成</td>
</tr>
<tr>
<td>ACC_ANNOTION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这个一个枚举</td>
</tr>
</tbody>
</table>
<h4 id="类索引-父类索引与接口索引集合"><a href="#类索引-父类索引与接口索引集合" class="headerlink" title="类索引,父类索引与接口索引集合"></a>类索引,父类索引与接口索引集合</h4><ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名</li>
<li>接口索引集合用于描述这个类实现了哪些接口</li>
</ul>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><ul>
<li>字段表集合用于描述接口或者类中声明的变量.</li>
<li>字段包括类级变量和实例级变量, 但不包括在方法内的局部变量</li>
</ul>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><ul>
<li>方法表结构:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<ul>
<li>方法表集合结构跟字段表结构大致相同</li>
<li>如果父类分方法没有被子类重写,方法表集合中就不会出现父类方法的信息.</li>
</ul>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><ul>
<li>虚拟机规范预定义的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量值</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类,方法表字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EbcloseingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性,这个属性用于标识这个类所在的外围方法.</td>
</tr>
<tr>
<td>InnerClasses</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令对应的关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部属性描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性, 供新的类型检查验证器检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配.</td>
</tr>
<tr>
<td>Signature</td>
<td>类,方法表,字段表</td>
</tr>
</tbody>
</table>
<p>待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类文件结构&quot;&gt;&lt;a href=&quot;#类文件结构&quot; class=&quot;headerlink&quot; title=&quot;类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="JVM" scheme="http://cristianoro7.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://cristianoro7.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存分配与回收策略</title>
    <link href="http://cristianoro7.github.io/2017/09/29/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://cristianoro7.github.io/2017/09/29/Java内存分配与回收策略/</id>
    <published>2017-09-29T15:29:50.478Z</published>
    <updated>2017-09-29T15:29:50.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>对象优先在Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活对象将进入老年代</li>
<li>动态对象年龄判定</li>
<li>空间分配担保</li>
</ul>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><ul>
<li>大多数情况下, 对象主要分配在新生代的Eden区上.</li>
<li>当Eden区没有足够的空间进行分配时, 虚拟机将进行一次 Minor GC</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul>
<li>大对象指的是需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串以及数组.</li>
<li>经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”他们.</li>
</ul>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul>
<li>为了采用分代收集来管理内存,虚拟机给每个对象定义了一个对象年龄计数器.</li>
<li>如果对象在Eden出生并经历第一次Minor GC后仍然存活, 并且能被Survivor容纳的话,将被移动到Survivor,并且年龄就增加1岁.</li>
<li>当它的年龄增加到一定程度(默认为15岁),就会被晋升到老年代.</li>
</ul>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ul>
<li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或者等于该年龄的对象就可以直接进入老年代,无需等到MaxTenuringThreshold2中要求的年龄.</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>如果老年代最大可用连续空间大于新生代所有对象总空间,那么Minor GC可以确保是安全的.</li>
<li>如果老年代最大可用连续空间不大于新生代所有对象总空间的话且老年代最大可用连续空间是大于历次晋升到老年代对象的平均大小,那么Minor GC是冒险的.</li>
<li>如果老年代最大可用连续空间不大于新生代所有对象总空间的话且老年代最大可用连续空间是小于历次晋升到老年代对象的平均大小,那这时要进行一次Full GC.</li>
</ul>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存分配与回收策略&quot;&gt;&lt;a href=&quot;#内存分配与回收策略&quot; class=&quot;headerlink&quot; title=&quot;内存分配与回收策略&quot;&gt;&lt;/a&gt;内存分配与回收策略&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="JVM" scheme="http://cristianoro7.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://cristianoro7.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收器</title>
    <link href="http://cristianoro7.github.io/2017/09/29/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://cristianoro7.github.io/2017/09/29/java垃圾回收器/</id>
    <published>2017-09-29T15:29:46.698Z</published>
    <updated>2017-09-29T15:29:46.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>判定对象存活<ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
<li>再谈引用<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
</li>
<li>生存还是死亡</li>
<li>回收方法区</li>
</ul>
</li>
<li>垃圾收集算法<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-整理算法</li>
<li>分代收集算法</li>
</ul>
</li>
<li>HotSpot的算法实现<ul>
<li>枚举根节点</li>
<li>安全点</li>
<li>安全区域</li>
</ul>
</li>
<li>垃圾收集器<ul>
<li>Serial收集器</li>
<li>ParNew收集器</li>
<li>Parallel收集器</li>
<li>Serial Old 收集器</li>
<li>Parallel Old 收集器</li>
<li>CMS收集器</li>
<li>G1收集器</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="判定对象的存活"><a href="#判定对象的存活" class="headerlink" title="判定对象的存活"></a>判定对象的存活</h3></blockquote>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li>给一个对象添加一个计数器,每当有一处地方引用对象时,计数器值加1; 当引用失效时, 计数器值就减1; 任何时刻计数器为0对象就是不可能再被使用的.</li>
<li>引用计数算法最大的缺点就是很难解决对象之间的循环引用.</li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li>通过一系列的称为 “ GC Root “ 对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链, 当一个对象到” GC Root “ 没有任何引用链相连时,则证明此对象是不可用的.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收-1.png" alt=""></p>
<ul>
<li>在Java语言中, 可作为 GC Root的对象包括下面几种:<ul>
<li>虚拟机栈(栈帧中的本地变量表)引用的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(一般指Native方法)引用的对象</li>
</ul>
</li>
</ul>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK1.2后,Java对引用进行了扩充,将引用分强引用, 软引用, 弱引用和虚引用四种.</p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>程序代码中普遍存在的,类似”Object obj = new Object()”这类引用, 只要强引用存在的话, 对象就永远不会被回收</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用用于描述一些还有用但是又是非必需对象. 对于软引用关联着的对象, 在系统将要发生内存溢出之前, 将会把对象列进回收范围之中进行第二次回收, 如果这次回收没有足够的内存,才抛出内存溢出异常</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用也是用来描述非必需对象, 但是它的强度比软引用弱一些, 被弱引用关联的对象只能生存到下次垃圾收集发生之前.<br>当垃圾收集器工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象.</p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><ul>
<li>它是最弱的一种引用关系.</li>
<li>一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象的实例</li>
<li>一个对象虚引用关联的目的就是这个对象被收集器回收时收到一个系统通知.</li>
</ul>
<h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><ul>
<li>一个对象需要至少经历两次标记才能宣告死亡</li>
<li>如果一个对象在可达性分析后发现没有GC Roots相连接时, 那么它第一次被标记并且进行一次筛选, 筛选的条件是该对象是否有必要执行finalize()方法.当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过一次, 这两种情况虚拟机都是视为不必要调用.</li>
<li>如果这个对象被判定为需要执行finalize()方法的话, 那么对象将会被放置在F-Queue队列中, 稍后虚拟机会启动一个优先级较低的线程去执行它.</li>
<li>执行finalize()方法时, 虚拟机并不会等待它执行结束, 这样做是为了避免执行finalize()方法缓慢或者发生死循环. 这样可能会导致F-Queue队列中的对象处于永久等待中,甚至导致整个内存回收崩溃.</li>
<li>finalize()方法是对象逃脱死亡命运的最后一次机会, GC会在finalize()中进行第二次小规模的标记, 如果对象被第二次标记后,那么就宣告了一个对象的死亡.</li>
</ul>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><ul>
<li>方法区的回收主要回收两部分内容:废弃常量和无用的类.</li>
<li>回收废弃常量和回收Java堆很相似.例如: 字符串 “abc” 已经进入了常量池, 但是当前系统没有一个String对象叫做”abc”的,也就是没有任何String对象引用常量池之中的”abc”, 如果这时候发生内存回收, 而且必要的话, 这个”abc”会被清除出常量池.常量池中的其他类(接口),方法,字段的符号引用也与此类似.</li>
<li>一个类被视为无用的条件<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用, 无法通过反射获取类的方法.</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3></blockquote>
<h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><ul>
<li>首先标记出所有需要回收的对象,在完成标记后统一回收所有被标记的对象</li>
<li>不足的地方<ul>
<li>效率问题, 标记和清除的两个过程效率都不是很高</li>
<li>空间问题, 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时, 无法找到足够的连续内存而不得不提前触发另外一次GC</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/mark-sweep.png" alt=""></p>
<h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><ul>
<li>复制算法是为了解决标记-清除算法的效率问题而出现的</li>
<li>它将内存按照容量划分为相等的两块, 每次只用其中一块.当这一块内存快用完了, 就将还存活的对象复制到另一块内存,然后再把空间一次清理掉</li>
<li>复制算法的代价是将内存空间缩小为原来的一半.</li>
<li>HotSpot虚拟机默认Eden和Survivor的大小比例为8:1,只有10%的内存空间会被浪费.</li>
<li>如果另外一块Survivor空间没有足够的内存放上次新生代存活下来的对象时, 这些对象将直接通过分配担保直接进入老年代.</li>
</ul>
<h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><ul>
<li>标记过程仍然与”标记-清除”算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉边界以外的内存.</li>
</ul>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ul>
<li>一般将Java堆划分为新生代和老年代, 这样就可以根据各个年代的特点采用适当的算法</li>
<li>在新生代中,每次GC时,都发现大量对象死去, 只有少量对象存活, 那就选用复制算法.</li>
<li>而老年代中因为对象的存活率高, 没有额外的空间进行担保,就必须使用”标记-清除”或者”标记-整理”.</li>
</ul>
<blockquote>
<h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3></blockquote>
<p>在HotSpot上实现垃圾收集算法, 必须对算法的执行效率必须经过严格的考证, 才能保证虚拟机的执行效率</p>
<h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><ul>
<li>目前主流的Java虚拟机使用的都是标准式的GC, 所以当执行系统停顿下来时, 并不需要一个不漏的检查完所有执行上下文和全局的引用位置, 虚拟机使用一组称为OopMap的数据结构来得知哪些地方存放着对象引用.</li>
</ul>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><ul>
<li>HotSpot没有为每条指令都生成OopMap, 它只是在特定的位置记录了”这些信息”,这些位置被称为安全点(Safepoint),即程序并非在所有的地方都能停下来GC, 只有在安全点时才能停下来</li>
<li>安全点的选定基本上是以程序”是否具有让程序长时间执行的特征”为标准选定.”长时间执行”的最明显特征就是指令序列复用,例如方法调用,循环引用,循环跳转,异常跳转等,具有这些功能的指令才会生成Safepoint.</li>
<li>对于Safepoint,需要考虑的另外一个问题是如何让GC发生时停止所有线程时,所有线程都跑到安全点. 这里有两种方案可供选择:抢先式中断和主动式中断.<ul>
<li>抢先式中断不需要线程的配合,在发生GC时,首先把所有线程全部中断,如果发现有线程中断在不安全点上, 就恢复线程,让它跑到安全点上. 现在几乎没有虚拟机是这样实现的.</li>
<li>主动式的中断是思想是当GC需要中断线程的时候, 不直接对线程进行操作,仅仅简单的设置一个标志, 各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己挂起.轮询标志的地方和安全点是重合的.</li>
</ul>
</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><ul>
<li>安全区域是指在一段代码之中,引用关系不会发生变化. 在这个区域中的任何地方开始GC都是安全的.</li>
<li>线程执行到Safe Region时, 首先标识自己已经进入安全区域, 那样当在这段时间内JVM要发起GC时,就不用管已经标识为安全区域状态的线程. 在线程要离开安全区域时, 它首先要检查系统是否已经完成了根节点枚举, 如果完成了,就继续执行,否则它就要等到收到安全离开的信号为止.</li>
</ul>
<blockquote>
<h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></blockquote>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收器.png" alt=""></p>
<h4 id="Senial-收集器"><a href="#Senial-收集器" class="headerlink" title="Senial 收集器"></a>Senial 收集器</h4><ul>
<li>Serial 收集器在进行垃圾回收时,必须暂停其他所有的工作线程,直到它收集结束</li>
<li>下面是Serial/Serial Old收集器的工作过程</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/Serial.png" alt=""></p>
<ul>
<li>优点: 简单高效, 对于限定单CPU的环境来说, Serial收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率.</li>
<li>使用场景: 在用户的桌面应用场景中, 分配给虚拟机管理内存不会很大, 停顿时间可控制在10几到100多毫秒, 只要不频繁发生,这点的停顿还是可以接受的. 因此, Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择.</li>
</ul>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><ul>
<li>ParNew收集器其实就是多线程版本的Serial收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParNew.png" alt=""></p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul>
<li>Parallel Scavenge收集器的特点是它关注点与其他的收集器不同, CMS等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间, 而Parallel Scavenge收集器目的是达到一个可控的吞吐量, 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值.</li>
<li>停顿时间越短越适合需要与用户交互的程序; 高吞吐量则可以高效率地利用CPU时间, 尽快完成程序运算任务, 主要适合后台运算而不需要太多交互的任务.</li>
</ul>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ul>
<li>Serial Old是Serial收集器的老年代版本, 使用”标记-整理”算法, 这个收集器的主要意义是给Client模式下的虚拟机使用.</li>
<li>如果在Server模式下, 那么它有两大主要用途:<ul>
<li>在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用.</li>
<li>作为CMS收集器的后备预案,在并发收集发生 Concurrent Mode Failure时使用.</li>
</ul>
</li>
</ul>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ul>
<li>Parallel Old 是Parallel Scavenge收集器的老年代版本.</li>
<li>在吞吐量以及CPU资源敏感的场合, 都可以优先考虑Parallel Scavenge加Parallel Old收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParallelOld.png" alt=""></p>
<h4 id="CMS-收集器-Concurrent-Mark-Sweep"><a href="#CMS-收集器-Concurrent-Mark-Sweep" class="headerlink" title="CMS 收集器(Concurrent Mark Sweep)"></a>CMS 收集器(Concurrent Mark Sweep)</h4><ul>
<li>CMS收集器是一种以获取最短回收停顿时间为目标的收集器.</li>
<li>CMS 收集器是基于 “标记-清除”算法实现,整个过程分为4个步骤:<ul>
<li>初始化标记:仅仅只是标记一下GC Roots能直接关联到的对象, 速度很快.</li>
<li>并发标记:进行GC Roots Tracing的过程.</li>
<li>重新标记:为了修正并发标记期间因用户程序继续运行导致标记产生变动的那一部分对象标记记录,这个阶段的停顿时间一般会比初始化阶段稍微长一些,但远比并发标记的时间短.</li>
<li>并发清除: 清除标记.</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/cms.png" alt=""></p>
<ul>
<li><p>CMS 收集器明显的3个缺点:</p>
<ul>
<li><p>CMS收集器对CPU资源非常敏感,在并发阶段,它虽然不会导致用户线程中断,但是会因为占用了一部分CPU资源而导致应用程序变慢,总吞吐量降低.</p>
</li>
<li><p>CMS 收集器无法处理浮动垃圾, 可能出现 “Concurrent Mode Failure”失败而导致另一次Full GC产生.浮动垃圾指的是CMS并发清理阶段用户线程还在运行, 这期间产生的垃圾.CMS无法像其他收集器那样等到老年代几乎完全被填满时才收集, 需要预留一部分的空间提供并发手机时的程序运行使用.要是CMS运行期间预留内存无法满足程序需要, 就会出现一次”Concurrent Mode Failure” 失败. 这时虚拟机启动后备预案: 临时启动Serial Old收集器重新进行老年代垃圾收集, 这样停顿的时间就变长了.</p>
</li>
<li><p>由于CMS是基于”标记-清除”算法实现的, 这意味者收集结束时会有大量空间碎片产生.空间碎片太多会给大对象分配带来麻烦,因为无法找到连续足够大的空间来给大对象分配,这就不得不提前触发一次Full GC 了. 为了解决这个问题, CMS收集器提供了一个 -XX:+UseCMSCompactAtFullCollection开关参数,用户在CMS收集器顶不住要进行FullGC时开启内存碎片的合并过程整理, 内存整理无法并发进行, 因此会导致停顿时间变长. 虚拟机设计者还提供了一个参数-XX:CMSFullGCsBeforeCompaction,这个参数用于设置执行多少次不压缩的Full GC后,就跟着一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)</p>
</li>
</ul>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器的使命是在未来替代掉JDK1.5之中发布的CMS收集器,与其他收集器相比, G1具有的特点:</p>
<h5 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h5><p>G1能充分利用多CPU,多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World停顿时间</p>
<h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>虽然G1可以不需要其他收集器配合就能管理整个GC堆,但他能够采用不同的方式去处理新创建的对象和已经存活一段时间,熬过多次GC的旧对象以获取更好的收集效果.</p>
<h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><p>G1整体来看是基于”标记-整理”算法实现的收集器,从局部上来看是基于复制算法实现的.</p>
<h5 id="可预测的停顿"><a href="#可预测的停顿" class="headerlink" title="可预测的停顿"></a>可预测的停顿</h5><p>G1除了要求停顿降低外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒.</p>
<p>如果不计算维护Remembered Set操作,G1收集器的运作大致可划分为以下几个步骤:</p>
<ul>
<li>初始标记:标记一下GC Roots能直接关联到的对象并且修改TAMS的值,让下一阶段用户程序并发运行时,能在正确可用的Region中创建新对象,这个阶段需要停顿线程,但耗时很短.</li>
<li>并发标记:从GC Roots开始对堆中对象进行可达性分析, 找出存活对象,这阶段耗时很长,但可用与用户程序并发运行.</li>
<li>最终标记:为了修正在并发标记期间因用户程序继续运作而导致标记产生百年动的那一部分标记记录,虚拟机将这阶段对象变化记录在线程Remembered Set中, 这阶段需要停顿线程,但可并行执行.</li>
<li>筛选回收:首先对各个Region的回收价值和成本进行排行,根据用户所期望的GC停顿时间来指定回收计划.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/g1.png" alt=""></p>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目
    
    </summary>
    
      <category term="JVM" scheme="http://cristianoro7.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://cristianoro7.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
