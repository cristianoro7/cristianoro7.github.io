<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Desperado</title>
  <subtitle>Do one thing every day that scares you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cristianoro7.github.io/"/>
  <updated>2017-08-28T14:34:49.198Z</updated>
  <id>http://cristianoro7.github.io/</id>
  
  <author>
    <name>Desperado</name>
    <email>424494431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Java集合框架-set家族</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set%E5%AE%B6%E6%97%8F/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合框架-set家族/</id>
    <published>2017-08-28T14:34:49.198Z</published>
    <updated>2017-08-28T14:34:49.198Z</updated>
    
    <content type="html"><![CDATA[<p><code>Set</code>集合的最大特点是能够保证内部的元素唯一性. 这种特性是建立在<code>Map</code>的基础上的. 换句话说: <code>Set</code>通过组合的模式, 在<code>Map</code>的基础上扩展了一些特性. 由于<code>Set</code>是建立在<code>Map</code>的基础上的. 如果理解了<code>Map</code>的话, <code>Set</code>会很好理解. 接下来我们来看看<code>Set</code>家族的UML</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fizhykmqgzj30x10hwq3y.jpg" alt=""></p>
<p><code>Set</code>接口对应<code>Map</code>接口, 定义了<code>Set</code>的一些方法. <code>AbstractSet</code>对应<code>AbstractMap</code>, 为<code>Set</code>家族提供了一些默认的实现. <code>HashSet</code>通过组合<code>HashMap</code>并且利用<code>HashMap</code>的Key值的唯一性, 来保证内部元素的唯一性. <code>LinkedHashSet</code>通过组合<code>LinkedHashMap</code>, 使得Set内部的元素是有序的. 同种道理, <code>TreeSet</code>也是基于<code>TreeMap</code>来实现的.</p>
<blockquote>
<h2 id="Set家族"><a href="#Set家族" class="headerlink" title="Set家族"></a>Set家族</h2></blockquote>
<ul>
<li><code>HashSet</code></li>
<li><code>LinkedHashSet</code></li>
<li><code>TreeSet</code></li>
</ul>
<blockquote>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"></div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>前面说过<code>Set</code>家族都是通过组合<code>Map</code>家族来实现的. 从上面的字段, 可以看出<code>HashSet</code>是基于<code>HashMap</code>来实现的. 而<code>PRESENT</code>则是一个虚假的值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当向<code>HashSet</code>中添加元素时, 将元素作为map的key, 而value则是用一个虚假的值<code>PRESENT</code>. 由于<code>HashMap</code>中的Key是唯一的. 而<code>HashSet</code>中的元素是作为Key储存在<code>HashMap</code>中的.这样就保证了<code>HashSet</code>元素中没有重复的值.</p>
<blockquote>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3></blockquote>
<p><code>LinkedHashSet</code>继承于<code>HashSet</code>, 它对应<code>Map</code>家族的<code>LinkedHashMap</code>. 但是当你查看<code>LinkedHashSet</code>的时候, 可能会发现并没有<code>LinkedHashMap</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</div><div class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个构造函数是<code>HashSet</code>为<code>LinkedHashSet</code>预留的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.keySet().iterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>`LinkedHashSet</code>中还提供了一个迭代器接口, 迭代器遍历时是有序的遍历. 因为该迭代器是<code>LinkedHashMap</code>的一个实现.</p>
<blockquote>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3></blockquote>
<p><code>TreeSet</code>对应于<code>TreeMap</code>, <code>TreeSet</code>的实现思路跟前面两个<code>Set</code>差不多.. 这里不分析.</p>
<blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2></blockquote>
<p>到这里…不知不觉已经分析完了集合框架. 但是并没有包含并发的集合工具. 接下来准备看完并发后再来梳理并发集合工具.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Set&lt;/code&gt;集合的最大特点是能够保证内部的元素唯一性. 这种特性是建立在&lt;code&gt;Map&lt;/code&gt;的基础上的. 换句话说: &lt;code&gt;Set&lt;/code&gt;通过组合的模式, 在&lt;code&gt;Map&lt;/code&gt;的基础上扩展了一些特性. 由于&lt;code
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-TreeMap</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-TreeMap/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合框架-TreeMap/</id>
    <published>2017-08-28T14:29:03.864Z</published>
    <updated>2017-08-28T14:29:03.864Z</updated>
    
    <content type="html"><![CDATA[<p>这次要介绍的<code>Map</code>跟之前介绍的<code>Map</code>有点不一样. 之前的<code>Map</code>, 例如: <code>HashMap</code>, <code>LinkedHashMap</code>都是基于散列技术. 而这次要介绍的<code>TreeMap</code>则不同, <code>TreeMap</code>是基于一种叫<code>红黑树</code>的数据结构. 接下来, 我们先看看<code>TreeMap</code>的UML图片</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fizax4c2efj30o60c2dgl.jpg" alt=""></p>
<p>跟之前介绍过的<code>Map</code>一样, <code>TreeMap</code>实现了<code>Cloneable</code>和<code>Serializable</code>, 因此它支持克隆(浅克隆)和序列化.</p>
<p><code>SortMap</code>这个接口提供了一些有序的视图, 比如: key有序视图. 实现该接口的数据结构表明其遍历Key或者Value的时候,是有序的. <code>NavigableMap</code>继承<code>SortMap</code>接口, 并提供了更为丰富的视图操作.</p>
<blockquote>
<h2 id="TreeMap特性"><a href="#TreeMap特性" class="headerlink" title="TreeMap特性"></a>TreeMap特性</h2></blockquote>
<p><code>TreeMap</code>是基于红黑树来实现的. 红黑树是一种自平衡的二叉查找树, 插入, 查找, 删除等操作的时间复杂度都是<code>O(logn)</code>. 由于红黑树也是一种二叉查找树, 因此, 遍历<code>Treemap</code>是有序的.</p>
<p><code>TreeMap</code>的结点的默认顺序是<code>Key</code>的自然顺序(<code>Key</code>必须实现<code>Comparator</code>). 当然, <code>TreeMap</code>内部也支持外部提供<code>Comparator</code>来指定结点的排列顺序.</p>
<p><code>TreeMap</code>的Key是不支持null的, 而Value则支持null.</p>
<p>在了解了<code>TreeMap</code>一些特性后, 我们接着来分析<code>TreeMap</code>常用的操作和它的迭代器.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<ul>
<li>常用操作</li>
<li>迭代器</li>
</ul>
<blockquote>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; left; <span class="comment">//左孩子</span></div><div class="line">        Entry&lt;K,V&gt; right; <span class="comment">//右孩子</span></div><div class="line">        Entry&lt;K,V&gt; parent; <span class="comment">//父结点</span></div><div class="line">        <span class="keyword">boolean</span> color = BLACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Entry</code>是红黑树的结点类型, 除了K和V外, 还包含了左孩子, 右孩子和父结点.</p>
<blockquote>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * The comparator used to maintain order in this tree map, or</div><div class="line">   * null if it uses the natural ordering of its keys.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@serial</span></div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器, 可以通过构造函数赋值</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//红黑树的根结点</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The number of entries in the tree</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">//红黑树中的结点数</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The number of structural modifications to the tree.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">//用于实现fast-fail机制</span></div></pre></td></tr></table></figure>
<blockquote>
<h4 id="put-K-V"><a href="#put-K-V" class="headerlink" title="put(K, V)"></a>put(K, V)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//如果没有根结点的话, 证明树是空的</span></div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">//有指定比较器的情况</span></div><div class="line">        do &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用默认的Key自然顺序插入结点</span></div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        do &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key); <span class="comment">//比较</span></div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>); <span class="comment">//找到合适的插入位置</span></div><div class="line">    &#125;</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    fixAfterInsertion(e); <span class="comment">//恢复红黑树的特性</span></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入操作分为两种情况:</p>
<ul>
<li>根结点为空(红黑树为空): 直接将新结点赋值给根结点</li>
<li>根结点不为空:如果有指定比较器的话, 使用比较器来新结点的父节点. 没有的话, 根据Key的自然顺序来找新结点的父结点.</li>
</ul>
<p>插入结点后, 可能会违背红黑树的特性, 因此, 每次插入后, 都需要进行一些操作来恢复红黑树的特性.</p>
<blockquote>
<h4 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get</code>操作是获取key对应的value. 方法中主要调用了<code>getEntry(key)</code>来获取结点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key); <span class="comment">//如果比较器不为空的话, 使用指定的比较器来比较</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">//不支持Key为null的操作</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">//循环比较查找, 如果比较结果是&lt;0的话, 向左子树查找, &gt;0的话向右子树查找, 知道等于.</span></div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据二叉查找树的特性, 先比较结点, 如果大于0, 则向右子树查找, 如果小于0, 则左子树查找, 直到找到等于的结点.<br>如果不存在的话, 返回 null;</p>
<blockquote>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key); <span class="comment">//获取结点</span></div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    V oldValue = p.value;</div><div class="line">    deleteEntry(p); <span class="comment">//从红黑树中删除结点, 并做恢复红黑树特性的操作</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>remove</code>操作分两步: 获取要删除的结点, 找得到的话, 从红黑树中删除, 并且做恢复红黑树的操作, 最后返回被删除的结点; 如果找不到结点, 返回null.</p>
<blockquote>
<h4 id="firstKey和firstEntry"><a href="#firstKey和firstEntry" class="headerlink" title="firstKey和firstEntry"></a>firstKey和firstEntry</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">firstKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> key(getFirstEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>firstKey</code>是获取最小的Key值. 主要实现是在<code>getFirstEntry()</code>中, key(Entry)只是提取Entry中的key.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) <span class="comment">//循环遍历左子树</span></div><div class="line">            p = p.left;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据二叉查找树的特性, 想要获取树的最小值, 只要一直遍历左子树, 就能得到.</p>
<p>firstEntry的实现跟firstKey差不多.  不同的是, firstEntry得到Entry后, 会被包装成一个不可改变的Entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> :</div><div class="line">        <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Entry</code>在这个方法中被包装成了一个不可改变Value的Entry, 我们来看看为什么不改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>setValue</code>是SimpleImmutableEntry中的方法, 只要调用了, 都会抛出一个异常, 因此不支持改变Value.</p>
<p>与<code>firstKey</code>和<code>firstValue</code>对应的有<code>lastKey</code>和<code>lastValue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">lastKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> key(getLastEntry());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exportEntry(getLastEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>操作的思想都差不多, lastXX是获取Key最大的结点. 因此, 在查找时会循环查找右子树.</p>
<blockquote>
<h4 id="NavigableMap接口"><a href="#NavigableMap接口" class="headerlink" title="NavigableMap接口"></a>NavigableMap接口</h4></blockquote>
<p>接着, 我们来看看<code>NavigableMap</code>接口中的一些实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回小于Key的最大结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回小于等于Key的最大结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">floorKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回大于等于该Key的最小结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">ceilingKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回大于该Key的最小结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span>; <span class="comment">//删除最小的结点</span></div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span>; <span class="comment">//删除最大的结点</span></div></pre></td></tr></table></figure>
<p>上面的接口是获取红黑树中, 指定的结点. 这些接口的实现的思路都差不多, 这里只分析<code>lowerEntry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exportEntry(getLowerEntry(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的实现在<code>getLowerEntry</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; <span class="comment">//如果大于0,</span></div><div class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</div><div class="line">                p = p.right;  <span class="comment">//查找右子树,</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p; <span class="comment">//返回小于Key的最大值</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果&lt;=0</span></div><div class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</div><div class="line">                p = p.left; <span class="comment">//查找左子树</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//回退父结点查找</span></div><div class="line">                Entry&lt;K,V&gt; parent = p.parent;</div><div class="line">                Entry&lt;K,V&gt; ch = p;</div><div class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</div><div class="line">                    ch = parent;</div><div class="line">                    parent = parent.parent;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> parent;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面都是在二叉查找树中查找符合一定条件的结点的算法.没什么好说的.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    Entry&lt;K,V&gt; lastReturned;</div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line"></div><div class="line">    PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = <span class="keyword">null</span>;</div><div class="line">        next = first;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        next = successor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">prevEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        next = predecessor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="comment">// deleted entries are replaced by their successors</span></div><div class="line">        <span class="keyword">if</span> (lastReturned.left != <span class="keyword">null</span> &amp;&amp; lastReturned.right != <span class="keyword">null</span>)</div><div class="line">            next = lastReturned;</div><div class="line">        deleteEntry(lastReturned);</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PrivateEntryIterator</code>是<code>TreeMap</code>的基类迭代器, 提供了默认的一些操作.</p>
<p><code>nextEntry()</code>是获取下一个结点.主要获取的实现是在<code>successor</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123; <span class="comment">//如果右子树不为空的话,</span></div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) <span class="comment">//循环查找左子树, 找到大于t的最小结点</span></div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//为空的话, 回退到父结点, 查找大于t的最小结点</span></div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>successor(Entry)</code>的作用是, 在红黑树中找出比给定结点大的最小结点. <code>PrivateEntryIterator</code>构造函数传入的是红黑树中最小的结点. 所以循环调用<code>successor</code>的话, 得到的结点是按Key排序的, 换句话说: 遍历调用nextEntry函数, 得到的Entry顺序是按Key升序的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">prevEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = next;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    next = predecessor(e);</div><div class="line">    lastReturned = e;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理, <code>preEntry</code>是得到前一个结点.</p>
<p>接着我们来看看<code>PrivateEntryIterator</code>的子类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">     ValueIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">         <span class="keyword">super</span>(first);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> nextEntry().value;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">     KeyIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">         <span class="keyword">super</span>(first);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> nextEntry().key;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>KeyIterator</code> 继承了<code>PrivateEntryIterator</code>, 并提供了next()方法, 用于获取下一个key. <code>ValueIterator</code>也是同样的操作. 我们再来看看, 构造函数传入的是什么结点?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Iterator&lt;K&gt; <span class="title">keyIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(getFirstEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面分析过, <code>getFirstEntry()</code>是获取key最小的一个结点. 所以 循环调用<code>KeyIterator</code>的<code>next()</code>, 得到的是按Key升序的序列.</p>
<p>那有没有按Key降序的迭代器? 有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingKeyIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">        DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">            <span class="keyword">super</span>(first);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> prevEntry().key;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            deleteEntry(lastReturned);</div><div class="line">            lastReturned = <span class="keyword">null</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>DescendingKeyIterator</code>为反向Key的迭代器, 使用该迭代器遍历的时候, 得到的序列是Key的降序序列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Iterator&lt;K&gt; <span class="title">descendingKeyIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingKeyIterator(getLastEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次传入<code>DescendingKeyIterator</code>构造函数的Entry都是最大的结点.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><code>TreeMap</code>就讲到这里了. <code>Map</code>家族大概在这里就讲完了. 下篇会将<code>Set</code>家族, <code>Set</code>集合是基于<code>Map</code>来操作的, 如果理解<code>Map</code>集合后, <code>Set</code>会很好理解.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次要介绍的&lt;code&gt;Map&lt;/code&gt;跟之前介绍的&lt;code&gt;Map&lt;/code&gt;有点不一样. 之前的&lt;code&gt;Map&lt;/code&gt;, 例如: &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;都是基于散列技术. 而这次
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-WeakHashMap,%20IdentityHashMap%20%E5%92%8C%20HashTable/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable/</id>
    <published>2017-08-28T14:13:34.451Z</published>
    <updated>2017-08-28T14:13:34.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2></blockquote>
<p><code>WeakHashMap</code>总体实现和<code>HashMap</code>差不多, 不同的时, <code>WeakHashMap</code>中的Key是弱引用类型, <code>WeakHashMap</code>内部的Key是会被自动回收的. 另外需要关注的是, <code>WeakHashMap</code>并没有向<code>HashMap</code>那样, 在1.8做了优化.</p>
<blockquote>
<h3 id="弱引用Key"><a href="#弱引用Key" class="headerlink" title="弱引用Key"></a>弱引用Key</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    V value;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates new entry.</div><div class="line">     */</div><div class="line">    Entry(Object key, V value,</div><div class="line">          ReferenceQueue&lt;Object&gt; queue,</div><div class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(key, queue);</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.hash  = hash;</div><div class="line">        <span class="keyword">this</span>.next  = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (K) WeakHashMap.unmaskNull(get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">        K k1 = getKey();</div><div class="line">        Object k2 = e.getKey();</div><div class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">            V v1 = getValue();</div><div class="line">            Object v2 = e.getValue();</div><div class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        K k = getKey();</div><div class="line">        V v = getValue();</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>内部的结点是继承弱引用类型, 并且指定了一个<code>ReferenceQueue&lt;Object&gt;</code>, 当Key被GC回收时, Key对应的对象会被添加到<code>ReferenceQueue&lt;Object&gt;</code>这个队列中. 这个队列是定义在<code>WeakHashMap</code>内部的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Reference queue for cleared WeakEntries</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>的实现原理跟<code>HashMap</code>是差不多的. 不过<code>HashMap</code>在1.8后, 做了很多优化, 但是<code>WeakHashMap</code>并没有跟随<code>HashMap</code>进行优化.</p>
<p>由于<code>WeakHashMap</code>和<code>HashMap</code>差不多, 我们只分析重要的实现方法.</p>
<p><code>WeakHashMap</code>的增删查改, 都会做一个同步操作, 什么是同步操作? 因为<code>WeakHashMap</code>的Key是弱引用类型, Key值会随时被GC回收. 虽然Key被回收了,但是对应的Value还是没有被回收的. 所以, 同步操作就是移除被回收Key对应的Value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunges stale entries from the table.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123; <span class="comment">//判断queue队列中是否有被回收的Key, 有的话, 需要移除对应Value</span></div><div class="line">        <span class="keyword">synchronized</span> (queue) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</div><div class="line"></div><div class="line">            Entry&lt;K,V&gt; prev = table[i];</div><div class="line">            Entry&lt;K,V&gt; p = prev;</div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                Entry&lt;K,V&gt; next = p.next;</div><div class="line">                <span class="keyword">if</span> (p == e) &#123;</div><div class="line">                    <span class="keyword">if</span> (prev == e)</div><div class="line">                        table[i] = next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        prev.next = next;</div><div class="line">                    <span class="comment">// Must not null out e.next;</span></div><div class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></div><div class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></div><div class="line">                    size--;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                prev = p;</div><div class="line">                p = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是同步操作的方法, <code>WeakHashMap</code>增删改查时, 都会调用的方法. 原理是这样的: 每当弱引用类型Key被GC回收时, 由于<code>WeakHashMap</code>内部指定了<code>ReferenceQueue&lt;Object&gt;</code>, 因此, 被移除的Key会被添加到该队列. 这个方法就是调用队列的<code>poll()</code>方法, 获得被移除的Key, 然后利用该Key, 移除在<code>WeakHashMap</code>内部对应的Value.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li><p><code>WeakHashMap</code>和<code>HashMap</code>一样, Key和Value都支持null.</p>
</li>
<li><p><code>WeakHashMap</code>内部的继承WeakReference, 将Key指定为弱引用类型, 这样Key会被自动回收. 虽然Key会被自动回收, 但是Value不会被自动回收. 因此, <code>WeakHashMap</code>内部每次增删改查时, 都会做同步操作.</p>
</li>
</ul>
<blockquote>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2></blockquote>
<p><code>IdentityHashMap</code>继承于<code>AbstractMap</code>,并实现了<code>Map</code>接口. 总体来说, <code>IdentityHashMap</code>跟<code>HashMap</code>差别还是很大的. 虽然继承结构相同, 但是实现的思想却是截然不同.</p>
<p><code>IdentityHashMap</code>内部并没有结点, 它的Key和Vaule都是储存在数组内的. 因此, <code>IdentityHashMap</code>解决的冲突是开放地址法.</p>
<p>上面说到<code>IdentityHashMap</code>的Key和Value都是存在数组内的. Key和Value总是连续的存放.</p>
<p>另外值得一提的是: <code>IdentityHashMap</code>是利用 <code>==</code>来比较Key的相等性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    init(DEFAULT_CAPACITY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2</span></div><div class="line">    <span class="comment">// assert initCapacity &gt;= MINIMUM_CAPACITY;</span></div><div class="line">    <span class="comment">// assert initCapacity &lt;= MAXIMUM_CAPACITY;</span></div><div class="line"></div><div class="line">    table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>默认的容量是64. 长度跟<code>HashMap</code>一样, 都是2的次幂.还是跟之前的套路一样, 只分析一些重要的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object k = maskNull(key);</div><div class="line"></div><div class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> Object[] tab = table;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</div><div class="line">        <span class="keyword">int</span> i = hash(k, len); <span class="comment">//获得数组的index</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>; <span class="comment">//有冲的话, 查找下一个index</span></div><div class="line">             i = nextKeyIndex(i, len)) &#123;</div><div class="line">            <span class="keyword">if</span> (item == k) &#123;</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</div><div class="line">                tab[i + <span class="number">1</span>] = value;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</div><div class="line">        <span class="comment">// Use optimized form of 3 * s.</span></div><div class="line">        <span class="comment">// Next capacity is len, 2 * current capacity.</span></div><div class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len)) <span class="comment">//当储存的元素大于 容量的3分之一的话, 扩容</span></div><div class="line">            <span class="keyword">continue</span> retryAfterResize;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        tab[i] = k;</div><div class="line">        tab[i + <span class="number">1</span>] = value; <span class="comment">//Value始终是保存在Key的下个index</span></div><div class="line">        size = s;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>hash</code>函数, 获得index, 如果index对应已经存有元素的话, 会调用<code>nextKeyIndex(int, int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>是使用开放地址法解决冲突. 当发生冲突时, 它会寻找下个位置, 而下个位置是 i + 2. 之所以是i + 2,而不是i + 1的原因是 Key和Value总是连续的储存的, 因此寻找下个位置时, 需要跳多一个位置.如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fip01fuwt1j30er06bmx6.jpg" alt=""></p>
<p>如果index没有储存元素的话, 会先检查内部储存元素数量是不是大于容量的1/3, 是的话会进行扩容操作.每次扩容都是扩为原来的2倍.</p>
<blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2></blockquote>
<p><code>HashTable</code>是一个遗留类, 已经被<code>HashMap</code>替代了. 从功能上来说, 跟HashMap差不多. 主要比较它跟<code>HashMap</code>的异同.</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><code>HashMap</code>是允许K或者V为null的, 但是<code>HashTable</code>不允许K或者V为null</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><code>HashMap</code>是线程不安全的, 而<code>HashTable</code>是线程安全的, 因为内部的方法都是加了锁. 但是在并发的环境, 不建议使用<code>HashTable</code>, 应该使用<code>ConcurrentHashMap&lt;K,V&gt;</code>. <code>ConcurrentHashMap&lt;K,V&gt;</code>是使用分段锁来控制同步, 显然性能上要比<code>HashTable</code>好.</p>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p><code>HashMap</code>的容量为2的n次幂, 而<code>HashTable</code>为素数.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;W
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-LinkHashMap</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkHashMap/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合框架-LinkHashMap/</id>
    <published>2017-08-28T14:09:08.211Z</published>
    <updated>2017-08-28T14:09:08.211Z</updated>
    
    <content type="html"><![CDATA[<p>上篇我们分析了<code>HashMap</code>, 知道了遍历<code>HashMap</code>时, 顺序是不能够保证的.如果遍历时需要顺序, 那么应该用<code>LinkedHashMap</code>, 也就是我们这次要来分析的另外一个集合类.</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fio5jh7fepj30lg0hkgm9.jpg" alt=""></p>
<p>从UML图来看, <code>LinkedHashMap</code>的继承于<code>HashMap</code>, 可见<code>LinkedHashMap</code>是基于<code>HashMap</code>来扩展的. 如果理解了<code>HashMap</code>的话, 那<code>LinkedHashMap</code>应该算是很简单了.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<ul>
<li><p><code>LinkedHashMap</code>是底层的数据结构是<code>HashMap</code>和<code>双向链表</code>. <code>LinkedHashMap</code>内部维护着一条双向链表, 在遍历<code>LinkedHashMap</code>时, 会遍历内部的链表, 这样就可以保证遍历的顺序是特定的.至于遍历的顺序, 有两种可选: 按照插入的顺序(默认); 按照访问的顺序(结点每次被访问时, 都会把结点移动到链表尾).</p>
</li>
<li><p>由于<code>LinkedHashMap</code>内部维护一条链表, 因此它在性能上要稍微逊色于<code>HashMap</code>.</p>
</li>
</ul>
<blockquote>
<h3 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * HashMap.Node subclass for normal LinkedHashMap entries.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>内部的Entry继承于<code>HashMap.Entry</code>, 并且加了两个成员变量, 用来记录前一个结点和后后一个结点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The head (eldest) of the doubly linked list.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The tail (youngest) of the doubly linked list.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</div></pre></td></tr></table></figure>
<p><code>head</code>为头结点, <code>tail</code>为尾结点. 分析到这里, 我们可以确认<code>LinkedHashMap</code>内部确实维护一条双向链表.</p>
<blockquote>
<h3 id="hock函数"><a href="#hock函数" class="headerlink" title="hock函数"></a>hock函数</h3></blockquote>
<p>还记得上次分析<code>HashMap</code>时,说过<code>HashMap</code>留给<code>LinkedHashMap</code>的三个hock函数吗? 不记得的话也没关系, 耐心看下面的分析就会想起来了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125; <span class="comment">//结点被访问后, LinkedHashMap回调的函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125; <span class="comment">//结点插入时, LinkedHashMap回调的函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125; <span class="comment">//结点被移除时, LinkedHashMap回调的函数</span></div></pre></td></tr></table></figure>
<p>上面三个hock函数定义在<code>HashMap</code>内部, 并且为空的函数.这三个函数是预留给<code>LinkedHashMap</code>用的. 当结点被访问, 插入和被移除时,<code>LinkedHashMap</code>回调的函数.</p>
<blockquote>
<h3 id="put-K-V-和afterNodeInsertion-boolean-evict"><a href="#put-K-V-和afterNodeInsertion-boolean-evict" class="headerlink" title="put(K, V)和afterNodeInsertion(boolean evict)"></a>put(K, V)和afterNodeInsertion(boolean evict)</h3></blockquote>
<p><code>LinkedHashMap</code>内部没有重写<code>put(K, V)</code>函数, 意味着它的话复用了<code>HashMap</code>的<code>put(K, V)</code>方法, 那…我们暂且回调<code>HashMap</code>吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict); <span class="comment">//回调函数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>put(K, V)</code>内部会调用<code>afterNodeInsertion(evict)</code>. 回到<code>LinkedHashMap</code>看看这个函数的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>这个函数的实现是为了移除比较<code>老</code>的元素(越<code>老</code>的元素会在链表的越前面).但是这个函数的默认实现总是不会移除<code>老</code>的元素. 因为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法一直返回false. 重写这个方法, 我们可以控制当<code>LinkedHashMap</code>内部的元素数量达到一定数量时, 移除比较老的元素.</p>
<p>前面说<code>LinkedHashMap</code>是可以根据插入的顺序进行遍历, 那么内部肯定在<code>put(K, V)</code>的时候, 会构造链表.那么构造的操作在哪里?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>重写了newNode(int, K, V, Node<v, k="">), 在其中写了构造链表的逻辑. 具体实现<code>linkNodeLast</code></v,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//如果为尾结点为空,证明链表为空, 直接将头结点和为结点指点新插入的结点</span></div><div class="line">        head = p;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//插入新结点</span></div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的逻辑为向双向链表中插入结点.</p>
<blockquote>
<h3 id="get-K-和afterNodeAccess-Node-e"><a href="#get-K-和afterNodeAccess-Node-e" class="headerlink" title="get(K)和afterNodeAccess(Node e)"></a>get(K)和afterNodeAccess(Node<k,v> e)</k,v></h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面我们说过, <code>LinkedHashMap</code>支持按照访问的顺序来遍历.而get(K)操作正是访问操作. 默认情况下, <code>LinkedHashMap</code>是按照插入顺序来遍历的, 因为字段<code>accessOrder</code>字段默认为<code>false</code>, 如果要支持按照访问顺序的话, 需要显示调用这个构造方法, 将<code>accessOrder</code>指定为<code>true</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor,</span></span></div><div class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们接着看看<code>afterNodeAccess</code>这个回调函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的逻辑为: 将访问的结点移动到链表的尾端.</p>
<p>至于<code>remove(K)</code>函数和<code>afterNodeRemoval(Node&lt;K,V&gt; e)</code>的关系和前面将的两个回调函数的思想一样. <code>remove(K)</code>内部会回调<code>afterNodeRemoval(Node&lt;K, V&gt; e)</code>函数, <code>afterNodeRemoval(Node&lt;K, V&gt; e)</code>会将结点从双向链表中移除.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<p>和<code>HashMap</code>一样, 内部有提供了三个视图(KeySet, ValueSet, set<entry<k, v="">), 因此, <code>LinkedHashMap</code>内部也有三个迭代器. 不同的是, <code>LinkedHashMap</code>迭代器的遍历顺序是有的. 下面我只分析<code>LinkedValueIterator</code>.</entry<k,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line"></div><div class="line">    LinkedHashIterator() &#123;</div><div class="line">        next = head;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        current = e;</div><div class="line">        next = e.after;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; p = current;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        K key = p.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashIterator</code>是<code>LinkedHashMap</code>内部迭代器的基类, 在构造函数将链表的头结点复制给 <code>next</code>, 然后<code>nextNode()</code>函数内, 顺序的访问之前构造好的链表.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着<code>LinkedValueIterator</code>继承了<code>LinkedHashIterator</code>, 提供了一个<code>next()</code>的方法.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><p><code>LinkedHashMap</code>是基于<code>HashMap</code>来实现的, 它和<code>HashMap</code>不同之处是: 遍历元素的时候的是有序的. 因为它内部维护了一个双向链表. 遍历的顺序可以有两种: 按照结点的插入顺序; 按照元素被访问的顺序.默认是按结点被插入的顺序.</p>
</li>
<li><p><code>LinkedHashMap</code>可以用来实现<code>LRU</code>缓存.</p>
</li>
<li><p>由于<code>LinkedHashMap</code>内部维护了一个双向链表, 因此, 在性能上要稍微逊色于<code>HashMap</code>.</p>
</li>
<li><p>如果对遍历元素的顺序是无要求的话, 应该使用<code>HashMap</code>, 反之应该使用<code>LinkedHashMap</code>.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇我们分析了&lt;code&gt;HashMap&lt;/code&gt;, 知道了遍历&lt;code&gt;HashMap&lt;/code&gt;时, 顺序是不能够保证的.如果遍历时需要顺序, 那么应该用&lt;code&gt;LinkedHashMap&lt;/code&gt;, 也就是我们这次要来分析的另外一个集合类.&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合-HashMap</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88-HashMap/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合-HashMap/</id>
    <published>2017-08-28T13:59:50.176Z</published>
    <updated>2017-08-28T13:59:50.176Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章分别介绍了<code>ArrayList</code>和<code>LinkedList</code>, 这次我们来分析另外一个key-value键值对的映射集合-HashMap.按照前面的习惯,我们先来看看<code>HashMap</code>的UML</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimu0do73tj30ii0cv3z0.jpg" alt=""></p>
<p><code>HashMap</code>实现了<code>Cloneable</code>, <code>Serializable</code>, 所以<code>HashMap</code>支持克隆(浅克隆)和序列化. <code>Map</code>接口提供了一系列接口和三个视图. <code>AbstractMap</code>则是实现了<code>Map</code>接口, 并且实现了<code>Map</code>接口中的一些方法, 换句话说<code>AbstractMap</code>是<code>Map</code>家族里面的一个基本骨架, 具体的子类根据需要重写<code>AbstractMap</code>中的方法即可.</p>
<blockquote>
<h2 id="回顾Hash表"><a href="#回顾Hash表" class="headerlink" title="回顾Hash表"></a>回顾Hash表</h2></blockquote>
<p>学过数据结构的都应该清楚, Hash表是将一个key的hash值取模后映射到一个数组中的特定位置. 但是, 随着Hash表中的键值对的增多, 会出现冲突. 所谓的冲突是两个key的hash值取模后得到的数定位到了数组中的相同位置.对于冲突这种情况, 常用的解决方法有:开放地址法和链地址法.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>回顾完了Hash表的基础知识后, 我们来讲讲<code>HashMap</code>的实现方式.</p>
<p>总体来说, <code>HashMap</code>的实现为: 数组+链表+红黑树. 当出现冲突时, <code>HashMap</code>是使用链地址法来解决冲突.但是如果冲突越来越多, 链表就会变得越来越长.这样导致的结果是:原本访问一个Key对应的value的时间复杂度会从O(1)退化为O(n).因此, <code>HashMap</code>使用一种名为红黑树的数据结构来解决时间复杂度退化的这个问题.红黑树查找key值对应的value的时间复杂度为O(log n)(优于O(n)).</p>
<p>下面, 先来看看<code>HashMap</code>中的字段, 我们将重点介绍两个字段. 这两个字段影响着<code>HashMap</code>的性能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The table, initialized on first use, and resized as</div><div class="line"> * necessary. When allocated, length is always a power of two.</div><div class="line"> * (We also tolerate length zero in some operations to allow</div><div class="line"> * bootstrapping mechanics that are currently not needed.)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//内部的数组</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</div><div class="line"> * for keySet() and values().</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//返回包含key-value的视图</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of key-value mappings contained in this map.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//内部储存的key-value的个数</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of times this HashMap has been structurally modified</div><div class="line"> * Structural modifications are those that change the number of mappings in</div><div class="line"> * the HashMap or otherwise modify its internal structure (e.g.,</div><div class="line"> * rehash).  This field is used to make iterators on Collection-views of</div><div class="line"> * the HashMap fail-fast.  (See ConcurrentModificationException).</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//记录内部数据结构发生变化的次数, 主要用来实现fail-fast</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next size value at which to resize (capacity * load factor).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></div><div class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></div><div class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></div><div class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The load factor for the hash table.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<p>loadFactor是负载因子, 这个字段表示<code>HashMap</code>内部容量满载的一个界限. threshold为扩容的界限,它的计算公式为: threshold = capacity * loadFactor.当size &gt; threshold时, <code>HashMap</code>内部就会扩容.</p>
<p><code>loadFactor</code>内部默认实现为0.75. 这个数值是时间和空间的一个折中值.<code>loadFactor</code>如果设置为比较大, 也就是<code>threshold</code>会比较大, 那么空间的利用率就会变大, 但是空间利用率变大的代价是查找速度变慢了, 因因为冲突率会提高. 如果<code>loadFactor</code>设置为比较小的话, <code>threshold</code>会比较小, 虽然冲突率会变小, 因为会频繁扩容.但这也一定程度上浪费空间内存.</p>
<blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote>
<p><code>HashMap</code>的构造函数有几个重载, 我们既可以使用无参的构造方法, 使用内部默认指定的<code>capacity</code>和<code>loadFactor</code>.也可以调用指定这两个参数的构造函数.</p>
<p>如果没有特殊情况.我们一般调用无参的构造函数.它会帮我们指定默认的<code>loadFactor</code>.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>put</code>函数是往<code>HashMap</code>中添加元素, 在分析添加元素的实现之前, 我们先来看看<code>hash(key)</code>函数,得到的hash值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4></blockquote>
<p><code>hash</code>函数的实现思路: 将key的hashCode的高16位和低16位作异或操作.至于为什么是要这样操作?</p>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<p>分析完了<code>hash(int key)</code>函数, 我们回到<code>put(K key)</code>, 来看看真正的添加操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//检查HashMap是否为空</span></div><div class="line">        n = (tab = resize()).length; <span class="comment">//空的话, 先进行扩容</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断HashMap中有没有存该Key</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//没有存该值, 直接赋值.</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//HashMap不为空的情况.</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//判断HashMap有没存该Key</span></div><div class="line">            e = p; <span class="comment">//没有的话直接赋值</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断这个结点是不是红黑树结点</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); 是的话, 插入到红黑树结构中</div><div class="line">        <span class="keyword">else</span> &#123; <span class="comment">//插入到链表结构中</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash); <span class="comment">//如果链表的结点个数为8的话, 将链表转化为红黑树, 这样提高查找的速度</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e); <span class="comment">//hock函数, 用于LinkHashMap中</span></div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//如果size &gt; threshold的话, 需要进行扩容</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面注释已经将函数解析得挺清楚了, 下面主要介绍这个<code>hash &amp; (n - 1)</code>操作. <code>hash &amp; (n - 1)</code>其实等价于取模操作, 但是比普通的 % 操作高效, 因为<code>hash &amp; (n - 1)</code>运用的位运算.</p>
<p>一个数和2的n次方进行去模操作, 余数是由这个数的低n决定,所以<code>hash &amp; (n - 1)</code>就是取得hash的底n位,也就是余数.如下图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimz01cbwzj30d60dm74h.jpg" alt=""></p>
<p>前面说过<code>HashMap</code>内部的长度总是为2的次方, <code>n</code>为<code>HashMap</code>的长度,所以跟上面的例子原理一样.</p>
<p><code>afterNodeAccess(e);</code>和<code>afterNodeInsertion(evict);</code>是hock函数, 是预留给<code>LinkedHashMap</code>使用的.</p>
<p>链表的构造使用的是头插法, 后插入的会在链表头.</p>
<p>如果一直向<code>HashMap</code>中添加元素的话, 其内部会扩容, 扩容通俗地说就是用更大的数组来代替之前的小数组以装下更多的元素.1.8的<code>HashMap</code>内部的扩容机制做了一些优化, 接下来, 我们来详细分析其中的优化.</p>
<blockquote>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩大为原来的两倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>resize()</code>函数为<code>HashMap</code>的扩容机制,扩容的情况有两种, 一种的初始化默认的容量, 另外一种是扩大为原来的两倍.</p>
<p>扩大容量后, 还需要把原来的数据搬到新的数组中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">            oldTab[j] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//定位到新的位置, 并且赋值</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">//如果结点是红黑树的结点的话, 会进行修剪树的操作</span></div><div class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order 头结点后面有元素,且为链表的结构</span></div><div class="line">              <span class="comment">//重新定位链表的策略: 定义两条链表, 构造完链条链表后, 再将他们的头结点定位到数组对应的index</span></div><div class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">//留在原来的位置的链表</span></div><div class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">//移动在原来位置+2的n次方位置的链表</span></div><div class="line">                Node&lt;K,V&gt; next;</div><div class="line">                do &#123;</div><div class="line">                    next = e.next;</div><div class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//新增位为0</span></div><div class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                            loHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            loTail.next = e;</div><div class="line">                        loTail = e;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//新增位为1</span></div><div class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                            hiHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            hiTail.next = e;</div><div class="line">                        hiTail = e;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    loTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    hiTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合代码中的注释, 我们来解析这个扩容机制, 首先遍历原来的数组, 然后拿到每个位置的头结点, 再判断头结点后面有没有元素, 没有的话, 直接用<code>&amp;</code>运算定位到新的位置.如果有的话, 先判断这个结点是不是红黑树的结点, 是的话做修剪树的操作.不是的话, 说明后面的结点的结构是链表.</p>
<p>前面说过, <code>HashMap</code>的每次扩容为原来的2倍, 这样的话, 原来的元素不是定位到原地, 就是在原地移动2的次幂.我们结合扩容前和扩容后的图来解释:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin22vrzufj30nb0c50tb.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin27c3g43j30o10bpmxq.jpg" alt=""></p>
<p>扩容后,决定位置的位数多了一位, 拿16扩容到32来说, 16的时候, 决定位置是由结果的后4位来决定, 如果扩容为32位后, 决定位置是由结果的后5位.如果新增的那一位为0的话,表示新的位置是原来的位置, 如果为1的话, 新的位置为原来的位置 + 原来的容量(原来的容量为2的n次方).</p>
<p>所以代码中<code>e.hash &amp; oldCap</code>就是为了取得新增的那一位, 如果为0的话, 说明新的位置为原来的位置, 如果为1的话,则需要移动2的n次幂(也就是 原来的位置 + 旧的容量).</p>
<p>上面重新组装链表的时候, 思路是这样的: 因为新的位置不是在原来的位置, 就是需要在原来的位置上移动2的次幂.所以, 定义两条链表, 一条表示新位置是原来的位置的链表(简称L1), 另外一条表示新的位置在原来的位置移动2的次幂(简称L2). 接着会先遍历原来的链表, 再进行<code>e.hash &amp; oldCap</code>, 如果为0的话, 将该结点插入到L1, 如果为1的话, 插入到L2. 插入的方法为尾插法, 这样重构后的链表不会乱序(1.7之前的版本是会乱序的). 最后,将新构造的两条链表定位到对应的位置,也就是下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">    loTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">    hiTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.8的扩容机制的优化主要是不需要再重新计算hash值, 只是做个<code>&amp;</code>操作就行了, 并且重构后的链表不会乱序. 这种优化的一个重要的前提是容量为2的n次幂. 因此 <code>HashMap</code>内部的容量为什么不定义为素数而是定义为2的n次幂. 这样做是为了减少扩容时的<code>rehash</code>操作.</p>
<p>到这里, 我们已经把<code>HashMap</code>内部的精华都分析完了, 其他操作都挺简单的, 也没什么好讲的.最后, 做个总结</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>hash</code>函数</li>
<li>扩容机制</li>
<li>冲突优化</li>
<li>其他</li>
</ul>
<blockquote>
<h3 id="hash函数-1"><a href="#hash函数-1" class="headerlink" title="hash函数"></a><code>hash</code>函数</h3></blockquote>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<blockquote>
<h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3></blockquote>
<ul>
<li><p><code>HashMap</code>的扩容后的长度总是2的次幂, 这个设置主要是为了优化扩容机制. <code>HashMap</code>内部扩容时,不需要重新计算hash值,并且链表的顺序还是保持原来的顺序.</p>
</li>
<li><p>频繁进行扩容会一定程度上影响<code>HashMap</code>性能.因此,如果预先知道需要储存的数据有很多的话, 可以直接设置一个较大的容量来减少扩容的次数.</p>
</li>
</ul>
<blockquote>
<h3 id="冲突优化"><a href="#冲突优化" class="headerlink" title="冲突优化"></a>冲突优化</h3></blockquote>
<p>对于hash冲突的情况, 如果冲突的链表结点个数大于8的话, <code>HashMap</code>会将链表转化为红黑树的结构, 将查找的复杂度从O(N)优化为O(logN).</p>
<blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></blockquote>
<ul>
<li><p><code>HashMap</code>既支持<code>Key</code>为<code>null</code>, 也支持<code>value</code>为<code>null</code>.</p>
</li>
<li><p>遍历<code>HashMap</code>时, 顺序是不保证的, 如果需要有序的遍历, 应该使用<code>LinkedHashMap</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章分别介绍了&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;, 这次我们来分析另外一个key-value键值对的映射集合-HashMap.按照前面的习惯,我们先来看看&lt;code&gt;HashMap&lt;/code&gt;的UML&lt;/p&gt;
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-ArrayList</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-ArrayList/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合框架-ArrayList/</id>
    <published>2017-08-28T13:42:30.259Z</published>
    <updated>2017-08-28T13:42:30.259Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1filh3gnlr2j30n90iw75f.jpg" alt=""></p>
<p>从上面的UML图, 我们可以看出 ArrayList实现了三个标记接口, 他们分别是:RandomAccess, Serializable, Cloneable. RandomAccess接口表示ArrayList支持随机访问其中的元素, 也就是ArrayList可以随机访问其中的元素, 并且时间复杂度为O(1). Serializable接口表示ArrayList可以被序列化. Cloneable接口说明ArrayList可以被克隆(内部实现为浅克隆).</p>
<p>回到UML图, <code>Collection</code>接口是集合的一个基类接口,它继承了<code>Iterable</code>接口,将遍历的任务交给了Iterable接口. <code>AbstracCollection</code>是一个抽象类, 他实现了<code>Collection</code>接口, 在其内部实现了一些默认行为, 同理<code>AbstractList</code>也是一个抽象类, 实现了<code>List</code>接口的一些默认行为. 从这里可以看出, Java的集合框架用到了适配器的模式, 利用AbstractXX一系列抽象类来实现一些默认行为, 其他的让具体子类去实现或者重写.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>分析完<code>ArrayList</code>的继承结构后, 我们开始来分析<code>ArrayList</code>的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Default initial capacity.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for empty instances.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for default sized empty instances. We</div><div class="line">    * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line">    * first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The array buffer into which the elements of the ArrayList are stored.</div><div class="line">    * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line">    * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line">    * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The size of the ArrayList (the number of elements it contains).</div><div class="line">    *</div><div class="line">    * <span class="doctag">@serial</span></div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>上面为<code>ArrayList</code>中的字段, 其中<code>elementData</code>字段是保存 <code>ArrayList</code>中的元素, 从这点可以看出, <code>ArrayList</code>的底层数据结构是数组. <code>size</code>字段记录集合中的元素.</p>
<blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with an initial capacity of ten.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>平常我们使用ArrayList时, 都会调用空的构造方法, 如上.这个构造方法中, 只是简单的将<code>elementData</code>赋值为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>, 也就是一个空的数组对象. 因为此时我们并没有添加元素, 构造一个空的数组也是合情合理的.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<p>实例已经得到了, 我们来看看添加元素的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Appends the specified element to the end of this list.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们要向集合添加元素, 由于之前我们构造的是一个空的数组, 那么内部肯定会帮我们扩容数组, 也就是<code>ensureCapacityInternal(size + 1)</code>. 我们进入该方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个方法主要是比较一下<code>elementData</code>对象是不是为空, 空的话, 就取<code>DEFAULT_CAPACITY</code>和<code>minCapacity</code>字段的最大值. 由于我们数组的大小为0, 所以, 取得的是<code>DEFAULT_CAPACITY</code>(也就是10). 进入:<code>ensureExplicitCapacity(minCapacity)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>modCount</code>是用来记录<code>ArrayList</code>内部结构发生变化的次数, 主要用来实现<code>fast-fail</code>机制. 接着会调用<code>grow(int)</code>, 该方法是<code>ArrayList</code>扩容的方法.</p>
<p> 我们接下去,看看<code>ArrayList</code>的扩容策略:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//右移1位,也就是除以2</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>扩容的大小为: 新容量 = 旧容量+旧容量 / 2. 在计算出新容量后, 会与旧容量作差, 再根据结果进行扩容. 主要有下面两种情况:</p>
<ul>
<li>当初始化时(也就是调用空的构造方法), 首次添加会扩容为10.</li>
<li>下次扩容时, 会加上原来容量的一半.</li>
</ul>
<blockquote>
<h3 id="随机访问元素"><a href="#随机访问元素" class="headerlink" title="随机访问元素"></a>随机访问元素</h3></blockquote>
<p>经过前面的分析, <code>ArrayList</code>实现了<code>RandomAccess</code>接口, 表示<code>ArrayList</code>具有随机访问元素的能力, 这种能力是数组本身就有的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>get(E)</code>中, 会首先检查一下index是否会越界, 会的话, 直接抛异常, 不会的话, 直接访问数组对应的index.</p>
<blockquote>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>ArrayList</code>中的移除元素的方法. 首先检查边界, 没有越界的话, 通过index访问元素. 接着再将index后面的元素向先移动. 最后手动将被移除的元素复制为null, 让其能够被GC回收.</p>
<p>这里需要注意的是: 虽然元素被移除了, 但是空间还是留着.</p>
<blockquote>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3></blockquote>
<p>在Java集合框架中, 使用了迭代器模式去遍历集合中的元素, 这使得在遍历元素时, 不用去关心集合的底层实现的数据结构, 各种集合只需要实现符合自己数据结构的迭代器.</p>
<p>在<code>ArrayList</code>中, 默认实现了两个迭代器, 它们分别是:单向迭代器, 双向迭代器.</p>
<blockquote>
<h4 id="单向迭代器"><a href="#单向迭代器" class="headerlink" title="单向迭代器"></a>单向迭代器</h4></blockquote>
<p>单向迭代器是众多迭代器的最简单的,也是最常用的. 内部实现是只能向一个方向遍历数据.</p>
<blockquote>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4></blockquote>
<p>与单向迭代器比, 双向迭代器能够向两个方向遍历数据</p>
<blockquote>
<h4 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h4></blockquote>
<p>如果一个线程利用迭代器遍历集合时, 另外一个线程向集合中添加元素. 这时会抛出异常. 这也说明了<code>ArrayList</code>是线程不安全的.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>ArrayList</code>实现的底层数据结构为数组.</li>
<li>由于<code>ArrayList</code>是基于数组来实现的, 因此决定了<code>ArrayList</code>的使用场景. 它适合用在需要频繁访问元素的场景, 因为其快速访问特性. 但是它不适合使用在需要频繁随机插入和删除的场景, 因为数组每次随机插入和删除元素时, 都需要移动后面的元素.</li>
<li><code>ArrayList</code>具有自动扩容的特性, 默认的容量为10, 后面每次扩容都会增加原来的一半.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-LinkedList</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkedList/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合框架-LinkedList/</id>
    <published>2017-08-28T13:41:24.091Z</published>
    <updated>2017-08-28T13:41:24.091Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们学了<code>ArrayList</code>, 知道了<code>ArrayList</code>比较适合需要频繁访问元素的场景. 但是在插入和删除元素时, 表现得效率低下. 这次, 我们来分析适合使用在频繁插入和删除元素的场景的集合: <code>LinkedList</code>.</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1filur9c5nfj30p10h7dh8.jpg" alt=""></p>
<p>我们先来看看UML图, <code>LinkedList</code>在继承关系上, 跟<code>ArrayList</code>基本相同. 我们这里只分析不同点.</p>
<ul>
<li><code>LinkedList</code>继承<code>AbstractSequentialList</code>, <code>AbstractSequentialList</code>这个是顺序访问列表的默认实现类, 换句话说, <code>LinkedList</code>访问元素时, 是顺序访问的, 不是像<code>ArrayList</code>那样, 具有随机访问元素的能力.</li>
<li>由于<code>LinkedList</code>是顺序访问列表, 因此它并没有实现<code>RandomAccess</code>接口.</li>
<li><code>LinkedList</code>实现了<code>Deque</code>接口, <code>Deque</code>接口是双向队列的一个接口.因此<code>LinkedList</code>可以看做是一个双端队列. 而且它还可以作为栈来使用.</li>
</ul>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Pointer to first node.</div><div class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line"> *            (first.prev == null &amp;&amp; first.item != null)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Pointer to last node.</div><div class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line"> *            (last.next == null &amp;&amp; last.item != null)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</div></pre></td></tr></table></figure>
<p>我们来先看看<code>LinkedList</code>中的字段. <code>size</code>记录集合内部的元素个数.<code>first</code>和<code>next</code>代表表头和表尾. <code>Node</code>是<code>LinkedList</code>的内部类, 代表链表的结点.从这里可以看出, <code>LinkedList</code>的内部实现是基于双向链表来实现的, 这也解释了为什么<code>LinkedList</code>适合使用在频繁插入和删除的场景.</p>
<blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个构造函数是一个空实现.证明一开始初始化时, 内部是不给结点分配内存的.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<p><code>LinkedList</code>既可以作为双向队列, 也可以作为栈. 说明其支持向队头队尾进行操作.我们接下来分析这些操作</p>
<blockquote>
<h4 id="队头插入元素"><a href="#队头插入元素" class="headerlink" title="队头插入元素"></a>队头插入元素</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the beginning of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkFirst(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the front of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to insert</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerFirst&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Pushes an element onto the stack represented by this list.  In other</div><div class="line"> * words, inserts the element at the front of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to push</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面三个操作都是向队头添加元素, 最终调用<code>addFirst(E)</code>, 而<code>addFirst(E)</code>又会调用<code>linkFirst(E)</code>.向队头插入元素的实现都是这个函数, 我们来分析一波:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Links e as first element.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f); <span class="comment">//创建一个新的结点,</span></div><div class="line">    first = newNode;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        last = newNode; <span class="comment">//如果队列为空的话,</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        f.prev = newNode; <span class="comment">// 队列不为空的话.</span></div><div class="line">    size++;</div><div class="line">    modCount++; <span class="comment">//记录内部结构发生变化的次数, 用于实现fast-fail机制.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>linkFirst</code>函数将一个元素插入到队头, 如果队列为空的话, 会将新插入的元素赋值给队列结点. 如果不为空的话, 将该元素复制为插入前的队头结点的前驱.</p>
<blockquote>
<h4 id="队尾插入元素"><a href="#队尾插入元素" class="headerlink" title="队尾插入元素"></a>队尾插入元素</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the end of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to insert</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerLast&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Adds the specified element as the tail (last element) of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.5</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> add(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法都是向队尾添加元素.它们最终都会调用<code>linkLast</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Links e as last element.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    last = newNode;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>linkLast</code>中的实现会向队尾添加一个结点, 思路和前面的大致一样.这里不多分析.</p>
<blockquote>
<h4 id="指定位置插入"><a href="#指定位置插入" class="headerlink" title="指定位置插入"></a>指定位置插入</h4></blockquote>
<p>既然<code>LinkedList</code>是基于链表来实现的, 那么<code>LinkedList</code>肯定是支持指定位置插入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the specified position in this list.</div><div class="line"> * Shifts the element currently at that position (if any) and any</div><div class="line"> * subsequent elements to the right (adds one to their indices).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</div><div class="line"> * <span class="doctag">@param</span> element element to be inserted</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index == size)</div><div class="line">        linkLast(element);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>add(int, E)</code>方法用于向指定位置插入一个元素, 如果index是等于size的话, 会直接插入到队尾. 如果不是的话, 会用<code>linkBefore(element, node(index))</code>. 我们来看看<code>LinkedList</code>怎么通过index定位到一个结点的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the (non-null) Node at the specified element index.</div><div class="line"> */</div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总体是比较index是否大于size / 2, 小于的话,就从队头遍历, 大于的话从队尾开始遍历. 这里虽然做了一些优化, 但是总体速度还是挺慢的. 接下来的<code>linkBefore</code>就是常规的向一个结点前插入元素的操作.</p>
<blockquote>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3></blockquote>
<p>移除元素的套路跟添加元素的套路一样. 有向队尾,队头,或者指定位置移除元素, 这三种操作, 最后都会调用到下面的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null first node f.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></div><div class="line">    <span class="keyword">final</span> E element = f.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</div><div class="line">    f.item = <span class="keyword">null</span>;</div><div class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    first = next;</div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">        last = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        next.prev = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null last node l.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></div><div class="line">    <span class="keyword">final</span> E element = l.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</div><div class="line">    l.item = <span class="keyword">null</span>;</div><div class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    last = prev;</div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</div><div class="line">        first = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null node x.</div><div class="line"> */</div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert x != null;</span></div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下去的获得元素的操作跟插入元素的思路都差不多.这里不多说.我们接下来看看<code>LinkedList</code>中的迭代器.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<p><code>LinkedList</code>中实现了两个迭代器, 一个是双向迭代器, 另外一个是单向迭代器.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>LinkedList</code>是基于链表来实现的, 决定了它比较适合使用在需要频繁插入和删除的场景. 但是不适合使用在经常要访问特定位置的元素. 因为每次都会遍历链表.</li>
<li><code>LinkedList</code>既可以作为双向队列,也可以作为栈来使用.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们学了&lt;code&gt;ArrayList&lt;/code&gt;, 知道了&lt;code&gt;ArrayList&lt;/code&gt;比较适合需要频繁访问元素的场景. 但是在插入和删除元素时, 表现得效率低下. 这次, 我们来分析适合使用在频繁插入和删除元素的场景的集合: &lt;code&gt;Lin
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>CustomView总结</title>
    <link href="http://cristianoro7.github.io/2017/08/28/CustomView%E6%80%BB%E7%BB%93/"/>
    <id>http://cristianoro7.github.io/2017/08/28/CustomView总结/</id>
    <published>2017-08-28T09:22:00.500Z</published>
    <updated>2017-08-28T09:22:00.500Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# CustomView总结</p>
<blockquote>
<h2 id="LayoutParams认知"><a href="#LayoutParams认知" class="headerlink" title="LayoutParams认知"></a>LayoutParams认知</h2></blockquote>
<h3 id="Q-什么是LayoutParams-它跟view的关系是什么"><a href="#Q-什么是LayoutParams-它跟view的关系是什么" class="headerlink" title="Q: 什么是LayoutParams? 它跟view的关系是什么?"></a>Q: 什么是LayoutParams? 它跟view的关系是什么?</h3><blockquote>
<h4 id="什么是LayoutParams"><a href="#什么是LayoutParams" class="headerlink" title="什么是LayoutParams?"></a>什么是LayoutParams?</h4></blockquote>
<p>我们在XML布局中定义的layout_xx属性,最终都会以Java代码的形式展现出来, 而LayoutParams就是这些layout_xx属性在Java层的映射, 也就是说LayoutParams是view在xml布局中layout_xx的属性容器.</p>
<p>可见, LayoutParams是子View跟父View进行协商的桥梁. 协商的内容可有: 子View宽高, 子View在父View中摆放的位置等.</p>
<blockquote>
<h4 id="LayoutParams的继承关系"><a href="#LayoutParams的继承关系" class="headerlink" title="LayoutParams的继承关系"></a>LayoutParams的继承关系</h4></blockquote>
<p>LayoutParams是作为内部类定义在ViewGroup中,下面是LayoutParams的继承关系:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik760lyaqj30s20l8dgp.jpg" alt=""></p>
<p>LayoutParams是定义在ViewGroup, LayoutParams只支持 height, width. ViewGroupn内部的一个默认实现是MarginLayoutParams, 该类继承LayoutParams, 扩展了margin属性.接下来, 各个VieGroup的子类内部都有LayoutParams的子类,扩展对应ViewGroup的属性.比如 LinearLayout.LayoutParams, 增加了weight属性.</p>
<blockquote>
<h4 id="在Java代码中获取view的LayoutParams"><a href="#在Java代码中获取view的LayoutParams" class="headerlink" title="在Java代码中获取view的LayoutParams"></a>在Java代码中获取view的LayoutParams</h4></blockquote>
<p>既然LayoutParms是View对自己在父布局中的属性设置, 那么父View在测量或者布局的时候, 肯定是需要拿到这个LayoutParams对象的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(deepExport = <span class="keyword">true</span>, prefix = <span class="string">"layout_"</span>)</div><div class="line">    <span class="keyword">public</span> ViewGroup.<span class="function">LayoutParams <span class="title">getLayoutParams</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mLayoutParams;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set the layout parameters associated with this view. These supply</div><div class="line">     * parameters to the &lt;i&gt;parent&lt;/i&gt; of this view specifying how it should be</div><div class="line">     * arranged. There are many subclasses of ViewGroup.LayoutParams, and these</div><div class="line">     * correspond to the different subclasses of ViewGroup that are responsible</div><div class="line">     * for arranging their children.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> params The layout parameters for this view, cannot be null</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(ViewGroup.LayoutParams params)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Layout parameters cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line">        mLayoutParams = params;</div><div class="line">        resolveLayoutParams();</div><div class="line">        <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">            ((ViewGroup) mParent).onSetLayoutParams(<span class="keyword">this</span>, params);</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是View提供的接口, 用于设置和获取View中的LayoutParams.父View在测量和布局时, 就是通过<code>view.getLayoutParams()</code>来获得子<code>View</code>设置的<code>LayoutParams</code>.</p>
<blockquote>
<h2 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h2></blockquote>
<h3 id="Q-什么是MeasureSpec-它的工作原理是什么"><a href="#Q-什么是MeasureSpec-它的工作原理是什么" class="headerlink" title="Q: 什么是MeasureSpec? 它的工作原理是什么?"></a>Q: 什么是MeasureSpec? 它的工作原理是什么?</h3><blockquote>
<h4 id="什么是MeasureSpec"><a href="#什么是MeasureSpec" class="headerlink" title="什么是MeasureSpec?"></a>什么是MeasureSpec?</h4></blockquote>
<p>我们都知道, Android体系中, View有三种测量模式,每种测量模式都有对应View的宽高.</p>
<p>一个View可能会被多次测量, 在运行时也可能被动态改变而导致重新测量,布局. Android团队为了减少多次测量带来的对象分配消耗, 将View的测量模式和View的大小打包成一个int类型的值,从而减少了对象分配带来的消耗.</p>
<p>MeasureSpec这个类就是提供了打包和解包方法, 将测量模式和大小打包或者解包成int值.</p>
<blockquote>
<h4 id="MeasureSpec的工作原理"><a href="#MeasureSpec的工作原理" class="headerlink" title="MeasureSpec的工作原理"></a>MeasureSpec的工作原理</h4></blockquote>
<p>在Java中, int类型固定占4字节, 也就是32位.</p>
<p>由于三种测量模式用2位就能够表示, 可分别表示为:<code>00(UNSPECIFIED)</code>, <code>01(EXACTLY)</code>, <code>10(AT_MOST)</code>.</p>
<p>既然三种测量模式用2位表示就够, 那么剩下的低30位用来表示大小.</p>
<p>问题来了? 如何将2位的测量模式和30位的大小打包成一个int后, 能够无差错的解包成测量模式和View的大小?</p>
<p>答案: 使用掩码和逻辑或,与运算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has not imposed any constraint</div><div class="line"> * on the child. It can be whatever size it wants.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has determined an exact size</div><div class="line"> * for the child. The child is going to be given those bounds regardless</div><div class="line"> * of how big it wants to be.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The child can be as large as it wants up</div><div class="line"> * to the specified size.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div></pre></td></tr></table></figure>
<p>MODE_SHIFT为移多少位, MODE_MASK为掩码. 现在我们来算算掩码:3表示为二进制为:11, 所以0x3 &lt;&lt; 30 表示为: 1100000000(30个0). 这个掩码的作用就是配合逻辑与,或操作来进行打包和解包的操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>上面是打包操作, 在<code>size &amp; ~MODE_MASK</code>中, ~MODE_MASK为: 0011111(30个1),由于低30为全为1, 那么与size进行&amp;操作时, 低30位就由szie的低三十为决定, 而高2位则为00, <code>size &amp; ~MODE_MASK</code>这个操作就是将size的高2为设置为00, 同理:<code>(mode &amp; MODE_MASK)</code>这个操作是将mode低30位设置为0. 最后再进行 | 操作, 这样就得到了高2位为测量模式, 低30位为大小的int.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>getMode方法将一个打包的measureSpec解包为mode, 原理是通过&amp;获取measureSpec的高2位. 同理getSize(int measureSpec)也是同种道理.</p>
<blockquote>
<h2 id="LayoutParams和MeasureSpec的关系"><a href="#LayoutParams和MeasureSpec的关系" class="headerlink" title="LayoutParams和MeasureSpec的关系"></a>LayoutParams和MeasureSpec的关系</h2></blockquote>
<ul>
<li><p>MeasureSpec是由父容器中LayoutParams和本身的LayoutParams这两个因素决定的.</p>
</li>
<li><p>但是对于顶级View(DecorView),他的MeasureSpec是由屏幕的大小和自身的LayoutParams所决定的.</p>
</li>
<li><p>以上两点在阅读源码就可以看出来.</p>
</li>
</ul>
<h2 id="从源码角度来理解测量和布局"><a href="#从源码角度来理解测量和布局" class="headerlink" title="从源码角度来理解测量和布局"></a>从源码角度来理解测量和布局</h2><blockquote>
<h3 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h3></blockquote>
<p>为了更好的理解测量过程, 我们需要理解清楚MeasureSpec和LayoutParams的关系, 看MeasureSpec是怎么在LayoutParams的约束下生成的.</p>
<p>测量过程的工作是确定View的宽高.我们先从ViewRootImpl这个类来分析顶级View类是如何开始测量的.</p>
<p>测量,布局,绘制,这三个步骤将View显示到屏幕上,而触发这三个流程的地方是在<code>performTraversals()</code>方法中.</p>
<p>在<code>performTraversals()</code>方法中,除了测量,布局,绘制这三个阶段外, 其实在存在另外的两个阶段:预测量和窗口布局.</p>
<blockquote>
<h4 id="预测量"><a href="#预测量" class="headerlink" title="预测量"></a>预测量</h4></blockquote>
<p>ViewRootImpl在进行测量时,会预先进行一次测量,而这次预测量是在<code>measureHierarchy</code>方法中进行的. 预测量的目的就是为了在大屏幕的设备上将View更优雅的显示出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></div><div class="line">            <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight) &#123;</div><div class="line">        <span class="keyword">int</span> childWidthMeasureSpec;</div><div class="line">        <span class="keyword">int</span> childHeightMeasureSpec;</div><div class="line">        <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(TAG,</div><div class="line">                <span class="string">"Measuring "</span> + host + <span class="string">" in display "</span> + desiredWindowWidth</div><div class="line">                + <span class="string">"x"</span> + desiredWindowHeight + <span class="string">"..."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; <span class="comment">//为了让dialog显示得更好, 先根据预先定义好的dialog尺寸, 以此测量出一个包裹dialog的宽度.</span></div><div class="line">            <span class="comment">// On large screens, we don't want to allow dialogs to just</span></div><div class="line">            <span class="comment">// stretch to fill the entire width of the screen to display</span></div><div class="line">            <span class="comment">// one line of text.  First try doing the layout at a smaller</span></div><div class="line">            <span class="comment">// size to see if it will fit.</span></div><div class="line">            <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</div><div class="line">            res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">int</span> baseSize = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</div><div class="line">                baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": baseSize="</span> + baseSize);</div><div class="line">            <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</div><div class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//打包成MeasureSpec</span></div><div class="line">                childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//开始第一次测量</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                        + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123; <span class="comment">//如果测量出来的大小太小的话, 会再进行测量</span></div><div class="line">                    goodMeasure = <span class="keyword">true</span>; <span class="comment">//对测量结果满意</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Didn't fit in that size... try expanding a bit.</span></div><div class="line">                    baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": next baseSize="</span></div><div class="line">                            + baseSize); <span class="comment">//需要的话, 扩大宽度,进行二次测量</span></div><div class="line">                    childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//再次打包成MeasureSpec</span></div><div class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//第二次测量</span></div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                            + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                    <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Good!"</span>);</div><div class="line">                        goodMeasure = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!goodMeasure) &#123; <span class="comment">//最后还是太小的话, 只能妥协,返回窗口的可能改变的标记</span></div><div class="line">            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">            <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</div><div class="line">                windowSizeMayChange = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DBG) &#123;</div><div class="line">            System.out.println(<span class="string">"======================================"</span>);</div><div class="line">            System.out.println(<span class="string">"performTraversals -- after measure"</span>);</div><div class="line">            host.debug();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> windowSizeMayChange;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>为了让View更优雅的显示出来, 比如dialog在大屏幕的情况下, 如果其内容太大并且测量模式为WRAP_CONTENT的话,有可能会出现这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7l94nxgj30hi0br3yi.jpg" alt=""></p>
<ul>
<li>考虑到上面dialog的宽度有可能太小,会出现下面这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7n6wvkcj30c809ka9y.jpg" alt=""></p>
<ul>
<li><p>所以在预测量阶段,每次测量后都会根据一个标记<code>(MEASURED_STATE_TOO_SMALL)</code>来判断是否要进行二次测量来扩大宽度.</p>
</li>
<li><p>如果进行了二次测量的话, 宽度还是大小,就只能妥协,放弃预测量.</p>
</li>
<li><p>预测量是针对悬浮窗口而言, 也就是对于非悬浮窗口而言, 是没有预测量阶段的.</p>
</li>
</ul>
<blockquote>
<h4 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h4></blockquote>
<p>一般测量阶段都会伴随一个布局阶段, 预测量也是如此, 窗口布局就是根据预测量阶段得出的结果来进行布局.</p>
<blockquote>
<h4 id="开始测量"><a href="#开始测量" class="headerlink" title="开始测量"></a>开始测量</h4></blockquote>
<p>分析完预测量和预布局, 我们来分析<code>&quot;真正&quot;</code>的测量阶段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG, <span class="string">"Ooops, something changed!  mWidth="</span></div><div class="line">                            + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</div><div class="line">                            + <span class="string">" mHeight="</span> + mHeight</div><div class="line">                            + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</div><div class="line">                            + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</div><div class="line"></div><div class="line"><span class="comment">// Ask host how big it wants to be</span></div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
<ul>
<li>在View的测量机制中, 是通过给子View传递MeasureSpec来进行的, 因此, 测量阶段会首先进行获取测量规格, 并传递给子View, 我们先来看看顶级View如何进行获取MeasureSpec.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码通过调用<code>getRootMeasureSpec(mWidth, lp.width)</code>来获取宽度的MeasureSpec, 传递给方法的参数分别为屏幕的窗口大小和顶级View的LayoutParams封装的宽度信息.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> measureSpec;</div><div class="line">        <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>如果宽度为<code>ViewGroup.LayoutParams.MATCH_PARENT</code>, 直接把将窗口的大小和<code>MeasureSpec.EXACTLY</code>打包成一个MeasureSpec; 当宽度为<code>ViewGroup.LayoutParams.WRAP_CONTENT</code>情况也是如此.</p>
</li>
<li><p>至于<code>getRootMeasureSpec(mHeight, lp.height)</code>跟上面的基本一致,这里不多说.</p>
</li>
<li><p>分析到这里, 也验证了,<code>顶级View的MeasureSpec是由窗口的大小和自身的LayoutParams所决定的</code></p>
</li>
</ul>
<p>我们接着继续分析<code>performMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个方法中只是简单的调用了View的measure(int, int)方法, 也就是从RootViewImppl调到了View中. 方法中的参数刚刚生成的两个测量规格.可见,测量规格是在父View中生成并传递给子View的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            <span class="keyword">int</span> oWidth  = insets.left + insets.right;</div><div class="line">            <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</div><div class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></div><div class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</div><div class="line">        <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// first clears the measured dimension flag</span></div><div class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">            resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</div><div class="line">                    mMeasureCache.indexOfKey(key);</div><div class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</div><div class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></div><div class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">                <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></div><div class="line">                setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</div><div class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></div><div class="line">            <span class="comment">// an exception to warn the developer</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></div><div class="line">                        + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></div><div class="line">                        + <span class="string">" measured dimension by calling"</span></div><div class="line">                        + <span class="string">" setMeasuredDimension()"</span>);</div><div class="line">            &#125;</div><div class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">        mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</div><div class="line">                (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法略长, 但是核心思路只有两个, 第一: 判断传入的大小和前一次测量的大小是否一样, 如果一样的话, 不进行测量, 如果不一样的话, 就开始测量. 第二:如果传入的大小和前一次测量的大小不一样的话, 会调用onMeasure(int, int),开始测量.</p>
</li>
<li><p>对于<code>onMeasure(int, int)</code>而言, View和ViewGroup的测量职责是不一样的. <code>对于View, 它只需测量自身的大小, 而对于ViewGroup, 它需要测量自己和测量自己的孩子, 一般都是先测量孩子,然后根据孩子的大小来设置自己的大小.</code></p>
</li>
<li><p>由于<code>measure()</code>方法是被final修饰的, 所以<code>measure(int, int)</code>是不允许被重写的, 需要我们重写的是onMeasure(int, int). 这样做的优点是:开发者无需关心View测量的其他细节, 只需关心测量View的大小就行, 减轻了开发者的开发难度.</p>
</li>
<li><p>既然View和ViewGroup的测量职责不一样, 那么View和ViewGroup中的onMeasure(int, int)的实现肯定不一样, 所以我们开始分情况来讨论</p>
</li>
</ul>
<blockquote>
<h5 id="View-onMeasure-int-int"><a href="#View-onMeasure-int-int" class="headerlink" title="View#onMeasure(int, int)"></a>View#onMeasure(int, int)</h5></blockquote>
<p>我们先从简单的View入手, 进入View的onMeasure(int, int):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>View的onMeasure(int, int)只是简单调用了setMeasureDimension(int size, int measureSpec),这个是保存测量得到的宽高.</p>
</li>
<li><p>setMeasureDimension(int, int), 其中的宽高是通过<code>getDefaultSize(int size, int measureSpec)</code>来获取的.我们进入该方法看看:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = size;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先根据传入的measureSpec来获得测量模式和测量大小, 如果测量模式是<code>AT_MOST</code>或者<code>EXACTLY</code>的话, 直接返回测量得到的大小.</p>
</li>
<li><p>从这个方法我们知道, View的onMeasure(int, int)的默认实现是根据传入的MeasureSpec来获取测量结果.那么这个MeasureSpec是怎么产生的? 前面我们说过, ViewGroup的onMeasure(int, int)中, 是需要测量孩子的, 这个MeasureSpec就是ViewGroup在测量子View时传递给子View的, 换句话说, 这个MeasureSpec是从ViewGroup传递下来的, 通过解包操作, 可以得到MeasureSpec中的大小, 这个大小究竟是ViewGroup的总体大小还是剩余大小? 这个得看具体的ViewGroup的具体实现.</p>
</li>
<li><p>上面的分析可能有点难以理解, 不过接下来分析完ViewGroup后, 自然会解开你的迷惑.</p>
</li>
</ul>
<blockquote>
<h5 id="ViewGroup-onMeasure-int-int"><a href="#ViewGroup-onMeasure-int-int" class="headerlink" title="ViewGroup#onMeasure(int, int)"></a>ViewGroup#onMeasure(int, int)</h5></blockquote>
<p>由于ViewGroup的子类对测量都有不同的策略, 因此, ViewGroup并没有重写onMeasure(int, int), 而是让其子类去重写.我们拿比较简单的FrameLayout来分析吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</div><div class="line">                MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</div><div class="line">                MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</div><div class="line">        mMatchParentChildren.clear();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> childState = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">            <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</div><div class="line">                measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">                maxWidth = Math.max(maxWidth,</div><div class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</div><div class="line">                maxHeight = Math.max(maxHeight,</div><div class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</div><div class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class="line">                <span class="keyword">if</span> (measureMatchParentChildren) &#123;</div><div class="line">                    <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</div><div class="line">                            lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                        mMatchParentChildren.add(child);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Account for padding too</span></div><div class="line">        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</div><div class="line">        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</div><div class="line"></div><div class="line">        <span class="comment">// Check against our minimum height and width</span></div><div class="line">        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</div><div class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line"></div><div class="line">        <span class="comment">// Check against our foreground's minimum height and width</span></div><div class="line">        <span class="keyword">final</span> Drawable drawable = getForeground();</div><div class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</div><div class="line">            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</div><div class="line">            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</div><div class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</div></pre></td></tr></table></figure>
<ul>
<li>我抽取了FrameLayout中onMeasure(int, int)的核心代码, 主要思路: 遍历子View,让子View测量自己,也就是触发子View的测量. 接着再根据子View的大小来计算自己的大小.我们先来看看measureChildrenWithMargins(View, int, int).</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该方法是ViewGroup提供的工具类, 关于View和ViewGroup提供的测量工具类, 后面的专门分析.</p>
</li>
<li><p>首先拿到View的LayoutParams, 然后调用getChildMeasureSpec来得到子View的MeasureSpec, 我们看看它是怎么得到的.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">                <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">                <span class="comment">// be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">                <span class="comment">// big it should be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先进行解包操作, 拿到父View传递下来的测量模式和测量大小, 在xml布局中的顶级View的MeasureSpec是由RootViewImpl传递下来的, 而对于顶级View(DecorView)来说, 其MeasureSpec是由窗口大小和自身的LayoutParams决定的.</p>
</li>
<li><p>接着进入switch语句:</p>
<ul>
<li><p>当父View的mode为<code>MeasureSpec.EXACTLY</code>时, 再根据子View的LayoutParams(也就是子View在xml文件中声明的layout_xx属性的容器), 又分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽(用宽来举例子)为确定的值, 那么resultSize为子View在xml文件中声明的宽度(也就是xxdp),resultMode为<code>MeasureSpec.EXACTLY</code>,然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占满父View的宽度, 因此, resultSize设置为父View的大小size, reslutMode为<code>MeasureSpec.EXACTLY</code></li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.WRAP_CONTENT)</code>时, 表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为<code>MeasureSpec.AT_MOST</code></li>
</ol>
</li>
<li><p>当父View的mode为<code>MeasureSpec.AT_MOST</code>时, 根据子View的LayoutParams, 分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽为确定的值时, resultSize为子View在xml文件中声明的宽度(也就是xxdp), resultMode为<code>MeasureSpec.EXACTLY</code>, 然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占有父View的宽度, 但是由于父View的测量模式为<figure class="highlight plain"><figcaption><span>所以resultMode只能为```MeasureSpec.AT_MOST``(因为父View自身也不知道自己多大), resultSize设置为父Viw的大小.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">   3. 当子View在xml文件中声明的宽为``LayoutParams.AT_MOST``时表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为``MeasureSpec.AT_MOST``.</div><div class="line"></div><div class="line">* 分析到这里, 我们可以总结出View的MeasureSpec是由哪些因素决定的</div><div class="line"> * 对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以会看之前分析的代码)</div><div class="line"> * 对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</div><div class="line"></div><div class="line">* 上面我们针对宽度来进行了分析, 对于高度而言, 过程跟宽度一样</div><div class="line"></div><div class="line">* 最后调用子View的``measure(int, int)``, 将在``getChildMeasureSpec``中得到的宽和高对应的MeasureSpec(也就是我们上面以宽度为例子来分析的情况),传递给子View,接下去的过程跟我们前面在分析子View的情况一样.</div><div class="line"></div><div class="line">* 现在我们可以更加确定了这样一个事实: View的onMeasure(int, int)中的widthMeasureSpec和heightMeasureSpec是由父View根据自身的MeasureSpec和子View的LayoutParams产生并传递给子View的.</div><div class="line"></div><div class="line">* 如果你仔细总结的话,会发现:只要子View的的宽或高设置为``LayoutParams``设置为WRAP_CONTENT时, 生成MeasureSpec中的size都是父View的size(一般是父View剩下的size),而mode为AT_MOST.</div><div class="line"></div><div class="line">* 我们现在继续调到子View的measure方法中的onMeasure(), 我们再来看看getDefaultSize()这个方法:</div><div class="line"></div><div class="line">```java</div><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">        int result = size;</div><div class="line">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>首先解包出由父View传递下来的MeasureSpec, 通过上面的分析, 当子View在xml文件中将layout_width设置为WRAP_CONTENT时, 对应的SpecMode为AT_MOST, 此时进入switch语句, 得到的大小其实是父View的大小, 这也解释了,在自定义View(继承View)时,如果没有重写onMeasure(int, int)时,当这个自定义View的宽度或者高度设置为<code>WRAP_CONTENT</code>时,会变成占有父View的全部高度和宽度.</p>
</li>
<li><p>分析到这里, 已经基本分析完了测量过程,我们还是总结一下,再进入下一个流程.</p>
</li>
</ul>
<blockquote>
<h4 id="测量过程总结"><a href="#测量过程总结" class="headerlink" title="测量过程总结"></a>测量过程总结</h4></blockquote>
<ul>
<li><p>onMeasure(int widthSpec, int heightSpec)中的这两个MeasureSpec是由父View传递下来的.MeasureSpec一旦确定了, 在这个方法中就可以确定View的测量宽高了.</p>
</li>
<li><p>如何确定MeasureSpec?</p>
<ul>
<li>对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以回看之前分析的代码)</li>
<li>对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</li>
</ul>
</li>
<li><p>父View的MeasureSpec和子View的LayoutParams如何确定MeasureSpec?</p>
<ul>
<li>在View测量的时候, 系统会将View的LayoutParams在父View的SpecMode的约束下再次打包为一个传递给子View的MeasureSpec.</li>
</ul>
</li>
<li><p>EXACTLY,AT_MOST和LayoutParams的关系</p>
<ul>
<li>EXACTLY: 父View已经检测出子View所需要的大小(通常是子View在xml文件中声明为精确的值,比如20dp),它对应于LayoutParams中的match_parent和具体的数值</li>
<li>AT_MOST: 子View不能超过父View给定的大小, 它对应与LayoutParams中的wrap_content.</li>
</ul>
</li>
<li><p>最后来看看流程图加深印象:</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8aodsxyj30nq0i2ta8.jpg" alt=""></p>
<blockquote>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3></blockquote>
<p>经过测量阶段后, View已经知道自己的宽和高, 接着就需要在布局阶段确定应该显示在哪个区域,也就是屏幕上的四个点.那我们回到VewiRootImpl中的performLayout()方法, 该方法是触发布局的起点, 在里面调用了View的layout方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</div></pre></td></tr></table></figure>
<ul>
<li><p>layout方法中的四个参数分别为屏幕上的四个点, 也就是整个屏幕的区域</p>
</li>
<li><p>我们进入View的layout方法:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们主要分析上面的两个核心操作:<ul>
<li>setFrame(left, top, right, bottom)这个方法主要是保存四个点的位置, 并且判断传入的位置跟之前的是不是一样, 不一样的话,会回调onSizeChange接口</li>
<li>调用onLayout(left, top, right, bottom), 但是这个方法View是一个空方法, 对于ViewGroup来说,具体的子类有其具体的实现方法.因此, <code>layout方法主要是view用于确定自己的位置的, 而onLayout是用于ViewGroup循环调用子类的layout方法来对子类进行布局的.</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>理解了上面的这两点, 其实布局过程就基本没什么了.</p>
</li>
<li><p>最后还是看看流程图, 加深理解.</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8dhsrxmj30kh0flwfa.jpg" alt=""></p>
<ul>
<li>分析到这里, 测量,布局都分析完了, 绘制流程就不讲了,</li>
</ul>
<h1 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h1><blockquote>
<h2 id="继承View重写onDraw方法和onMeasure方法"><a href="#继承View重写onDraw方法和onMeasure方法" class="headerlink" title="继承View重写onDraw方法和onMeasure方法"></a>继承View重写onDraw方法和onMeasure方法</h2></blockquote>
<p>这种方法一般用于实现基础控件和组合控件难以达到的效果. 所以需要重写onDraw方法来画出自己的图形, 重写onMeasure方法来支持wrap_content属性,和padding属性.</p>
<blockquote>
<h2 id="继承ViewGrroup派生特殊的Layout"><a href="#继承ViewGrroup派生特殊的Layout" class="headerlink" title="继承ViewGrroup派生特殊的Layout"></a>继承ViewGrroup派生特殊的Layout</h2></blockquote>
<p>当系统的基础布局容器不能满足我们的需求时, 我们可以继承ViewGroup来自定义一个布局容器. 这种方法需要合适处理ViewGroup的<code>测量(测量孩子和测量自己)</code>,布局这两个过程.</p>
<blockquote>
<h2 id="继承基础控件-如TextView"><a href="#继承基础控件-如TextView" class="headerlink" title="继承基础控件(如TextView)"></a>继承基础控件(如TextView)</h2></blockquote>
<p>这种方法一般用于扩展基础控件的功能,相对比较简单. 这种方法不需要自己处理wrap_content和padding.</p>
<blockquote>
<h2 id="继承基础容器-如LinearLayout"><a href="#继承基础容器-如LinearLayout" class="headerlink" title="继承基础容器(如LinearLayout)"></a>继承基础容器(如LinearLayout)</h2></blockquote>
<p>这种方法一般用于组合一些基础控件或者自定义View.</p>
<h1 id="自定义View的方法论"><a href="#自定义View的方法论" class="headerlink" title="自定义View的方法论"></a>自定义View的方法论</h1><blockquote>
<h2 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h2></blockquote>
<p>这种自定义方法,我们处理的主要有两个方法:</p>
<ul>
<li><p>在onMeasure(int, int)中处理wrap_content和padding</p>
</li>
<li><p>在onDraw(Canvas)中绘制你想要的UI和处理padding</p>
</li>
</ul>
<blockquote>
<h3 id="onMeasure-int-int-处理"><a href="#onMeasure-int-int-处理" class="headerlink" title="onMeasure(int, int)处理"></a>onMeasure(int, int)处理</h3></blockquote>
<p>在onMeasure(int, int)中需要处理的有两个: wrap_content和padding这两个属性.</p>
<blockquote>
<h4 id="支持wrap-content"><a href="#支持wrap-content" class="headerlink" title="支持wrap_content"></a>支持wrap_content</h4></blockquote>
<p>经过前面的分析, 我们知道对于一个继承View的控件, 如果没有重写onMeasure(int, int), 在xml布局中设置layout_width=”wrap_content”的时候, 会占满父View的宽度, 其中的原因前面已经分析了, 这里主要将如何支持wrap_content. 接下来我会讲解决这个问题的基本方法和另外一种快捷方法</p>
<ul>
<li>基本方法:</li>
</ul>
<p>当layout_width或者layout_height为wrap_content, 我们不用默认的高宽, 而是自己根据自己View的内容来决定View的高宽</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"><span class="comment">//1.首先拿到宽高的大小和测量模式</span></div><div class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">//2.接着判断宽高和mode是否为wrap_content, 如果是的话, 我们不用widthSize或者heightSize, 我们自己指定View的大小</span></div><div class="line">        <span class="comment">//wrap_content对应MeasureSpec.AT_MOST属性</span></div><div class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">  setMeasuredDimension(<span class="number">300</span>, <span class="number">300</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(<span class="number">300</span>, heightSize); <span class="comment">//只有width为wrap_content, 所以高直接用heightSize就行</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(widthSize, <span class="number">300</span>); <span class="comment">//只有height为wrap_content, 所以宽直接用widthSize就行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提供了解决wrap_content的基本思路.下面我们介绍另外一种快捷而且屏幕适配更好的方法.在介绍之前,我们先来看看View中的几个有用的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法返回一个建议的最小高度.如果View没有设置背景,那么返回值为mMinHeight(也就是在xml布局中声明的属性), 如果有的话, 会返回背景的Drawable对象的高度和mMinHeight中的最大值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法和前面的一样,这里不多说.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">                <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">                    result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    result = size;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">                result = specSize;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                result = size;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code>这个方法是View本身提供的一个支持wrap_content的一个方法(getDefaultSize()方法不支持wrap_content),这个方法除了支持wrap_content外, 还通过掩码操作添加了一些信息, 如果当size的大小大于父View的高度时, 会通过掩码操作将 MEASURED_STATE_TOO_SMALL和size打包成一个int值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resolveSizeAndState(size, measureSpec, <span class="number">0</span>) &amp; MEASURED_SIZE_MASK;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个是上个方法的重载版本, childMeasuredState属性传入0,表示不对标志做处理, 最后用MEASURED_SIZE_MASK这个掩码提取出想要是size值.</p>
<p>介绍完了上面的几个方法, 我们开始介绍另外一种快捷的适配wrap_content的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumWidth(), mTextSize); <span class="comment">//将默认的最小宽度和自己定义的字体大小比较, 取最大值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumHeight(), mTextSize); <span class="comment">//将默认的高度和自己定义的字体大小比较, 取最大值.</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们知道,支持wrap_content的实质就是根据内容来决定View的大小.那么我们可以利用<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>这个两个方法来获取最小的高度和宽度.当mode为wrap_content时, 怎么计算出最小的高度和宽度, 这个看你的自定View情况, 自己灵活选择.</p>
<blockquote>
<h4 id="支持padding"><a href="#支持padding" class="headerlink" title="支持padding"></a>支持padding</h4></blockquote>
<p>支持padding是需要在onDraw和onMeasure中实现, 思路都很简单, 在onMeasure中的宽高将padding考虑进去, 在onDraw中绘制图形时,除去padding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        maxWidth = maxWidth + getPaddingLeft() + getPaddingRight(); <span class="comment">//加上paddingLeft和paddingRight得到宽度</span></div><div class="line">        maxHeight = maxHeight + getPaddingBottom() + getPaddingTop(); <span class="comment">//加上paddingBottom和paddingTop得到高度</span></div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是onMeasure中支持padding, 下面看看onDraw中支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> wdith = getWidth() - getPaddingLeft() - getPaddingRight();</div><div class="line">        <span class="keyword">int</span> height = getHeight() - getPaddingTop() - getPaddingBottom();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在onDraw中, 用到宽高时, 先减去对应的padding就能支持padding了.</p>
<blockquote>
<h2 id="继承ViewGroup"><a href="#继承ViewGroup" class="headerlink" title="继承ViewGroup"></a>继承ViewGroup</h2></blockquote>
<p>继承ViewGroup的View, 相当于自定义一个布局容器, 需要我们处理的有两个:</p>
<ul>
<li><p>onMeaure(int, int)</p>
</li>
<li><p>onLayout(int, int, int, int)</p>
</li>
</ul>
<blockquote>
<h3 id="处理onMeasure-int-int"><a href="#处理onMeasure-int-int" class="headerlink" title="处理onMeasure(int, int)"></a>处理onMeasure(int, int)</h3></blockquote>
<p>自定义ViewGroup不同于自定义View, 自定义ViewGroup在onMeasure(int, int)中, 除了测量自己,还需要测量孩子, 通常是遍历孩子并触发孩子的测量方法, 然后根据孩子的宽高来决定自己的宽高. 我们下面来看看ViewGroup给我们提供的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过传入子View,父View的宽高测量规格, 该方法内部会帮我们调用view的measure方法去测量View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法内部遍历所有子View, 然后调用上一个方法测量View, 也就是帮我们测量了所有子View, 不用我们手动for循环去测量View. 你们可以根据自己的需要去调用其中的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法也是测量子View的方法, 不过这个方法把子View的margin考虑进去了.</p>
<p>下面说说ViewGroup测量的套路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxHeight = getPaddingTop() + getPaddingBottom(); <span class="comment">//支持padding</span></div><div class="line">    <span class="keyword">int</span> maxWidth = getPaddingLeft() + getPaddingRight(); <span class="comment">//支持padding</span></div><div class="line">    <span class="comment">//循环测量孩子</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>); <span class="comment">//考虑margin测量孩子</span></div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        maxHeight = maxHeight + child.getMeasuredHeight() + params.topMargin + params.bottomMargin; <span class="comment">//将支持margin</span></div><div class="line">        maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + params.leftMargin + params.rightMargin); <span class="comment">//将支持margin</span></div><div class="line">    &#125;</div><div class="line">    setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), resolveSize(maxHeight, heightMeasureSpec)); <span class="comment">//测量自己</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我模拟了LinearLayout中的vertical布局属性.注意记得考虑padding和margin.</p>
<p>首先考虑padding, 然后循环遍历子View并测量, 最后根据孩子测量得到的宽高和孩子的margin属性和自己的布局属性来进行测量自己的大小.</p>
<blockquote>
<h3 id="onLayout-int-int-int-int"><a href="#onLayout-int-int-int-int" class="headerlink" title="onLayout(int, int, int, int)"></a>onLayout(int, int, int, int)</h3></blockquote>
<p>onLayout的职责就是将根据子View测量得到的宽高将其摆放在合适的位置. 注意: 在onLayout阶段, 没有特殊情况的话, 子View的布局要根据其测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> i, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = getPaddingLeft(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> top = getPaddingTop(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> bottom;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; getChildCount(); j++) &#123;</div><div class="line">        View child = getChildAt(j);</div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        left = left + params.leftMargin;</div><div class="line">        top = top + params.topMargin;</div><div class="line">        bottom = params.bottomMargin;</div><div class="line">        <span class="keyword">int</span> width = child.getMeasuredWidth();</div><div class="line">        <span class="keyword">int</span> height = child.getMeasuredHeight();</div><div class="line">        child.layout(left, top, left + width, top + height + bottom);</div><div class="line">        top = top + height + bottom;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是简单的模仿LinearLayout的vertical布局属性, 思路: 遍历所有的子View, 然后确定四个点的位置, 一般都是确定left, top这两个点, 然后对应加上View的宽高再得到另外的right, bottom.注意:这里right和bottom这两个点的确定,如果没有特殊情况, 应该根据view的测量得到的宽高来确定, 不能随便指定特定的值, 这样会导致getMeasureXX和getXX不相等, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child.layout(left, top, left + width + <span class="number">100</span>, top + height + bottom + <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>如果你按照上面的操作, getWidth会比getMeasureWidth大100, getHeight会比getMeasureHeight大100. 原因就是你布局的时候没有根据测量阶段View的宽高来布局(也就是私自加多了100, 导致两个点相减时会多出100). 因此,如果没有特殊情况, 布局阶段请按照子View测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<blockquote>
<h3 id="定义你自己的LayoutParams"><a href="#定义你自己的LayoutParams" class="headerlink" title="定义你自己的LayoutParams"></a>定义你自己的LayoutParams</h3></blockquote>
<p>最后补充一个. 如果你的自定义ViewGroup需要自定义LayoutParams的话, 需要进行下面两个步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayoutParams</span> <span class="keyword">extends</span> <span class="title">MarginLayoutParams</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> attr;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(c, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(width, height);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(LayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在你的类中定义上面的内部类, 属性自己定义.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(LayoutParams p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(p);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后重载上面的方法.</p>
<p>如果理解了上面的方法轮, 那么自定义View也就没多大问题了, 最后剩下的就是绘制了.</p>
<p>剩下的两种情况都不怎么难, 这里多说了.</p>
<blockquote>
<h2 id="自定义View的步骤"><a href="#自定义View的步骤" class="headerlink" title="自定义View的步骤"></a>自定义View的步骤</h2></blockquote>
<p>1: 首先分析这个View是怎么绘制的? 哪些是需要抽象成参数</p>
<p>2: 将抽象出来的参数定义在attr资源文件</p>
<p>3: 重写onMeasure方法,并让你的View支持wrap_content,或者padding(如果有必要的话)</p>
<p>4: 重写onDraw方法, 主要在onDraw也是要处理padding(如果有必要的话)</p>
<p>5: 暴露接口给外部(例如监听接口, 动态改变属性的接口)</p>
<p>6: 如果存在滑动冲突的话, 需要解决滑动冲突</p>
<p>7: 根据实际情况优化你的View</p>
<blockquote>
<h2 id="自己的自定义View的习惯"><a href="#自己的自定义View的习惯" class="headerlink" title="自己的自定义View的习惯:"></a>自己的自定义View的习惯:</h2></blockquote>
<p>上面是标准的自定义View的步骤, 实际情况中, 不需要按照严格的顺序进行.下面说说我写的时候的套路:</p>
<p>1: 先分析这个自定义View是怎么话的?</p>
<p>2: 抽象出一些参数,定义在View中</p>
<p>3: 先在onDraw中把图形先画出来,</p>
<p>4: 图形出来后, 再重写onMeasure来支持wrap_content.padding等属性</p>
<p>5: 将抽象出来的参数定义在attr资源文件</p>
<p>6: 暴露接口给外部</p>
<p>7: 优化View</p>
<h2 id="自定义View的使用场景"><a href="#自定义View的使用场景" class="headerlink" title="自定义View的使用场景"></a>自定义View的使用场景</h2><blockquote>
<h3 id="优先考虑继承现有的空间来实现额外的功能"><a href="#优先考虑继承现有的空间来实现额外的功能" class="headerlink" title="优先考虑继承现有的空间来实现额外的功能"></a>优先考虑继承现有的空间来实现额外的功能</h3></blockquote>
<p>如果一些效果是继承现有控件能够实现的话, 那么优先继承现有的控件, 因为现有的控件都是经过官方多次的优化,性能肯定比我们自己写出来的好.</p>
<blockquote>
<h3 id="当一个View嵌套很多布局时-考虑自定义View的实现"><a href="#当一个View嵌套很多布局时-考虑自定义View的实现" class="headerlink" title="当一个View嵌套很多布局时, 考虑自定义View的实现."></a>当一个View嵌套很多布局时, 考虑自定义View的实现.</h3></blockquote>
<p>如果View嵌套太深, requesLayout触发时, 会导致整个布局都被测量和布局, 这样的消耗太大了, 更好的做法是,自定义一个View, 减少测量和布局阶段的消耗.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;﻿# CustomView总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;LayoutParams认知&quot;&gt;&lt;a href=&quot;#LayoutParams认知&quot; class=&quot;headerlink&quot; title=&quot;LayoutParams认知&quot;&gt;&lt;/a&gt;LayoutPa
    
    </summary>
    
      <category term="自定义View" scheme="http://cristianoro7.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="自定义View" scheme="http://cristianoro7.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构-栈</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://cristianoro7.github.io/2017/06/29/大话数据结构-栈/</id>
    <published>2017-06-29T14:40:50.497Z</published>
    <updated>2017-06-29T14:40:50.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*顺序储存结构*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> top;</div><div class="line">&#125;SqStack;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>入栈操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">push</span><span class="params">(SqStack &amp;S, ElemType elemType)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top == MAXSIZE - <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    S.data[++S.top] = elemType;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">pop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = S.data[S.top - <span class="number">1</span>];</div><div class="line">    S.top--;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈和入栈都没有涉及到循环语句,因此时间复杂度为0(1)</li>
</ul>
<h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><ul>
<li>适合一个栈同增加的同时另一个栈在减少</li>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 共享栈结构体</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> top1;</div><div class="line">    <span class="keyword">int</span> top2;</div><div class="line">&#125;SqShareStack;</div></pre></td></tr></table></figure>
<ul>
<li><p>当top1 + 1 == top2时视为栈满</p>
</li>
<li><p>入栈</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sharePush</span><span class="params">(SqShareStack &amp;S, ElemType e, <span class="keyword">int</span> stackNumber)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top1 + <span class="number">1</span> == S.top2) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (stackNumber == <span class="number">1</span>) &#123;</div><div class="line">        S.data[++S.top1] = e;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">2</span>) &#123;</div><div class="line">        S.data[--S.top2] = e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sharePop</span><span class="params">(SqShareStack &amp;S, ElemType &amp;e, <span class="keyword">int</span> stackNumber)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(S.top1 == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        e = S.data[S.top1--];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(S.top2 == MAXSIZE) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        e = S.data[S.top2++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链式储存结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> StackNode &#123;</div><div class="line">    ElemType data;</div><div class="line">    <span class="keyword">struct</span> StackNode *next;</div><div class="line">&#125;StackNode, *LinkStackPtr;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> LinkStack &#123;</div><div class="line">    LinkStackPtr top;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">&#125;LinkStack;</div></pre></td></tr></table></figure>
<ul>
<li>入栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sPush</span><span class="params">(LinkStack &amp;S, ElemType e)</span> </span>&#123;</div><div class="line">    LinkStackPtr ptr = (LinkStackPtr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</div><div class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    ptr-&gt;data = e;</div><div class="line">    ptr-&gt;next = S.top;</div><div class="line">    S.top = ptr;</div><div class="line">    S.count++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sPop</span><span class="params">(LinkStack &amp;S, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(S.top != <span class="literal">NULL</span>) &#123;</div><div class="line">        LinkStackPtr ptr;</div><div class="line">        ptr = S.top;</div><div class="line">        S.top = ptr-&gt;next;</div><div class="line">        e = ptr-&gt;data;</div><div class="line">        <span class="built_in">free</span>(ptr);</div><div class="line">        S.count--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>顺序栈与链栈的时间复杂度都是O(1)</li>
<li>空间上链栈没有空间限制,但是链栈要求每个元素都要有指针域,者也一定程度上增加了内存的开销.顺序栈需要事先规定一个固定长度，可能会造成内存浪费,但是它对于存取时定位很方便</li>
</ul>
<blockquote>
<p>参考资料:《大话数据结构》<br><a href="https://github.com/cristianoro7/data-structure-practice" target="_blank" rel="external">源码</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;h4 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*顺序储存结构*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ElemType data[MAXSIZE];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; top;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;SqStack;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://cristianoro7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://cristianoro7.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>可靠传输的工作原理</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/06/29/可靠传输的工作原理/</id>
    <published>2017-06-29T14:39:49.337Z</published>
    <updated>2017-06-29T14:39:49.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>可靠运输的实现</li>
<li>停止等待协议</li>
<li>连续ARQ协议</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>TCP发送的报文段是交给IP层传送的, 但是IP层只能提供尽最大努力交付的服务,也就是说网络层提供的是不可靠的传输.因此,TCP必须采用适当的措施才能使得两个运输层之间的传输信道变得可靠.</p>
<blockquote>
<h3 id="可靠运输的实现"><a href="#可靠运输的实现" class="headerlink" title="可靠运输的实现"></a>可靠运输的实现</h3></blockquote>
<p>怎么样的运输才算是可靠运输? 要回答这个问题,可以从三方面入手:</p>
<ol>
<li>保证传输的分组无出错,也就是二进制比特流没有出现差错.</li>
<li>保证分组在传输的过程中没有丢失.</li>
<li>分组能够按序达到.</li>
</ol>
<p>既然知道了怎么样才能实现可靠运输,那么下面,我们来一步一步实现可靠运输原理.</p>
<h4 id="可靠运输1-0"><a href="#可靠运输1-0" class="headerlink" title="可靠运输1.0"></a>可靠运输1.0</h4><p>现在我们假设分组的传输是在一个可靠的信道上面传输的,也就是二进制比特流在这条通道上传输是不会出现比特流差错的.如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>但是,实际环境中,由于信道会受到声噪等因素影响,会使得传输的信道变得不可靠, 那么这时也就不能保证比特流的无差错.有没有什么办法能够解决这个问题?</p>
<h4 id="可靠运输2-0"><a href="#可靠运输2-0" class="headerlink" title="可靠运输2.0"></a>可靠运输2.0</h4><p>如何保证接收方接收到的比特流的无出错的? 关于这个问题,我们在可靠运输2.0版本中,通过使用一个比特流的检验和方法来检验接收方接收到的比特是否产生了差错.</p>
<p>我们引入了比特的差错检验来查看接收方收到的比特流的情况. 如果检验得比特流无差错,那么接收方可以直接接收.但是检验的结果是出现错误的话,那么这时接收方应该怎么做?</p>
<p>分析到这里, 我们需要引入另外的一种机制来解决这个问题. 这里我们引入确认机制,即接收方应该在接收到比特流后,应该向发送方确认,确认收到的比特流是否出现错误,可以使用ACK代表无差错,NACK代表有差错.</p>
<p>如果发送方接收到接收方发送的NACK,代表比特流出现了错误,那么发送方该怎么做?</p>
<p>这个时候,我们得引入重传机制, 也就是当发送方接收到NACK时,发送方应该重传分组.</p>
<p>整个过程如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/可靠运输2.0.png" alt=""></p>
<p>为了在不可靠的信道上实现比特无差错,我们引入了检验和,确认(ACK/NACK)和重传机制来保证.但是我们如何解决ACK或NACK出现错误?</p>
<h4 id="可靠运输2-1"><a href="#可靠运输2-1" class="headerlink" title="可靠运输2.1"></a>可靠运输2.1</h4><p>为了应对ACK/NACK被破坏的情况,我们可以在ACK/NACK增加检验和机制来保证ACK/NACK不出现差错.</p>
<p>我们在2.0中引入了重传机制.因此,有可能出现分组的重复.在2.1中,我们将每个分组进行编号,保证分组不会因为重传而出现重复.</p>
<h4 id="可靠运输2-2"><a href="#可靠运输2-2" class="headerlink" title="可靠运输2.2"></a>可靠运输2.2</h4><p>为了提高确认机制的效率,我们采用累计确认机制.</p>
<p>所谓的累计确认是这样的: 收到分组后,需要给发送方发送一个ACK来表示已经收到分组.在发送分组的同时,附加上该分组的编号,来表示小于该编号之前的分组都已经被成功接收了.</p>
<p>既然引入了累计确认机制,NACK也就显得有点多余,在2.2中,我们把NACK去掉.</p>
<h4 id="可靠传输3-0"><a href="#可靠传输3-0" class="headerlink" title="可靠传输3.0"></a>可靠传输3.0</h4><p>前面的2.0~2.2版本都是针对如何解决保证分组在传输的过程中不出错,在3.0中,我们来考虑如何保证传输的分组不丢失?</p>
<p>为了保证分组在传输的时候不丢失,我们可以为每个传输的分组设置一个定时器,如果在定时器期限到达之前,没有收到ACK的话,就认为分组在传输的过程中丢失了,于是我们就重传该分组.</p>
<p>现在,我们基本可以保证分组不丢失了.但是,我们仔细想一下,会发现传输的信道利用率很低,因为,每次发送完一个分组,都得等待收到接收方的ACK后才能发送另外一个分组.由此看来,信道大部分时间都是处于等待状态的.</p>
<h4 id="可靠运输3-1"><a href="#可靠运输3-1" class="headerlink" title="可靠运输3.1"></a>可靠运输3.1</h4><p>为了解决3.0中信道利用率低的问题.我们可以采用流水线机制.即:每次发送完一个分组不必等待接收方的ACK才发送下一个分组.也就是可以连续发送多个分组.</p>
<p>由于我们引入了连续发送分组的这种协议,我们不得不面临多一个问题:如何解决分组乱序到达的情况?</p>
<h4 id="可靠运输3-2"><a href="#可靠运输3-2" class="headerlink" title="可靠运输3.2"></a>可靠运输3.2</h4><p>我们可以使用回退N步或者选择重传这两种机制来解决分组乱序的问题.</p>
<p>回退N步,本文下面会讲到,这里不多说.<br>选择重传: 对于乱序到达的分组,选择重传机制会将它们缓存起来,等待失序的分组到达后再发送ACK.</p>
<blockquote>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3></blockquote>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>上图为最简单的无差错情况. A发送分组M1,发完就暂停发送,等待B确认.当B收到了M1就向A发送确认.A收到了M1的确认后,就再次发送M2分组.同样, 在收到B对M2的确认后, A再发送M3.</p>
<h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p><img src="/uploads/计网/运输层/TCP/出现差错.png" alt=""></p>
<p>上图为分组在传输的过程中出现差错的情况. B接收M1时检测出了差错, 就丢弃M1,其他什么都不做.也可能是M1在传输的过程中丢失了. 这两种情况下, B都不会发送任何信息. 可靠传输协议是这样设计: A只要超过一段时间仍然没有接收到确认, 就认为刚才发送的分组丢失了, 因此重传前面发送过的分组,这叫做超时重传.为了实现超时重传, 要在每发送完一个分组设置一个超时计时器. 如果在超时计时器到期之前收到了对方的确认, 就撤销计时器.</p>
<p>注意:</p>
<ol>
<li>A发送完一个分组后, 必须暂时保存已发送的分组的副本.只有在收到相应的确认后才能清除暂时保留的分组副本.</li>
<li>分组和确认分组都必须进行编号. 这样才能明确是哪一个发送出去的分组收到了确认, 而哪一个分组没收到确认.</li>
<li>超时计时器设置的重传时间应当比数据在分组传送的平均往返时间更长一些.</li>
</ol>
<h4 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h4><p><img src="/uploads/计网/运输层/TCP/确认丢失.png" alt=""></p>
<p>上图为B发送的确认分组丢失的情况. A在设定的超时重传时间内没有收到确认, 但无法知道是自己发送的分组出错,丢失,或者是B发送的确认丢失了. 此时A必须重传M1分组. 假定B收到了重传M1,此时应采取两个行动.</p>
<ol>
<li>丢弃这个重复的分组M1,不向上层交付.</li>
<li>向A发送确认.</li>
</ol>
<p><img src="/uploads/计网/运输层/TCP/确认迟到.png" alt=""></p>
<p>上图为确认迟到的情况. 传输过程没有出错, 但B对M1的确认迟到了. A会收到重复的确认. 这时, A只要收下后丢弃.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述的确认和重传机制, 可以在不可靠的传输网路上实现可靠的通信. 这种可靠传输协议称为自动重传请求ARQ(Automatic Repeat Request).ARQ协议的优点是简单, 但是缺点是信道利用率太低了.</p>
<blockquote>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3></blockquote>
<p>为了提高信道的利用率, 发送方可以采用流水线传输.流水线传输就是发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认.</p>
<p><img src="/uploads/计网/运输层/TCP/发送窗口.png" alt=""></p>
<p>上图为发送方维护的发送窗口, 它表示位于发送窗口内的3个分组都可以连续发送出去,而不需要对方等待. 这样信道利用率就提高了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口.png" alt=""></p>
<p>发送方每接收到一个确认,就把滑动窗口向前滑动一个分组的位置.接收方一般都是采取累计确认的方式.也就是说, 接收方不必对收到的分组逐个发送确认,而是在收到几个分组后,对按序到达的最后一个分组发送确认, 这就表示: 到这个分组为止的所有分组都已经正确收到.</p>
<p>累计确认的缺点是不能向发送方反映接收方已经正确接收的所有分组信息.例如,如果发送了5个分组,而中间的3个分组丢失了. 这时接收方只能前两个分组发出确认.发送方无法知道后面三个分组的下落, 只好把后面三个分组都再传一次, 这叫做回退N步(Go Back N).</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br>计算机网络-自顶向下</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;可靠传输的工作原理&quot;&gt;&lt;a href=&quot;#可靠传输的工作原理&quot; class=&quot;headerlink&quot; title=&quot;可靠传输的工作原理&quot;&gt;&lt;/a&gt;可靠传输的工作原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>路由器工作原理</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/06/29/路由器工作原理/</id>
    <published>2017-06-29T14:39:37.889Z</published>
    <updated>2017-06-29T14:39:37.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>输入端口</li>
<li>交换结构</li>
<li>输出端口</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>路由器是一种具有多个输入和输出端口的专用计算机,其任务是转发分组.路由器的转发分组是网络层的主要工作之一. 下面给出典型的路由器构成图:</p>
<p><img src="/uploads/计网/路由选择协议/路由器工作原理.png" alt=""></p>
<blockquote>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3></blockquote>
<p><img src="/uploads/计网/路由选择协议/输入端口.png" alt=""></p>
<ul>
<li>输入端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层.</li>
<li>路由器使用转发表来查找输出端口,使得到达的分组将能经过交换结构转发到输出端口.</li>
<li>转发表是由路由器处理和更新的,但转发表的一份影子副本通常会被存放在每个输入端口, 有了影子副本,转发决策能在每个输入端口本地做出,无须调用中央路由选择处理器, 因此也避免了集中式处理的瓶颈.</li>
</ul>
<blockquote>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3></blockquote>
<p>交换结构位于一台路由器的核心部位.正是通过这种交换结构,分组才能实际从一个输入端口交换到一个输出端口.交换可以由下面的三种交换技术完成.</p>
<p><img src="/uploads/计网/路由选择协议/内存交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/纵横式交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/总线交换结构.png" alt=""></p>
<h4 id="内存交换结构"><a href="#内存交换结构" class="headerlink" title="内存交换结构"></a>内存交换结构</h4><ul>
<li>在输入端口和输出之间交换是在CPU的直接控制下完成的.</li>
<li>一个分组到达一个输入端口时, 该端口会先通过中断方式向路由选择处理器发送信号.于是,该分组从输入端口处被复制到处理器内存中.路由器选择处理器从其首部提取目的地址,在转发表中找出合适的输出端口,并将该分组复制到输出端口的缓存中.需要注意的是:不能同时发送两个分组,即使他们有不同的端口,因为经过共享系统总线一次仅能执行一次内存读/写.</li>
</ul>
<h4 id="总线交换"><a href="#总线交换" class="headerlink" title="总线交换"></a>总线交换</h4><ul>
<li>输入端口经过一根共享总线将分组直接传送到输出端口,不需要路由选择处理器的干预.</li>
<li>当一个分组到达路由器时, 输入端口为分组预先计划一个交换机内部标签, 用于指示本地输出端口,是分组在总线上传送和传输到输出端口.该分组能由所有输出端口收到, 但只有与该标签匹配的端口才能保存该分组.</li>
<li>如果多个分组同时到达路由器,每个位于不同的输出端口,除了正在总线上传输的分组外,其他分组必须等待,因为一次只有一个分组能够跨越总线.</li>
</ul>
<h4 id="纵横式交换结构"><a href="#纵横式交换结构" class="headerlink" title="纵横式交换结构"></a>纵横式交换结构</h4><ul>
<li>纵横式交换机是一种由2N条总线组成的互联网络.网络互联使得它能克服单一,共享式总宽带限制的缺点.</li>
<li>当某个分组到达A端口时, 需要转发到端口Y,交换机控制器闭合总线A和Y交叉部位的叉点,然后端口A在其总线上发送该分组, 该分组仅由总线Y安排接收.注意:来自端口B的一个分组在同一时间能够转发到端口X,因为A到Y和B到X的分组使用不同的输入和输出总线.然而,如果来自不同端口的两个分组其目的地为相同的输出端口,那么其中一个分组必须等待, 因为在某个时刻,总线上仅有一个分组能被传送.</li>
</ul>
<blockquote>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3></blockquote>
<p>输出端口处理取出存放在输出端口内存中的分组并将其发送到输出链路上.这包括选择和取出排队的分组进行传输,执行所需的链路层和物理层传输功能.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络自顶向下<br>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由器工作原理&quot;&gt;&lt;a href=&quot;#路由器工作原理&quot; class=&quot;headerlink&quot; title=&quot;路由器工作原理&quot;&gt;&lt;/a&gt;路由器工作原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>路由选择协议</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
    <id>http://cristianoro7.github.io/2017/06/29/路由选择协议/</id>
    <published>2017-06-29T14:39:27.777Z</published>
    <updated>2017-06-29T14:39:27.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>内部网关协议RIP</li>
<li>内部网关协议OSPF</li>
<li>外部网关协议BGP</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>从路由算法能否随网络的通信或者拓扑自适应地进行调整变化来划分, 可将路由选择分为两大类:静态路由选择策略和动态路由选择策略.<ul>
<li>静态路由选择策略: 也叫做非自适应路由选择, 其特点是简单和开销较小, 但不能及时适应网络状态变化, 适用于小型网络.</li>
<li>动态路由选择协议: 也叫做自适应路由选择, 其特点是能较好地适应网络状态的变化, 但实现起来复杂, 开销也较大. 因此, 动态路由选择适合复杂的大型网络.</li>
</ul>
</li>
<li>因特网采用的路由选择协议主要是自适应的分布式路由选择协议.</li>
<li>因特网采用分层次的路由选择协议的两个原因:<ul>
<li>因特网的规模宏大. 如果让所有的路由器知道所有的网络应怎么样到达,则这种路由表非常大, 处理起来也花费很多时间.</li>
<li>许多单位不愿意让外界了解自己单位网络的布局细节和本部门所采用的路由选择协议,同时还希望能接上因特网.</li>
</ul>
</li>
<li>基于上面的两个原因, 因特网将整个互联网划分为许多较小的自治系统(autonomous system),一般称为AS.</li>
<li>一个AS对外表现出是一个单一的和一致的路由选择策略.</li>
<li>一个大的ISP就是一个自治系统, 因特网把路由选择协议分为两大类:<ul>
<li>内部网关协议IGP: 在一个自治系统内使用的路由选择协议,而这与互联网中的其他自治系统选用什么路由选择协议无关,目前用得最多的内部网关协议有:RIP, OSPF.</li>
<li>外部网关协议EGP: 若元源主机和目的主机处于两个不同的自治系统内, 当数据报传到一个自治系统的边界时, 就需要使用一种协议将路由选择信息传递到另外一个自治系统中. 目前使用得最多的外部网关协议: BGP</li>
</ul>
</li>
<li>自治系统之间的路由选择也叫做域间路由选择, 而在自治系统内的路由选择叫做域间内部选择.</li>
</ul>
<blockquote>
<h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3></blockquote>
<p>RIP是一种分布式,异步,收敛,迭代的基于距离向量的路由选择协议.</p>
<ol>
<li>分布: 每个节点将自己的路由表发给自己直接相邻的节点.</li>
<li>异步: 节点不需要在某个固定的时间同时发送和交换信息.</li>
<li>收敛: 在有限次的信息交换次数内, 不管初始值是多少, 路由表中的每一项一定会收敛成某个固定值, 也就是真正的最短路径.</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>从一个路由器到直接连接的网络距离定义为1.</li>
<li>从路由器到非直接连接的网络距离定义为所经过的路由器数+1,</li>
<li>RIP允许一条路径只能包含15个路由器,因此,当距离等于16时,相当于不可达.</li>
<li>RIP不能在两个网络之间同时使用多条路由, RIP只会选择一条具有最少路由器的路径.</li>
</ul>
<p>RIP协议下的路由器都需要不断和其他的路由器交换路由信息,那么,是和哪些路由器交换信息?交换什么信息?在什么时候交换信息?</p>
<h5 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点:"></a>RIP协议的特点:</h5><ul>
<li>仅和相邻路由器交换信息</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息,即自己的路由表.也就是,交换的信息是: 一个路由器到本自治系统内所有网络的最短距离,以及到每个网络应经过的下一个路由器.</li>
<li>按固定时间交换路由信息.路由表中的最主要信息:到某个网络的距离,以及经过的下一跳地址和下一跳路由的地址.</li>
</ul>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p>对每个相邻路由器发来的RIP报文, 将进行一下步骤:</p>
<ol>
<li>对地址为X的相邻路由器发送过来的RIP报文, 先修改此报文中的所有项目, 把下一跳字段中的地址改为X, 把所有距离都+1.每个项目都有三个关键数据:到目的网络N, 距离d, 下一跳路由器X.</li>
<li>对修改的RIP报文中的每一个项目,进行一下步骤:<br><br>若原来的路由表没有目的网络N, 则把该项目添加到路由表.<br><br>否则,若下一跳路由器地址为X, 则把收到项目替换掉原来路由表中的项目.否则什么也不做</li>
<li>若3分钟还没有收到相邻路由器的更新路由表,则把此相邻路由器记录为不可到达网络,即把距离设置为16.</li>
<li>返回.</li>
</ol>
<h5 id="“坏消息传得慢”"><a href="#“坏消息传得慢”" class="headerlink" title="“坏消息传得慢”"></a>“坏消息传得慢”</h5><p>RIP存在一个缺点是当网络发生故障时, 要经过比较长的时间才能将信息传送到所有的路由器.例如:</p>
<p><img src="/uploads/计网/路由选择协议/RIP缺点.png" alt=""></p>
<p>假定路由器1到网1的链路出了故障, R1无法到达网1. 于是路由器R1把到网1的距离设置为16, 因而在R1的路由表中相应的项目变为”1, 16, 直接”. 但是很可能要经过30秒后才能把更新信息发给R2.然而R2可能已经先把自己的路由信息”1, 2, R1”发给R1, R1收到这个报文后,误认为可以通过R2到达网1, 于是更新”1, 2, R1”修改为”1, 3, R2”,并发给R2.同理,R2接着又更新自己的路由表信息为”1, 4, R1”.这样的更新一直持续到R1,R2到网1的距离都增大到16,R1, R2才知道网1原来不可达.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>RIP最大的优点是实现简单,开销小.</li>
<li>RIP只能使用的最大距离为15, 这样限制了网络的规模.</li>
<li>路由器之间的路由交换信息是路由器中完整的路由表,因而随着网络规模的扩大, 开销也就增加.</li>
<li>坏消息传播得慢,使得更新过程的收敛时间过长.</li>
<li>对于较大规模的网络应该换用OSPF协议.</li>
</ul>
<blockquote>
<h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3></blockquote>
<p>OSPF最主要的特征是使用了分布式的链路状态协议.</p>
<h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><h5 id="向本自治系统中的所有路由器发送信息"><a href="#向本自治系统中的所有路由器发送信息" class="headerlink" title="向本自治系统中的所有路由器发送信息"></a>向本自治系统中的所有路由器发送信息</h5><p>路由器通过所有输出端口向所有相邻路由器发送信息,也就是端口洪泛.而每个相邻路由器又再将此信息发往其所有的相邻路由器.这样整个区域中所有路由器都得到了这个信息的一个副本.</p>
<h5 id="发送的信息"><a href="#发送的信息" class="headerlink" title="发送的信息"></a>发送的信息</h5><p>发送的信息是与本路由器相邻的所有路由器的链路状态.所谓”链路状态”是本路由器都和哪些路由器相邻,以及该链路的度量.</p>
<h5 id="何时发送信息"><a href="#何时发送信息" class="headerlink" title="何时发送信息"></a>何时发送信息</h5><p>只有当链路状态发生改变时,路由器才向所有路由器洪泛此信息.</p>
<h5 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h5><p>由于各个路由器之间频繁进行链路状态交换,因此所有路由器最终都能建立一个链路状态数据库.这个数据库实际上就是全网的拓扑结构.链路状态数据库能较快地进行更新,使各个路由器能及时更新路由表.</p>
<h5 id="链路状态更新"><a href="#链路状态更新" class="headerlink" title="链路状态更新"></a>链路状态更新</h5><p>只有当链路状态发生变化时, 路由器才向所有路由器用洪泛法发送此消息.</p>
<h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><p>OFPS将一个自治系统再划分为几个更小的范围,叫作区域.划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是一个完整的自治系统.</p>
<blockquote>
<h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3></blockquote>
<p>不同自治系统之间的路由选择不使用RIP或者OSPF的原因:</p>
<ol>
<li>因特网的规模太大,使得AS之间的路由变得非常困难.如果使用链路状态协议, 则每个路由器需要维持一个很大的链路状态数据库.另外,不同的自治系统各自运行着自己选定的内部路由选择协议, 并使用本AS指明的路径度量.因此当一条路径通过不同的自治系统时,路径的度量可能会出歧义.例如:对某AS来说, 代价为1000可能表示一条比较长的路由, 但对另外一AS代价为1000, 可能表示不可接受的坏路由.</li>
<li>AS之间的路由选择必须考虑策略. 由于相连的网络性能相差很大, 如果根据最少跳数找出来的路径, 可能并不合适.也有的代价啊很高或不安全.</li>
</ol>
<p>基于上述的情况, 边界网关协议BGP只能力求寻找一条能够到达目的网络比较好的路由,而非寻找一条最佳路由.BGP采用了路径向量路由选择协议.</p>
<h4 id="BGP发言人"><a href="#BGP发言人" class="headerlink" title="BGP发言人"></a>BGP发言人</h4><ul>
<li><p>在配置BGP时, 每个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人.一般来说,这两个BGP发言人都是通过一个网络共享连接在一起的,而BGP发言人往往是边界路由器.</p>
</li>
<li><p>一个BGP发言人与其他AS的BGP发言人要交换路由信息,就要先建立TCP连接,然后在此连接上交换BGP报文以建立BGP会话,利用BGP会话交换路由信息,如增加了新的路由,或者撤销过时的路由,以及报告差错等.使用TCP连接交换路由信息的两个BGP发言人,彼此成为对方的邻站或对等站.</p>
</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由选择协议&quot;&gt;&lt;a href=&quot;#路由选择协议&quot; class=&quot;headerlink&quot; title=&quot;路由选择协议&quot;&gt;&lt;/a&gt;路由选择协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网际控制报文协议ICMP</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP/"/>
    <id>http://cristianoro7.github.io/2017/06/29/网际控制报文协议ICMP/</id>
    <published>2017-06-29T14:39:15.533Z</published>
    <updated>2017-06-29T14:39:15.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>ICMP报文种类</li>
<li>ICMP应用举例</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>为了更有效地转发IP数据报和提高交付成功的机会, 在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol). ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告.ICMP报文作为IP层的数据报的数据.</p>
<blockquote>
<h3 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h3></blockquote>
<ul>
<li>网际报文的种类有两种, 即ICMP差错报告报文和ICMP询问报文.</li>
<li>几种常用的ICMP报文类型</li>
</ul>
<table>
<thead>
<tr>
<th>ICMP报文类型</th>
<th>类型的值</th>
<th>ICMP报文的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>差错报告报文</td>
<td>3</td>
<td>终点不可达</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>4</td>
<td>源点抑制</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>11</td>
<td>时间超过</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>12</td>
<td>参数问题</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>5</td>
<td>改变路由</td>
</tr>
<tr>
<td>询问报文</td>
<td>8或0</td>
<td>回送请求或回答</td>
</tr>
<tr>
<td>询问报文</td>
<td>13或14</td>
<td>时间戳请求或回答</td>
</tr>
</tbody>
</table>
<h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p>当路由器或者主机不能交付数据报时就向源点发送终点不可达报文</p>
<h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p>当路由器或者主机因拥塞而丢弃数据报时, 就向源点发送源点抑制报文, 使源点知道应当把数据报的发送速率放慢.</p>
<h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p>当路由器收到生存时间为0的数据报时, 除了丢弃数据报外, 还要向源点发送时间超过报文.</p>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p>当路由器或者目的主机收到的数据报的首部中有的字段的值不正确时, 就丢弃该数据报,并向源点发送参数问题报文.</p>
<h4 id="改变路由-路由重定向"><a href="#改变路由-路由重定向" class="headerlink" title="改变路由(路由重定向)"></a>改变路由(路由重定向)</h4><p>路由器把改变路由报文发送给主机, 让主机知道下次应该将数据报发送给另外的路由器.</p>
<h4 id="回送请求和回答"><a href="#回送请求和回答" class="headerlink" title="回送请求和回答"></a>回送请求和回答</h4><p>ICMP回送请求报文是由主机或者路由器向一个特定的目的主机发送询问. 收到此报文的主机必须给源主机或者路由发送ICMP回送回答报文.</p>
<h4 id="时间戳请求和回答"><a href="#时间戳请求和回答" class="headerlink" title="时间戳请求和回答"></a>时间戳请求和回答</h4><p>ICMP时间戳请求报文是请某个主机或者路由器回答当前的日期和时间.</p>
<blockquote>
<h3 id="ICMP的应用举例"><a href="#ICMP的应用举例" class="headerlink" title="ICMP的应用举例"></a>ICMP的应用举例</h3></blockquote>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><ul>
<li>ICMP一个重要应用就是分组网间探测PING, 用来测试两个主机之间的连通性.</li>
<li>PING使用了ICMP的回送请求和回送回答报文.</li>
<li>PING是应用层直接使用网络层ICMP的例子, 它没有通过运输层的TCP或UDP.</li>
</ul>
<h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><ul>
<li>traceroute是用来跟踪一个分组从源点到终点的路径.</li>
<li>traceroute从源主机向目的主机发送一连串IP数据报, 数据报中封装的是无法交付的UDP用户数据报.第一个数据报P1的生存时间为TTL设置为1.当P1到达路径上的第一个路由器R1时, 路由器R1先收下它, 接着把TTL的值减1.由于TTL等于0了, R1就把P1丢弃了, 并向源主机发送一个ICMP时间超过的差错报告报文.</li>
<li>如此循环下去, 当最后一个数据报刚刚达到目的主机时, 数据报的TTL是1, 主机不转发数据, 也不把TTL减1.但因IP数据报封装的是无法交付的运输层UDP用户数据报, 因此目的主机要向源主机发送ICMP终点不可达差错报告报文.</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网际控制报文协议ICMP&quot;&gt;&lt;a href=&quot;#网际控制报文协议ICMP&quot; class=&quot;headerlink&quot; title=&quot;网际控制报文协议ICMP&quot;&gt;&lt;/a&gt;网际控制报文协议ICMP&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>子网的划分和构成超网</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/"/>
    <id>http://cristianoro7.github.io/2017/06/29/子网的划分和构造超网/</id>
    <published>2017-06-29T14:39:04.513Z</published>
    <updated>2017-06-29T14:39:04.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子网的划分和构成超网"><a href="#子网的划分和构成超网" class="headerlink" title="子网的划分和构成超网"></a>子网的划分和构成超网</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>划分子网</li>
<li>使用子网时的分组转发</li>
<li>无分类编址CIDR</li>
</ul>
<blockquote>
<h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2></blockquote>
<h3 id="两级IP地址的不合理"><a href="#两级IP地址的不合理" class="headerlink" title="两级IP地址的不合理"></a>两级IP地址的不合理</h3><h4 id="IP空间利用率低"><a href="#IP空间利用率低" class="headerlink" title="IP空间利用率低"></a>IP空间利用率低</h4><p>一个A类网路可容纳的主机数超过1000W, 而B类网络可容纳主机超过6W.但是有些网络对连接在网络上的主机数量是有限制的, 这就导致了地址空间的利用率低下.</p>
<h4 id="路由表变大导致网络性能低下"><a href="#路由表变大导致网络性能低下" class="headerlink" title="路由表变大导致网络性能低下"></a>路由表变大导致网络性能低下</h4><p>给每个物理网络分配一个网络号的话, 会导致路由表中的项目大大增大, 同时查找路由的耗时也就变得更长.</p>
<p>为了解决二级IP带来的问题,从1985年起,将IP地址中增加了一个”子网号字段”, 使得二级IP地址变成三级IP地址.这种做法叫做划分子网.</p>
<blockquote>
<h3 id="划分子网的基本思路"><a href="#划分子网的基本思路" class="headerlink" title="划分子网的基本思路"></a>划分子网的基本思路</h3></blockquote>
<ul>
<li>一个拥有许多物理地址的单位, 可将所属的物理网络划分为多个子网.划分子网属于单位内部的事情,对外还是表现为一个网络.</li>
<li>划分子网的方法是从网路的主机号借用若干位作为子网号,于是二级IP地址在单位内部就变成了三级IP地址,即 network-id:subnet-id-host-id</li>
</ul>
<blockquote>
<h3 id="子网划分实例"><a href="#子网划分实例" class="headerlink" title="子网划分实例"></a>子网划分实例</h3></blockquote>
<p><img src="/uploads/计网/划分子网/子网.png" alt=""></p>
<p>上图的网络被划分为三个子网, 整个网络对外表现为一个网络, 其网络地址为145.13.0.0.但是网络145.13.0.0上的路由器R1在收到外来的数据报后, 再根据数据报的目的地址将它转发到对应的子网.</p>
<blockquote>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3></blockquote>
<p>我们知道, 从IP数据报的首部无法看出源主机或目的主机是否进行了子网的划分,路由器是如何将数据报转发到子网?使用子网掩码可以解决这个问题.</p>
<h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><ul>
<li>子网掩码是一个32位2进制数, 对应的网络地址全为1,主机地址全为0.</li>
<li>A类网络的默认子网掩码为:255.0.0.0, B类为255.255.0.0, C类为255.255.255.0</li>
</ul>
<h4 id="通过目的IP地址和子网掩码计算子网的网络地址"><a href="#通过目的IP地址和子网掩码计算子网的网络地址" class="headerlink" title="通过目的IP地址和子网掩码计算子网的网络地址"></a>通过目的IP地址和子网掩码计算子网的网络地址</h4><ul>
<li>将数据报的目的IP地址与子网掩码逐位相”与”.</li>
</ul>
<p>例如: IP地址为141.14.72.24, 子网掩码为255.255.192.0,求网络地址<br>解析: 子网掩码为11111111 11111111 11000000 00000000, 由于子网掩码的前两个字节的位全为1, 最后一个字节的位全为0,因此, 可暂时推断网络地址为: 141.14.X.0. 此时, 只需要将72对应的二进制数与11000000逐位相”与”,就可得出完整的网络地址: 141.14.64.0.</p>
<h4 id="利用子网数来计算子网掩码"><a href="#利用子网数来计算子网掩码" class="headerlink" title="利用子网数来计算子网掩码"></a>利用子网数来计算子网掩码</h4><p>在求子网掩码时, 必须弄清楚划分子网的数目,以及每个子网内所需的主机数目.<br><br><br>1)将子数目转为二进制<br><br>2)取得二进制的位数N<br><br>3)取得该IP地址的类子网掩码, 将其主机号的前N位置1,即可得该IP地址划分子网的子网掩码<br></p>
<p>eg: 将B类IP地址168.192.0.0划分为27个子网.<br><br>1) 27 = 11011<br><br>2) N = 5<br><br>3) B类子网掩码: 255.255.0.0<br><br>4) 该IP地址划分的子网掩码: 255.255.248.0.</p>
<h4 id="子网的划分选择"><a href="#子网的划分选择" class="headerlink" title="子网的划分选择"></a>子网的划分选择</h4><p>下面给出B类子网的划分选择(使用固定的长度子网)</p>
<table>
<thead>
<tr>
<th>子网号位数</th>
<th>子网掩码</th>
<th>子网数</th>
<th>每个子网的主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>255.255.192.0</td>
<td>2^2-2</td>
<td>2^14-2</td>
</tr>
<tr>
<td>3</td>
<td>255.255.224.0</td>
<td>2^3-2</td>
<td>2^13-2</td>
</tr>
<tr>
<td>4</td>
<td>255.255.240.0</td>
<td>2^4-2</td>
<td>2^12 -2</td>
</tr>
<tr>
<td>5</td>
<td>255.255.248.0</td>
<td>2^5-2</td>
<td>2^11-2</td>
</tr>
<tr>
<td>6</td>
<td>255.255.252.0</td>
<td>2^6-2</td>
<td>2^10-2</td>
</tr>
<tr>
<td>7</td>
<td>255.255.254.0</td>
<td>2^7-2</td>
<td>2^9-2</td>
</tr>
<tr>
<td>8</td>
<td>255.255.255.0</td>
<td>2^8-2</td>
<td>2^8-2</td>
</tr>
<tr>
<td>9</td>
<td>255.255.255.128</td>
<td>2^9-2</td>
<td>2^7-2</td>
</tr>
<tr>
<td>10</td>
<td>255.255.248.192</td>
<td>2^10-2</td>
<td>2^6-2</td>
</tr>
<tr>
<td>11</td>
<td>255.255.252.224</td>
<td>2^11-2</td>
<td>2^5-2</td>
</tr>
<tr>
<td>12</td>
<td>255.255.254.240</td>
<td>2^12-2</td>
<td>2^4-2</td>
</tr>
<tr>
<td>13</td>
<td>255.255.255.248</td>
<td>2^13-2</td>
<td>2^3-2</td>
</tr>
<tr>
<td>14</td>
<td>255.255.255.252</td>
<td>2^14-2</td>
<td>2^2-2</td>
</tr>
</tbody>
</table>
<p><br><br>上面-2是因为去掉全0和全1的情况, 子网号位数没有0,1,15,16这四种情况是因为这几种情况没有意义.</p>
<blockquote>
<h3 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h3></blockquote>
<p>使用子网划分后, 路由表必须包含这三项内容:目的网络地址,子网掩码和下一跳地址.</p>
<h4 id="路由转发算法"><a href="#路由转发算法" class="headerlink" title="路由转发算法"></a>路由转发算法</h4><ol>
<li>从收到的数据报的首部提取目的IP地址D.</li>
<li>先判断是否可以直接交付. 对路由器相连的网络逐个检查:用各个网络的子网掩码与D逐位相”与”, 看结果是否和相应的网络地址匹配.若匹配,则把分组直接交付, 否则执行(3).</li>
<li>若路由器表中有目的地址为D的特定主机路由, 则把数据报传送给下一跳的路由器,否则执行(4)</li>
<li>对路由表中的每一行,用其中的子网掩码和D逐位相”与”,若结果与目的网络地址匹配,把数据报传送下一跳的路由器, 否则执行(5).</li>
<li>若路由表中有一个默认的路由, 则把数据报传给默认路由, 否则执行(6)</li>
<li>报告转发分组时出错.</li>
</ol>
<h4 id="转发实例"><a href="#转发实例" class="headerlink" title="转发实例"></a>转发实例</h4><p><img src="/uploads/计网/划分子网/子网转发分组.png" alt=""></p>
<p>讨论R1收到H1向H2发送分组后,查找路由表的过程</p>
<ol>
<li>H1把本子网的子网掩码 255.255.255.128 与目的主机的ip地址逐位相”与”, 得出 128.30.33.128,它不等于H1的网络地址,说明H1与H2不在同一个子网内, 因此H1不能把分组直接交付给H2,必须交给子网上的默认路由器R1,由R1来进行转发</li>
<li>R1收到一个分组后, 就在路由表中寻找有无匹配的网络地址.(1)计算出目的网络地址为128.30.33.128, 与路由表中的第二行的目的网络地址匹配, 说明这个网络就是分组想要寻找的目的网络, 于是R1将分组从接口1,直接交付给主机H2.</li>
</ol>
<blockquote>
<h2 id="无分类编址CIDR-构成超网"><a href="#无分类编址CIDR-构成超网" class="headerlink" title="无分类编址CIDR(构成超网)"></a>无分类编址CIDR(构成超网)</h2></blockquote>
<p>无分类域间路由选择CIDR解决的问题:</p>
<ol>
<li>B类地址眼看就快要分配完了</li>
<li>因特网主干网上的路由表项目数急剧增长.</li>
</ol>
<blockquote>
<h3 id="CIDR的两个主要的特点"><a href="#CIDR的两个主要的特点" class="headerlink" title="CIDR的两个主要的特点"></a>CIDR的两个主要的特点</h3></blockquote>
<ul>
<li>CIDR消除了传统的A类,B类,C类地址以及子网的划分的概念,把32位的IP地址划分了两个部分.前一部分用来表示网络前缀,以表示网络. 后一部分则用来表主机.</li>
<li>CIDR把网络前缀相同的连续IP地址组成一块”CIDR地址块”.</li>
</ul>
<blockquote>
<h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3></blockquote>
<ul>
<li><strong>由于一个CIDR地址块中有很多地址,所以在路由表中就利用CIDR地址块来查找目的网络. 这种地址的聚合称为路由聚合.</strong></li>
<li>它使得一个路由表可以表示更多地址. 路由聚合也称为构成子网.</li>
</ul>
<blockquote>
<h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3></blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在使用CIDR时, 由于采用了网络前缀这种记法, 因此在路由表中的项目也要有相应的改变.在查找路由表时, 可能会得到不止一个匹配结果, 那么我们应该选择哪条结果?</p>
<h4 id="最长匹配"><a href="#最长匹配" class="headerlink" title="最长匹配"></a>最长匹配</h4><p>为了解决上述问题, 应该从匹配结果中选择具有最长网络前缀的路由, 这叫做最长前缀匹配.</p>
<h4 id="使用二叉线索查找路由表"><a href="#使用二叉线索查找路由表" class="headerlink" title="使用二叉线索查找路由表"></a>使用二叉线索查找路由表</h4><p>使用CIDR后, 由于要查找最长前缀匹配, 使路由表的查找过程变得更加复杂.为了更有效的查找, 通常是把无分类编址的路由表存放在一种层次的数据结构中, 然后,自上而下进行查找.这里最常用的是二叉线索.为了提高二叉线索的查找速度,可以使用压缩技术.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.360doc.com/content/10/0205/11/276520_15184122.shtml" target="_blank" rel="external">http://www.360doc.com/content/10/0205/11/276520_15184122.shtml</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;子网的划分和构成超网&quot;&gt;&lt;a href=&quot;#子网的划分和构成超网&quot; class=&quot;headerlink&quot; title=&quot;子网的划分和构成超网&quot;&gt;&lt;/a&gt;子网的划分和构成超网&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; cl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>IP地址分类</title>
    <link href="http://cristianoro7.github.io/2017/06/29/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/"/>
    <id>http://cristianoro7.github.io/2017/06/29/IP地址分类/</id>
    <published>2017-06-29T14:38:02.913Z</published>
    <updated>2017-06-29T14:38:02.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分类</li>
<li>特殊IP地址</li>
<li>共有IP地址</li>
<li>私有IP地址</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>IP地址是连接在因特网上的主机的唯一标识, 通过特定的IP地址能找到被该IP地址标识的主机.例如:我们的家地址可以看作一个IP地址, 通过这个地址,可以找到我们,也就是主机.</li>
<li>在TCP/IP协议中, IP地址是以二进制数字形式出现, 共32Bit, 1Bit就是二进制中的1位, 由于二进制的形式不适合人们阅读.因此换用一种”点分十进制法”表示IP地址.</li>
<li>例如:<br><br>点分十进制: 192.168.1.1<br><br>二进制: 11000000.10101000.00000001.00000001</li>
</ul>
<blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></blockquote>
<table>
<thead>
<tr>
<th></th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class A</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class B</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class C</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
</tr>
<tr>
<td>Class D</td>
<td>多播</td>
</tr>
<tr>
<td>Class E</td>
<td>科研用</td>
</tr>
</tbody>
</table>
<h4 id="Class-A"><a href="#Class-A" class="headerlink" title="Class A"></a>Class A</h4><ul>
<li>A类地址的第一个8 Bit 表示网络位, 且<code>网络位的第一个Bit为0</code>, 1-7Bit表示网络标识,格式为:0XXXXXXXX.</li>
<li>后3个8 Bit 表示主机位.</li>
<li>A类地址的网络范围:00000001~01111111, 用十进制表示: 1.0.0.0到126.0.0.0,一共有126个网络.</li>
<li>主机标识为2的24次幂-2个(去掉全0和全1的地址), 全0的主机号字段表示该IP地址是”本机”连接到的单个网络地址,而1的主机号表示该网络上的所有主机.每个网络可容纳的主机数为16777214个.</li>
<li>A类地址支持巨型网络,一般分给有大量主机的网络使用.</li>
</ul>
<h4 id="Class-B"><a href="#Class-B" class="headerlink" title="Class B"></a>Class B</h4><ul>
<li>B类地址的前两个8 Bit表示网络标位, 且网络位的前两个Bit总是10, 即格式为: 10XXXXXX XXXXXXXX.</li>
<li>B类地址可指派的网络数为: 2的14次幂-1, -1的原因是128.0.0.0是不指派的.</li>
<li>后两个8 Bit表示主机位.</li>
<li>B类的每个网络可容纳的主机数是2的16次幂-2, 即65534.</li>
</ul>
<h4 id="Class-C"><a href="#Class-C" class="headerlink" title="Class C"></a>Class C</h4><ul>
<li>C类地址的前3个字节表示网路号, 且开头必须为<code>110</code>, 可以指派的最小网络地址为:192.0.1.0, 指派的网络范围为2的21次幂-1, -1的原因是192.0.0.0是不指派的.</li>
<li>每个C类地址可容纳的主机数为:2的8次幂-2.</li>
</ul>
<blockquote>
<h3 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h3></blockquote>
<h4 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h4><ul>
<li>它表示所有不清楚的主机和目的网络.</li>
<li>不清楚的是意思是本机路由表中没有指定如何到达.</li>
<li>如果在网络设置中设置了缺省网关, 那么系统会自动生成一个目的地址为0.0.0.0的缺省路由,所有不清楚的目的网络和主机都会被送到这里.</li>
</ul>
<h4 id="255-255-255-255"><a href="#255-255-255-255" class="headerlink" title="255.255.255.255"></a>255.255.255.255</h4><ul>
<li>对本机来说, 这个地址指本网段内的所有主机. 这个地址不能被路由器所转发.</li>
</ul>
<h4 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h4><ul>
<li>A类网络中的127是一个保留地址, 用于网络软件测试和本机进程间的通信.</li>
<li>无论什么程序, 只要发送了该地址的数据, 就会被立刻发送回本机.</li>
<li>127网络号的分组不能出现在网络传输上.</li>
</ul>
<h4 id="局域网内的IP"><a href="#局域网内的IP" class="headerlink" title="局域网内的IP"></a>局域网内的IP</h4><ul>
<li>当主机号的全为0时,表示一个网络本身.</li>
<li>当主机号全为1时, 表示网络中的全部主机.</li>
<li>网络号代表一个网络本身, 同时也是一个网段的第一个地址. 广播地址是网段的最后一个地址,这两个地址是不能配在主机上的.</li>
</ul>
<blockquote>
<h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3></blockquote>
<ul>
<li>属于非注册地址, 专门为组织机构(学校,企业)内部使用, 简单来说私有地址不能直接上网.</li>
<li>私有IP的范围:<ul>
<li>A类私有IP地址: 10.0.0.0~10.255.255.255</li>
<li>B类私有IP地址: 172.16.0.0~172.31.255.255</li>
<li>C类私有地址: 192.168.0.0~192.168.255.255</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="公有IP"><a href="#公有IP" class="headerlink" title="公有IP"></a>公有IP</h3></blockquote>
<ul>
<li>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Internet NIC提出申请的组织机构。通过它直接访问因特网，它是广域网范围内的。</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45337405" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45337405</a></li>
<li><a href="http://blog.csdn.net/txx9010/article/details/7712438" target="_blank" rel="external">http://blog.csdn.net/txx9010/article/details/7712438</a></li>
<li><a href="https://www.zhihu.com/question/27714563" target="_blank" rel="external">https://www.zhihu.com/question/27714563</a></li>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45226275" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45226275</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP地址分类&quot;&gt;&lt;a href=&quot;#IP地址分类&quot; class=&quot;headerlink&quot; title=&quot;IP地址分类&quot;&gt;&lt;/a&gt;IP地址分类&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP滑动窗口</title>
    <link href="http://cristianoro7.github.io/2017/06/29/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://cristianoro7.github.io/2017/06/29/TCP滑动窗口/</id>
    <published>2017-06-29T14:37:18.384Z</published>
    <updated>2017-06-29T14:37:18.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>以字节流为单位的滑动窗口</li>
<li>TCP数据流的类别</li>
<li>接收窗口的确认机制</li>
<li>窗口缩放</li>
<li>缓冲区</li>
<li>超时重传时间的选择</li>
<li>选择确认SACK</li>
</ul>
<blockquote>
<h3 id="以字节流为单位的滑动窗口"><a href="#以字节流为单位的滑动窗口" class="headerlink" title="以字节流为单位的滑动窗口"></a>以字节流为单位的滑动窗口</h3></blockquote>
<p>现假定A收到B发来的确认报文,其中窗口是20,而确认号为31.根据这两个数据,A就构造出了自己的发送窗口:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/滑动窗口.png" alt=""></p>
<ul>
<li>在没有收到B的确认的情况下,A可以连续把窗口内的数据都发送出去.凡是已经发送过去的数据,在未收到确认之前都必须暂时保留,以便在超时重传时使用.</li>
<li>窗口后沿的后面部分表示已经确认接收.这些数据不需要再保留了.</li>
<li>窗口的前沿部分表示不允许发送,因为接收方都没有为这部分数据保留缓存空间.</li>
</ul>
<blockquote>
<h3 id="TCP数据流的类别"><a href="#TCP数据流的类别" class="headerlink" title="TCP数据流的类别"></a>TCP数据流的类别</h3></blockquote>
<p>现在假定A发送序号为31到41的数据.此时, 发送窗口位置并未改变,如图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/数据流分类.png" alt=""></p>
<p>从上图,可以得来的信息:</p>
<p>小于P1的是已经发送并已经收到确认的部分.而大于P3的是不允许发送的部分.<br>P3-P1 = A 的发送窗口.</p>
<p>P2-P1 = 已发送但尚未确认的字节数</p>
<p>P3-P2 = 允许发送但尚未发送的字节数.又称为可用窗口.</p>
<blockquote>
<h3 id="接收窗口的确认机制"><a href="#接收窗口的确认机制" class="headerlink" title="接收窗口的确认机制"></a>接收窗口的确认机制</h3></blockquote>
<p>B的接收窗口大小是20. 在接收窗口外面,到30号为止的数据是已经发送过确认.接收窗口内的序号31~50是允许接收的. 下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/接收窗口确认机制.png" alt=""></p>
<p>B收到了序号为32和33的数据.这些数据没有按序到达,因为序号31还没有到达.此时,B只能对按序到达的数据中的最高序号给出确认,因此B发送的确认报文段中的确认号仍然为31.</p>
<blockquote>
<h3 id="窗口缩放"><a href="#窗口缩放" class="headerlink" title="窗口缩放"></a>窗口缩放</h3></blockquote>
<p>现在假定B收到了序号为31的数据,并把序号为31~33的数据交付主机,然后B删除这些数据.接着把接收窗口向前移动3个序号,如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/B的接收窗口.png" alt=""></p>
<p>同时给A发送确认,其中窗口值为20,但确认号为34.我们注意到, B收到了序号为37,38,40的数据,但这些数据没有按序到达,只能暂时存放在接收窗口中.</p>
<p>A收到B的确认后,就可以把发送窗口向前移动3个序号,但指针P2不动.可以看出,现在A的可用窗口增大了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/A的可用窗口增大.png" alt=""></p>
<p>A在继续发送完序号42~53的数据后,指针P2和P3重合.发送窗口内的序号已经用完,但还没有收到确认.这时A必须停止发送.如果一段时间后,A还没有收到B发来的确认,那么A必须重传这部分数据.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/发送窗口满.png" alt=""></p>
<blockquote>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3></blockquote>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/sliding_window-900x358.jpg" alt=""></p>
<p>上图中，我们可以看到：</p>
<ul>
<li><p>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</p>
</li>
<li><p>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</p>
</li>
</ul>
<blockquote>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3></blockquote>
<p>由于TCP的下层是互联网环境, 发送的报文段可能经过一个高速率的局域网, 也可能经过多个低速率的网络.如果把超时重传时间设置得太短, 就会引起很多报文的不必要重传. 如果把超时重传的时间设置得过长, 则会使得网络的空闲时间太长,从而降低了传输效率.</p>
<p>TCP采用了一种自适应的算法, 它记录一个报文段的发出时间, 以及收到相应的确认时间.这两个时间之差就是报文段的往返时间 RTT. TCP保留了RTT的一个加权平均往返时间RTTs.每当第一次测量到样本RTT样本时,RTTs的值就取为所测量到的RTT样本值.但以后每测量到一个新的RTT样本时,就按照下面的公式计算RTTs:</p>
<p>新的RTTs = (1 - a) <em> (旧的RTTs) + a </em> (新的RTT样本)</p>
<p>RFC推荐a的值为1/8.用这种方法测出的加权平均往返时间RTTs会比测量的RTT值更加平滑.</p>
<p>显然超时重传时间应略大于RTTs. RCF推荐使用下面公式计算:</p>
<p>RTO = RTTs+= + 4 * RTTD</p>
<p>RTTD是RTT的偏差加权平均值,它与RTTs和新的RTT样本的差有关.当第一次测量时, RTTD取为测量到的RTT样本值的一半.在以后的测量中,可以使用下面的公式计算出RTTD</p>
<p>新的RTTD = (1 - B) <em> (旧的RTTD) + B </em> |RTTs - 新的RTT样本 |</p>
<blockquote>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3></blockquote>
<p>现在假设接收方收到的报文段无差错, 只是未按序号,中间还缺少一些序号的数据,通过选择确认SACK可以实现只传送缺少的数据而不重传已经正确到达接收方的数据.下面使用一个例子来理解SACK的工作原理.</p>
<p>TCP接收方在接收对方发送过来的数据字节流的序号不连续,结果就形成了不连续的字节块:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/SACK.png" alt=""></p>
<p>从上图可以看出, 序号1~1000收到了,但序号1001~1500没有收到,接下来的字节又收到了,但是缺少3001~3500.后面序号4501起也没有收到.换句话说,接收方收到了和前面的字节流不连续的两个字节块.如果这些字节块都在接收窗口的范围内,那么接收方就先收下这些数据,但要把这些信息发给发送方,防止发送方重传接收方已经接收到的数据.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">http://coolshell.cn/articles/11609.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP滑动窗口&quot;&gt;&lt;a href=&quot;#TCP滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;TCP滑动窗口&quot;&gt;&lt;/a&gt;TCP滑动窗口&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP首部</title>
    <link href="http://cristianoro7.github.io/2017/06/29/TCP%E9%A6%96%E9%83%A8/"/>
    <id>http://cristianoro7.github.io/2017/06/29/TCP首部/</id>
    <published>2017-06-29T14:36:59.572Z</published>
    <updated>2017-06-29T14:36:59.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></blockquote>
<p>TCP的全部功能都体现在其首部中的各个字段的作用.因此, 只有弄清TCP首部各个字段的作用才能理解TCP的工作原理.</p>
<p>TCP首部的前20个字节是固定的,后面有4n字节是根据需要而增加的选项.因此,TCP首部的最小长度为20字节.</p>
<h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占2个字节, 分别写入源端口号和目的端口号. TCP的分用和复用功能是通过端口实现的.</p>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占4个字节.TCP是面向字节流的,在一个TCP连接中传送的字节流中的每一个字节都按顺序编号.序号字段值是用来指定本报文段所发送的数据的第一个字节的序号.</p>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占4字节.是接收方期望收到发送方下一个报文段的第一个数据字节序号.例如:B正确接收了A发送过来的一个报文段,其序号字段为501,数据长度为200字节,表明B正确接收了501~700的序号的数据.因此,B期望收到A的下一个数据序号是701, 于是B在发送给A的确认报文中把确认号置为701.</p>
<h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占4位, 它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远.这个字段实际上是指出TCP首部的长度.</p>
<h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占6位, 保留为今后使用, 但目前应置为0</p>
<h3 id="紧急URG"><a href="#紧急URG" class="headerlink" title="紧急URG"></a>紧急URG</h3><p>当URG = 1时, 表明紧急指针字段有效.它告诉系统,当前报文段有紧急数据,应当尽快传送.</p>
<h3 id="确认ACK"><a href="#确认ACK" class="headerlink" title="确认ACK"></a>确认ACK</h3><p>仅当ACK = 1时确认号字段才有效.当ACK = 0时,确认号无效. TCP规定,在连接建立后所有传送的报文段都必须把ACK置为1.</p>
<h3 id="推送PSH"><a href="#推送PSH" class="headerlink" title="推送PSH"></a>推送PSH</h3><p>当发送方将PSH置为1,并立即创建一个报文段发送出去.接收方TCP收到PSH = 1的报文段时,就尽快地交付接收应用程序,而不再等到整个缓存填满了再向上交付.</p>
<h3 id="复位-RST"><a href="#复位-RST" class="headerlink" title="复位(RST)"></a>复位(RST)</h3><p>当RST = 1 时, 表明TCP连接出现严重错误,必须释放连接,然后再重新建立连接.</p>
<h3 id="同步SYN"><a href="#同步SYN" class="headerlink" title="同步SYN"></a>同步SYN</h3><p>在连接建立时用来同步序号. 当SYN = 1 时而ACK = 0 时表示这是一个连接请求报文段.若对方同意连接后, 则应在响应报文中使SYN = 1和ACK = 1.实际上SYN = 1 时表示这是一个连接请求或接受报文.</p>
<h3 id="终止FIN"><a href="#终止FIN" class="headerlink" title="终止FIN"></a>终止FIN</h3><p>用来释放一个连接. 当FIN = 1 时, 表明此报文段的发送数据已发送完毕,并要求释放连接.</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占2字节.窗口指的是发送报文段一方的接收窗口.窗口值告诉对方:接收方目前允许对方发送的数据量.</p>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>检验和字段检验的范围包括首部和数据这两部分.</p>
<h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占2字节. 当URG = 1 时才有意义, 它指出本报文段中的紧急数据字节数.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP首部&quot;&gt;&lt;a href=&quot;#TCP首部&quot; class=&quot;headerlink&quot; title=&quot;TCP首部&quot;&gt;&lt;/a&gt;TCP首部&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-储存系统和结构</title>
    <link href="http://cristianoro7.github.io/2017/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    <id>http://cristianoro7.github.io/2017/06/07/计算机组成原理-储存系统和结构/</id>
    <published>2017-06-06T16:20:46.280Z</published>
    <updated>2017-06-06T16:20:46.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="储存系统和结构"><a href="#储存系统和结构" class="headerlink" title="储存系统和结构"></a>储存系统和结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>储存器的分类</li>
<li>随机储存器</li>
<li>高速储存缓冲器</li>
<li>虚拟储存器</li>
</ul>
<blockquote>
<h3 id="储存器的分类"><a href="#储存器的分类" class="headerlink" title="储存器的分类"></a>储存器的分类</h3></blockquote>
<p>下面针对常见的储存器分类进行讨论</p>
<h4 id="按储存器在计算机系统中的作用分类"><a href="#按储存器在计算机系统中的作用分类" class="headerlink" title="按储存器在计算机系统中的作用分类"></a>按储存器在计算机系统中的作用分类</h4><h5 id="高速缓冲储存器"><a href="#高速缓冲储存器" class="headerlink" title="高速缓冲储存器"></a>高速缓冲储存器</h5><p>位于CPU和主储存器之间, 用来缓存正在执行的程序段和数据,以便CPU能高速使用它们.高速缓冲器的速度与CPU匹配.</p>
<h5 id="主储存器"><a href="#主储存器" class="headerlink" title="主储存器"></a>主储存器</h5><p>用来存放正在运行的程序和数据,CPU可以直接随机地进行访问主存.由于访问主存的速度与CPU运算的速度差别很大,因此,主存的性能一定程度上影响了整个计算机的性能.</p>
<h5 id="辅助储存器"><a href="#辅助储存器" class="headerlink" title="辅助储存器"></a>辅助储存器</h5><p>用来存放当前暂不参与运行的程序和数据以及一些需要永久性保存的数据.辅助储存器的存取速度很慢并且CPU不能直接访问它.辅助储存器中的信息需要先读入主存后,才能被CPU访问.</p>
<h4 id="按存取分类"><a href="#按存取分类" class="headerlink" title="按存取分类"></a>按存取分类</h4><h5 id="随机存取储存器-RAM"><a href="#随机存取储存器-RAM" class="headerlink" title="随机存取储存器(RAM)"></a>随机存取储存器(RAM)</h5><p>随机储存指的是CPU能够随机对储存器中的内容进行操作, CPU对任何一个储存单元的操作时间都一样,与储存单元的物理位置无关.</p>
<h5 id="只读储存器-ROM"><a href="#只读储存器-ROM" class="headerlink" title="只读储存器(ROM)"></a>只读储存器(ROM)</h5><p>ROM可以看做是RAM的一种特殊形式, 其特殊在:储存器的内容只能随机读取而不能写入.这类储存器常用来储存那些不需要改变的信息.</p>
<h4 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a>按信息的可保存性分类</h4><h5 id="非易失性储存器"><a href="#非易失性储存器" class="headerlink" title="非易失性储存器"></a>非易失性储存器</h5><p>断电后信息仍然能够保存的储存器称为非易失性储存器.</p>
<h5 id="易失储存器"><a href="#易失储存器" class="headerlink" title="易失储存器"></a>易失储存器</h5><p>断电后信息不能够保存的储存器称为易失性储存器.</p>
<blockquote>
<h3 id="随机储存器RAM"><a href="#随机储存器RAM" class="headerlink" title="随机储存器RAM"></a>随机储存器RAM</h3></blockquote>
<p>RAM细分为静态RAM(SRAM)和动态RAM(DRAM).</p>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>SRAM的记忆单元为双稳态触发器.由于双稳态触发器的工作特性,SRAM中保存的信息一直处于充电状态,这使得SRAM不像DRAM那样需要定时刷新电路来保存信息.因此,SRAM的存取速度要比DRAM快.但SRAM的集成度较低,功耗也较大,所以一般用来组成高速缓冲储存器.</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>DRAM的记忆单元为3个MOS管组成的记忆单元.DRAM中的信息是靠MOS管中的栅极电容保存的,因此需要定时给电容充电,以保证信息不丢失.DRAM虽然储存速度没有SRAM快,但是其集成度高,功耗较小.</p>
<blockquote>
<h3 id="高速缓冲器"><a href="#高速缓冲器" class="headerlink" title="高速缓冲器"></a>高速缓冲器</h3></blockquote>
<p>由于主存的存取速度跟不上CPU的运算速度,主存的速度影响了计算机的整体性能.出于各个方面的考虑,计算机的设计者在主存和CPU之间架设由SRAM组成的高速缓冲器,利用高速缓冲器的运行速度接近CPU的特点,来解决主存的性能瓶颈.</p>
<h4 id="高速缓冲器的工作原理"><a href="#高速缓冲器的工作原理" class="headerlink" title="高速缓冲器的工作原理"></a>高速缓冲器的工作原理</h4><p>首先介绍一下程序局部性原理这个概念. 程序局部性包含两个方面:时间局部性和空间局部性.</p>
<p>时间局部性指的是如果一个储存单元被访问,则可能该储存单元很快会被访问到,这是因此程序中存在循环.</p>
<p>空间局部性指的是如果一个储存单元被访问,则该储存单元邻近的单元很可能很快就被访问, 这是因此程序中大部分指令是顺序储存,顺序执行,数据一般也是以数组,向量,树,表等形式簇聚在一起.</p>
<p>高速缓冲技术就是利用程序局部性原理,把程序中正在使用的部分存放在一个高速但容量较小的Cache中,使得CPU的访存操作大部分都针对Cache进行,从而提高程序的执行速度.</p>
<h4 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h4><h5 id="Cache的读操作"><a href="#Cache的读操作" class="headerlink" title="Cache的读操作"></a>Cache的读操作</h5><p>当CPU发出读请求时,如果请求的数据存在Cache时,就直接对Cache进行操作.否则访问主存,并把该块信息一次从主存调入Cache内.若此时Cache的容量已满的话,则需要根据某些替换算法来替换.</p>
<h5 id="Cache的写操作"><a href="#Cache的写操作" class="headerlink" title="Cache的写操作"></a>Cache的写操作</h5><p>当CPU发出写请求时, 如果要写入的数据存在Cache中的话,需要进行一定的写处理,比如:写直达法和写回法.如果写Cache不命中的话,就直接把信息写入主存,并有两种处理方法:</p>
<ul>
<li>不按写分配法,即只把要写的信息写入主存.</li>
<li>按写分配法,即把要写的信息写入主存后还需要写入Cache中.</li>
</ul>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>当Cache的空间被占满后,就需要进行数据的替换.常用的替换算法有如下三种:</p>
<h5 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h5><p>简单的根据一个随机数来进行替换</p>
<h5 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h5><p>按照调入Cache的顺序来决定替换的顺序.先Cache的数据会先被替换掉.这种方法容易实现并且系统开销小.其缺点是当遇到循环程序块时,效率会不高.</p>
<h5 id="近期最少使用算法-LRU"><a href="#近期最少使用算法-LRU" class="headerlink" title="近期最少使用算法(LRU)"></a>近期最少使用算法(LRU)</h5><p>LRU算法是把CPU近期最少使用的块作为被替换的目标.LRU算法相对上面两种方法合理,但是实现起来比较复杂,系统开销也大.</p>
<h4 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h4><p>为了保证Cache与主存的内容一致,必须选择合适的更新策略.</p>
<h5 id="写直达法"><a href="#写直达法" class="headerlink" title="写直达法"></a>写直达法</h5><p>在CPU执行写操作时,必须同时把数据写入Cache和主存中.这种方法实现简单,而且能够随时保证主存数据的正确性.但是由于每次进行写操作时,都得写入主存,这一定程度上会降低存取速度.</p>
<blockquote>
<h3 id="虚拟储存器"><a href="#虚拟储存器" class="headerlink" title="虚拟储存器"></a>虚拟储存器</h3></blockquote>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>虚拟储存器是将主存或者辅助储存的地址空间进行统一的编址,形成一个庞大的储存空间.这样一来,可以不必考虑程序在主存中是否装得下以及这些程序在主存中的存放位置.</p>
<p>虚拟地址:通常程序员编写程序用到的地址称为虚拟地址.<br><br>物理地址:实际主存单元地址称为物理地址.</p>
<p>虚地址和物理地址是一一对应的关系,实现这个一一映射的关系需要硬件和操作系统的协助.在操作系统的管理下,程序和数据会先存放在磁盘,然后操作系统将当前需要的程序和数据调入主存中,供CPU使用,还没使用到的程序和数据都存放在磁盘中.</p>
<p>当程序运行时,CPU以虚地址来访问主存,在硬件找出虚地址和物理地址之间对应的关系后,判断该虚地址对应的内容是否已经调入主存.如果已经装入主存的话,则通过CPU变址来访问主存中的内容.如果不存在主存中,则将虚拟地址对应的数据从磁盘中装入内存,再由CPU访问.如果此时主存已满,根据替换算法将主存中暂时不需要的数据调回辅存中,再从辅存中调入需要的数据.</p>
<h4 id="页式虚拟储存器"><a href="#页式虚拟储存器" class="headerlink" title="页式虚拟储存器"></a>页式虚拟储存器</h4><p>以页为基本单位的虚拟储存器称为页式虚拟储存器.主存空间和虚拟空间都被分为若干个大小相等的页.主存的页称为实页,虚存的页称为虚页.</p>
<p><img src="/uploads/计算机组成原理/页式虚拟储存.png" alt=""></p>
<p>上图为虚拟地址到物理地址的映射过程.</p>
<p>虚地址是由虚页号和页内地址所组成的.虚页号为页表中的索引号,页表是用于虚地址到物理地址的转换,简单的说就是虚页号的集合.每个虚页号和储存在页面基址寄存器的页表起始地址组成一个页表地址,页表地址指向页表中的一项,项目中含有装入位和实页号.如果装入位1为的话,说明该页面已经被调入主存,实页号和虚地址中的页内地址组成物理地址.如果装入位为0的话,证明该页面还没有被调入主存,需要启动IO系统,将该页从辅存中主存后再拱CPU使用.</p>
<h4 id="段式虚拟储存"><a href="#段式虚拟储存" class="headerlink" title="段式虚拟储存"></a>段式虚拟储存</h4><p>段式虚拟储存中的段是按照程序中的逻辑结构划分的,各个段的长度是因程序而异.在页式虚拟储存中,虚地址到物理地址的映射需要一个页表,同样的,在段式储存中,虚地址到物理地址的转换也需要一个段表.段表中的每一个项目记录了段号,装入位,段起点和段长度等.</p>
<p><img src="/uploads/计算机组成原理/段式储存.png" alt=""></p>
<p>上图为段式虚拟储存中,虚地址到物理地址的映射过程,原理跟虚拟地址差不多,这里不多做记录.</p>
<h4 id="段页式虚拟储存"><a href="#段页式虚拟储存" class="headerlink" title="段页式虚拟储存"></a>段页式虚拟储存</h4><p>结合段式和页式虚拟储存的特点,这种虚拟储存方式为段页式虚拟储存.段页式将程序其逻辑结构分段,每段再划分为若干个大小相同的页,主存空间也划分为若干同样大小的页.</p>
<p>虚存和实存之间以页为基本单位进行传送,每个程序对应一个段表,每段对应一个页表.</p>
<p>CPU访问时,虚地址包括段号,段内页号,页内地址3部分.</p>
<p>首先将段表起始地址和段号合成,得到页表地址,然后从段表中取出该段的页表起始地址,与段内页号合成,得到页表地址.最后从页表中得到实页号,与页内地址拼接成主存的实地址.</p>
<p>段页式虚拟储存整合了前面两种结构的优点.但是要经过两级查询才能完成地址转换,费时自然也会增多.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机组成原理</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;储存系统和结构&quot;&gt;&lt;a href=&quot;#储存系统和结构&quot; class=&quot;headerlink&quot; title=&quot;储存系统和结构&quot;&gt;&lt;/a&gt;储存系统和结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理概述</title>
    <link href="http://cristianoro7.github.io/2017/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <id>http://cristianoro7.github.io/2017/06/04/计算机组成原理概述/</id>
    <published>2017-06-04T08:37:00.429Z</published>
    <updated>2017-06-04T08:37:00.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理概述"><a href="#计算机组成原理概述" class="headerlink" title="计算机组成原理概述"></a>计算机组成原理概述</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>储存程序概念</li>
<li>计算机硬件的组成</li>
<li>储存器的设计思想</li>
<li>计算机的主要性能指标</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>最近,突然对操作系统感兴趣,于是提前看了网上关于操作系统的视频. 但是在看的过程中对操作系统启动时从实模式到保护模式的切换,分段机制和分页机制, CPU的工作模型和总线等概念不怎么熟悉. 于是Google了一番, 发现这些大都是涉及到计算机组成原理的知识,刚好这学期学校有开设计算机组成原理课程.于是乎, 系统的学习了一波计算机组成原理的知识.</p>
<p>由于自己的方向是偏软件开发的, 因此,在学习的过程中,主要理解计算机的工作原理以及设计思想, 对于硬件的设计和工作原理就基本没深入了解. 接下来关于计算机组成原理的文章,都是偏向与理论并且不涉及到硬件的具体工作原理等.</p>
<blockquote>
<h3 id="储存程序概念"><a href="#储存程序概念" class="headerlink" title="储存程序概念"></a>储存程序概念</h3></blockquote>
<p>储存程序是由冯*诺依曼为首的研究小组提出来的概念.储存程序的诞生主要是为了解决使用线路连接编程的缺点.</p>
<p>储存程序的要点可以概括为下面三点:</p>
<ul>
<li>计算机应由运算器,储存器,控制器,输入设备和输出设备5大基本部件组成.</li>
<li>计算机内部统一使用二进制表示指令和数据.</li>
<li>将编好的程序和原始数据事先存入储存器中,然后再启动计算机工作.</li>
</ul>
<p>但是随着计算机的高速发展, 访问CPU的速度远远快于访问主存的速度.因此,储存器的访问成为了计算机性能的瓶颈.</p>
<blockquote>
<h3 id="计算机硬件的组成"><a href="#计算机硬件的组成" class="headerlink" title="计算机硬件的组成"></a>计算机硬件的组成</h3></blockquote>
<h4 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h4><h5 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h5><p>输入设备的作用是将编好的程序和数据输入到计算机,并且将他们转换为计算机内部能够识别和接受的信息.</p>
<h5 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h5><p>输出设备的任务是将计算机内部处理的结果以数字,字符,图像等方式展示给人们看.</p>
<h5 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h5><p>储存器是用来存放程序和数据的部件,是实现”储存程序”的基础.</p>
<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>运算器是对信息进行处理和运算的部件.进行的运算有:算术运算和逻辑运算.</p>
<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>控制器的主要工作是指挥各个部件工作.</p>
<h4 id="连接各个部件的总线"><a href="#连接各个部件的总线" class="headerlink" title="连接各个部件的总线"></a>连接各个部件的总线</h4><p>总线可以实现各个部件之间的信息共享.例如:主存中的数据通过总线传递到CPU.</p>
<p>最简单的总线结构为单总线结构,也称为系统总线:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Computer_system_bus.svg/350px-Computer_system_bus.svg.png" alt=""></p>
<p>各个部件都连接在总线上, CPU与主存,CPU与外部设备之间可以直接通信.主存与外部设备,外部设备和外部设备之间可以直接通信,而无须经过CPU的干预.</p>
<p>系统总线的结构限定了同一时刻只允许一对设备之间传递信息.</p>
<p>系统总线按传递信息的不同,可以细分为:</p>
<ul>
<li>数据总线: CPU可以沿数据总线从主存或者外部设备读入信息,也可以向主存或者外部设备写入信息.</li>
<li>地址总线: 用于CPU向主存,外部设备传输地址信息.</li>
<li>控制总线: 传递CPU发出的控制命令和主存返回给CPU的信号.</li>
</ul>
<blockquote>
<h3 id="储存器的设计思想"><a href="#储存器的设计思想" class="headerlink" title="储存器的设计思想"></a>储存器的设计思想</h3></blockquote>
<p>储存器的设计思想可以分为:冯*诺依曼结构和哈佛结构.</p>
<h4 id="冯-诺依曼结构"><a href="#冯-诺依曼结构" class="headerlink" title="冯*诺依曼结构"></a>冯*诺依曼结构</h4><p>在冯诺依曼结构下的储存器结构,指令和数据是不加以区分地储存在储存器中,并共享数据总线.</p>
<p><img src="/uploads/计算机组成原理/冯诺依曼.png" alt=""></p>
<p>由于指令和数据存放在同一储存器中,因此,在这种结构下,不能同时进行取指令和取操作数.</p>
<p>又由于储存器的访问速度远远慢于CPU的运算速度,从而使得计算机运算速度受到了很大的影响.</p>
<h4 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h4><p>哈佛结构的指令和数据是分开的.储存器分为两部分:程序储存器和数据储存器.前者是用来存放指令,而后者则是存放数据.</p>
<p><img src="/uploads/计算机组成原理/哈佛结构.png" alt=""></p>
<blockquote>
<h3 id="计算机的主要性能指标"><a href="#计算机的主要性能指标" class="headerlink" title="计算机的主要性能指标"></a>计算机的主要性能指标</h3></blockquote>
<h4 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h4><p>机器字长是指运算器进行一次运算所处理的位数,它通常是由寄存器,加法器的位数决定的,所以机器字长一般等于寄存器的位数.</p>
<h4 id="数据通路宽度"><a href="#数据通路宽度" class="headerlink" title="数据通路宽度"></a>数据通路宽度</h4><p>数据总线一次并行传送信息的位数,称为数据通路宽度.它影响到信息传送能力,从而影响到计算机的有效处理速度.</p>
<h4 id="储存容量"><a href="#储存容量" class="headerlink" title="储存容量"></a>储存容量</h4><p>一个主储存器所能储存的全部信息量成为主存容量.计算机的主存容量越大,存放的信息就越多,处理问题的能力就越强.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机组成原理<br><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%8C%AF%E6%B5%81%E6%8E%92" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%8C%AF%E6%B5%81%E6%8E%92</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机组成原理概述&quot;&gt;&lt;a href=&quot;#计算机组成原理概述&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理概述&quot;&gt;&lt;/a&gt;计算机组成原理概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-运输层</title>
    <link href="http://cristianoro7.github.io/2017/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://cristianoro7.github.io/2017/05/30/计算机网络-运输层/</id>
    <published>2017-05-30T15:17:35.464Z</published>
    <updated>2017-05-30T15:17:35.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-运输层"><a href="#计算机网络-运输层" class="headerlink" title="计算机网络-运输层"></a>计算机网络-运输层</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分用和复用</li>
<li>UDP协议</li>
<li>运输层梳理</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>当网络的边缘部分中的两个主机使用网络的核心部分功能进行通信时,只有主机的协议栈才有运输层,而网络的核心部分中的路由器在转发分组时都只用到下三层的功能.</p>
<p>网络层是为主机之间提供逻辑通信,而运输层为应用进程之间提供端到端的逻辑通信.</p>
<p>在网络层中, IP数据报首部的检验和字段只检验首部是否出现差错而不检查数据部分.而在运输层中, 应当进行首部和数据的差错检验.</p>
<blockquote>
<h3 id="分用和复用"><a href="#分用和复用" class="headerlink" title="分用和复用"></a>分用和复用</h3></blockquote>
<p>复用是指发送方不同的应用程序都可以使用同一个运输层协议传送数据.</p>
<p>分用是指接收方的运输层去掉报文的首部后能够把数据正确交付到目的进程中.</p>
<blockquote>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3></blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>UDP协议只在IP数据报服务上增加了很少的功能,这些功能是分用和复用还有差错检验.</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>UDP是无连接的,因此减少了开销和发送数据之前的时延</li>
<li>UDP使用尽最大努力交付,即不保证可靠交付.</li>
<li>UDP是面向报文的.应用层交给UDP多长的报文,UDP就照样发送,一次发一个报文.</li>
<li>UDP没有拥塞控制.</li>
<li>UDP支持1对1,1对多,多对1,多对多的交互通信.</li>
<li>UDP的首部开销小,只有8字节.</li>
</ol>
<blockquote>
<h3 id="运输层梳理"><a href="#运输层梳理" class="headerlink" title="运输层梳理"></a>运输层梳理</h3></blockquote>
<p>运输层主要有两个协议:</p>
<ol>
<li>UDP</li>
<li>TCP</li>
</ol>
<p>UDP是面向无连接的协议,只是在IP数据报上添加复用,分用和差错检验的功能,UDP协议本身比较简单.</p>
<p>TCP协议是面向连接的一种协议,在进程之间的通信中提供一种可靠交付的服务.相比于UDP协议, TCP协议比较复杂.</p>
<p>下面给出运输层的知识梳理图:</p>
<p><img src="/uploads/计网/运输层/运输层梳理.png" alt=""></p>
<p>其中TCP协议涉及的内容比较多,归纳起来可以分为:</p>
<p><a href="https://cristianoro7.github.io/2017/05/22/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">可靠传输的工作原理</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/22/TCP%E9%A6%96%E9%83%A8/">TCP首部</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/23/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">TCP滑动窗口</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/23/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">TCP流量控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/24/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/24/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/">TCP连接管理</a></p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-运输层&quot;&gt;&lt;a href=&quot;#计算机网络-运输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-运输层&quot;&gt;&lt;/a&gt;计算机网络-运输层&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
</feed>
