<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Desperado</title>
  <subtitle>Do one thing every day that scares you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cristianoro7.github.io/"/>
  <updated>2017-10-31T09:43:21.911Z</updated>
  <id>http://cristianoro7.github.io/</id>
  
  <author>
    <name>Desperado</name>
    <email>424494431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>J.U.C中的并发工具类</title>
    <link href="http://cristianoro7.github.io/2017/10/31/J.U.C%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://cristianoro7.github.io/2017/10/31/J.U.C中的并发工具类/</id>
    <published>2017-10-31T09:43:21.911Z</published>
    <updated>2017-10-31T09:43:21.911Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fl1ikq8wyhj30m80b4qi7.jpg" alt=""></p>
<p>在<code>Java</code>的<code>J.U.C</code>包中提供了几个并发编程中非常有用工具类, 例如: <code>Semaphore</code>, <code>CountDownLatch</code>和<code>CyclicBarrier</code>. 这次准备来介绍这三个工具类.</p>
<blockquote>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2></blockquote>
<p><code>Semaphore</code>中文意思为: 信号量. 它主要用来维护一组有限的资源. 比如数据库连接, <code>Socket</code>连接. 信号量的使用方式很简单, 在构造函数中, 传入你需要维护的有限资源的数量, 每次需要申请资源时, 调用<code>acquire()</code>, 接着做一些业务逻辑, 完成后, 再调用<code>release()</code>归还有限资源. 如果有限资源被申请完了后, 还调用<code>acquire()</code>的话, 调用的线程会被阻塞, 直到其他线程归还资源后, 才从阻塞中返回.</p>
<blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>Semaphore</code>的原理很简单. 基于<code>AQS</code>构建的. 它内部维护一个状态计数器, 每次调用申请资源时, 都会递减状态计数器值, 归还资源时, 会增加状态计数器的值. 当状态计数器为负数时, 说明有限资源已经被申请完了, 这时<code>AQS</code>会将申请不到资源的线程添加进同步队列中, 并挂起线程, 直到其他线程唤醒.</p>
<p>由于<code>Semaphore</code>也是基于<code>AQS</code>实现的, 所以它支持不响应中断, 响应中断和响应中断且超时获取资源这三种类型. 同时获取资源的方式支持公平性和非公平性的获取. 默认的实现是非公平的获取方式.</p>
<blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面给出一个简单的例子: 数据库连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DBPool pool = <span class="keyword">new</span> DBPool(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        doSomeWork();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</div><div class="line">        Connection connection = pool.get();</div><div class="line">        <span class="comment">//访问数据库</span></div><div class="line">        pool.release(connection);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBPool</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Semaphore semaphore;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Connection[] pool;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] connectionFlags;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(size, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">boolean</span> isFair)</span> </span>&#123;</div><div class="line">        semaphore = <span class="keyword">new</span> Semaphore(size, isFair);</div><div class="line">        initPool(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        pool = <span class="keyword">new</span> Connection[size];</div><div class="line">        connectionFlags = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            pool[i] = DBDriver.create();</div><div class="line">            connectionFlags[i] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        semaphore.acquireUninterruptibly();</div><div class="line">        <span class="keyword">return</span> fetchConnection();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">fetchConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pool.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!connectionFlags[i]) &#123;</div><div class="line">                connectionFlags[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span> pool[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection connection)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectionFlags.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (pool[i] == connection &amp;&amp; connectionFlags[i]) &#123;</div><div class="line">                connectionFlags[i] = <span class="keyword">false</span>;</div><div class="line">                semaphore.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DBDriver</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">static</span> Connection <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//fake connection</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2></blockquote>
<p>当一个或者多个线程的执行需要等待其他线程执行完后才能执行的话, <code>CountDownLatch</code>能够很好的完成任务.</p>
<p><code>CountDownLatch</code>的使用方式很简单, 只要在构造函数中传入需要等待执行完的线程数, 在需要等待其他线程执行完才执行的线程调用<code>await()</code>, 如果此时其他线程还没执行完的话, 该操作会阻塞, 直到每个线程中调用<code>countDown()</code>方法来表示自己已经完成了, 最后被阻塞的线程才会从<code>await()</code>中返回.</p>
<blockquote>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面是<code>CountDownLatch</code>的一个例子: 工头要带搬砖工去搬砖, 所以工头必须得等他们都上车了才可以开车.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); <span class="comment">//需要等待10个搬砖工上车</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(countDownLatch)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            countDownLatch.await(); <span class="comment">//等待搬砖工上车完才开车.</span></div><div class="line">            System.out.println(<span class="string">"OK, 搬砖工已经上车了, 开车去搬砖"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            getOnBus();</div><div class="line">            countDownLatch.countDown(); <span class="comment">//执行完了.</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getOnBus</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"搬砖工上车了!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>CountDownLatch</code>内部实现的原理很简单. 它基于<code>AQS</code>, 通过构造函数传入的<code>int</code>数值, 来维护一个计数器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sync(<span class="keyword">int</span> count) &#123;</div><div class="line">    setState(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入<code>count</code>被设置为<code>AQS</code>内部的状态值.</p>
<p>接下来看看<code>await()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>await()</code>中最终会回调<code>tryAcquireShared(int acquires)</code>. 该方法实现的逻辑: 如果状态不为0的话, 说明还有其他线程还没执行完, 所以返回-1告诉<code>AQS</code>阻塞当前线程. 如果状态为0, 说明全部线程已经执行完, 此时返回1, 告诉<code>AQS</code>不用阻塞线程.</p>
<p>当线程被阻塞后, 需要它等待的线程执行完才会被唤醒. 被等待的线程调用<code>countDown()</code>表示自己已经完成.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>countDown()</code>通过循环和<code>CAS</code>来更新同步状态, 当最后一个线程也调用了该方法的话, 同步状态为0. 此时被阻塞的线程会得以唤醒.</p>
<blockquote>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2></blockquote>
<p><code>CyclicBarrier</code>允许一组线程互相等待其到达一个同步点的时候才继续执行. 同时<code>CyclicBarrier</code>具有重用性, 当等待的一组线程被释放后(成功或者失败), 它能够被继续使用. 这点和<code>CountDownLatch</code>不一样, <code>CountDownLatch</code>只能够使用一次.</p>
<p><code>CyclicBarrier</code>遵循<code>all-or-none</code>的损坏模式, 相互等待的一组线程如果其中一个线程被中断的或者等待超时的话, 其他线程也将失败. 简单来讲, 要么全部成功, 要么全部失败.</p>
<p><code>CyclicBarrier</code>还支持一组等待的线程被释放后, 执行传入的<code>Runnable</code>.</p>
<blockquote>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面给出一个例子. 游戏玩家都必须等待各自准备好才能开始.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(<span class="string">"玩家-"</span> + i, cyclicBarrier)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, CyclicBarrier cyclicBarrier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name + <span class="string">"已经准备好"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cyclicBarrier.await(); <span class="comment">//等待其他玩家</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还可以在<code>CyclicBarrier</code>的构造函数中传入一个<code>Runnable</code>, 当所有线程都到达同步点后, 该任务会被执行, 默认是最后一个到达的线程执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> ReadyFinish());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(<span class="string">"玩家-"</span> + i, cyclicBarrier)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, CyclicBarrier cyclicBarrier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name + <span class="string">"已经准备好"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cyclicBarrier.await(); <span class="comment">//等待其他玩家</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadyFinish</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"所以玩家已经准备完了, 开始游戏"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>CyclicBarrier</code>内部基于<code>ReentrantLock</code>和<code>Condition</code>实现的. 到达同步点的线程会被暂时挂在条件队列中等待.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//支持重用性, 表示第几代</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> broken = <span class="keyword">false</span>; <span class="comment">//是否成功等待所有线程到达同步点</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//确保线程安全</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition(); <span class="comment">//到达安全点的线程会被挂在等待队列中</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties; <span class="comment">//互相等待的一组线程</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand; <span class="comment">//全部线程到达后, 执行的一个任务</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//记录还有多少个线程没到达同步点</span></div></pre></td></tr></table></figure>
<p>上面是<code>CyclicBarrier</code>中的实例域, 具体讲解看注释.</p>
<p>下面我们来看看线程到达同步点时的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</div><div class="line">           TimeoutException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">//失败</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//线程被中断了, 失败</span></div><div class="line">            breakBarrier();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> index = --count; <span class="comment">//获得还没到达的线程数</span></div><div class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                    command.run();</div><div class="line">                ranAction = <span class="keyword">true</span>;</div><div class="line">                nextGeneration();</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!ranAction)</div><div class="line">                    breakBarrier();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!timed)</div><div class="line">                    trip.await(); <span class="comment">//挂起线程</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</div><div class="line">                    nanos = trip.awaitNanos(nanos); <span class="comment">//挂起线程</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; <span class="comment">//中断失败</span></div><div class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> ie;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                    <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">//有一个线程失败了, 所有线程也跟着失败</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">//如果当前代对象不相等的话, 证明已经更新代数了.</span></div><div class="line">                <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得还没到达的线程数, 如果不为0的话, 说明还有线程没到达, 这时, 应该阻塞线程. 当最后一个线程到达时, <code>index</code>为0, 此时说明全部线程已经到达, 所以进入唤醒等待线程的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">    <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">            command.run();</div><div class="line">        ranAction = <span class="keyword">true</span>;</div><div class="line">        nextGeneration();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!ranAction)</div><div class="line">            breakBarrier();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</div><div class="line">    trip.signalAll(); <span class="comment">//唤醒在条件队列中等待的线程</span></div><div class="line">    <span class="comment">//重置CyclicBarrier, 使得它可以被复用</span></div><div class="line">    count = parties;</div><div class="line">    generation = <span class="keyword">new</span> Generation();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果构造函数中有传入<code>Runnable</code>对象的话, 最后一个线程会执行该<code>Runnable</code>对象, 然后进入<code>nextGeneration()</code>中唤醒在同步点等待的线程, 最后更新当前年代.</p>
<p>如果等待线程在等待的过程中有被中断或者等待超时的话, 会执行<code>breakBarrier()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</div><div class="line">    generation.broken = <span class="keyword">true</span>;</div><div class="line">    count = parties;</div><div class="line">    trip.signalAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先设置当代已经被破坏了, 这样可以让其他线程都失败.然后唤醒在等待队列上等待的线程. 被唤醒的线程会检查<code>broken</code>字段, 最后抛出异常.</p>
<p>如果等待的过程中没有超时或者被中断的话, 其他线程从阻塞的方法中返回后, 当前的<code>generation</code>是否相等, 不是的话, 说明已经进入下一代了,所以返回一个<code>index</code>, 该<code>index</code>表示这线程是第几个到达同步点的.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<p><code>Semaphore</code>用来维护一组有限的资源, 每次申请资源时, 都会递减资源数, 如果资源没了的话, 会阻塞当前线程, 直到有可用的资源为止. 有限的资源可以是: 数据库连接, <code>Socket</code>连接.</p>
<p><code>CountDownLatch</code>适用于 : 当一个或者多个线程的执行需要等待其他线程执行完后才可以执行的场景.</p>
<p>多个线程需要等待彼此到达一个同步点时, 才继续执行, 这种情况下, 可以用<code>CyclicBarrier</code>. 而且它具有重用行, 可被多次使用, 这点和<code>CountDownLatch</code>不一样, 后者只能被使用一次.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fl1ikq8wyhj30m80b4qi7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;J.U.C&lt;/code&gt;包中提供了几个并发
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#工具类" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock和ReentrantReadWriteLock详解</title>
    <link href="http://cristianoro7.github.io/2017/10/31/ReentrantLock%E5%92%8CReentrantReadWriteLock%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cristianoro7.github.io/2017/10/31/ReentrantLock和ReentrantReadWriteLock详解/</id>
    <published>2017-10-31T09:09:28.487Z</published>
    <updated>2017-10-31T09:09:28.487Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkz6p5rdydj30m80b47at.jpg" alt=""></p>
<p><code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>是<code>Java</code>并发包中提供的锁, 他们都属于可重入锁.但是<code>ReentrantLock</code>是一种悲观锁, 它总是假设竞争条件总是会发生, 所以它同一时刻只能有一个线程获得锁, 而<code>ReentrantReadWriteLock</code>是属于乐观锁, 它假设竞争条件并不会经常发生, 所以同一时刻能让多个线程执行.</p>
<p>他们的一个共同点是: 都支持公平和非公平性的获取锁.</p>
<blockquote>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h2></blockquote>
<p>前面分析过<code>AQS</code>, 它是并发包中的锁的基本骨架. 所以<code>ReentrantLock</code>内部也是基于<code>AQS</code>实现的. <code>ReentrantLock</code>内部将获取锁和释放锁的方法都代理给其内部类: <code>Sync</code>, 而<code>Sync</code>是继承<code>AQS</code>的, 为了支持公平性和非公平性的锁, <code>Sync</code>有两个子类, 分别为<code>NonfairSync</code>和<code>FairSync</code>, 他们都重写了<code>tryAcquire(int)</code>方法来实现自己公平和非公平获取锁的逻辑, 由于释放锁的逻辑都一样, 因此<code>tryRelease(int)</code>由<code>Sync</code>重写.</p>
<p>既然<code>ReentrantLock</code>基于<code>AQS</code>实现的, 所以它支持三种方式获取锁:</p>
<ul>
<li><p><code>lock()</code>: 不支持中断的获取锁</p>
</li>
<li><p><code>lockInterruptibly()</code>: 响应中断地获取锁</p>
</li>
<li><p><code>tryLock(long timeout, TimeUnit unit)</code>: 响应中断并且支持超时获取锁.</p>
</li>
</ul>
<p>由于三种方式在<code>AQS</code>中已经分析过, 所以这里只分析<code>lock()</code>. 主要分析公平性和非公平性地获取锁的逻辑</p>
<blockquote>
<h3 id="NonfairSync-非公平锁"><a href="#NonfairSync-非公平锁" class="headerlink" title="NonfairSync: 非公平锁"></a>NonfairSync: 非公平锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是非公平性获取锁的逻辑: 如果同步状态为0的话, 证明锁还没被获取, 所以利用<code>CAS</code>来获取同步状态, 成功的话, 设置当前线程持有锁. 如果同步状态不为0的话, 判断获取锁的线程是否为当前线程, 如果是的话, 更新同步状态, 从这里也可以看出来<code>ReentrantLock</code>是可重入锁.</p>
<blockquote>
<h3 id="FairSync-公平锁"><a href="#FairSync-公平锁" class="headerlink" title="FairSync: 公平锁"></a>FairSync: 公平锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平和非公平的区别是: 公平性意味着哪个线程等待的时间更长, 就应该首先让它获取锁, 也就是获取锁的顺序必须是<code>FIFO</code>. 所以每次获取同步状态时, 都会调用<code>hasQueuedPredecessors()</code>判断当前节点是不是有前驱节点, 如果有的话, 证明已经有线程在等待, 因此不获取同步状态, 这样就实现了公平性地获取锁.<br>至于其他逻辑和前面的大致一样.</p>
<blockquote>
<h3 id="tryRelease-int-releases"><a href="#tryRelease-int-releases" class="headerlink" title="tryRelease(int releases)"></a>tryRelease(int releases)</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平锁和非公平锁的释放锁的逻辑都是一样的, 由于<code>ReentrantLock</code>是可重入的, 因此只有当同步状态为0的时候才需要将当前持有锁的线程设置为<code>null</code>, 也就是释放锁.</p>
<blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></blockquote>
<p><code>ReentrantLock</code>内部默认是非公平锁, 因为非公平锁的吞吐量会比公平锁高, 这是由于非公平锁每次获取锁的时候, 不需要理会当前节点是否有前驱节点, 也就是前面有线程在等待, 只要被唤醒了, 并且能够获取同步状态的话, 就可以获取. 而公平锁每次获取锁时, 当前节点必须是头节点, 也就是它的前面没有线程在等待. 在这种情况下, 如果非头结点的线程被唤醒的话或者是刚刚释放锁的线程又立刻获取锁, 是不能获取锁的, 只能再进行多一次调度. 因此, 非公平锁的吞吐量会比公平锁的高.</p>
<blockquote>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2></blockquote>
<p>与<code>ReentrantLock</code>不同,  <code>ReentrantReadWriteLock</code>的伸缩性要强一些, 因为它将读写锁分离. 在进行读操作的时候, 多个线程是可以同时获取锁的, 这样能更大地提高并发度. 下面是<code>ReentrantReadWriteLock</code>的特性</p>
<ul>
<li><p>公平性: 与<code>ReentrantLock</code>一样, <code>ReentrantReadWriteLock</code>内部也是支持公平性和非公平性锁, 默认是非公平性的锁.</p>
</li>
<li><p>可重入: <code>ReentrantReadWriteLock</code>支持一个线程多次获取锁.</p>
</li>
<li><p>读写分离: <code>ReentrantReadWriteLock</code>内部维护两个锁, 一个是读锁, 另外一个是写锁. 在读多写少的情况下, <code>ReentrantReadWriteLock</code>能发挥更大的并发度.  因为<code>ReentrantReadWriteLock</code>支持多个读线程同时获取锁. <code>ReentrantReadWriteLock</code>的读写规则: 当一个写线程获得锁后, 其他线程不能获取锁. 当读线程获得锁后, 其他的读线程可以获得锁, 但是写线程不能.</p>
</li>
<li><p>锁降级: 当一个线程持有写锁后, 再获取读锁, 然后释放写锁, 这个过程称为一个锁的降级. <code>ReentrantReadWriteLock</code>不支持锁的升级, 因为锁的升级有可能带来竞争条件的问题.</p>
</li>
</ul>
<blockquote>
<h3 id="读写同步状态设计"><a href="#读写同步状态设计" class="headerlink" title="读写同步状态设计"></a>读写同步状态设计</h3></blockquote>
<p><code>ReentrantReadWriteLock</code>内部也是基于<code>AQS</code>实现的, 但是<code>AQS</code>内只有一个<code>int</code>类型的变量, 那么<code>ReentrantReadWriteLock</code>怎么表示两个同步状态呢? 答案是通过位运算来处理.</p>
<p><code>int</code>类型有32位, <code>ReentrantReadWriteLock</code>将高16位作为读状态, 低16位作为写状态. 这样每次通过一定的位运算来获取高16位或者低16位.</p>
<blockquote>
<h3 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h3></blockquote>
<p>写锁是一种互斥锁, 同一个时刻锁只能被一个线程获取.</p>
<blockquote>
<h4 id="非公平性写锁"><a href="#非公平性写锁" class="headerlink" title="非公平性写锁"></a>非公平性写锁</h4></blockquote>
<p>跟<code>ReentrantLock</code>一样, <code>ReentrantReadWriteLock</code>内部支持三种类型的获取, 因此下面只分析一种.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>lock()</code>方法中, 会调用<code>AQS</code>的<code>acquire(int)</code>, 在<code>acquire(int)</code>中又会回调子类重写的模板方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Walkthrough:</div><div class="line">     * 1. If read count nonzero or write count nonzero</div><div class="line">     *    and owner is a different thread, fail.</div><div class="line">     * 2. If count would saturate, fail. (This can only</div><div class="line">     *    happen if count is already nonzero.)</div><div class="line">     * 3. Otherwise, this thread is eligible for lock if</div><div class="line">     *    it is either a reentrant acquire or</div><div class="line">     *    queue policy allows it. If so, update state</div><div class="line">     *    and set owner.</div><div class="line">     */</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">//获取写的同步状态</span></div><div class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></div><div class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        <span class="comment">// Reentrant acquire</span></div><div class="line">        setState(c + acquires);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>c != 0</code>且 <code>w(写状态)</code>为0的话, 证明读状态不为0, 说明此时获得锁的是读线程, 所以会直接返回<code>false</code>来表示获取失败. 如果<code>w != 0</code>的话, 说明此时写线程拥有锁, 此时如果拥有锁是当前线程的话, 会更新同步状态来支持可重入的特性, 可重入的次数为65535.</p>
<p>如果<code>c == 0</code>的话, 说明同步状态还没被获取, 此时应该会先调用<code>writerShouldBlock()</code>, 在非公平的写锁的实现为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非公平性的写锁默认是返回<code>false</code>, 接着利用<code>CAS</code>更新同步状态, 如果成功的话, 设置当前线程为执行线程, 否则的话返回<code>false</code>, 进入<code>AQS</code>中排队.</p>
<blockquote>
<h4 id="非公平性写锁-1"><a href="#非公平性写锁-1" class="headerlink" title="非公平性写锁"></a>非公平性写锁</h4></blockquote>
<p>公平锁和非公平锁获取锁的基本一样, 不一样的话<code>writerShouldBlock()</code>的实现不一样.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></div><div class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></div><div class="line">    <span class="comment">// thread is first in queue.</span></div><div class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></div><div class="line">    Node h = head;</div><div class="line">    Node s;</div><div class="line">    <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平锁每次获取锁时, 为了保证公平性, 都需要看看同步队列中是否有比当前线程等待时间更长的线程, 如果有的话, 就不能获取.</p>
<blockquote>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4></blockquote>
<p><code>ReentrantReadWriteLock</code>释放锁的逻辑跟<code>ReentrantLock</code>一样.</p>
<blockquote>
<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3></blockquote>
<p>读锁是一种共享锁, 多个读线程可以同时获取锁. 但是当读线程持有锁时, 写线程是不能持有锁的.</p>
<blockquote>
<p>非公平读锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Walkthrough:</div><div class="line">     * 1. If write lock held by another thread, fail.</div><div class="line">     * 2. Otherwise, this thread is eligible for</div><div class="line">     *    lock wrt state, so ask if it should block</div><div class="line">     *    because of queue policy. If not, try</div><div class="line">     *    to grant by CASing state and updating count.</div><div class="line">     *    Note that step does not check for reentrant</div><div class="line">     *    acquires, which is postponed to full version</div><div class="line">     *    to avoid having to check hold count in</div><div class="line">     *    the more typical non-reentrant case.</div><div class="line">     * 3. If step 2 fails either because thread</div><div class="line">     *    apparently not eligible or CAS fails or count</div><div class="line">     *    saturated, chain to version with full retry loop.</div><div class="line">     */</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</div><div class="line">        getExclusiveOwnerThread() != current)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> r = sharedCount(c);</div><div class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</div><div class="line">        r &lt; MAX_COUNT &amp;&amp;</div><div class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">            firstReader = current;</div><div class="line">            firstReaderHoldCount = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</div><div class="line">            firstReaderHoldCount++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            HoldCounter rh = cachedHoldCounter;</div><div class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</div><div class="line">                cachedHoldCounter = rh = readHolds.get();</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</div><div class="line">                readHolds.set(rh);</div><div class="line">            rh.count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取写状态, 如果写状态为不0且持有写锁的线程是当前执行的线程, 说明这是一个锁降级的操作, 因此允许继续获取同步状态.</p>
<p>如果写状态为0且<code>getExclusiveOwnerThread() != current</code>为<code>true</code>的话, 表示持有写锁的不是当前执行的线程, 所以返回-1表示失败.</p>
<p>在尝试获取同步状态前, 会先调用<code>readerShouldBlock()</code>判断是否应该阻塞读线程, 这个方法在公平和非公平锁的实现不一样.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></div><div class="line">      * block if the thread that momentarily appears to be head</div><div class="line">      * of queue, if one exists, is a waiting writer.  This is</div><div class="line">      * only a probabilistic effect since a new reader will not</div><div class="line">      * block if there is a waiting writer behind other enabled</div><div class="line">      * readers that have not yet drained from the queue.</div><div class="line">      */</div><div class="line">     <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</div><div class="line">     Node h, s;</div><div class="line">     <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">         (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</div><div class="line">         !s.isShared()         &amp;&amp;</div><div class="line">         s.thread != <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在非公平锁的实现中, 只要同步状态队列中有写线程正在等待的话, 就应该阻塞读线程, 不让其获取同步状态. 这样做是为了防止写线程出现饥饿现象.</p>
<blockquote>
<p>公平读锁</p>
</blockquote>
<p>公平读锁和非公平读锁的实现也是基本一样, 不一样的就是<code>readerShouldBlock()</code>实现不同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></div><div class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></div><div class="line">    <span class="comment">// thread is first in queue.</span></div><div class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></div><div class="line">    Node h = head;</div><div class="line">    Node s;</div><div class="line">    <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了保持公平性, 每次都是让同步队列中的队头线程获取锁, 因为队头线程等待的时间最长.</p>
<blockquote>
<p>释放读锁</p>
</blockquote>
<p>忽略一些其他的操作的话, 读锁的释放逻辑跟写锁的差不多, 都是<code>CAS</code>来更新同步状态, 不同的是, 读锁是共享锁, 必须通过循环<code>CAS</code>来保证线程安全.</p>
<blockquote>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3></blockquote>
<p><code>ReentrantReadWriteLock</code>内部维护两个锁, 一个是写锁, 另外一个是读锁. 通过将读写锁分离, 在读多写少的情况下, 更够提高程序的并发程度, 因此, <code>ReentrantReadWriteLock</code>的伸缩性要好于<code>ReentrantLock</code>. 在读多写少的情况下, 应该使用<code>ReentrantReadWriteLock</code>更为合适.</p>
<p><code>ReentrantReadWriteLock</code>只支持锁降级, 不支持锁升级. 因为锁升级有可能会出现条件竞争. 由于读锁是可以被多个线程持有的, 如果进行锁升级的话, 当写线程改变共享变量的状态时, 其他读线程有可能感知不到.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fkz6p5rdydj30m80b47at.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;和&lt;code&gt;ReentrantRead
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#Lock" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-Lock/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer中的ConditionObject剖析</title>
    <link href="http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer%E4%B8%AD%E7%9A%84ConditionObject%E5%89%96%E6%9E%90/"/>
    <id>http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer中的ConditionObject剖析/</id>
    <published>2017-10-31T09:09:23.612Z</published>
    <updated>2017-10-31T09:09:23.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer中的ConditionObject剖析"><a href="#AbstractQueuedSynchronizer中的ConditionObject剖析" class="headerlink" title="AbstractQueuedSynchronizer中的ConditionObject剖析"></a>AbstractQueuedSynchronizer中的ConditionObject剖析</h1><p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktlv07v17j30jg0dwngp.jpg" alt=""></p>
<p>在多线程环境中, 有时候, 一个线程的执行是需要等待一个条件发生后才能执行的. 在经典的生产者和消费者模式中, 如果缓冲区满后, 生产者是不能向缓冲区投放<code>item</code>的, 它需要等待一个条件: <code>缓冲区不为满的状态</code>. 同理, 如果缓冲区为空时, 消费者是不能消费<code>item</code>的, 它需要等待一个条件: <code>缓冲区不为空</code>. 一个线程需要等待一定的条件发生, 这个条件往往是别的线程触发的, 这就是经典的<code>等待/唤醒</code>模式.</p>
<p>在<code>JDK1.5</code>之前要实现这种模式的话, 只能够借助<code>synchronized</code>关键字和<code>Object</code>的对象锁来实现. 在<code>1.5</code>之后, 可以利用基于<code>AQS</code>实现的锁和<code>AQS</code>内部的<code>ConditionObject</code>来实现. 下面以<code>ReentrantLock</code>为例实现一个等待/唤醒模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObjectTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Condition isEmpty = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Condition isFull = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        ReentrantLock reentrantLock = lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">if</span> (count &gt;= MAX_LENGTH) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                isEmpty.await(); <span class="comment">//等待一个缓冲区不为满的条件</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        queue.add(i);</div><div class="line">        count++;</div><div class="line">        isFull.signal(); <span class="comment">//通知缓冲区已经不为空</span></div><div class="line">        reentrantLock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</div><div class="line">        ReentrantLock reentrantLock = lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                isFull.await(); <span class="comment">//等待缓冲区不为空的条件</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = queue.peek(); <span class="comment">//消费</span></div><div class="line">        count--;</div><div class="line">        isEmpty.signal(); <span class="comment">//通知缓冲区不为满</span></div><div class="line">        reentrantLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中定义了两个条件, 一个是缓冲区为空的条件, 另外一个是缓冲区为满的条件. 当队列达到最大长度时, 也就是缓冲区满了, 此时生产者调用了<code>isEmpty.await()</code>来等待一个缓冲区不为满的条件, 因此线程会暂时被挂起. 这个条件是由消费者消费了一个<code>item</code>后调用<code>isEmpty.signal()</code>是触发的. 触发了这个条件后, 会唤醒处于等待的生产者线程, 使它从<code>isEmpty.await()</code>中返回. 至于当缓冲区为满时的情况原理是一样的, 这里不多分析. 下面主要分析<code>AQS</code>内部怎么实现等待通知模式的.</p>
<blockquote>
<h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2></blockquote>
<p>一般而言, 线程是否需要等待一个条件的判断, 这个判断往往是访问一个共享变量, 在前面的例子中, 这个共享变量是<code>缓冲区</code>. 因此, 每次等待一个条件或者触发一个条件时, 都必须先获得锁. 这也解释为什么<code>ConditionObject</code>会作为<code>AQS</code>的内部类.</p>
<blockquote>
<h2 id="ConditionObject的等待-通知方法"><a href="#ConditionObject的等待-通知方法" class="headerlink" title="ConditionObject的等待/通知方法"></a>ConditionObject的等待/通知方法</h2></blockquote>
<p><code>ConditionObject</code>中的等待方法支持的类型跟<code>AQS</code>中一样, 都支持不可中断, 可中断, 超时三种类型.</p>
<blockquote>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4></blockquote>
<ul>
<li><p><code>awaitUninterruptibly()</code>: 不可中断的等待一个条件</p>
</li>
<li><p><code>await()</code>: 响应中断的等待一个条件</p>
</li>
<li><p><code>awaitNanos(long nanosTimeout)</code>: 超时等待一个条件, 如果超过指定的等待时间的话, 会直接返回. 超时等待还有两个重载方法, 这里只列出一个.</p>
</li>
</ul>
<blockquote>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4></blockquote>
<ul>
<li><p><code>signal()</code>: 从等待队列中唤醒一个正在等待的线程</p>
</li>
<li><p><code>signalAll()</code>: 唤醒等待队列中的全部线程.</p>
</li>
</ul>
<blockquote>
<h4 id="awaitUninterruptibly-解读"><a href="#awaitUninterruptibly-解读" class="headerlink" title="awaitUninterruptibly()解读"></a><code>awaitUninterruptibly()</code>解读</h4></blockquote>
<p>三种类型的等待方法的实现逻辑跟<code>AQS</code>中的获取同步状态的三种类型差不多, 这里只分析<code>awaitUninterruptibly()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node node = addConditionWaiter(); <span class="comment">//添加进等待队列, 等待队列不是AQS中的同步队列</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放同步状态, 相当于释放锁</span></div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//判断节点是不是在同步队列中, 也就是等待获取同步状态的队列</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">//不在同步队列的话, 证明已经在等待队列了, 需要等待一个条件, 因此挂起线程, 等待其他线程唤醒</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">//被唤醒后, 重新竞争同步状态, 也就是竞争锁</span></div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于每次调用这个方法时, 必定时已经获取了锁的, 所以不用控制同步, 实现起来比较简单. 首先将当前节点添加进等待队列, 接着释放同步状态, 也就是释放锁, 它准备要被挂起了, 挂起前必须释放同步状态, 不然有可能引起死锁. 然后, 判断节点是否存在同步队列中, 如果不存在的话,证明已经被添加进等待队列中, 此时进入<code>While</code>循环挂起线程. 接下来执行到这里就停了. 需要等待其他线程触发它等待的条件.</p>
<blockquote>
<h4 id="signal-解读"><a href="#signal-解读" class="headerlink" title="signal()解读"></a><code>signal()</code>解读</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    Node first = firstWaiter;</div><div class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">        doSignal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次都是释放等待队列中的第一个节点, 说明等待队列是一个<code>FIFO</code>队列. 释放的主要逻辑都在<code>doSignal(first)</code>中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">    do &#123;</div><div class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</div><div class="line">            lastWaiter = <span class="keyword">null</span>;</div><div class="line">        first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</div><div class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>doSignal()</code>中会调用<code>transferForSignal(first)</code>将等待队列中的节点移动到同步队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If cannot change waitStatus, the node has been cancelled.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Splice onto queue and try to set waitStatus of predecessor to</div><div class="line">     * indicate that thread is (probably) waiting. If cancelled or</div><div class="line">     * attempt to set waitStatus fails, wake up to resync (in which</div><div class="line">     * case the waitStatus can be transiently and harmlessly wrong).</div><div class="line">     */</div><div class="line">    Node p = enq(node);</div><div class="line">    <span class="keyword">int</span> ws = p.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">        LockSupport.unpark(node.thread);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过<code>CAS</code>设置节点的状态, 如果设置失败的话, 说明节点已经被取消. 接着调用<code>enq(node)</code>方法, 将节点移动到同步队列中, 然后设置节点的状态为<code>SIGNAL</code>.最后唤醒线程. 唤醒后, 在之前的等待方法中, 会被执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node node = addConditionWaiter(); <span class="comment">//添加进等待队列, 等待队列不是AQS中的同步队列</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放同步状态, 相当于释放锁</span></div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//判断节点是不是在同步队列中, 也就是等待获取同步状态的队列</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">//不在同步队列的话, 证明已经在等待队列了, 需要等待一个条件, 因此挂起线程, 等待其他线程唤醒</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">//被唤醒后, 重新竞争同步状态, 也就是竞争锁</span></div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于节点已经被移动到同步队列中, 所以<code>isOnSyncQueue(node)</code>会返回<code>true</code>跳出循环, 接着调用<code>acquireQueued(node, savedState)</code>来竞争同步状态, 也就是重新获得锁. 如果成功的话, 将从<code>awaitUninterruptibly()</code>中返回.</p>
<p>对于<code>signalAll()</code>, 它通过一个循环, 调用<code>signal()</code>来实现唤醒等待队列中的全部线程.</p>
<blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote>
<p>当一个线程调用等待方法时, 它首先会把自己添加进等待队列中, 接着释放同步状态, 然后被挂起. 直到其他线程调用唤醒的方法, 节点会被移动到同步队列中并且唤醒对应的线程去竞争同步状态, 如果成功的话, 将从等待的方法中返回, 下面是逻辑图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktlspogakj30f20n9q4q.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AbstractQueuedSynchronizer中的ConditionObject剖析&quot;&gt;&lt;a href=&quot;#AbstractQueuedSynchronizer中的ConditionObject剖析&quot; class=&quot;headerlink&quot; title=&quot;Ab
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#AQS" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-AQS/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer剖析</title>
    <link href="http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer%E5%89%96%E6%9E%90/"/>
    <id>http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer剖析/</id>
    <published>2017-10-31T09:09:19.644Z</published>
    <updated>2017-10-31T09:09:19.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktbn58ux2j30m80b47l5.jpg" alt=""></p>
<h1 id="AbstractQueuedSynchronizer剖析"><a href="#AbstractQueuedSynchronizer剖析" class="headerlink" title="AbstractQueuedSynchronizer剖析"></a>AbstractQueuedSynchronizer剖析</h1><p>在介绍AbstractQueuedSynchronizer(下面称AQS)前, 我们先来看看一个不安全的锁, 然后引出构建安全锁需要处理哪些情况.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">lock_t</span> &#123;</div><div class="line">    <span class="keyword">int</span> flag;</div><div class="line">&#125; <span class="keyword">lock_t</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    mutex-&gt;flag = <span class="number">0</span>; <span class="comment">//0表示锁空闲, 1表示锁被占有</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(mutex-&gt;flag == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//自旋等待</span></div><div class="line">    &#125;</div><div class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">//获得锁</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    mutex-&gt;flag = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>flag</code>字段是一个状态字段, 0表示锁空闲, 1表示锁被占有. 初始化时, <code>flag</code>被初始化为0, 表示锁是空闲的. 在<code>lock(lock_t*)</code>中, 会循环检查<code>flag</code>标记, 如果是为1的话, 表示锁已经被占有, 于是就一直自旋等待. 直到<code>flag</code>被设置为0, 也就是<code>unlock(lock_t*)</code>操作.</p>
<p>但是这个锁, 是不能保证正确性的. 因为 <code>mutex-&gt;flag == 1</code>和 <code>mutex-&gt;flag = 1</code>不是原子操作, 执行这两句的过程中, 有可能被中断.</p>
<p>而且, 这个锁的性能也不怎么好, 如果锁已经被占有的话, 它只会一直循环, 这样就白白浪费了CPU时间片.</p>
<p>如果能将<code>mutex-&gt;flag == 1;</code>和 <code>mutex-&gt;flag = 1</code>作为一个原子操作的话, 那么就能保证锁的正确性. 换句话说, 只要把检查和更新锁的状态字段的操作作为一个原子操作的话, 就不会出现问题. 所以现代处理器普遍都提供了<code>campare and swap</code>原句来解决这个问题.</p>
<p>至于性能的问题: 与其让它一直自旋等待, 不如让出时间片, 等锁空闲的时候再调度或者自旋等待一段时间, 超过这个时间后还没获得锁的话, 就放弃时间片.</p>
<p>现在总结一下解决这两个问题需要处理的情况:</p>
<ul>
<li><p>需要管理<code>flag</code>字段的同步状态, 利用一些同步原句来更新和管理同步状态.</p>
</li>
<li><p>为了提高锁的性能, 我们需要让获取锁失败的线程挂起或者等待一段时间后才挂起, 防止浪费时间片. 所以, 我们需要一个数据结构来管理记录这些获取锁失败的线程, 并且在当锁空闲的时候, 负责唤醒挂起的线程, 以便他们进行获取锁的操作.</p>
</li>
</ul>
<blockquote>
<h2 id="AQS的使命"><a href="#AQS的使命" class="headerlink" title="AQS的使命"></a>AQS的使命</h2></blockquote>
<p>经过上面的简单介绍, 我们知道构建一个安全并且性能高的锁需要处理下面的情况</p>
<ul>
<li><p>管理同步状态</p>
</li>
<li><p>管理获取锁失败的线程, 并且负责挂起和唤醒获取锁失败的线程.</p>
</li>
</ul>
<p><code>AQS</code>的使命就是来完成上面的任务, 以便让各种类型的锁只关注自己本身的特性. 换句话说: <code>AQS</code>是并发包中的基本骨架, 并发包中的各种锁都是基于<code>AQS</code>, <code>AQS</code>为其他锁将所有的脏活和累活(管理同步状态, 将获取锁失败的线程排队,挂起和唤醒.)都解决掉, 让其他的锁只关注自己的特性.</p>
<blockquote>
<h2 id="AQS设计"><a href="#AQS设计" class="headerlink" title="AQS设计"></a>AQS设计</h2></blockquote>
<p><code>AQS</code>是基于模板设计模式来实现的. 它将公用的特性自己实现, 对于具体的子类特性, <code>AQS</code>提供了一些方法作为模板, 子类只需要实现对应的模板方法来构建就行了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//独占式获取同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//独占式释放同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//共享式获取同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//共享式释放同步状态</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tryXXX</code>是<code>AQS</code>提供给子类实现的模板方法, 这些模板对应两种获取同步状态的模式: 独占式模式和共享式模式. 每种模式对应有获取和释放方法. 对于共享式, 同个时刻可以有多个线程获取同步状态, 至于获取的规则由子类去实现. 子类实现这种模式一般是共享锁. 至于独占式, 同个时刻只有一个线程可以获取, 获取的规则也是由子类去重写对应的模板方法实现. 子类实现这种模式一般是独占锁.</p>
<blockquote>
<h3 id="AQS中的同步队列"><a href="#AQS中的同步队列" class="headerlink" title="AQS中的同步队列"></a>AQS中的同步队列</h3></blockquote>
<p>对于获取锁失败的线程, <code>AQS</code>需要用一个数据结构来追踪记录他们. 这个数据结构是一个双向链表. 也可以看做是一个FIFO的<code>同步队列</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); <span class="comment">//标记当前模式为共享式</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; <span class="comment">//标记当前模式为独占式</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>; <span class="comment">//当前节点已经被取消</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>; <span class="comment">//标记后继节点需要被唤醒</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; <span class="comment">//标记当前节点处于等待队列中(注意不是同步队列)</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; <span class="comment">//用于共享模式中, 表示后继节点获取同步状态可以无条件传递下去.</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">//前继节点</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">//后继节点</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">//获取锁失败的线程</span></div><div class="line"></div><div class="line">    Node nextWaiter; <span class="comment">//等待队列中的当前节点的下个节点</span></div></pre></td></tr></table></figure>
<p>如果线程获取锁失败时, <code>AQS</code>会将其包装成一个<code>Node</code>节点并且入队在同步队列中. <code>Node</code>节点和<code>Thread</code>引用通过<code>volatile</code>来保证每次读取的值是最新的. 需要注意的是: <code>nextWaiter</code>是<code>等待队列</code>中的后继节点引用, 这里的<code>等待队列</code>和<code>同步队列</code>不是一样的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">//队列头结点</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">//队列尾节点</span></div></pre></td></tr></table></figure>
<p>每次出队时, 是从<code>head</code>节点出队, 入队时. 是从<code>tail</code>节点插入. 头尾节点也是被<code>volatile</code>修饰来保证他们在多线程环境下的可见性.</p>
<blockquote>
<h3 id="AQS中的状态管理"><a href="#AQS中的状态管理" class="headerlink" title="AQS中的状态管理"></a>AQS中的状态管理</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> state;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</div><div class="line">   state = newState;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">   <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">   <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于同步状态的管理, <code>AQS</code>采用一个<code>int</code>变量来表示, 并且该变量也是由<code>volatile</code>来修饰, 因此<code>getState</code>和<code>setState</code>这两个方法不用加锁. 这里需要注意的是: <code>volatile</code>能保证可见性, 但是不能保证原子性. 它只能保证单操作的原子性, 也就是更新时不依赖本身的状态或者是其他变量的值. 如果需要原子更新的话, 应该使用<code>compareAndSetState(int expect, int update)</code>, 该方法能够保证原子性和可见性.</p>
<blockquote>
<h3 id="AQS分类"><a href="#AQS分类" class="headerlink" title="AQS分类"></a>AQS分类</h3></blockquote>
<p>总得来说, <code>AQS</code>的操作分为两种模式:</p>
<ul>
<li><p>共享式: 共享式可以细分为: 1. <code>不响应中断的共享式获取同步状态</code>. 2. <code>响应中断的共享式获取同步状态</code>. 3. <code>同时响应中断和超时的共享式获取同步状态</code>.</p>
</li>
<li><p>独占式: 独占式跟共享式基本一样, 可以分为: 1. <code>不响应中断的独占式获取同步状态</code>. 2. <code>响应中断的独占式获取同步状态</code>. 3. <code>同时响应中断和超时的独占式获取同步状态</code>.</p>
</li>
</ul>
<p>下面我们通过官方的例子来解析AQS的原理. 如果理解了下面例子的话, 理解并发包中的其他锁自然也不在话下.</p>
<blockquote>
<h3 id="独占式锁"><a href="#独占式锁" class="headerlink" title="独占式锁"></a>独占式锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// Our internal helper class</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">     <span class="comment">// Reports whether in locked state</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Acquires the lock if state is zero</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">         setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Releases the lock by setting state to zero</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">       setState(<span class="number">0</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Provides a Condition</span></div><div class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Deserializes properly</span></div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></div><div class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</div><div class="line">       s.defaultReadObject();</div><div class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.acquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.release(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.newCondition();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> sync.isHeldExclusively();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Mutex</code>是一个简单的独占锁, 同一个时刻只允许有一个线程获取锁. <code>Sync</code>是<code>Mutex</code>的一个静态内部类, 该类继承了<code>AQS</code>, 并且重写了<code>AQS</code>提供的模板方法. <code>Sync</code>是<code>Mutex</code>一个代理类, <code>Mutex</code>的所有操作都是代理给<code>Sync</code>. <code>Sync</code>会调用<code>AQS</code>的方法, 而<code>AQS</code>又会回调<code>Sync</code>实现的模板方法.<br>这就是<code>AQS</code>的设计思路: 实现一个锁时, 往往是设置一个内部静态类, 该类继承<code>AQS</code>并且重写其中的模板方法, 最后锁内部的方法都代理给这个内部静态类. 并发包中的其他锁的实现思想也是这样的.</p>
<blockquote>
<h4 id="不响应中断的获取同步状态-acquire-int"><a href="#不响应中断的获取同步状态-acquire-int" class="headerlink" title="不响应中断的获取同步状态: acquire(int)"></a>不响应中断的获取同步状态: acquire(int)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">  sync.acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lock()</code>方法为不响应中断获取同步状态, 内部会调用<code>sync</code>的<code>acquire</code>, 而<code>acquire</code>方法是定义在<code>AQS</code>里面的. 那么先到<code>AQS</code>中看看.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会调用<code>tryAcquire(int)</code>来尝试获取同步状态, 如果获取成功的话, 直接返回. 获取失败的话, 需要入队. 获取的逻辑是在<code>Sync</code>重写的<code>tryAcquire(int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">    setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Mutex</code>实现得很简单, 通过<code>CAS</code>来更新状态. 如果获取成功的话, 返回<code>true</code>. 失败的话, 返回<code>false</code>.</p>
<p>如果获取同步状态失败的话, 也就是<code>tryAcquire</code>返回<code>false</code>的话, <code>AQS</code>会将对应的线程包装成一个<code>Node</code>节点, 然后加入同步队列中, 最后挂起线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//由于Head和Tail节点采用延迟加载的策略, 因此tail有可能为空</span></div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">//成功的话, 证明入队成功.</span></div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node); <span class="comment">//失败的话, 说明被其他线程给更新了尾节点, 因此进入enq方法入队.</span></div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 由于Head和Tail节点采用延迟加载的策略, 因此tail有可能为空</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addWaiter</code>内部首先尝试使用<code>CAS</code>来更新尾节点, 也就是插入新的节点. 如果<code>CAS</code>返回<code>true</code>的话, 证明插入成功, 如果失败的话, 进入<code>enq</code>方法.</p>
<p>在<code>enq</code>中, 通过一个死循环来保证入队的成功.</p>
<p>入队完成后, 进入<code>acquireQueued(final Node node, int arg)</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//拿到当前节点的前驱节点</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//如果当前节点的前驱节点为Head节点的话, 证明该节点处于队列的第二位置(第一是头节点. 仅仅做标记用), 因此它有权获取同步状态.</span></div><div class="line">                setHead(node); <span class="comment">//获取成功后, 更新头节点</span></div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果p != head或者获取同步状态失败的话, 需要将线程挂起</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>acquireQueued</code>的逻辑: 首先拿到当前节点的前驱节点, 如果前驱节点为<code>head</code>的话, 证明该节点处于队列的第二个位置, 由于<code>head</code>节点仅仅起标记的作用, 因此处于第二个位置的节点逻辑上是处于队头, 它能够竞争同步状态. 如果前驱节点不是<code>head</code>节点的话, 需要将线程挂起.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkr4pd1fycj30r607zt92.jpg" alt=""></p>
<p>现在我们来看看挂起线程的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">//首先判断是不是已经设置了SIGNAL状态, 是的话, 证明需要被挂起</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">//节点状态为CANCELLED, 跳过这些取消的节点</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        do &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">//设置节点为SIGNAL, 表明需要被挂起.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个线程被挂起前, 必须设置状态为<code>SIGNAL</code>, 设置为<code>SIGNAL</code>后, 表明前驱节点出队后, 必须唤醒这个节点. 如果节点的状态被设置为<code>CANCELLED</code>的话, 说明它不需要被挂起.</p>
<p>所以<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>, 如果线程需要被挂起的话, 它的状态为0(默认状态), 那么它通过<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</code>来将状态设置为<code>SIGNAL</code>, 表明它需要被挂起, 在下次再调用该方法时, 会执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回<code>true</code>来表示它需要被挂起.</p>
<p>如果线程的状态被设置为<code>CANCELLED</code>, 也就是<code>ws &gt; 0</code>, 那么会跳过这些取消的节点, 下次循环进入时, 执行上面的逻辑.</p>
<p>当<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>返回<code>true</code>时, 会调用<code>parkAndCheckInterrupt()</code>来挂起线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LockSupport.park(this)</code>是一个挂起线程的操作.</p>
<p>现在我们再经过一张图来理清<code>acquire(int)</code>的逻辑</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkrwnsxu5ej30oi0mq75m.jpg" alt=""></p>
<p>当线程尝试获取同步状态时, 如果成功的话, 直接退出. 如果失败的话, 将线程包装成一个<code>Node</code>节点并且加入到队列中. 入队后, 需要判断线程是否需要被挂起. 如果当前节点的前驱节点是<code>head</code>节点的话, 尝试获取同步状态, 如果成功的话, 将自己设置为头节点后退出. 如果当前节点的前驱节点不是<code>head</code>或者是<code>head</code>节点但是获取同步状态失败, 将线程挂起. 被挂起的线程会被前驱节点唤醒, 接着继续竞争同步状态.</p>
<blockquote>
<h4 id="响应中断的获取同步状态-acquireInterruptibly-int-arg"><a href="#响应中断的获取同步状态-acquireInterruptibly-int-arg" class="headerlink" title="响应中断的获取同步状态: acquireInterruptibly(int arg)"></a>响应中断的获取同步状态: acquireInterruptibly(int arg)</h4></blockquote>
<p><code>acquireInterruptibly(int arg)</code>可以响应线程的中断而退出.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">        doAcquireInterruptibly(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查线程的中断状态标记, 如果已经被设置了中断的话, 抛出中断异常来响应. 如果没有被中断的话, 先尝试快速的获取同步状态, 如果成功的话, 直接退出. 失败的话进入<code>doAcquireInterruptibly(arg);</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doAcquireInterruptibly(int arg)</code>方法的逻辑和<code>acquireQueued(final Node node, int arg)</code>大致一样. 下面只说说不一样的地方. 如果<code>parkAndCheckInterrupt()</code>返回<code>true</code>的话, 会抛出中断异常来响应中断.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程被唤醒后会检查中断标记位.</p>
<p>由于<code>acquireInterruptibly(int arg)</code>逻辑和<code>acquire</code>差不多, 所以这里不多讲.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkrxgdyggoj30p30mujss.jpg" alt=""></p>
<blockquote>
<h4 id="支持超时的获取同步状态-tryAcquireNanos-int-arg-long-nanosTimeout"><a href="#支持超时的获取同步状态-tryAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="支持超时的获取同步状态: tryAcquireNanos(int arg, long nanosTimeout)"></a>支持超时的获取同步状态: tryAcquireNanos(int arg, long nanosTimeout)</h4></blockquote>
<p><code>tryAcquireNanos(int arg, long nanosTimeout)</code>方法如果在给定的一个时间内不能够获取锁的话, 会直接返回. 该方法同时也支持中断. 换句话说<code>tryAcquireNanos(int arg, long nanosTimeout)</code>是在<code>acquireInterruptibly(int arg)</code>的基础上加入超时获取的逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</div><div class="line">        doAcquireNanos(arg, nanosTimeout);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查中断标志, 如果<code>true</code>的话, 抛出异常来响应. <code>false</code>的话, 首先尝试获取同步状态, 成功的话直接返回. 失败的话, 进入<code>doAcquireNanos(arg, nanosTimeout);</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">//记录超时的时间</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">//如果nanosTimeout &lt; 0=的话, 证明超时了</span></div><div class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// 剩余的超时时间如果小于这个spinForTimeoutThreshold的话, 线程不会被挂起, 而是会自旋</span></div><div class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doAcquireNanos(int, long)</code>的逻辑和<code>doAcquireInterruptibly(int arg)</code>大体相同, 不同的是: <code>doAcquireNanos(int, long)</code>支持超时获取锁. 超时获取的逻辑: 首先计算出超时的时间戳<code>final long deadline = System.nanoTime() + nanosTimeout;</code>, 在自旋的过程中, 如果<code>deadline - System.nanoTime() &lt;= 0</code>的话,证明已经超时, 所以返回<code>false</code>. 如果大于0的话, 说明还没超时. 如果线程挂起的另外一个条件是<code>nanosTimeout &gt; spinForTimeoutThreshold</code>. 这样做为因为<code>spinForTimeoutThreshold = 1000</code>纳秒, 已经很小了, 如果再进行超时等待的话, 反而会更加不准确. 因此, 如果<code>nanosTimeout</code>小于等于<code>spinForTimeoutThreshold(1000纳秒)</code>时,将不会使该线程进行超时等待,而是进入快速的自旋过程。</p>
<blockquote>
<h4 id="释放同步状态-release-int-arg"><a href="#释放同步状态-release-int-arg" class="headerlink" title="释放同步状态: release(int arg)"></a>释放同步状态: release(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head; <span class="comment">//获取头结点</span></div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>release(int)</code>为释放同步状态, 它会调用<code>tryRelease(int)</code>模板方法, 这个模板方法是由<code>Mutex</code>来重写的, 具体代码前面已经贴出来了.<br>接着它会进入<code>unparkSuccessor(h);</code>来唤醒同步队列中的线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了防止提前线程被提前唤醒, 首先利用<code>CAS</code>将状态更新为默认状态. 一般而言, 需要唤醒的节点为<code>head</code>节点的下个节点, 但是为了防止节点已经被取消或者为空, 需要判断一下, 如果是的话, 从队列找到下一个需要释放的节点. 最后才唤醒线程.</p>
<blockquote>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3></blockquote>
<p>共享锁是指允许同个时刻, 允许多个线程获得资源. 共享锁的实现需要<code>AQS</code>的四组方法支持</p>
<ul>
<li><p><code>acquireShared(int arg)</code>: 不支持中断获取同步状态</p>
</li>
<li><p><code>acquireSharedInterruptibly(int arg)</code>: 支持中断地获取同步状态</p>
</li>
<li><p><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>: 超时获取并且支持中断获取同步状态</p>
</li>
<li><p><code>releaseShared(int arg)</code>: 释放同步状态</p>
</li>
</ul>
<p>这四组方法的逻辑跟独占模式下的方法的逻辑差不多, 因此, 这里只分析<code>acquireShared(int arg)</code>和<code>releaseShared(int arg)</code>.</p>
<blockquote>
<h4 id="acquireShared-int-arg"><a href="#acquireShared-int-arg" class="headerlink" title="acquireShared(int arg)"></a>acquireShared(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireShared(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tryAcquireShared(arg)</code>为子类重写的模板方法. 如果方法返回值小于0的话, 说明获取同步状态失败. 因此进入<code>doAcquireShared(arg)</code>进行排队和挂起等操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">//添加进队列</span></div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获取前驱节点</span></div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">//获取同步状态</span></div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">//如果同步状态还有剩余的话</span></div><div class="line">                    setHeadAndPropagate(node, r); <span class="comment">//唤醒后续的线程</span></div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    <span class="keyword">if</span> (interrupted)</div><div class="line">                        selfInterrupt();</div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前驱节点为<code>head</code>节点的话, 此时会超时获取同步状态, 如果成功并且状态大于等于0的话, 证明同步资源还有剩余, 可以唤醒后面的线程. 因此会调用<code>setHeadAndPropagate(node, r)</code>, 设置头结点并且将唤醒后面的线程.</p>
<blockquote>
<h4 id="releaseShared-int-arg"><a href="#releaseShared-int-arg" class="headerlink" title="releaseShared(int arg)"></a>releaseShared(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>共享式的释放和独占式的释放的主要区别在于: 独占式释放的时候, 只有一个线程在执行, 因此不存在竞争条件, 直接唤醒后续线程即可. 但是在共享式中, 由于同个时刻有多个线程在执行, 因此存在条件竞争, <code>doReleaseShared()</code>内部通过循环和<code>CAS</code>来保证线程安全.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<p><code>AQS</code>利用模板设计模式来为其子类屏蔽了同步状态的管理, 同步队列的管理, 线程的挂起和唤醒等操作, 使得子类只需要关注本身获取同步状态的逻辑. <code>AQS</code>内部总体实现分为两种模式:</p>
<ul>
<li><p>共享式</p>
</li>
<li><p>独占式</p>
</li>
</ul>
<p>共享式和独占式都支持不可中断, 可中断, 可中断并且超时获取同步状态.</p>
<p>关于<code>AQS</code>, 其内部还有一个<code>ConditionObject</code>类, 该类是实现等待/通知模式. 由于篇幅的关系, 打算在下篇中分析.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fktbn58ux2j30m80b47l5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;AbstractQueuedSynchronizer剖析&quot;&gt;&lt;a href=&quot;#A
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#AQS" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-AQS/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="http://cristianoro7.github.io/2017/10/31/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://cristianoro7.github.io/2017/10/31/java基础/</id>
    <published>2017-10-31T09:06:42.339Z</published>
    <updated>2017-10-31T09:06:42.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="使用-连接字符串"><a href="#使用-连接字符串" class="headerlink" title="使用+连接字符串"></a>使用+连接字符串</h4><ul>
<li>使用+连接字符串每次都会构建一个新的对象，在需要频繁拼接字符串的场景时，会比较耗时和浪费空间，因为String创建后就不可以再改变，因此+ 操作是线程安全的</li>
</ul>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><ul>
<li>该类可以解决String拼接字符串时出现的问题，但是StringBuilder线程不安全。</li>
</ul>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><ul>
<li>StringBuilder可以保证线程安全，但是也因此效率变得低</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>如果只需要简单的拼接字符串的话，可以直接使用+号拼接</li>
<li>如果需要频繁拼接而且无需考虑线程安全的，可以使用StringBuilder</li>
<li>如果需要频繁拼接但要考虑到线程安全的话，可以使用StringBuffer<a id="more"></a>
<h3 id="对象与克隆"><a href="#对象与克隆" class="headerlink" title="对象与克隆"></a>对象与克隆</h3></li>
</ul>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul>
<li>只能对类中的基本数据进行拷贝，类中的对象还是引用原对象</li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul>
<li>通过重写clone使得类中的子对象也能进行克隆</li>
<li>深拷贝步骤：<ul>
<li>实现Cloneable接口（该接口只是拷贝的标记接口）</li>
<li>使用public访问修饰符重新定义clone方法</li>
</ul>
</li>
</ul>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><ul>
<li>异常对象都派生于Throwable类</li>
<li>Throwable分为Error和Exception</li>
</ul>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ul>
<li>Error层次结构描述了java运行时系统内部错误和资源耗尽错误，这种情况很少出现</li>
</ul>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><ul>
<li>Exception派生出两个分支，一个是RuntimeException，另外一个是其他异常</li>
<li>划分规则：由程序导致的是RuntimeExeption；而程序本身没有问题，但由像I/O错误这类问题导致的异常属于其他异常</li>
</ul>
<h4 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h4><ul>
<li>java语言规范：将派生于Error或者RuntimeException类的所有异常称为未检查异常，所有其他异常称为已检查异常。</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>final通常指的是不可改变的, 不想改变的原因往往出于两种原因：设计和效率</li>
<li>final可能使用到的情况：数据、方法和类</li>
</ul>
<h4 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h4><ul>
<li>一个既是static又是final的数据只占一段不能改变的内存空间，如果final定义的变量是引用类型的话，表明该引用一定被初始化指向一个对象后，就不能再更改引用，但是可以对象自身是可以被修改的</li>
</ul>
<h4 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h4><ul>
<li>当参数被声明为final时，意味着你不能修改其值，只能读取，这一特性主要用来向匿名内部类传递数据</li>
</ul>
<h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><ul>
<li>使用final方法有两个原因：<ul>
<li>把方法锁定，以防止任何继承类来修改它的含义，这是处于设计的考虑</li>
</ul>
</li>
<li>出于效率的考虑（由于虚拟机的优化，通常已经不需要final来进行优化）</li>
</ul>
<h4 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a>final和private关键字</h4><ul>
<li>类中所有private方法都隐式地指定为final。由于无法取用private，也就无法覆盖它</li>
</ul>
<h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><ul>
<li>当一个类被定义为final时，就表明你不打算继承该类了，这是出于设计或者安全的考虑<blockquote>
<p>参考资料：java核心技术，java编程思想</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;h4 id=&quot;使用-连接字符串&quot;&gt;&lt;a href=&quot;#使用-连接字符串&quot; class=&quot;headerlink&quot; title=&quot;使用+连接字符串&quot;&gt;&lt;/a&gt;使用+连接字符串&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用+连接字符串每次都会构建一个新的对象，在需要频繁拼接字符串的场景时，会比较耗时和浪费空间，因为String创建后就不可以再改变，因此+ 操作是线程安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;StringBuilder&quot;&gt;&lt;a href=&quot;#StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;StringBuilder&quot;&gt;&lt;/a&gt;StringBuilder&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;该类可以解决String拼接字符串时出现的问题，但是StringBuilder线程不安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;StringBuffer&quot;&gt;&lt;a href=&quot;#StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer&quot;&gt;&lt;/a&gt;StringBuffer&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;StringBuilder可以保证线程安全，但是也因此效率变得低&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果只需要简单的拼接字符串的话，可以直接使用+号拼接&lt;/li&gt;
&lt;li&gt;如果需要频繁拼接而且无需考虑线程安全的，可以使用StringBuilder&lt;/li&gt;
&lt;li&gt;如果需要频繁拼接但要考虑到线程安全的话，可以使用StringBuffer
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础概念" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-简单的HTTP协议-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%9B%BE%E8%A7%A3HTTP-%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE-%E7%AC%94%E8%AE%B0/"/>
    <id>http://cristianoro7.github.io/2017/10/31/图解HTTP-简单的HTTP协议-笔记/</id>
    <published>2017-10-31T09:06:30.759Z</published>
    <updated>2017-10-31T09:06:30.759Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通过请求和响应来交换信息"><a href="#通过请求和响应来交换信息" class="headerlink" title="通过请求和响应来交换信息"></a>通过请求和响应来交换信息</h4><p><img src="/uploads/图解HTTP/简单的HTTP协议01.jpg" alt=""><br><a id="more"></a></p>
<ul>
<li>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</li>
<li>请求报文的构成</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议02.jpg" alt=""></p>
<ul>
<li>响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议03.jpg" alt=""></p>
<h4 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h4><ul>
<li>HTTP协议自身不对请求和响应之间的状态进行保存, 也就是HTTP不对请求和响应做持久化处理</li>
<li>不保存状态这种设计的优点:更快的处理大量事物</li>
</ul>
<h4 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h4><ul>
<li>GET:获取资源</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议04.png" alt=""></p>
<ul>
<li>POST:传输实体主体</li>
<li>PUT:PUT 方法用来传输文件。就像 FTP 协议的文件上传一样,要求在请求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置。36但是,鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制,任何人都可以上传文件 , 存在安全性问题,因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制,或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web 网站,就可能会开放使用 PUT 方法。</li>
<li>HEAD:获得报文首部, 返回的不包含主体部分,常用于URI的有效期以及更新日期</li>
<li>OPTIONS:询问支持的方法, OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li>
<li>CONNECT:要求用隧道协议连接代理。CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP通信。主要使用 SSL(Secure Sockets Layer,安全套接层)和 TLS(Transport Layer Security,传输层安全)协议把通信内容加 密后经网络隧道传输。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议05.jpg" alt=""></p>
<h4 id="持久连接减少通信量"><a href="#持久连接减少通信量" class="headerlink" title="持久连接减少通信量"></a>持久连接减少通信量</h4><p>在HTTP协议初始的几个版本中, 每次HTTP请求都得断开一次, 这样TCP频繁的连接和断开会增加通信量的开销</p>
<p><img src="/uploads/图解HTTP/简单的HTTP协议06.jpg" alt=""></p>
<ul>
<li>为了解决该问题, 在HTTP1.1和部分HTTP1.0中想出了持久连接(HTTP Persistent Connections,也称为 HTTP keep-alive 或<br>HTTP connection reuse)的方法。该方法的特点是:只要任意一端没有明确提出断开连接,则保持 TCP 连接状态。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议07.jpg" alt=""></p>
<ul>
<li>线管化技术<br>在之前的HTTP请求都是要一个请求完另外一个才能继续,但是持久化连接使得请求线管化成为了可能。即一次性可以请求多个</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议08.jpg" alt=""></p>
<h4 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h4><ul>
<li>HTTP是无状态协议,无状态指的是它不对之前发生的请求和响应进行管理。例如:一个需要登录的Web网站,无法对是否登录进行状态管理,每次跳转页面不是要重新登录就是要在报文中添加附加的数据来进行登录状态管理</li>
<li>无协议状态的优点:减少服务器的CPU及内存消耗</li>
<li>为了解决这一矛盾,由此引进了Cookie技术来进行状态管理</li>
</ul>
<h5 id="Cookie技术简介"><a href="#Cookie技术简介" class="headerlink" title="Cookie技术简介"></a>Cookie技术简介</h5><ul>
<li><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>
</li>
<li><p>服务器端发现客户端发送过来的Cookie后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息。</p>
</li>
<li>没有Cookie下的请求:</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议09.jpg" alt=""></p>
<ul>
<li>第 2 次以后(存有 Cookie 信息状态)的请求</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议10.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;通过请求和响应来交换信息&quot;&gt;&lt;a href=&quot;#通过请求和响应来交换信息&quot; class=&quot;headerlink&quot; title=&quot;通过请求和响应来交换信息&quot;&gt;&lt;/a&gt;通过请求和响应来交换信息&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/uploads/图解HTTP/简单的HTTP协议01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#HTTP" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-返回结果的状态码-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%9B%BE%E8%A7%A3HTTP-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-%E7%AC%94%E8%AE%B0/"/>
    <id>http://cristianoro7.github.io/2017/10/31/图解HTTP-返回结果的状态码-笔记/</id>
    <published>2017-10-31T09:04:50.769Z</published>
    <updated>2017-10-31T09:04:50.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="状态码类别："><a href="#状态码类别：" class="headerlink" title="状态码类别："></a>状态码类别：</h4><p>类别    原因短语<br>1XX    Informational(信息性状态码)    接收的请求正在处理<br>2XX    Success(成功状态码)    请求正常处理完毕<br>3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求<br>4XX    Client Error(客户端错误状态码)    服务器无法处理请求<br>5XX    Server Error(服务器错误状态码)    服务器处理请求出错</p>
<a id="more"></a>
<h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h5><ul>
<li>200 OK：表示客户端的请求被服务器成功处理</li>
<li><p>204 No Content：该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</p>
</li>
<li><p>206 Partial Content：该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h5><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<ul>
<li><p>301 Moved Permanently:永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</p>
</li>
<li><p>302 Found:临时性重定向：该状态码表示请求的资源已被分配了新的URI，希望用户本次请求能使用新的URI。302和301很相似，302表示的URI并不是永久性移动，换句话说就是URI还有可能发生变化。</p>
</li>
<li><p>303 See Other：该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。303和302有着相似的功能，他们之间的区别是303状态码表示明确客户端采用GET请求获取资源</p>
</li>
<li><p>304 Not Modified  </p>
</li>
</ul>
<h5 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h5><p>4XX响应结果表示错误发生在客户端</p>
<ul>
<li><p>400 Bad Request:该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。</p>
</li>
<li><p>403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。</p>
</li>
<li><p>404 Not Found：该状态码表明服务器上无法找到请求的资源。</p>
</li>
</ul>
<h5 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h5><p>5XX 的响应结果表明服务器本身发生错误。</p>
<ul>
<li><p>500 Internal Server Error:该状态码表明服务器端在执行请求时发生了错误。</p>
</li>
<li><p>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。</p>
</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;状态码类别：&quot;&gt;&lt;a href=&quot;#状态码类别：&quot; class=&quot;headerlink&quot; title=&quot;状态码类别：&quot;&gt;&lt;/a&gt;状态码类别：&lt;/h4&gt;&lt;p&gt;类别    原因短语&lt;br&gt;1XX    Informational(信息性状态码)    接收的请求正在处理&lt;br&gt;2XX    Success(成功状态码)    请求正常处理完毕&lt;br&gt;3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求&lt;br&gt;4XX    Client Error(客户端错误状态码)    服务器无法处理请求&lt;br&gt;5XX    Server Error(服务器错误状态码)    服务器处理请求出错&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#HTTP" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-与HTTP协议的Web服务器-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://cristianoro7.github.io/2017/10/31/与HTTP协议的Web服务器/</id>
    <published>2017-10-31T09:03:42.347Z</published>
    <updated>2017-10-31T09:03:42.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h3><h4 id="通信数据转发程序-代理、网关、隧道"><a href="#通信数据转发程序-代理、网关、隧道" class="headerlink" title="通信数据转发程序:代理、网关、隧道"></a>通信数据转发程序:代理、网关、隧道</h4><ul>
<li>在HTTP通信时,代理、网关和隧道是用于通信数据的转发的应用程序,他们可以配合服务器进行工作</li>
<li>代理就像一个中介,他接收客户端发来的信息继而转发给服务器,同时也可以接受服务器的信息转发给客户端</li>
<li>网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。</li>
<li>隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。</li>
</ul>
<h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器01.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>每次通过代理服务器转发请求或响应时,会追加写入 Via 首部信息</li>
<li>利用代理的作用:<ul>
<li>利用缓存技术减少宽带流量</li>
<li>对特定网站的控制访问,以获取访问日志为主要目的</li>
</ul>
</li>
<li>代理的分类:<ul>
<li>缓存代理(Caching Proxy):代理转发响应时,缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。</li>
<li>透明代理:转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理(TransparentProxy)。反之,对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
</li>
</ul>
<h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器02.jpg" alt=""></p>
<ul>
<li>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</li>
<li>利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如,网关可以连接数据库,使用SQL 语句查询数据。另外,在 Web 购物网站上进行信用卡结算时,网关可以和信用卡结算系统联动。</li>
</ul>
<h5 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h5><ul>
<li>隧道可按要求建立起一条与其他服务器的通信线路,届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
</ul>
<h4 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h4><ul>
<li>利用缓存技术可以减少对服务器的访问,以及通信流量和通信时间。</li>
</ul>
<h5 id="缓存的有限期限"><a href="#缓存的有限期限" class="headerlink" title="缓存的有限期限"></a>缓存的有限期限</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器03.jpg" alt=""></p>
<h5 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器04.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源与图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与HTTP协作的Web服务器&quot;&gt;&lt;a href=&quot;#与HTTP协作的Web服务器&quot; class=&quot;headerlink&quot; title=&quot;与HTTP协作的Web服务器&quot;&gt;&lt;/a&gt;与HTTP协作的Web服务器&lt;/h3&gt;&lt;h4 id=&quot;通信数据转发程序-代理、网关、隧道&quot;&gt;&lt;a href=&quot;#通信数据转发程序-代理、网关、隧道&quot; class=&quot;headerlink&quot; title=&quot;通信数据转发程序:代理、网关、隧道&quot;&gt;&lt;/a&gt;通信数据转发程序:代理、网关、隧道&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在HTTP通信时,代理、网关和隧道是用于通信数据的转发的应用程序,他们可以配合服务器进行工作&lt;/li&gt;
&lt;li&gt;代理就像一个中介,他接收客户端发来的信息继而转发给服务器,同时也可以接受服务器的信息转发给客户端&lt;/li&gt;
&lt;li&gt;网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。&lt;/li&gt;
&lt;li&gt;隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/uploads/图解HTTP/与HTTP协议的Web服务器01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#HTTP" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收器</title>
    <link href="http://cristianoro7.github.io/2017/10/31/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://cristianoro7.github.io/2017/10/31/java垃圾回收器/</id>
    <published>2017-10-31T09:02:46.340Z</published>
    <updated>2017-10-31T09:02:46.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>判定对象存活<ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
<li>再谈引用<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
</li>
<li>生存还是死亡</li>
<li>回收方法区</li>
</ul>
</li>
<li>垃圾收集算法<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-整理算法</li>
<li>分代收集算法</li>
</ul>
</li>
<li>HotSpot的算法实现<ul>
<li>枚举根节点</li>
<li>安全点</li>
<li>安全区域</li>
</ul>
</li>
<li>垃圾收集器<ul>
<li>Serial收集器</li>
<li>ParNew收集器</li>
<li>Parallel收集器</li>
<li>Serial Old 收集器</li>
<li>Parallel Old 收集器</li>
<li>CMS收集器</li>
<li>G1收集器</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="判定对象的存活"><a href="#判定对象的存活" class="headerlink" title="判定对象的存活"></a>判定对象的存活</h3></blockquote>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li>给一个对象添加一个计数器,每当有一处地方引用对象时,计数器值加1; 当引用失效时, 计数器值就减1; 任何时刻计数器为0对象就是不可能再被使用的.</li>
<li>引用计数算法最大的缺点就是很难解决对象之间的循环引用.</li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li>通过一系列的称为 “ GC Root “ 对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链, 当一个对象到” GC Root “ 没有任何引用链相连时,则证明此对象是不可用的.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收-1.png" alt=""></p>
<ul>
<li>在Java语言中, 可作为 GC Root的对象包括下面几种:<ul>
<li>虚拟机栈(栈帧中的本地变量表)引用的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(一般指Native方法)引用的对象</li>
</ul>
</li>
</ul>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK1.2后,Java对引用进行了扩充,将引用分强引用, 软引用, 弱引用和虚引用四种.</p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>程序代码中普遍存在的,类似”Object obj = new Object()”这类引用, 只要强引用存在的话, 对象就永远不会被回收</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用用于描述一些还有用但是又是非必需对象. 对于软引用关联着的对象, 在系统将要发生内存溢出之前, 将会把对象列进回收范围之中进行第二次回收, 如果这次回收没有足够的内存,才抛出内存溢出异常</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用也是用来描述非必需对象, 但是它的强度比软引用弱一些, 被弱引用关联的对象只能生存到下次垃圾收集发生之前.<br>当垃圾收集器工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象.</p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><ul>
<li>它是最弱的一种引用关系.</li>
<li>一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象的实例</li>
<li>一个对象虚引用关联的目的就是这个对象被收集器回收时收到一个系统通知.</li>
</ul>
<h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><ul>
<li>一个对象需要至少经历两次标记才能宣告死亡</li>
<li>如果一个对象在可达性分析后发现没有GC Roots相连接时, 那么它第一次被标记并且进行一次筛选, 筛选的条件是该对象是否有必要执行finalize()方法.当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过一次, 这两种情况虚拟机都是视为不必要调用.</li>
<li>如果这个对象被判定为需要执行finalize()方法的话, 那么对象将会被放置在F-Queue队列中, 稍后虚拟机会启动一个优先级较低的线程去执行它.</li>
<li>执行finalize()方法时, 虚拟机并不会等待它执行结束, 这样做是为了避免执行finalize()方法缓慢或者发生死循环. 这样可能会导致F-Queue队列中的对象处于永久等待中,甚至导致整个内存回收崩溃.</li>
<li>finalize()方法是对象逃脱死亡命运的最后一次机会, GC会在finalize()中进行第二次小规模的标记, 如果对象被第二次标记后,那么就宣告了一个对象的死亡.</li>
</ul>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><ul>
<li>方法区的回收主要回收两部分内容:废弃常量和无用的类.</li>
<li>回收废弃常量和回收Java堆很相似.例如: 字符串 “abc” 已经进入了常量池, 但是当前系统没有一个String对象叫做”abc”的,也就是没有任何String对象引用常量池之中的”abc”, 如果这时候发生内存回收, 而且必要的话, 这个”abc”会被清除出常量池.常量池中的其他类(接口),方法,字段的符号引用也与此类似.</li>
<li>一个类被视为无用的条件<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用, 无法通过反射获取类的方法.</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3></blockquote>
<h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><ul>
<li>首先标记出所有需要回收的对象,在完成标记后统一回收所有被标记的对象</li>
<li>不足的地方<ul>
<li>效率问题, 标记和清除的两个过程效率都不是很高</li>
<li>空间问题, 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时, 无法找到足够的连续内存而不得不提前触发另外一次GC</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/mark-sweep.png" alt=""></p>
<h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><ul>
<li>复制算法是为了解决标记-清除算法的效率问题而出现的</li>
<li>它将内存按照容量划分为相等的两块, 每次只用其中一块.当这一块内存快用完了, 就将还存活的对象复制到另一块内存,然后再把空间一次清理掉</li>
<li>复制算法的代价是将内存空间缩小为原来的一半.</li>
<li>HotSpot虚拟机默认Eden和Survivor的大小比例为8:1,只有10%的内存空间会被浪费.</li>
<li>如果另外一块Survivor空间没有足够的内存放上次新生代存活下来的对象时, 这些对象将直接通过分配担保直接进入老年代.</li>
</ul>
<h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><ul>
<li>标记过程仍然与”标记-清除”算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉边界以外的内存.</li>
</ul>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ul>
<li>一般将Java堆划分为新生代和老年代, 这样就可以根据各个年代的特点采用适当的算法</li>
<li>在新生代中,每次GC时,都发现大量对象死去, 只有少量对象存活, 那就选用复制算法.</li>
<li>而老年代中因为对象的存活率高, 没有额外的空间进行担保,就必须使用”标记-清除”或者”标记-整理”.</li>
</ul>
<blockquote>
<h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3></blockquote>
<p>在HotSpot上实现垃圾收集算法, 必须对算法的执行效率必须经过严格的考证, 才能保证虚拟机的执行效率</p>
<h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><ul>
<li>目前主流的Java虚拟机使用的都是标准式的GC, 所以当执行系统停顿下来时, 并不需要一个不漏的检查完所有执行上下文和全局的引用位置, 虚拟机使用一组称为OopMap的数据结构来得知哪些地方存放着对象引用.</li>
</ul>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><ul>
<li>HotSpot没有为每条指令都生成OopMap, 它只是在特定的位置记录了”这些信息”,这些位置被称为安全点(Safepoint),即程序并非在所有的地方都能停下来GC, 只有在安全点时才能停下来</li>
<li>安全点的选定基本上是以程序”是否具有让程序长时间执行的特征”为标准选定.”长时间执行”的最明显特征就是指令序列复用,例如方法调用,循环引用,循环跳转,异常跳转等,具有这些功能的指令才会生成Safepoint.</li>
<li>对于Safepoint,需要考虑的另外一个问题是如何让GC发生时停止所有线程时,所有线程都跑到安全点. 这里有两种方案可供选择:抢先式中断和主动式中断.<ul>
<li>抢先式中断不需要线程的配合,在发生GC时,首先把所有线程全部中断,如果发现有线程中断在不安全点上, 就恢复线程,让它跑到安全点上. 现在几乎没有虚拟机是这样实现的.</li>
<li>主动式的中断是思想是当GC需要中断线程的时候, 不直接对线程进行操作,仅仅简单的设置一个标志, 各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己挂起.轮询标志的地方和安全点是重合的.</li>
</ul>
</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><ul>
<li>安全区域是指在一段代码之中,引用关系不会发生变化. 在这个区域中的任何地方开始GC都是安全的.</li>
<li>线程执行到Safe Region时, 首先标识自己已经进入安全区域, 那样当在这段时间内JVM要发起GC时,就不用管已经标识为安全区域状态的线程. 在线程要离开安全区域时, 它首先要检查系统是否已经完成了根节点枚举, 如果完成了,就继续执行,否则它就要等到收到安全离开的信号为止.</li>
</ul>
<blockquote>
<h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></blockquote>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收器.png" alt=""></p>
<h4 id="Senial-收集器"><a href="#Senial-收集器" class="headerlink" title="Senial 收集器"></a>Senial 收集器</h4><ul>
<li>Serial 收集器在进行垃圾回收时,必须暂停其他所有的工作线程,直到它收集结束</li>
<li>下面是Serial/Serial Old收集器的工作过程</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/Serial.png" alt=""></p>
<ul>
<li>优点: 简单高效, 对于限定单CPU的环境来说, Serial收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率.</li>
<li>使用场景: 在用户的桌面应用场景中, 分配给虚拟机管理内存不会很大, 停顿时间可控制在10几到100多毫秒, 只要不频繁发生,这点的停顿还是可以接受的. 因此, Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择.</li>
</ul>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><ul>
<li>ParNew收集器其实就是多线程版本的Serial收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParNew.png" alt=""></p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul>
<li>Parallel Scavenge收集器的特点是它关注点与其他的收集器不同, CMS等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间, 而Parallel Scavenge收集器目的是达到一个可控的吞吐量, 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值.</li>
<li>停顿时间越短越适合需要与用户交互的程序; 高吞吐量则可以高效率地利用CPU时间, 尽快完成程序运算任务, 主要适合后台运算而不需要太多交互的任务.</li>
</ul>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ul>
<li>Serial Old是Serial收集器的老年代版本, 使用”标记-整理”算法, 这个收集器的主要意义是给Client模式下的虚拟机使用.</li>
<li>如果在Server模式下, 那么它有两大主要用途:<ul>
<li>在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用.</li>
<li>作为CMS收集器的后备预案,在并发收集发生 Concurrent Mode Failure时使用.</li>
</ul>
</li>
</ul>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ul>
<li>Parallel Old 是Parallel Scavenge收集器的老年代版本.</li>
<li>在吞吐量以及CPU资源敏感的场合, 都可以优先考虑Parallel Scavenge加Parallel Old收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParallelOld.png" alt=""></p>
<h4 id="CMS-收集器-Concurrent-Mark-Sweep"><a href="#CMS-收集器-Concurrent-Mark-Sweep" class="headerlink" title="CMS 收集器(Concurrent Mark Sweep)"></a>CMS 收集器(Concurrent Mark Sweep)</h4><ul>
<li>CMS收集器是一种以获取最短回收停顿时间为目标的收集器.</li>
<li>CMS 收集器是基于 “标记-清除”算法实现,整个过程分为4个步骤:<ul>
<li>初始化标记:仅仅只是标记一下GC Roots能直接关联到的对象, 速度很快.</li>
<li>并发标记:进行GC Roots Tracing的过程.</li>
<li>重新标记:为了修正并发标记期间因用户程序继续运行导致标记产生变动的那一部分对象标记记录,这个阶段的停顿时间一般会比初始化阶段稍微长一些,但远比并发标记的时间短.</li>
<li>并发清除: 清除标记.</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/cms.png" alt=""></p>
<ul>
<li><p>CMS 收集器明显的3个缺点:</p>
<ul>
<li><p>CMS收集器对CPU资源非常敏感,在并发阶段,它虽然不会导致用户线程中断,但是会因为占用了一部分CPU资源而导致应用程序变慢,总吞吐量降低.</p>
</li>
<li><p>CMS 收集器无法处理浮动垃圾, 可能出现 “Concurrent Mode Failure”失败而导致另一次Full GC产生.浮动垃圾指的是CMS并发清理阶段用户线程还在运行, 这期间产生的垃圾.CMS无法像其他收集器那样等到老年代几乎完全被填满时才收集, 需要预留一部分的空间提供并发手机时的程序运行使用.要是CMS运行期间预留内存无法满足程序需要, 就会出现一次”Concurrent Mode Failure” 失败. 这时虚拟机启动后备预案: 临时启动Serial Old收集器重新进行老年代垃圾收集, 这样停顿的时间就变长了.</p>
</li>
<li><p>由于CMS是基于”标记-清除”算法实现的, 这意味者收集结束时会有大量空间碎片产生.空间碎片太多会给大对象分配带来麻烦,因为无法找到连续足够大的空间来给大对象分配,这就不得不提前触发一次Full GC 了. 为了解决这个问题, CMS收集器提供了一个 -XX:+UseCMSCompactAtFullCollection开关参数,用户在CMS收集器顶不住要进行FullGC时开启内存碎片的合并过程整理, 内存整理无法并发进行, 因此会导致停顿时间变长. 虚拟机设计者还提供了一个参数-XX:CMSFullGCsBeforeCompaction,这个参数用于设置执行多少次不压缩的Full GC后,就跟着一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)</p>
</li>
</ul>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器的使命是在未来替代掉JDK1.5之中发布的CMS收集器,与其他收集器相比, G1具有的特点:</p>
<h5 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h5><p>G1能充分利用多CPU,多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World停顿时间</p>
<h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>虽然G1可以不需要其他收集器配合就能管理整个GC堆,但他能够采用不同的方式去处理新创建的对象和已经存活一段时间,熬过多次GC的旧对象以获取更好的收集效果.</p>
<h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><p>G1整体来看是基于”标记-整理”算法实现的收集器,从局部上来看是基于复制算法实现的.</p>
<h5 id="可预测的停顿"><a href="#可预测的停顿" class="headerlink" title="可预测的停顿"></a>可预测的停顿</h5><p>G1除了要求停顿降低外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒.</p>
<p>如果不计算维护Remembered Set操作,G1收集器的运作大致可划分为以下几个步骤:</p>
<ul>
<li>初始标记:标记一下GC Roots能直接关联到的对象并且修改TAMS的值,让下一阶段用户程序并发运行时,能在正确可用的Region中创建新对象,这个阶段需要停顿线程,但耗时很短.</li>
<li>并发标记:从GC Roots开始对堆中对象进行可达性分析, 找出存活对象,这阶段耗时很长,但可用与用户程序并发运行.</li>
<li>最终标记:为了修正在并发标记期间因用户程序继续运作而导致标记产生百年动的那一部分标记记录,虚拟机将这阶段对象变化记录在线程Remembered Set中, 这阶段需要停顿线程,但可并行执行.</li>
<li>筛选回收:首先对各个Region的回收价值和成本进行排行,根据用户所期望的GC停顿时间来指定回收计划.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/g1.png" alt=""></p>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#JVM" scheme="http://cristianoro7.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存分配与回收策略</title>
    <link href="http://cristianoro7.github.io/2017/10/31/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://cristianoro7.github.io/2017/10/31/Java内存分配与回收策略/</id>
    <published>2017-10-31T09:02:36.800Z</published>
    <updated>2017-10-31T09:02:36.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>对象优先在Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活对象将进入老年代</li>
<li>动态对象年龄判定</li>
<li>空间分配担保</li>
</ul>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><ul>
<li>大多数情况下, 对象主要分配在新生代的Eden区上.</li>
<li>当Eden区没有足够的空间进行分配时, 虚拟机将进行一次 Minor GC</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul>
<li>大对象指的是需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串以及数组.</li>
<li>经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”他们.</li>
</ul>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul>
<li>为了采用分代收集来管理内存,虚拟机给每个对象定义了一个对象年龄计数器.</li>
<li>如果对象在Eden出生并经历第一次Minor GC后仍然存活, 并且能被Survivor容纳的话,将被移动到Survivor,并且年龄就增加1岁.</li>
<li>当它的年龄增加到一定程度(默认为15岁),就会被晋升到老年代.</li>
</ul>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ul>
<li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或者等于该年龄的对象就可以直接进入老年代,无需等到MaxTenuringThreshold2中要求的年龄.</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>如果老年代最大可用连续空间大于新生代所有对象总空间,那么Minor GC可以确保是安全的.</li>
<li>如果老年代最大可用连续空间不大于新生代所有对象总空间的话且老年代最大可用连续空间是大于历次晋升到老年代对象的平均大小,那么Minor GC是冒险的.</li>
<li>如果老年代最大可用连续空间不大于新生代所有对象总空间的话且老年代最大可用连续空间是小于历次晋升到老年代对象的平均大小,那这时要进行一次Full GC.</li>
</ul>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存分配与回收策略&quot;&gt;&lt;a href=&quot;#内存分配与回收策略&quot; class=&quot;headerlink&quot; title=&quot;内存分配与回收策略&quot;&gt;&lt;/a&gt;内存分配与回收策略&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#JVM" scheme="http://cristianoro7.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://cristianoro7.github.io/2017/10/31/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://cristianoro7.github.io/2017/10/31/Java内存区域/</id>
    <published>2017-10-31T09:02:31.104Z</published>
    <updated>2017-10-31T09:02:31.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>运行时数据区<ul>
<li>程序计数器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>运行时常量池</li>
</ul>
</li>
<li>HotSpot虚拟机对象探秘<ul>
<li>对象的创建</li>
<li>对象的内存布局</li>
<li>对象的访问定位</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3></blockquote>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。</li>
<li>如果线程正在执行的是一个Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的方法是一个Native方法的，程序计数器的值为空（Undefine）。</li>
<li>此内存是JVM唯一没有规定任何OOM的区域。</li>
<li>程序计数器是线程私有的。</li>
</ul>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul>
<li>Java虚拟机栈是线程私有的。</li>
<li>Java虚拟机栈指的是Java方法执行的内存模型：即每个方法在执行时都会创建一个栈帧（是方法运行时的一种基础数据结构），用于储存局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机栈的入栈到出栈的过程。</li>
<li>局部变量表存放了编译期可知的各种基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用和returnAddress类型。</li>
<li>局部变量表所需的内存空间在编译期完成分配，在方法运行期间不会改变局部变量表的大小。</li>
<li>该区域会出现两种异常情况<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>发挥的作用与Java虚拟机栈相似。</li>
<li>与Java虚拟机栈之间的区别：<ul>
<li>虚拟机栈执行Java方法服务。</li>
<li>本地方法栈执行本地方法服务。</li>
</ul>
</li>
</ul>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul>
<li>Java虚拟机所管理的内存区域最大的一块。</li>
<li>Java堆是在虚拟机启动时被创建，是被所有线程所共享。</li>
<li>一般情况下：几乎所有对象实例和数组都是在堆上分配。</li>
<li>如果在堆上没有内存完成实例分配，并且堆也无法扩展时，将抛出OOM。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>与堆一样，是各个线程共享的内存区域。</li>
<li>它用于储存已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。</li>
<li>当方法区无法满足内存分配的需求时，将会抛出OOM。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>运行时常量池是方法区的一部分。</li>
<li>当运行时常量池无法满足内存分配的需求时，将会抛出OOM。</li>
</ul>
<hr>
<blockquote>
<h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3></blockquote>
<h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ul>
<li>当虚拟机遇到new指令时，首先检查这个指令的参数是否在常量池能定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析，初始化过。如果没有的话，那必须先进行类的加载</li>
<li>类加载检查通过后，虚拟机将为新生对象分配内存。</li>
<li>对象所需的内存在类加载完成后便完全可确定，为对象分配空间相当于在堆上划分一块内存出来。</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作在TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码可以不赋值就直接使用。程序能访问到这些字段的零值。</li>
<li>接下来，虚拟机需要为对象进行必要的设置。例如：类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：对象头，实例数据和对齐填充。</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><ul>
<li>对象头包含两部分信息。</li>
<li>第一部分用于储存对象自身的运行时数据，如哈希码，GC分代年龄，锁标记，线程持有的锁，偏向线程ID，偏向时间戳等。考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构，它会根据对象的状态来复用自己的内存空间。例如，在32位的虚拟机中，如果对象处于未被锁定的情况下，那么 Mark Word的32bit空间中的25bit用于储存哈希码，4bit用于储存对象分代年龄，2bit储存锁标志，1bit固定为0。</li>
<li>对象头的另一部分为类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><ul>
<li>实例数据为对象真正储存的有效信息，也是代码中所定义的各种类型的字段内容。</li>
</ul>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><ul>
<li>对齐填充不是必然存在的，它仅仅起到占位符的作用</li>
<li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。</li>
<li>对象头部分正好是8字节的倍数。</li>
<li>当实例数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ul>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><ul>
<li>Java程序需要通过栈上的reference数据来操作堆上的具体对象。</li>
<li>目前主流的访问方法有使用句柄和直接指针两种。</li>
<li>如果使用句柄的话，那么Java堆将划分出一块内存来作为句柄池，reference中储存的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</li>
</ul>
<p><img src="/uploads/jvm/java内存区域/句柄指针.png" alt=""></p>
<ul>
<li><p>如果使用指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中储存的直接就是对象地址。<br><img src="/uploads/jvm/java内存区域/直接指针.png" alt=""></p>
</li>
<li><p>两种访问方式的优缺：</p>
<ul>
<li>使用句柄的最大好处就是reference中储存的是稳定的句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference不需要修改。</li>
<li>直接使用指针的最大好处就是速度更快，它节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#JVM" scheme="http://cristianoro7.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://cristianoro7.github.io/2017/10/31/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://cristianoro7.github.io/2017/10/31/Class类文件结构/</id>
    <published>2017-10-31T09:01:55.505Z</published>
    <updated>2017-10-31T09:01:55.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>Class类文件结构<ul>
<li>特殊字符串概念</li>
<li>魔数与Class文件的版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引,父类索引与接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="类文件结构-1"><a href="#类文件结构-1" class="headerlink" title="类文件结构"></a>类文件结构</h3></blockquote>
<p>Class文件结构只有两种数据类型:无符号和表.<br>无符号数属于基本的数据类型,以u1,u2,u4,u8分别代表1个字节,2个字节,4个字节和8个字节的无符号数,它用来描述数字,索引引用,数量值或者UTF-8编码构成字符串值.<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型,所有表都习惯以”_info” 结尾<br>整个class文件本质就是一张表:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count</td>
</tr>
<tr>
<td>u2</td>
<td>access_flag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface</td>
<td>interface_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h4 id="特殊字符串的概念"><a href="#特殊字符串的概念" class="headerlink" title="特殊字符串的概念"></a>特殊字符串的概念</h4><ul>
<li>全限定名: 把类的全名中的”.”替换成”/“,最后再加上”;”</li>
<li>简单名称: 没有类型和参数修饰的方法或者字段名称.</li>
<li>方法和字段的描述符: 描述符的作用是用来描述字段的数据类型,方法参数列表和返回值.</li>
<li>描述符标识字符含义:</li>
</ul>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>特殊类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型</td>
</tr>
</tbody>
</table>
<h4 id="魔数与Class文件版本"><a href="#魔数与Class文件版本" class="headerlink" title="魔数与Class文件版本"></a>魔数与Class文件版本</h4><ul>
<li>每个Class文件的头4个字节称为魔数,它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件.</li>
<li>紧接魔数后面的4个字节储存的是Class文件的版本号: 第5,6个字节是此版本号(Minor Version),第7和第8个字节是主版本号.JDK的版本号是从45开始的.</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li>常量池可以理解为Class文件之中的资源仓库,它同时是Class文件关联其他项目最多的数据类型,也是占用Class文件空间最大的数据项目之一.</li>
<li>由于常量池中的常量是不固定的,所以需要在常量池入口放置一项u2类型的数据,代表常量池容量计数值.</li>
<li>常量池中主要储存两大类常量:字面量和符号引用．字面量比较接近Java语言层面的常量概念,如字符串,声明为final常量值等. 而符号引用则属于编译原理方面的概念,主要包含了下面三类常量:<ul>
<li>类和接口的全称限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>常量池的项目类型:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或者方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标识方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeType_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><ul>
<li>access_flags用于识别一些类或者接口层次的访问信息.例如:这个class是类还是接口;是否定义为public类型;是否定义为abstract类型等. 具体标记:</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final,只有类可设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令心新语意</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstact类型, 对于接口或者抽象类来说, 这个标志为真,其他值为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识这个类并非由用户代码生成</td>
</tr>
<tr>
<td>ACC_ANNOTION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这个一个枚举</td>
</tr>
</tbody>
</table>
<h4 id="类索引-父类索引与接口索引集合"><a href="#类索引-父类索引与接口索引集合" class="headerlink" title="类索引,父类索引与接口索引集合"></a>类索引,父类索引与接口索引集合</h4><ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名</li>
<li>接口索引集合用于描述这个类实现了哪些接口</li>
</ul>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><ul>
<li>字段表集合用于描述接口或者类中声明的变量.</li>
<li>字段包括类级变量和实例级变量, 但不包括在方法内的局部变量</li>
</ul>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><ul>
<li>方法表结构:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<ul>
<li>方法表集合结构跟字段表结构大致相同</li>
<li>如果父类分方法没有被子类重写,方法表集合中就不会出现父类方法的信息.</li>
</ul>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><ul>
<li>虚拟机规范预定义的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量值</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类,方法表字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EbcloseingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性,这个属性用于标识这个类所在的外围方法.</td>
</tr>
<tr>
<td>InnerClasses</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令对应的关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部属性描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性, 供新的类型检查验证器检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配.</td>
</tr>
<tr>
<td>Signature</td>
<td>类,方法表,字段表</td>
</tr>
</tbody>
</table>
<p>待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类文件结构&quot;&gt;&lt;a href=&quot;#类文件结构&quot; class=&quot;headerlink&quot; title=&quot;类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#JVM" scheme="http://cristianoro7.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-set家族</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set%E5%AE%B6%E6%97%8F/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-set家族/</id>
    <published>2017-10-31T09:01:09.713Z</published>
    <updated>2017-10-31T09:01:09.713Z</updated>
    
    <content type="html"><![CDATA[<p><code>Set</code>集合的最大特点是能够保证内部的元素唯一性. 这种特性是建立在<code>Map</code>的基础上的. 换句话说: <code>Set</code>通过组合的模式, 在<code>Map</code>的基础上扩展了一些特性. 由于<code>Set</code>是建立在<code>Map</code>的基础上的. 如果理解了<code>Map</code>的话, <code>Set</code>会很好理解. 接下来我们来看看<code>Set</code>家族的UML</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fizhykmqgzj30x10hwq3y.jpg" alt=""></p>
<p><code>Set</code>接口对应<code>Map</code>接口, 定义了<code>Set</code>的一些方法. <code>AbstractSet</code>对应<code>AbstractMap</code>, 为<code>Set</code>家族提供了一些默认的实现. <code>HashSet</code>通过组合<code>HashMap</code>并且利用<code>HashMap</code>的Key值的唯一性, 来保证内部元素的唯一性. <code>LinkedHashSet</code>通过组合<code>LinkedHashMap</code>, 使得Set内部的元素是有序的. 同种道理, <code>TreeSet</code>也是基于<code>TreeMap</code>来实现的.</p>
<blockquote>
<h2 id="Set家族"><a href="#Set家族" class="headerlink" title="Set家族"></a>Set家族</h2></blockquote>
<ul>
<li><code>HashSet</code></li>
<li><code>LinkedHashSet</code></li>
<li><code>TreeSet</code></li>
</ul>
<blockquote>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"></div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>前面说过<code>Set</code>家族都是通过组合<code>Map</code>家族来实现的. 从上面的字段, 可以看出<code>HashSet</code>是基于<code>HashMap</code>来实现的. 而<code>PRESENT</code>则是一个虚假的值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当向<code>HashSet</code>中添加元素时, 将元素作为map的key, 而value则是用一个虚假的值<code>PRESENT</code>. 由于<code>HashMap</code>中的Key是唯一的. 而<code>HashSet</code>中的元素是作为Key储存在<code>HashMap</code>中的.这样就保证了<code>HashSet</code>元素中没有重复的值.</p>
<blockquote>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3></blockquote>
<p><code>LinkedHashSet</code>继承于<code>HashSet</code>, 它对应<code>Map</code>家族的<code>LinkedHashMap</code>. 但是当你查看<code>LinkedHashSet</code>的时候, 可能会发现并没有<code>LinkedHashMap</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</div><div class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个构造函数是<code>HashSet</code>为<code>LinkedHashSet</code>预留的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.keySet().iterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>`LinkedHashSet</code>中还提供了一个迭代器接口, 迭代器遍历时是有序的遍历. 因为该迭代器是<code>LinkedHashMap</code>的一个实现.</p>
<blockquote>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3></blockquote>
<p><code>TreeSet</code>对应于<code>TreeMap</code>, <code>TreeSet</code>的实现思路跟前面两个<code>Set</code>差不多.. 这里不分析.</p>
<blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2></blockquote>
<p>到这里…不知不觉已经分析完了集合框架. 但是并没有包含并发的集合工具. 接下来准备看完并发后再来梳理并发集合工具.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Set&lt;/code&gt;集合的最大特点是能够保证内部的元素唯一性. 这种特性是建立在&lt;code&gt;Map&lt;/code&gt;的基础上的. 换句话说: &lt;code&gt;Set&lt;/code&gt;通过组合的模式, 在&lt;code&gt;Map&lt;/code&gt;的基础上扩展了一些特性. 由于&lt;code
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-WeakHashMap,%20IdentityHashMap%20%E5%92%8C%20HashTable/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable/</id>
    <published>2017-10-31T09:01:04.877Z</published>
    <updated>2017-10-31T09:01:04.877Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2></blockquote>
<p><code>WeakHashMap</code>总体实现和<code>HashMap</code>差不多, 不同的时, <code>WeakHashMap</code>中的Key是弱引用类型, <code>WeakHashMap</code>内部的Key是会被自动回收的. 另外需要关注的是, <code>WeakHashMap</code>并没有向<code>HashMap</code>那样, 在1.8做了优化.</p>
<blockquote>
<h3 id="弱引用Key"><a href="#弱引用Key" class="headerlink" title="弱引用Key"></a>弱引用Key</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    V value;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates new entry.</div><div class="line">     */</div><div class="line">    Entry(Object key, V value,</div><div class="line">          ReferenceQueue&lt;Object&gt; queue,</div><div class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(key, queue);</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.hash  = hash;</div><div class="line">        <span class="keyword">this</span>.next  = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (K) WeakHashMap.unmaskNull(get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">        K k1 = getKey();</div><div class="line">        Object k2 = e.getKey();</div><div class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">            V v1 = getValue();</div><div class="line">            Object v2 = e.getValue();</div><div class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        K k = getKey();</div><div class="line">        V v = getValue();</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>内部的结点是继承弱引用类型, 并且指定了一个<code>ReferenceQueue&lt;Object&gt;</code>, 当Key被GC回收时, Key对应的对象会被添加到<code>ReferenceQueue&lt;Object&gt;</code>这个队列中. 这个队列是定义在<code>WeakHashMap</code>内部的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Reference queue for cleared WeakEntries</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>的实现原理跟<code>HashMap</code>是差不多的. 不过<code>HashMap</code>在1.8后, 做了很多优化, 但是<code>WeakHashMap</code>并没有跟随<code>HashMap</code>进行优化.</p>
<p>由于<code>WeakHashMap</code>和<code>HashMap</code>差不多, 我们只分析重要的实现方法.</p>
<p><code>WeakHashMap</code>的增删查改, 都会做一个同步操作, 什么是同步操作? 因为<code>WeakHashMap</code>的Key是弱引用类型, Key值会随时被GC回收. 虽然Key被回收了,但是对应的Value还是没有被回收的. 所以, 同步操作就是移除被回收Key对应的Value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunges stale entries from the table.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123; <span class="comment">//判断queue队列中是否有被回收的Key, 有的话, 需要移除对应Value</span></div><div class="line">        <span class="keyword">synchronized</span> (queue) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</div><div class="line"></div><div class="line">            Entry&lt;K,V&gt; prev = table[i];</div><div class="line">            Entry&lt;K,V&gt; p = prev;</div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                Entry&lt;K,V&gt; next = p.next;</div><div class="line">                <span class="keyword">if</span> (p == e) &#123;</div><div class="line">                    <span class="keyword">if</span> (prev == e)</div><div class="line">                        table[i] = next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        prev.next = next;</div><div class="line">                    <span class="comment">// Must not null out e.next;</span></div><div class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></div><div class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></div><div class="line">                    size--;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                prev = p;</div><div class="line">                p = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是同步操作的方法, <code>WeakHashMap</code>增删改查时, 都会调用的方法. 原理是这样的: 每当弱引用类型Key被GC回收时, 由于<code>WeakHashMap</code>内部指定了<code>ReferenceQueue&lt;Object&gt;</code>, 因此, 被移除的Key会被添加到该队列. 这个方法就是调用队列的<code>poll()</code>方法, 获得被移除的Key, 然后利用该Key, 移除在<code>WeakHashMap</code>内部对应的Value.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li><p><code>WeakHashMap</code>和<code>HashMap</code>一样, Key和Value都支持null.</p>
</li>
<li><p><code>WeakHashMap</code>内部的继承WeakReference, 将Key指定为弱引用类型, 这样Key会被自动回收. 虽然Key会被自动回收, 但是Value不会被自动回收. 因此, <code>WeakHashMap</code>内部每次增删改查时, 都会做同步操作.</p>
</li>
</ul>
<blockquote>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2></blockquote>
<p><code>IdentityHashMap</code>继承于<code>AbstractMap</code>,并实现了<code>Map</code>接口. 总体来说, <code>IdentityHashMap</code>跟<code>HashMap</code>差别还是很大的. 虽然继承结构相同, 但是实现的思想却是截然不同.</p>
<p><code>IdentityHashMap</code>内部并没有结点, 它的Key和Vaule都是储存在数组内的. 因此, <code>IdentityHashMap</code>解决的冲突是开放地址法.</p>
<p>上面说到<code>IdentityHashMap</code>的Key和Value都是存在数组内的. Key和Value总是连续的存放.</p>
<p>另外值得一提的是: <code>IdentityHashMap</code>是利用 <code>==</code>来比较Key的相等性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    init(DEFAULT_CAPACITY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2</span></div><div class="line">    <span class="comment">// assert initCapacity &gt;= MINIMUM_CAPACITY;</span></div><div class="line">    <span class="comment">// assert initCapacity &lt;= MAXIMUM_CAPACITY;</span></div><div class="line"></div><div class="line">    table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>默认的容量是64. 长度跟<code>HashMap</code>一样, 都是2的次幂.还是跟之前的套路一样, 只分析一些重要的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object k = maskNull(key);</div><div class="line"></div><div class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> Object[] tab = table;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</div><div class="line">        <span class="keyword">int</span> i = hash(k, len); <span class="comment">//获得数组的index</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>; <span class="comment">//有冲的话, 查找下一个index</span></div><div class="line">             i = nextKeyIndex(i, len)) &#123;</div><div class="line">            <span class="keyword">if</span> (item == k) &#123;</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</div><div class="line">                tab[i + <span class="number">1</span>] = value;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</div><div class="line">        <span class="comment">// Use optimized form of 3 * s.</span></div><div class="line">        <span class="comment">// Next capacity is len, 2 * current capacity.</span></div><div class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len)) <span class="comment">//当储存的元素大于 容量的3分之一的话, 扩容</span></div><div class="line">            <span class="keyword">continue</span> retryAfterResize;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        tab[i] = k;</div><div class="line">        tab[i + <span class="number">1</span>] = value; <span class="comment">//Value始终是保存在Key的下个index</span></div><div class="line">        size = s;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>hash</code>函数, 获得index, 如果index对应已经存有元素的话, 会调用<code>nextKeyIndex(int, int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>是使用开放地址法解决冲突. 当发生冲突时, 它会寻找下个位置, 而下个位置是 i + 2. 之所以是i + 2,而不是i + 1的原因是 Key和Value总是连续的储存的, 因此寻找下个位置时, 需要跳多一个位置.如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fip01fuwt1j30er06bmx6.jpg" alt=""></p>
<p>如果index没有储存元素的话, 会先检查内部储存元素数量是不是大于容量的1/3, 是的话会进行扩容操作.每次扩容都是扩为原来的2倍.</p>
<blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2></blockquote>
<p><code>HashTable</code>是一个遗留类, 已经被<code>HashMap</code>替代了. 从功能上来说, 跟HashMap差不多. 主要比较它跟<code>HashMap</code>的异同.</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><code>HashMap</code>是允许K或者V为null的, 但是<code>HashTable</code>不允许K或者V为null</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><code>HashMap</code>是线程不安全的, 而<code>HashTable</code>是线程安全的, 因为内部的方法都是加了锁. 但是在并发的环境, 不建议使用<code>HashTable</code>, 应该使用<code>ConcurrentHashMap&lt;K,V&gt;</code>. <code>ConcurrentHashMap&lt;K,V&gt;</code>是使用分段锁来控制同步, 显然性能上要比<code>HashTable</code>好.</p>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p><code>HashMap</code>的容量为2的n次幂, 而<code>HashTable</code>为素数.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;W
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-TreeMap</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-TreeMap/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-TreeMap/</id>
    <published>2017-10-31T09:01:00.490Z</published>
    <updated>2017-10-31T09:01:00.490Z</updated>
    
    <content type="html"><![CDATA[<p>这次要介绍的<code>Map</code>跟之前介绍的<code>Map</code>有点不一样. 之前的<code>Map</code>, 例如: <code>HashMap</code>, <code>LinkedHashMap</code>都是基于散列技术. 而这次要介绍的<code>TreeMap</code>则不同, <code>TreeMap</code>是基于一种叫<code>红黑树</code>的数据结构. 接下来, 我们先看看<code>TreeMap</code>的UML图片</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fizax4c2efj30o60c2dgl.jpg" alt=""></p>
<p>跟之前介绍过的<code>Map</code>一样, <code>TreeMap</code>实现了<code>Cloneable</code>和<code>Serializable</code>, 因此它支持克隆(浅克隆)和序列化.</p>
<p><code>SortMap</code>这个接口提供了一些有序的视图, 比如: key有序视图. 实现该接口的数据结构表明其遍历Key或者Value的时候,是有序的. <code>NavigableMap</code>继承<code>SortMap</code>接口, 并提供了更为丰富的视图操作.</p>
<blockquote>
<h2 id="TreeMap特性"><a href="#TreeMap特性" class="headerlink" title="TreeMap特性"></a>TreeMap特性</h2></blockquote>
<p><code>TreeMap</code>是基于红黑树来实现的. 红黑树是一种自平衡的二叉查找树, 插入, 查找, 删除等操作的时间复杂度都是<code>O(logn)</code>. 由于红黑树也是一种二叉查找树, 因此, 遍历<code>Treemap</code>是有序的.</p>
<p><code>TreeMap</code>的结点的默认顺序是<code>Key</code>的自然顺序(<code>Key</code>必须实现<code>Comparator</code>). 当然, <code>TreeMap</code>内部也支持外部提供<code>Comparator</code>来指定结点的排列顺序.</p>
<p><code>TreeMap</code>的Key是不支持null的, 而Value则支持null.</p>
<p>在了解了<code>TreeMap</code>一些特性后, 我们接着来分析<code>TreeMap</code>常用的操作和它的迭代器.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<ul>
<li>常用操作</li>
<li>迭代器</li>
</ul>
<blockquote>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; left; <span class="comment">//左孩子</span></div><div class="line">        Entry&lt;K,V&gt; right; <span class="comment">//右孩子</span></div><div class="line">        Entry&lt;K,V&gt; parent; <span class="comment">//父结点</span></div><div class="line">        <span class="keyword">boolean</span> color = BLACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Entry</code>是红黑树的结点类型, 除了K和V外, 还包含了左孩子, 右孩子和父结点.</p>
<blockquote>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * The comparator used to maintain order in this tree map, or</div><div class="line">   * null if it uses the natural ordering of its keys.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@serial</span></div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器, 可以通过构造函数赋值</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//红黑树的根结点</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The number of entries in the tree</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">//红黑树中的结点数</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The number of structural modifications to the tree.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">//用于实现fast-fail机制</span></div></pre></td></tr></table></figure>
<blockquote>
<h4 id="put-K-V"><a href="#put-K-V" class="headerlink" title="put(K, V)"></a>put(K, V)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//如果没有根结点的话, 证明树是空的</span></div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">//有指定比较器的情况</span></div><div class="line">        do &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用默认的Key自然顺序插入结点</span></div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        do &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key); <span class="comment">//比较</span></div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>); <span class="comment">//找到合适的插入位置</span></div><div class="line">    &#125;</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    fixAfterInsertion(e); <span class="comment">//恢复红黑树的特性</span></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入操作分为两种情况:</p>
<ul>
<li>根结点为空(红黑树为空): 直接将新结点赋值给根结点</li>
<li>根结点不为空:如果有指定比较器的话, 使用比较器来新结点的父节点. 没有的话, 根据Key的自然顺序来找新结点的父结点.</li>
</ul>
<p>插入结点后, 可能会违背红黑树的特性, 因此, 每次插入后, 都需要进行一些操作来恢复红黑树的特性.</p>
<blockquote>
<h4 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get</code>操作是获取key对应的value. 方法中主要调用了<code>getEntry(key)</code>来获取结点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key); <span class="comment">//如果比较器不为空的话, 使用指定的比较器来比较</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">//不支持Key为null的操作</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">//循环比较查找, 如果比较结果是&lt;0的话, 向左子树查找, &gt;0的话向右子树查找, 知道等于.</span></div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据二叉查找树的特性, 先比较结点, 如果大于0, 则向右子树查找, 如果小于0, 则左子树查找, 直到找到等于的结点.<br>如果不存在的话, 返回 null;</p>
<blockquote>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key); <span class="comment">//获取结点</span></div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    V oldValue = p.value;</div><div class="line">    deleteEntry(p); <span class="comment">//从红黑树中删除结点, 并做恢复红黑树特性的操作</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>remove</code>操作分两步: 获取要删除的结点, 找得到的话, 从红黑树中删除, 并且做恢复红黑树的操作, 最后返回被删除的结点; 如果找不到结点, 返回null.</p>
<blockquote>
<h4 id="firstKey和firstEntry"><a href="#firstKey和firstEntry" class="headerlink" title="firstKey和firstEntry"></a>firstKey和firstEntry</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">firstKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> key(getFirstEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>firstKey</code>是获取最小的Key值. 主要实现是在<code>getFirstEntry()</code>中, key(Entry)只是提取Entry中的key.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) <span class="comment">//循环遍历左子树</span></div><div class="line">            p = p.left;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据二叉查找树的特性, 想要获取树的最小值, 只要一直遍历左子树, 就能得到.</p>
<p>firstEntry的实现跟firstKey差不多.  不同的是, firstEntry得到Entry后, 会被包装成一个不可改变的Entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> :</div><div class="line">        <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Entry</code>在这个方法中被包装成了一个不可改变Value的Entry, 我们来看看为什么不改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>setValue</code>是SimpleImmutableEntry中的方法, 只要调用了, 都会抛出一个异常, 因此不支持改变Value.</p>
<p>与<code>firstKey</code>和<code>firstValue</code>对应的有<code>lastKey</code>和<code>lastValue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">lastKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> key(getLastEntry());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exportEntry(getLastEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>操作的思想都差不多, lastXX是获取Key最大的结点. 因此, 在查找时会循环查找右子树.</p>
<blockquote>
<h4 id="NavigableMap接口"><a href="#NavigableMap接口" class="headerlink" title="NavigableMap接口"></a>NavigableMap接口</h4></blockquote>
<p>接着, 我们来看看<code>NavigableMap</code>接口中的一些实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回小于Key的最大结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回小于等于Key的最大结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">floorKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回大于等于该Key的最小结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">ceilingKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回大于该Key的最小结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span>; <span class="comment">//删除最小的结点</span></div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span>; <span class="comment">//删除最大的结点</span></div></pre></td></tr></table></figure>
<p>上面的接口是获取红黑树中, 指定的结点. 这些接口的实现的思路都差不多, 这里只分析<code>lowerEntry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exportEntry(getLowerEntry(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的实现在<code>getLowerEntry</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; <span class="comment">//如果大于0,</span></div><div class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</div><div class="line">                p = p.right;  <span class="comment">//查找右子树,</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p; <span class="comment">//返回小于Key的最大值</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果&lt;=0</span></div><div class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</div><div class="line">                p = p.left; <span class="comment">//查找左子树</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//回退父结点查找</span></div><div class="line">                Entry&lt;K,V&gt; parent = p.parent;</div><div class="line">                Entry&lt;K,V&gt; ch = p;</div><div class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</div><div class="line">                    ch = parent;</div><div class="line">                    parent = parent.parent;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> parent;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面都是在二叉查找树中查找符合一定条件的结点的算法.没什么好说的.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    Entry&lt;K,V&gt; lastReturned;</div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line"></div><div class="line">    PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = <span class="keyword">null</span>;</div><div class="line">        next = first;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        next = successor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">prevEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        next = predecessor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="comment">// deleted entries are replaced by their successors</span></div><div class="line">        <span class="keyword">if</span> (lastReturned.left != <span class="keyword">null</span> &amp;&amp; lastReturned.right != <span class="keyword">null</span>)</div><div class="line">            next = lastReturned;</div><div class="line">        deleteEntry(lastReturned);</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PrivateEntryIterator</code>是<code>TreeMap</code>的基类迭代器, 提供了默认的一些操作.</p>
<p><code>nextEntry()</code>是获取下一个结点.主要获取的实现是在<code>successor</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123; <span class="comment">//如果右子树不为空的话,</span></div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) <span class="comment">//循环查找左子树, 找到大于t的最小结点</span></div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//为空的话, 回退到父结点, 查找大于t的最小结点</span></div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>successor(Entry)</code>的作用是, 在红黑树中找出比给定结点大的最小结点. <code>PrivateEntryIterator</code>构造函数传入的是红黑树中最小的结点. 所以循环调用<code>successor</code>的话, 得到的结点是按Key排序的, 换句话说: 遍历调用nextEntry函数, 得到的Entry顺序是按Key升序的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">prevEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = next;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    next = predecessor(e);</div><div class="line">    lastReturned = e;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理, <code>preEntry</code>是得到前一个结点.</p>
<p>接着我们来看看<code>PrivateEntryIterator</code>的子类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">     ValueIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">         <span class="keyword">super</span>(first);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> nextEntry().value;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">     KeyIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">         <span class="keyword">super</span>(first);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> nextEntry().key;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>KeyIterator</code> 继承了<code>PrivateEntryIterator</code>, 并提供了next()方法, 用于获取下一个key. <code>ValueIterator</code>也是同样的操作. 我们再来看看, 构造函数传入的是什么结点?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Iterator&lt;K&gt; <span class="title">keyIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(getFirstEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面分析过, <code>getFirstEntry()</code>是获取key最小的一个结点. 所以 循环调用<code>KeyIterator</code>的<code>next()</code>, 得到的是按Key升序的序列.</p>
<p>那有没有按Key降序的迭代器? 有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingKeyIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">        DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">            <span class="keyword">super</span>(first);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> prevEntry().key;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            deleteEntry(lastReturned);</div><div class="line">            lastReturned = <span class="keyword">null</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>DescendingKeyIterator</code>为反向Key的迭代器, 使用该迭代器遍历的时候, 得到的序列是Key的降序序列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Iterator&lt;K&gt; <span class="title">descendingKeyIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingKeyIterator(getLastEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次传入<code>DescendingKeyIterator</code>构造函数的Entry都是最大的结点.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><code>TreeMap</code>就讲到这里了. <code>Map</code>家族大概在这里就讲完了. 下篇会将<code>Set</code>家族, <code>Set</code>集合是基于<code>Map</code>来操作的, 如果理解<code>Map</code>集合后, <code>Set</code>会很好理解.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次要介绍的&lt;code&gt;Map&lt;/code&gt;跟之前介绍的&lt;code&gt;Map&lt;/code&gt;有点不一样. 之前的&lt;code&gt;Map&lt;/code&gt;, 例如: &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;都是基于散列技术. 而这次
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-LinkHashMap</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkHashMap/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-LinkHashMap/</id>
    <published>2017-10-31T09:00:56.142Z</published>
    <updated>2017-10-31T09:00:56.142Z</updated>
    
    <content type="html"><![CDATA[<p>上篇我们分析了<code>HashMap</code>, 知道了遍历<code>HashMap</code>时, 顺序是不能够保证的.如果遍历时需要顺序, 那么应该用<code>LinkedHashMap</code>, 也就是我们这次要来分析的另外一个集合类.</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fio5jh7fepj30lg0hkgm9.jpg" alt=""></p>
<p>从UML图来看, <code>LinkedHashMap</code>的继承于<code>HashMap</code>, 可见<code>LinkedHashMap</code>是基于<code>HashMap</code>来扩展的. 如果理解了<code>HashMap</code>的话, 那<code>LinkedHashMap</code>应该算是很简单了.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<ul>
<li><p><code>LinkedHashMap</code>是底层的数据结构是<code>HashMap</code>和<code>双向链表</code>. <code>LinkedHashMap</code>内部维护着一条双向链表, 在遍历<code>LinkedHashMap</code>时, 会遍历内部的链表, 这样就可以保证遍历的顺序是特定的.至于遍历的顺序, 有两种可选: 按照插入的顺序(默认); 按照访问的顺序(结点每次被访问时, 都会把结点移动到链表尾).</p>
</li>
<li><p>由于<code>LinkedHashMap</code>内部维护一条链表, 因此它在性能上要稍微逊色于<code>HashMap</code>.</p>
</li>
</ul>
<blockquote>
<h3 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * HashMap.Node subclass for normal LinkedHashMap entries.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>内部的Entry继承于<code>HashMap.Entry</code>, 并且加了两个成员变量, 用来记录前一个结点和后后一个结点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The head (eldest) of the doubly linked list.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The tail (youngest) of the doubly linked list.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</div></pre></td></tr></table></figure>
<p><code>head</code>为头结点, <code>tail</code>为尾结点. 分析到这里, 我们可以确认<code>LinkedHashMap</code>内部确实维护一条双向链表.</p>
<blockquote>
<h3 id="hock函数"><a href="#hock函数" class="headerlink" title="hock函数"></a>hock函数</h3></blockquote>
<p>还记得上次分析<code>HashMap</code>时,说过<code>HashMap</code>留给<code>LinkedHashMap</code>的三个hock函数吗? 不记得的话也没关系, 耐心看下面的分析就会想起来了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125; <span class="comment">//结点被访问后, LinkedHashMap回调的函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125; <span class="comment">//结点插入时, LinkedHashMap回调的函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125; <span class="comment">//结点被移除时, LinkedHashMap回调的函数</span></div></pre></td></tr></table></figure>
<p>上面三个hock函数定义在<code>HashMap</code>内部, 并且为空的函数.这三个函数是预留给<code>LinkedHashMap</code>用的. 当结点被访问, 插入和被移除时,<code>LinkedHashMap</code>回调的函数.</p>
<blockquote>
<h3 id="put-K-V-和afterNodeInsertion-boolean-evict"><a href="#put-K-V-和afterNodeInsertion-boolean-evict" class="headerlink" title="put(K, V)和afterNodeInsertion(boolean evict)"></a>put(K, V)和afterNodeInsertion(boolean evict)</h3></blockquote>
<p><code>LinkedHashMap</code>内部没有重写<code>put(K, V)</code>函数, 意味着它的话复用了<code>HashMap</code>的<code>put(K, V)</code>方法, 那…我们暂且回调<code>HashMap</code>吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict); <span class="comment">//回调函数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>put(K, V)</code>内部会调用<code>afterNodeInsertion(evict)</code>. 回到<code>LinkedHashMap</code>看看这个函数的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>这个函数的实现是为了移除比较<code>老</code>的元素(越<code>老</code>的元素会在链表的越前面).但是这个函数的默认实现总是不会移除<code>老</code>的元素. 因为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法一直返回false. 重写这个方法, 我们可以控制当<code>LinkedHashMap</code>内部的元素数量达到一定数量时, 移除比较老的元素.</p>
<p>前面说<code>LinkedHashMap</code>是可以根据插入的顺序进行遍历, 那么内部肯定在<code>put(K, V)</code>的时候, 会构造链表.那么构造的操作在哪里?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>重写了newNode(int, K, V, Node<v, k="">), 在其中写了构造链表的逻辑. 具体实现<code>linkNodeLast</code></v,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//如果为尾结点为空,证明链表为空, 直接将头结点和为结点指点新插入的结点</span></div><div class="line">        head = p;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//插入新结点</span></div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的逻辑为向双向链表中插入结点.</p>
<blockquote>
<h3 id="get-K-和afterNodeAccess-Node-e"><a href="#get-K-和afterNodeAccess-Node-e" class="headerlink" title="get(K)和afterNodeAccess(Node e)"></a>get(K)和afterNodeAccess(Node<k,v> e)</k,v></h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面我们说过, <code>LinkedHashMap</code>支持按照访问的顺序来遍历.而get(K)操作正是访问操作. 默认情况下, <code>LinkedHashMap</code>是按照插入顺序来遍历的, 因为字段<code>accessOrder</code>字段默认为<code>false</code>, 如果要支持按照访问顺序的话, 需要显示调用这个构造方法, 将<code>accessOrder</code>指定为<code>true</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor,</span></span></div><div class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们接着看看<code>afterNodeAccess</code>这个回调函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的逻辑为: 将访问的结点移动到链表的尾端.</p>
<p>至于<code>remove(K)</code>函数和<code>afterNodeRemoval(Node&lt;K,V&gt; e)</code>的关系和前面将的两个回调函数的思想一样. <code>remove(K)</code>内部会回调<code>afterNodeRemoval(Node&lt;K, V&gt; e)</code>函数, <code>afterNodeRemoval(Node&lt;K, V&gt; e)</code>会将结点从双向链表中移除.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<p>和<code>HashMap</code>一样, 内部有提供了三个视图(KeySet, ValueSet, set<entry<k, v="">), 因此, <code>LinkedHashMap</code>内部也有三个迭代器. 不同的是, <code>LinkedHashMap</code>迭代器的遍历顺序是有的. 下面我只分析<code>LinkedValueIterator</code>.</entry<k,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line"></div><div class="line">    LinkedHashIterator() &#123;</div><div class="line">        next = head;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        current = e;</div><div class="line">        next = e.after;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; p = current;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        K key = p.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashIterator</code>是<code>LinkedHashMap</code>内部迭代器的基类, 在构造函数将链表的头结点复制给 <code>next</code>, 然后<code>nextNode()</code>函数内, 顺序的访问之前构造好的链表.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着<code>LinkedValueIterator</code>继承了<code>LinkedHashIterator</code>, 提供了一个<code>next()</code>的方法.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><p><code>LinkedHashMap</code>是基于<code>HashMap</code>来实现的, 它和<code>HashMap</code>不同之处是: 遍历元素的时候的是有序的. 因为它内部维护了一个双向链表. 遍历的顺序可以有两种: 按照结点的插入顺序; 按照元素被访问的顺序.默认是按结点被插入的顺序.</p>
</li>
<li><p><code>LinkedHashMap</code>可以用来实现<code>LRU</code>缓存.</p>
</li>
<li><p>由于<code>LinkedHashMap</code>内部维护了一个双向链表, 因此, 在性能上要稍微逊色于<code>HashMap</code>.</p>
</li>
<li><p>如果对遍历元素的顺序是无要求的话, 应该使用<code>HashMap</code>, 反之应该使用<code>LinkedHashMap</code>.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇我们分析了&lt;code&gt;HashMap&lt;/code&gt;, 知道了遍历&lt;code&gt;HashMap&lt;/code&gt;时, 顺序是不能够保证的.如果遍历时需要顺序, 那么应该用&lt;code&gt;LinkedHashMap&lt;/code&gt;, 也就是我们这次要来分析的另外一个集合类.&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合-HashMap</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88-HashMap/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合-HashMap/</id>
    <published>2017-10-31T09:00:51.934Z</published>
    <updated>2017-10-31T09:00:51.934Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章分别介绍了<code>ArrayList</code>和<code>LinkedList</code>, 这次我们来分析另外一个key-value键值对的映射集合-HashMap.按照前面的习惯,我们先来看看<code>HashMap</code>的UML</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimu0do73tj30ii0cv3z0.jpg" alt=""></p>
<p><code>HashMap</code>实现了<code>Cloneable</code>, <code>Serializable</code>, 所以<code>HashMap</code>支持克隆(浅克隆)和序列化. <code>Map</code>接口提供了一系列接口和三个视图. <code>AbstractMap</code>则是实现了<code>Map</code>接口, 并且实现了<code>Map</code>接口中的一些方法, 换句话说<code>AbstractMap</code>是<code>Map</code>家族里面的一个基本骨架, 具体的子类根据需要重写<code>AbstractMap</code>中的方法即可.</p>
<blockquote>
<h2 id="回顾Hash表"><a href="#回顾Hash表" class="headerlink" title="回顾Hash表"></a>回顾Hash表</h2></blockquote>
<p>学过数据结构的都应该清楚, Hash表是将一个key的hash值取模后映射到一个数组中的特定位置. 但是, 随着Hash表中的键值对的增多, 会出现冲突. 所谓的冲突是两个key的hash值取模后得到的数定位到了数组中的相同位置.对于冲突这种情况, 常用的解决方法有:开放地址法和链地址法.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>回顾完了Hash表的基础知识后, 我们来讲讲<code>HashMap</code>的实现方式.</p>
<p>总体来说, <code>HashMap</code>的实现为: 数组+链表+红黑树. 当出现冲突时, <code>HashMap</code>是使用链地址法来解决冲突.但是如果冲突越来越多, 链表就会变得越来越长.这样导致的结果是:原本访问一个Key对应的value的时间复杂度会从O(1)退化为O(n).因此, <code>HashMap</code>使用一种名为红黑树的数据结构来解决时间复杂度退化的这个问题.红黑树查找key值对应的value的时间复杂度为O(log n)(优于O(n)).</p>
<p>下面, 先来看看<code>HashMap</code>中的字段, 我们将重点介绍两个字段. 这两个字段影响着<code>HashMap</code>的性能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The table, initialized on first use, and resized as</div><div class="line"> * necessary. When allocated, length is always a power of two.</div><div class="line"> * (We also tolerate length zero in some operations to allow</div><div class="line"> * bootstrapping mechanics that are currently not needed.)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//内部的数组</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</div><div class="line"> * for keySet() and values().</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//返回包含key-value的视图</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of key-value mappings contained in this map.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//内部储存的key-value的个数</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of times this HashMap has been structurally modified</div><div class="line"> * Structural modifications are those that change the number of mappings in</div><div class="line"> * the HashMap or otherwise modify its internal structure (e.g.,</div><div class="line"> * rehash).  This field is used to make iterators on Collection-views of</div><div class="line"> * the HashMap fail-fast.  (See ConcurrentModificationException).</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//记录内部数据结构发生变化的次数, 主要用来实现fail-fast</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next size value at which to resize (capacity * load factor).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></div><div class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></div><div class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></div><div class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The load factor for the hash table.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<p>loadFactor是负载因子, 这个字段表示<code>HashMap</code>内部容量满载的一个界限. threshold为扩容的界限,它的计算公式为: threshold = capacity * loadFactor.当size &gt; threshold时, <code>HashMap</code>内部就会扩容.</p>
<p><code>loadFactor</code>内部默认实现为0.75. 这个数值是时间和空间的一个折中值.<code>loadFactor</code>如果设置为比较大, 也就是<code>threshold</code>会比较大, 那么空间的利用率就会变大, 但是空间利用率变大的代价是查找速度变慢了, 因因为冲突率会提高. 如果<code>loadFactor</code>设置为比较小的话, <code>threshold</code>会比较小, 虽然冲突率会变小, 因为会频繁扩容.但这也一定程度上浪费空间内存.</p>
<blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote>
<p><code>HashMap</code>的构造函数有几个重载, 我们既可以使用无参的构造方法, 使用内部默认指定的<code>capacity</code>和<code>loadFactor</code>.也可以调用指定这两个参数的构造函数.</p>
<p>如果没有特殊情况.我们一般调用无参的构造函数.它会帮我们指定默认的<code>loadFactor</code>.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>put</code>函数是往<code>HashMap</code>中添加元素, 在分析添加元素的实现之前, 我们先来看看<code>hash(key)</code>函数,得到的hash值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4></blockquote>
<p><code>hash</code>函数的实现思路: 将key的hashCode的高16位和低16位作异或操作.至于为什么是要这样操作?</p>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<p>分析完了<code>hash(int key)</code>函数, 我们回到<code>put(K key)</code>, 来看看真正的添加操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//检查HashMap是否为空</span></div><div class="line">        n = (tab = resize()).length; <span class="comment">//空的话, 先进行扩容</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断HashMap中有没有存该Key</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//没有存该值, 直接赋值.</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//HashMap不为空的情况.</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//判断HashMap有没存该Key</span></div><div class="line">            e = p; <span class="comment">//没有的话直接赋值</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断这个结点是不是红黑树结点</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); 是的话, 插入到红黑树结构中</div><div class="line">        <span class="keyword">else</span> &#123; <span class="comment">//插入到链表结构中</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash); <span class="comment">//如果链表的结点个数为8的话, 将链表转化为红黑树, 这样提高查找的速度</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e); <span class="comment">//hock函数, 用于LinkHashMap中</span></div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//如果size &gt; threshold的话, 需要进行扩容</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面注释已经将函数解析得挺清楚了, 下面主要介绍这个<code>hash &amp; (n - 1)</code>操作. <code>hash &amp; (n - 1)</code>其实等价于取模操作, 但是比普通的 % 操作高效, 因为<code>hash &amp; (n - 1)</code>运用的位运算.</p>
<p>一个数和2的n次方进行去模操作, 余数是由这个数的低n决定,所以<code>hash &amp; (n - 1)</code>就是取得hash的底n位,也就是余数.如下图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimz01cbwzj30d60dm74h.jpg" alt=""></p>
<p>前面说过<code>HashMap</code>内部的长度总是为2的次方, <code>n</code>为<code>HashMap</code>的长度,所以跟上面的例子原理一样.</p>
<p><code>afterNodeAccess(e);</code>和<code>afterNodeInsertion(evict);</code>是hock函数, 是预留给<code>LinkedHashMap</code>使用的.</p>
<p>链表的构造使用的是头插法, 后插入的会在链表头.</p>
<p>如果一直向<code>HashMap</code>中添加元素的话, 其内部会扩容, 扩容通俗地说就是用更大的数组来代替之前的小数组以装下更多的元素.1.8的<code>HashMap</code>内部的扩容机制做了一些优化, 接下来, 我们来详细分析其中的优化.</p>
<blockquote>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩大为原来的两倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>resize()</code>函数为<code>HashMap</code>的扩容机制,扩容的情况有两种, 一种的初始化默认的容量, 另外一种是扩大为原来的两倍.</p>
<p>扩大容量后, 还需要把原来的数据搬到新的数组中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">            oldTab[j] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//定位到新的位置, 并且赋值</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">//如果结点是红黑树的结点的话, 会进行修剪树的操作</span></div><div class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order 头结点后面有元素,且为链表的结构</span></div><div class="line">              <span class="comment">//重新定位链表的策略: 定义两条链表, 构造完链条链表后, 再将他们的头结点定位到数组对应的index</span></div><div class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">//留在原来的位置的链表</span></div><div class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">//移动在原来位置+2的n次方位置的链表</span></div><div class="line">                Node&lt;K,V&gt; next;</div><div class="line">                do &#123;</div><div class="line">                    next = e.next;</div><div class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//新增位为0</span></div><div class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                            loHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            loTail.next = e;</div><div class="line">                        loTail = e;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//新增位为1</span></div><div class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                            hiHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            hiTail.next = e;</div><div class="line">                        hiTail = e;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    loTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    hiTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合代码中的注释, 我们来解析这个扩容机制, 首先遍历原来的数组, 然后拿到每个位置的头结点, 再判断头结点后面有没有元素, 没有的话, 直接用<code>&amp;</code>运算定位到新的位置.如果有的话, 先判断这个结点是不是红黑树的结点, 是的话做修剪树的操作.不是的话, 说明后面的结点的结构是链表.</p>
<p>前面说过, <code>HashMap</code>的每次扩容为原来的2倍, 这样的话, 原来的元素不是定位到原地, 就是在原地移动2的次幂.我们结合扩容前和扩容后的图来解释:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin22vrzufj30nb0c50tb.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin27c3g43j30o10bpmxq.jpg" alt=""></p>
<p>扩容后,决定位置的位数多了一位, 拿16扩容到32来说, 16的时候, 决定位置是由结果的后4位来决定, 如果扩容为32位后, 决定位置是由结果的后5位.如果新增的那一位为0的话,表示新的位置是原来的位置, 如果为1的话, 新的位置为原来的位置 + 原来的容量(原来的容量为2的n次方).</p>
<p>所以代码中<code>e.hash &amp; oldCap</code>就是为了取得新增的那一位, 如果为0的话, 说明新的位置为原来的位置, 如果为1的话,则需要移动2的n次幂(也就是 原来的位置 + 旧的容量).</p>
<p>上面重新组装链表的时候, 思路是这样的: 因为新的位置不是在原来的位置, 就是需要在原来的位置上移动2的次幂.所以, 定义两条链表, 一条表示新位置是原来的位置的链表(简称L1), 另外一条表示新的位置在原来的位置移动2的次幂(简称L2). 接着会先遍历原来的链表, 再进行<code>e.hash &amp; oldCap</code>, 如果为0的话, 将该结点插入到L1, 如果为1的话, 插入到L2. 插入的方法为尾插法, 这样重构后的链表不会乱序(1.7之前的版本是会乱序的). 最后,将新构造的两条链表定位到对应的位置,也就是下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">    loTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">    hiTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.8的扩容机制的优化主要是不需要再重新计算hash值, 只是做个<code>&amp;</code>操作就行了, 并且重构后的链表不会乱序. 这种优化的一个重要的前提是容量为2的n次幂. 因此 <code>HashMap</code>内部的容量为什么不定义为素数而是定义为2的n次幂. 这样做是为了减少扩容时的<code>rehash</code>操作.</p>
<p>到这里, 我们已经把<code>HashMap</code>内部的精华都分析完了, 其他操作都挺简单的, 也没什么好讲的.最后, 做个总结</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>hash</code>函数</li>
<li>扩容机制</li>
<li>冲突优化</li>
<li>其他</li>
</ul>
<blockquote>
<h3 id="hash函数-1"><a href="#hash函数-1" class="headerlink" title="hash函数"></a><code>hash</code>函数</h3></blockquote>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<blockquote>
<h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3></blockquote>
<ul>
<li><p><code>HashMap</code>的扩容后的长度总是2的次幂, 这个设置主要是为了优化扩容机制. <code>HashMap</code>内部扩容时,不需要重新计算hash值,并且链表的顺序还是保持原来的顺序.</p>
</li>
<li><p>频繁进行扩容会一定程度上影响<code>HashMap</code>性能.因此,如果预先知道需要储存的数据有很多的话, 可以直接设置一个较大的容量来减少扩容的次数.</p>
</li>
</ul>
<blockquote>
<h3 id="冲突优化"><a href="#冲突优化" class="headerlink" title="冲突优化"></a>冲突优化</h3></blockquote>
<p>对于hash冲突的情况, 如果冲突的链表结点个数大于8的话, <code>HashMap</code>会将链表转化为红黑树的结构, 将查找的复杂度从O(N)优化为O(logN).</p>
<blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></blockquote>
<ul>
<li><p><code>HashMap</code>既支持<code>Key</code>为<code>null</code>, 也支持<code>value</code>为<code>null</code>.</p>
</li>
<li><p>遍历<code>HashMap</code>时, 顺序是不保证的, 如果需要有序的遍历, 应该使用<code>LinkedHashMap</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章分别介绍了&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;, 这次我们来分析另外一个key-value键值对的映射集合-HashMap.按照前面的习惯,我们先来看看&lt;code&gt;HashMap&lt;/code&gt;的UML&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-LinkedList</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkedList/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-LinkedList/</id>
    <published>2017-10-31T09:00:43.662Z</published>
    <updated>2017-10-31T09:00:43.662Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们学了<code>ArrayList</code>, 知道了<code>ArrayList</code>比较适合需要频繁访问元素的场景. 但是在插入和删除元素时, 表现得效率低下. 这次, 我们来分析适合使用在频繁插入和删除元素的场景的集合: <code>LinkedList</code>.</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1filur9c5nfj30p10h7dh8.jpg" alt=""></p>
<p>我们先来看看UML图, <code>LinkedList</code>在继承关系上, 跟<code>ArrayList</code>基本相同. 我们这里只分析不同点.</p>
<ul>
<li><code>LinkedList</code>继承<code>AbstractSequentialList</code>, <code>AbstractSequentialList</code>这个是顺序访问列表的默认实现类, 换句话说, <code>LinkedList</code>访问元素时, 是顺序访问的, 不是像<code>ArrayList</code>那样, 具有随机访问元素的能力.</li>
<li>由于<code>LinkedList</code>是顺序访问列表, 因此它并没有实现<code>RandomAccess</code>接口.</li>
<li><code>LinkedList</code>实现了<code>Deque</code>接口, <code>Deque</code>接口是双向队列的一个接口.因此<code>LinkedList</code>可以看做是一个双端队列. 而且它还可以作为栈来使用.</li>
</ul>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Pointer to first node.</div><div class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line"> *            (first.prev == null &amp;&amp; first.item != null)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Pointer to last node.</div><div class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line"> *            (last.next == null &amp;&amp; last.item != null)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</div></pre></td></tr></table></figure>
<p>我们来先看看<code>LinkedList</code>中的字段. <code>size</code>记录集合内部的元素个数.<code>first</code>和<code>next</code>代表表头和表尾. <code>Node</code>是<code>LinkedList</code>的内部类, 代表链表的结点.从这里可以看出, <code>LinkedList</code>的内部实现是基于双向链表来实现的, 这也解释了为什么<code>LinkedList</code>适合使用在频繁插入和删除的场景.</p>
<blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个构造函数是一个空实现.证明一开始初始化时, 内部是不给结点分配内存的.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<p><code>LinkedList</code>既可以作为双向队列, 也可以作为栈. 说明其支持向队头队尾进行操作.我们接下来分析这些操作</p>
<blockquote>
<h4 id="队头插入元素"><a href="#队头插入元素" class="headerlink" title="队头插入元素"></a>队头插入元素</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the beginning of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkFirst(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the front of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to insert</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerFirst&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Pushes an element onto the stack represented by this list.  In other</div><div class="line"> * words, inserts the element at the front of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to push</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面三个操作都是向队头添加元素, 最终调用<code>addFirst(E)</code>, 而<code>addFirst(E)</code>又会调用<code>linkFirst(E)</code>.向队头插入元素的实现都是这个函数, 我们来分析一波:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Links e as first element.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f); <span class="comment">//创建一个新的结点,</span></div><div class="line">    first = newNode;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        last = newNode; <span class="comment">//如果队列为空的话,</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        f.prev = newNode; <span class="comment">// 队列不为空的话.</span></div><div class="line">    size++;</div><div class="line">    modCount++; <span class="comment">//记录内部结构发生变化的次数, 用于实现fast-fail机制.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>linkFirst</code>函数将一个元素插入到队头, 如果队列为空的话, 会将新插入的元素赋值给队列结点. 如果不为空的话, 将该元素复制为插入前的队头结点的前驱.</p>
<blockquote>
<h4 id="队尾插入元素"><a href="#队尾插入元素" class="headerlink" title="队尾插入元素"></a>队尾插入元素</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the end of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to insert</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerLast&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Adds the specified element as the tail (last element) of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.5</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> add(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法都是向队尾添加元素.它们最终都会调用<code>linkLast</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Links e as last element.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    last = newNode;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>linkLast</code>中的实现会向队尾添加一个结点, 思路和前面的大致一样.这里不多分析.</p>
<blockquote>
<h4 id="指定位置插入"><a href="#指定位置插入" class="headerlink" title="指定位置插入"></a>指定位置插入</h4></blockquote>
<p>既然<code>LinkedList</code>是基于链表来实现的, 那么<code>LinkedList</code>肯定是支持指定位置插入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the specified position in this list.</div><div class="line"> * Shifts the element currently at that position (if any) and any</div><div class="line"> * subsequent elements to the right (adds one to their indices).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</div><div class="line"> * <span class="doctag">@param</span> element element to be inserted</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index == size)</div><div class="line">        linkLast(element);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>add(int, E)</code>方法用于向指定位置插入一个元素, 如果index是等于size的话, 会直接插入到队尾. 如果不是的话, 会用<code>linkBefore(element, node(index))</code>. 我们来看看<code>LinkedList</code>怎么通过index定位到一个结点的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the (non-null) Node at the specified element index.</div><div class="line"> */</div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总体是比较index是否大于size / 2, 小于的话,就从队头遍历, 大于的话从队尾开始遍历. 这里虽然做了一些优化, 但是总体速度还是挺慢的. 接下来的<code>linkBefore</code>就是常规的向一个结点前插入元素的操作.</p>
<blockquote>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3></blockquote>
<p>移除元素的套路跟添加元素的套路一样. 有向队尾,队头,或者指定位置移除元素, 这三种操作, 最后都会调用到下面的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null first node f.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></div><div class="line">    <span class="keyword">final</span> E element = f.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</div><div class="line">    f.item = <span class="keyword">null</span>;</div><div class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    first = next;</div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">        last = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        next.prev = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null last node l.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></div><div class="line">    <span class="keyword">final</span> E element = l.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</div><div class="line">    l.item = <span class="keyword">null</span>;</div><div class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    last = prev;</div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</div><div class="line">        first = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null node x.</div><div class="line"> */</div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert x != null;</span></div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下去的获得元素的操作跟插入元素的思路都差不多.这里不多说.我们接下来看看<code>LinkedList</code>中的迭代器.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<p><code>LinkedList</code>中实现了两个迭代器, 一个是双向迭代器, 另外一个是单向迭代器.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>LinkedList</code>是基于链表来实现的, 决定了它比较适合使用在需要频繁插入和删除的场景. 但是不适合使用在经常要访问特定位置的元素. 因为每次都会遍历链表.</li>
<li><code>LinkedList</code>既可以作为双向队列,也可以作为栈来使用.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们学了&lt;code&gt;ArrayList&lt;/code&gt;, 知道了&lt;code&gt;ArrayList&lt;/code&gt;比较适合需要频繁访问元素的场景. 但是在插入和删除元素时, 表现得效率低下. 这次, 我们来分析适合使用在频繁插入和删除元素的场景的集合: &lt;code&gt;Lin
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-ArrayList</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-ArrayList/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-ArrayList/</id>
    <published>2017-10-31T09:00:39.690Z</published>
    <updated>2017-10-31T09:00:39.690Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1filh3gnlr2j30n90iw75f.jpg" alt=""></p>
<p>从上面的UML图, 我们可以看出 ArrayList实现了三个标记接口, 他们分别是:RandomAccess, Serializable, Cloneable. RandomAccess接口表示ArrayList支持随机访问其中的元素, 也就是ArrayList可以随机访问其中的元素, 并且时间复杂度为O(1). Serializable接口表示ArrayList可以被序列化. Cloneable接口说明ArrayList可以被克隆(内部实现为浅克隆).</p>
<p>回到UML图, <code>Collection</code>接口是集合的一个基类接口,它继承了<code>Iterable</code>接口,将遍历的任务交给了Iterable接口. <code>AbstracCollection</code>是一个抽象类, 他实现了<code>Collection</code>接口, 在其内部实现了一些默认行为, 同理<code>AbstractList</code>也是一个抽象类, 实现了<code>List</code>接口的一些默认行为. 从这里可以看出, Java的集合框架用到了适配器的模式, 利用AbstractXX一系列抽象类来实现一些默认行为, 其他的让具体子类去实现或者重写.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>分析完<code>ArrayList</code>的继承结构后, 我们开始来分析<code>ArrayList</code>的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Default initial capacity.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for empty instances.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for default sized empty instances. We</div><div class="line">    * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line">    * first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The array buffer into which the elements of the ArrayList are stored.</div><div class="line">    * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line">    * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line">    * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The size of the ArrayList (the number of elements it contains).</div><div class="line">    *</div><div class="line">    * <span class="doctag">@serial</span></div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>上面为<code>ArrayList</code>中的字段, 其中<code>elementData</code>字段是保存 <code>ArrayList</code>中的元素, 从这点可以看出, <code>ArrayList</code>的底层数据结构是数组. <code>size</code>字段记录集合中的元素.</p>
<blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with an initial capacity of ten.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>平常我们使用ArrayList时, 都会调用空的构造方法, 如上.这个构造方法中, 只是简单的将<code>elementData</code>赋值为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>, 也就是一个空的数组对象. 因为此时我们并没有添加元素, 构造一个空的数组也是合情合理的.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<p>实例已经得到了, 我们来看看添加元素的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Appends the specified element to the end of this list.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们要向集合添加元素, 由于之前我们构造的是一个空的数组, 那么内部肯定会帮我们扩容数组, 也就是<code>ensureCapacityInternal(size + 1)</code>. 我们进入该方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个方法主要是比较一下<code>elementData</code>对象是不是为空, 空的话, 就取<code>DEFAULT_CAPACITY</code>和<code>minCapacity</code>字段的最大值. 由于我们数组的大小为0, 所以, 取得的是<code>DEFAULT_CAPACITY</code>(也就是10). 进入:<code>ensureExplicitCapacity(minCapacity)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>modCount</code>是用来记录<code>ArrayList</code>内部结构发生变化的次数, 主要用来实现<code>fast-fail</code>机制. 接着会调用<code>grow(int)</code>, 该方法是<code>ArrayList</code>扩容的方法.</p>
<p> 我们接下去,看看<code>ArrayList</code>的扩容策略:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//右移1位,也就是除以2</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>扩容的大小为: 新容量 = 旧容量+旧容量 / 2. 在计算出新容量后, 会与旧容量作差, 再根据结果进行扩容. 主要有下面两种情况:</p>
<ul>
<li>当初始化时(也就是调用空的构造方法), 首次添加会扩容为10.</li>
<li>下次扩容时, 会加上原来容量的一半.</li>
</ul>
<blockquote>
<h3 id="随机访问元素"><a href="#随机访问元素" class="headerlink" title="随机访问元素"></a>随机访问元素</h3></blockquote>
<p>经过前面的分析, <code>ArrayList</code>实现了<code>RandomAccess</code>接口, 表示<code>ArrayList</code>具有随机访问元素的能力, 这种能力是数组本身就有的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>get(E)</code>中, 会首先检查一下index是否会越界, 会的话, 直接抛异常, 不会的话, 直接访问数组对应的index.</p>
<blockquote>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>ArrayList</code>中的移除元素的方法. 首先检查边界, 没有越界的话, 通过index访问元素. 接着再将index后面的元素向先移动. 最后手动将被移除的元素复制为null, 让其能够被GC回收.</p>
<p>这里需要注意的是: 虽然元素被移除了, 但是空间还是留着.</p>
<blockquote>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3></blockquote>
<p>在Java集合框架中, 使用了迭代器模式去遍历集合中的元素, 这使得在遍历元素时, 不用去关心集合的底层实现的数据结构, 各种集合只需要实现符合自己数据结构的迭代器.</p>
<p>在<code>ArrayList</code>中, 默认实现了两个迭代器, 它们分别是:单向迭代器, 双向迭代器.</p>
<blockquote>
<h4 id="单向迭代器"><a href="#单向迭代器" class="headerlink" title="单向迭代器"></a>单向迭代器</h4></blockquote>
<p>单向迭代器是众多迭代器的最简单的,也是最常用的. 内部实现是只能向一个方向遍历数据.</p>
<blockquote>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4></blockquote>
<p>与单向迭代器比, 双向迭代器能够向两个方向遍历数据</p>
<blockquote>
<h4 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h4></blockquote>
<p>如果一个线程利用迭代器遍历集合时, 另外一个线程向集合中添加元素. 这时会抛出异常. 这也说明了<code>ArrayList</code>是线程不安全的.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>ArrayList</code>实现的底层数据结构为数组.</li>
<li>由于<code>ArrayList</code>是基于数组来实现的, 因此决定了<code>ArrayList</code>的使用场景. 它适合用在需要频繁访问元素的场景, 因为其快速访问特性. 但是它不适合使用在需要频繁随机插入和删除的场景, 因为数组每次随机插入和删除元素时, 都需要移动后面的元素.</li>
<li><code>ArrayList</code>具有自动扩容的特性, 默认的容量为10, 后面每次扩容都会增加原来的一半.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-确保Web安全的HTTPS-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E7%A1%AE%E4%BF%9DWeb%E5%AE%89%E5%85%A8%E7%9A%84HTTPS/"/>
    <id>http://cristianoro7.github.io/2017/10/31/确保Web安全的HTTPS/</id>
    <published>2017-10-31T08:59:20.011Z</published>
    <updated>2017-10-31T08:59:20.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP存在的不足"><a href="#HTTP存在的不足" class="headerlink" title="HTTP存在的不足"></a>HTTP存在的不足</h3><ul>
<li>通信使用明文(不加密), 内容可能会被窃听</li>
<li>不验证对方身份,因此有可能遭遇伪装</li>
<li>无法证明报文的完整性,所以有可能遭到篡改</li>
</ul>
<h4 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h4><ul>
<li>HTTP本身是不具备加密的功能的,因此在发送报文时是采用明文传输.</li>
<li>如何采用明文进行传输的话,内容可以通过抓取传输时的数据包,再由工具进行解析,就可以得到通信的内容</li>
</ul>
<a id="more"></a>
<h4 id="不验证通信对方就有可能在遇到伪装"><a href="#不验证通信对方就有可能在遇到伪装" class="headerlink" title="不验证通信对方就有可能在遇到伪装"></a>不验证通信对方就有可能在遇到伪装</h4><ul>
<li>HTTP 协议的实现本身非常简单,不论是谁发送过来的请求都会返回响应,因此不确认通信方,会存在以下各种隐患。<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息,只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service,拒绝服务攻击)。</li>
</ul>
</li>
<li>查明对手的证书<ul>
<li>虽然使用 HTTP 协议无法确定通信方,但如果使用 SSL 则可以。SSL 不仅提供加密处理,而且还使用了一种被称为证书的手段,可用于确定方。</li>
</ul>
</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS01.jpg" alt=""></p>
<h4 id="无法证明报文完整性-可能已遭篡改"><a href="#无法证明报文完整性-可能已遭篡改" class="headerlink" title="无法证明报文完整性,可能已遭篡改"></a>无法证明报文完整性,可能已遭篡改</h4><h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3><h4 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h4><ul>
<li>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已。</li>
<li>通常,HTTP 直接和 TCP 通信。当使用 SSL 时,则演变成先和 SSL 通信,再由 SSL 和 TCP 通信了。简言之,所谓 HTTPS,其实就是身披SSL 协议这层外壳的 HTTP。</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS02.jpg" alt=""></p>
<h4 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h4><h5 id="共享密钥加密的困境"><a href="#共享密钥加密的困境" class="headerlink" title="共享密钥加密的困境"></a>共享密钥加密的困境</h5><ul>
<li>加密和解密同用一个密钥的方式称为共享密钥加密(Common keycrypto system),也被叫做对称密钥加密。</li>
<li>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交?在互联网上转发密钥时,如果通信被监听那么密钥就可会落入攻击者之手,同时也就失去了加密的意<br>义。另外还得设法安全地保管接收到的密钥。</li>
</ul>
<h5 id="使用两把密钥的公开密钥加密"><a href="#使用两把密钥的公开密钥加密" class="headerlink" title="使用两把密钥的公开密钥加密"></a>使用两把密钥的公开密钥加密</h5><ul>
<li>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)。顾名思义,私有密钥不能让其他任何人知道,而公开密钥则可以随意发<br>布,任何人都可以获得。</li>
<li>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密。利用这种方式,不需要发送用来解密的私有密钥,也<br>不必担心密钥被攻击者窃听而盗走。</li>
</ul>
<h5 id="HTTPS-采用混合加密机制"><a href="#HTTPS-采用混合加密机制" class="headerlink" title="HTTPS 采用混合加密机制"></a>HTTPS 采用混合加密机制</h5><ul>
<li>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</li>
<li>采用混合加密的机制是因为公开密钥加密的速度慢</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS03.jpg" alt=""></p>
<h4 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h4><ul>
<li>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。</li>
<li>为了解决这个问题,可以使用由数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密钥证书</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS04.jpg" alt=""></p>
<h4 id="HTTPS-的安全通信机制"><a href="#HTTPS-的安全通信机制" class="headerlink" title="HTTPS 的安全通信机制"></a>HTTPS 的安全通信机制</h4><p><img src="/uploads/图解HTTP/确保Web安全的HTTPS05.jpg" alt=""></p>
<ul>
<li><p>步骤 1: 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。</p>
</li>
<li><p>步骤 2: 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应154答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>
</li>
<li><p>步骤 3: 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
</li>
<li><p>步骤 4: 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。</p>
</li>
<li><p>步骤 5: SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>
</li>
<li><p>步骤 6: 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>
</li>
<li><p>步骤 7: 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。</p>
</li>
<li><p>步骤 8: 服务器同样发送 Change Cipher Spec 报文。</p>
</li>
<li><p>步骤 9: 服务器同样发送 Finished 报文。</p>
</li>
<li><p>步骤 10: 服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。</p>
</li>
<li><p>步骤 11: 应用层协议通信,即发送 HTTP 响应。</p>
</li>
<li><p>步骤 12: 最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</p>
</li>
</ul>
<h4 id="HTTPS存在的不足"><a href="#HTTPS存在的不足" class="headerlink" title="HTTPS存在的不足"></a>HTTPS存在的不足</h4><ul>
<li>HTTPS使用了SSL,因此速度会变慢</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS06.jpg" alt=""></p>
<ul>
<li>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源,导致处理速度变慢。<ul>
<li>和使用 HTTP 相比,网络负载可能会变慢 2 到 100 倍。除去和TCP 连接、发送 HTTP 请求 • 响应以外,还必须进行 SSL 通信,因此整体上处理通信量不可避免会增加。</li>
</ul>
</li>
<li>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲,比起 HTTP 会更多地消耗服务器和客户端的硬件资源,导致负载增强。</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP存在的不足&quot;&gt;&lt;a href=&quot;#HTTP存在的不足&quot; class=&quot;headerlink&quot; title=&quot;HTTP存在的不足&quot;&gt;&lt;/a&gt;HTTP存在的不足&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文(不加密), 内容可能会被窃听&lt;/li&gt;
&lt;li&gt;不验证对方身份,因此有可能遭遇伪装&lt;/li&gt;
&lt;li&gt;无法证明报文的完整性,所以有可能遭到篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;通信使用明文可能会被窃听&quot;&gt;&lt;a href=&quot;#通信使用明文可能会被窃听&quot; class=&quot;headerlink&quot; title=&quot;通信使用明文可能会被窃听&quot;&gt;&lt;/a&gt;通信使用明文可能会被窃听&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;HTTP本身是不具备加密的功能的,因此在发送报文时是采用明文传输.&lt;/li&gt;
&lt;li&gt;如何采用明文进行传输的话,内容可以通过抓取传输时的数据包,再由工具进行解析,就可以得到通信的内容&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#HTTP" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    
  </entry>
  
</feed>
