<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Desperado</title>
  <subtitle>Do one thing every day that scares you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cristianoro7.github.io/"/>
  <updated>2017-08-28T13:30:37.388Z</updated>
  <id>http://cristianoro7.github.io/</id>
  
  <author>
    <name>Desperado</name>
    <email>424494431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Java集合框架-ArrayList</title>
    <link href="http://cristianoro7.github.io/2017/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-ArrayList/"/>
    <id>http://cristianoro7.github.io/2017/08/28/深入理解Java集合框架-ArrayList/</id>
    <published>2017-08-28T13:30:37.388Z</published>
    <updated>2017-08-28T13:30:37.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1filh3gnlr2j30n90iw75f.jpg" alt=""></p>
<p>从上面的UML图, 我们可以看出 ArrayList实现了三个标记接口, 他们分别是:RandomAccess, Serializable, Cloneable. RandomAccess接口表示ArrayList支持随机访问其中的元素, 也就是ArrayList可以随机访问其中的元素, 并且时间复杂度为O(1). Serializable接口表示ArrayList可以被序列化. Cloneable接口说明ArrayList可以被克隆(内部实现为浅克隆).</p>
<p>回到UML图, <code>Collection</code>接口是集合的一个基类接口,它继承了<code>Iterable</code>接口,将遍历的任务交给了Iterable接口. <code>AbstracCollection</code>是一个抽象类, 他实现了<code>Collection</code>接口, 在其内部实现了一些默认行为, 同理<code>AbstractList</code>也是一个抽象类, 实现了<code>List</code>接口的一些默认行为. 从这里可以看出, Java的集合框架用到了适配器的模式, 利用AbstractXX一系列抽象类来实现一些默认行为, 其他的让具体子类去实现或者重写.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>分析完<code>ArrayList</code>的继承结构后, 我们开始来分析<code>ArrayList</code>的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Default initial capacity.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for empty instances.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for default sized empty instances. We</div><div class="line">    * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line">    * first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The array buffer into which the elements of the ArrayList are stored.</div><div class="line">    * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line">    * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line">    * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The size of the ArrayList (the number of elements it contains).</div><div class="line">    *</div><div class="line">    * <span class="doctag">@serial</span></div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>上面为<code>ArrayList</code>中的字段, 其中<code>elementData</code>字段是保存 <code>ArrayList</code>中的元素, 从这点可以看出, <code>ArrayList</code>的底层数据结构是数组. <code>size</code>字段记录集合中的元素.</p>
<blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with an initial capacity of ten.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>平常我们使用ArrayList时, 都会调用空的构造方法, 如上.这个构造方法中, 只是简单的将<code>elementData</code>赋值为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>, 也就是一个空的数组对象. 因为此时我们并没有添加元素, 构造一个空的数组也是合情合理的.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<p>实例已经得到了, 我们来看看添加元素的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Appends the specified element to the end of this list.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们要向集合添加元素, 由于之前我们构造的是一个空的数组, 那么内部肯定会帮我们扩容数组, 也就是<code>ensureCapacityInternal(size + 1)</code>. 我们进入该方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个方法主要是比较一下<code>elementData</code>对象是不是为空, 空的话, 就取<code>DEFAULT_CAPACITY</code>和<code>minCapacity</code>字段的最大值. 由于我们数组的大小为0, 所以, 取得的是<code>DEFAULT_CAPACITY</code>(也就是10). 进入:<code>ensureExplicitCapacity(minCapacity)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>modCount</code>是用来记录<code>ArrayList</code>内部结构发生变化的次数, 主要用来实现<code>fast-fail</code>机制. 接着会调用<code>grow(int)</code>, 该方法是<code>ArrayList</code>扩容的方法.</p>
<p> 我们接下去,看看<code>ArrayList</code>的扩容策略:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//右移1位,也就是除以2</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>扩容的大小为: 新容量 = 旧容量+旧容量 / 2. 在计算出新容量后, 会与旧容量作差, 再根据结果进行扩容. 主要有下面两种情况:</p>
<ul>
<li>当初始化时(也就是调用空的构造方法), 首次添加会扩容为10.</li>
<li>下次扩容时, 会加上原来容量的一半.</li>
</ul>
<blockquote>
<h3 id="随机访问元素"><a href="#随机访问元素" class="headerlink" title="随机访问元素"></a>随机访问元素</h3></blockquote>
<p>经过前面的分析, <code>ArrayList</code>实现了<code>RandomAccess</code>接口, 表示<code>ArrayList</code>具有随机访问元素的能力, 这种能力是数组本身就有的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>get(E)</code>中, 会首先检查一下index是否会越界, 会的话, 直接抛异常, 不会的话, 直接访问数组对应的index.</p>
<blockquote>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>ArrayList</code>中的移除元素的方法. 首先检查边界, 没有越界的话, 通过index访问元素. 接着再将index后面的元素向先移动. 最后手动将被移除的元素复制为null, 让其能够被GC回收.</p>
<p>这里需要注意的是: 虽然元素被移除了, 但是空间还是留着.</p>
<blockquote>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3></blockquote>
<p>在Java集合框架中, 使用了迭代器模式去遍历集合中的元素, 这使得在遍历元素时, 不用去关心集合的底层实现的数据结构, 各种集合只需要实现符合自己数据结构的迭代器.</p>
<p>在<code>ArrayList</code>中, 默认实现了两个迭代器, 它们分别是:单向迭代器, 双向迭代器.</p>
<blockquote>
<h4 id="单向迭代器"><a href="#单向迭代器" class="headerlink" title="单向迭代器"></a>单向迭代器</h4></blockquote>
<p>单向迭代器是众多迭代器的最简单的,也是最常用的. 内部实现是只能向一个方向遍历数据.</p>
<blockquote>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4></blockquote>
<p>与单向迭代器比, 双向迭代器能够向两个方向遍历数据</p>
<blockquote>
<h4 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h4></blockquote>
<p>如果一个线程利用迭代器遍历集合时, 另外一个线程向集合中添加元素. 这时会抛出异常. 这也说明了<code>ArrayList</code>是线程不安全的.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>ArrayList</code>实现的底层数据结构为数组.</li>
<li>由于<code>ArrayList</code>是基于数组来实现的, 因此决定了<code>ArrayList</code>的使用场景. 它适合用在需要频繁访问元素的场景, 因为其快速访问特性. 但是它不适合使用在需要频繁随机插入和删除的场景, 因为数组每次随机插入和删除元素时, 都需要移动后面的元素.</li>
<li><code>ArrayList</code>具有自动扩容的特性, 默认的容量为10, 后面每次扩容都会增加原来的一半.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0
    
    </summary>
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>CustomView总结</title>
    <link href="http://cristianoro7.github.io/2017/08/28/CustomView%E6%80%BB%E7%BB%93/"/>
    <id>http://cristianoro7.github.io/2017/08/28/CustomView总结/</id>
    <published>2017-08-28T09:22:00.500Z</published>
    <updated>2017-08-28T09:22:00.500Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# CustomView总结</p>
<blockquote>
<h2 id="LayoutParams认知"><a href="#LayoutParams认知" class="headerlink" title="LayoutParams认知"></a>LayoutParams认知</h2></blockquote>
<h3 id="Q-什么是LayoutParams-它跟view的关系是什么"><a href="#Q-什么是LayoutParams-它跟view的关系是什么" class="headerlink" title="Q: 什么是LayoutParams? 它跟view的关系是什么?"></a>Q: 什么是LayoutParams? 它跟view的关系是什么?</h3><blockquote>
<h4 id="什么是LayoutParams"><a href="#什么是LayoutParams" class="headerlink" title="什么是LayoutParams?"></a>什么是LayoutParams?</h4></blockquote>
<p>我们在XML布局中定义的layout_xx属性,最终都会以Java代码的形式展现出来, 而LayoutParams就是这些layout_xx属性在Java层的映射, 也就是说LayoutParams是view在xml布局中layout_xx的属性容器.</p>
<p>可见, LayoutParams是子View跟父View进行协商的桥梁. 协商的内容可有: 子View宽高, 子View在父View中摆放的位置等.</p>
<blockquote>
<h4 id="LayoutParams的继承关系"><a href="#LayoutParams的继承关系" class="headerlink" title="LayoutParams的继承关系"></a>LayoutParams的继承关系</h4></blockquote>
<p>LayoutParams是作为内部类定义在ViewGroup中,下面是LayoutParams的继承关系:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik760lyaqj30s20l8dgp.jpg" alt=""></p>
<p>LayoutParams是定义在ViewGroup, LayoutParams只支持 height, width. ViewGroupn内部的一个默认实现是MarginLayoutParams, 该类继承LayoutParams, 扩展了margin属性.接下来, 各个VieGroup的子类内部都有LayoutParams的子类,扩展对应ViewGroup的属性.比如 LinearLayout.LayoutParams, 增加了weight属性.</p>
<blockquote>
<h4 id="在Java代码中获取view的LayoutParams"><a href="#在Java代码中获取view的LayoutParams" class="headerlink" title="在Java代码中获取view的LayoutParams"></a>在Java代码中获取view的LayoutParams</h4></blockquote>
<p>既然LayoutParms是View对自己在父布局中的属性设置, 那么父View在测量或者布局的时候, 肯定是需要拿到这个LayoutParams对象的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(deepExport = <span class="keyword">true</span>, prefix = <span class="string">"layout_"</span>)</div><div class="line">    <span class="keyword">public</span> ViewGroup.<span class="function">LayoutParams <span class="title">getLayoutParams</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mLayoutParams;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set the layout parameters associated with this view. These supply</div><div class="line">     * parameters to the &lt;i&gt;parent&lt;/i&gt; of this view specifying how it should be</div><div class="line">     * arranged. There are many subclasses of ViewGroup.LayoutParams, and these</div><div class="line">     * correspond to the different subclasses of ViewGroup that are responsible</div><div class="line">     * for arranging their children.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> params The layout parameters for this view, cannot be null</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(ViewGroup.LayoutParams params)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Layout parameters cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line">        mLayoutParams = params;</div><div class="line">        resolveLayoutParams();</div><div class="line">        <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">            ((ViewGroup) mParent).onSetLayoutParams(<span class="keyword">this</span>, params);</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是View提供的接口, 用于设置和获取View中的LayoutParams.父View在测量和布局时, 就是通过<code>view.getLayoutParams()</code>来获得子<code>View</code>设置的<code>LayoutParams</code>.</p>
<blockquote>
<h2 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h2></blockquote>
<h3 id="Q-什么是MeasureSpec-它的工作原理是什么"><a href="#Q-什么是MeasureSpec-它的工作原理是什么" class="headerlink" title="Q: 什么是MeasureSpec? 它的工作原理是什么?"></a>Q: 什么是MeasureSpec? 它的工作原理是什么?</h3><blockquote>
<h4 id="什么是MeasureSpec"><a href="#什么是MeasureSpec" class="headerlink" title="什么是MeasureSpec?"></a>什么是MeasureSpec?</h4></blockquote>
<p>我们都知道, Android体系中, View有三种测量模式,每种测量模式都有对应View的宽高.</p>
<p>一个View可能会被多次测量, 在运行时也可能被动态改变而导致重新测量,布局. Android团队为了减少多次测量带来的对象分配消耗, 将View的测量模式和View的大小打包成一个int类型的值,从而减少了对象分配带来的消耗.</p>
<p>MeasureSpec这个类就是提供了打包和解包方法, 将测量模式和大小打包或者解包成int值.</p>
<blockquote>
<h4 id="MeasureSpec的工作原理"><a href="#MeasureSpec的工作原理" class="headerlink" title="MeasureSpec的工作原理"></a>MeasureSpec的工作原理</h4></blockquote>
<p>在Java中, int类型固定占4字节, 也就是32位.</p>
<p>由于三种测量模式用2位就能够表示, 可分别表示为:<code>00(UNSPECIFIED)</code>, <code>01(EXACTLY)</code>, <code>10(AT_MOST)</code>.</p>
<p>既然三种测量模式用2位表示就够, 那么剩下的低30位用来表示大小.</p>
<p>问题来了? 如何将2位的测量模式和30位的大小打包成一个int后, 能够无差错的解包成测量模式和View的大小?</p>
<p>答案: 使用掩码和逻辑或,与运算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has not imposed any constraint</div><div class="line"> * on the child. It can be whatever size it wants.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has determined an exact size</div><div class="line"> * for the child. The child is going to be given those bounds regardless</div><div class="line"> * of how big it wants to be.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The child can be as large as it wants up</div><div class="line"> * to the specified size.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div></pre></td></tr></table></figure>
<p>MODE_SHIFT为移多少位, MODE_MASK为掩码. 现在我们来算算掩码:3表示为二进制为:11, 所以0x3 &lt;&lt; 30 表示为: 1100000000(30个0). 这个掩码的作用就是配合逻辑与,或操作来进行打包和解包的操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>上面是打包操作, 在<code>size &amp; ~MODE_MASK</code>中, ~MODE_MASK为: 0011111(30个1),由于低30为全为1, 那么与size进行&amp;操作时, 低30位就由szie的低三十为决定, 而高2位则为00, <code>size &amp; ~MODE_MASK</code>这个操作就是将size的高2为设置为00, 同理:<code>(mode &amp; MODE_MASK)</code>这个操作是将mode低30位设置为0. 最后再进行 | 操作, 这样就得到了高2位为测量模式, 低30位为大小的int.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>getMode方法将一个打包的measureSpec解包为mode, 原理是通过&amp;获取measureSpec的高2位. 同理getSize(int measureSpec)也是同种道理.</p>
<blockquote>
<h2 id="LayoutParams和MeasureSpec的关系"><a href="#LayoutParams和MeasureSpec的关系" class="headerlink" title="LayoutParams和MeasureSpec的关系"></a>LayoutParams和MeasureSpec的关系</h2></blockquote>
<ul>
<li><p>MeasureSpec是由父容器中LayoutParams和本身的LayoutParams这两个因素决定的.</p>
</li>
<li><p>但是对于顶级View(DecorView),他的MeasureSpec是由屏幕的大小和自身的LayoutParams所决定的.</p>
</li>
<li><p>以上两点在阅读源码就可以看出来.</p>
</li>
</ul>
<h2 id="从源码角度来理解测量和布局"><a href="#从源码角度来理解测量和布局" class="headerlink" title="从源码角度来理解测量和布局"></a>从源码角度来理解测量和布局</h2><blockquote>
<h3 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h3></blockquote>
<p>为了更好的理解测量过程, 我们需要理解清楚MeasureSpec和LayoutParams的关系, 看MeasureSpec是怎么在LayoutParams的约束下生成的.</p>
<p>测量过程的工作是确定View的宽高.我们先从ViewRootImpl这个类来分析顶级View类是如何开始测量的.</p>
<p>测量,布局,绘制,这三个步骤将View显示到屏幕上,而触发这三个流程的地方是在<code>performTraversals()</code>方法中.</p>
<p>在<code>performTraversals()</code>方法中,除了测量,布局,绘制这三个阶段外, 其实在存在另外的两个阶段:预测量和窗口布局.</p>
<blockquote>
<h4 id="预测量"><a href="#预测量" class="headerlink" title="预测量"></a>预测量</h4></blockquote>
<p>ViewRootImpl在进行测量时,会预先进行一次测量,而这次预测量是在<code>measureHierarchy</code>方法中进行的. 预测量的目的就是为了在大屏幕的设备上将View更优雅的显示出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></div><div class="line">            <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight) &#123;</div><div class="line">        <span class="keyword">int</span> childWidthMeasureSpec;</div><div class="line">        <span class="keyword">int</span> childHeightMeasureSpec;</div><div class="line">        <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(TAG,</div><div class="line">                <span class="string">"Measuring "</span> + host + <span class="string">" in display "</span> + desiredWindowWidth</div><div class="line">                + <span class="string">"x"</span> + desiredWindowHeight + <span class="string">"..."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; <span class="comment">//为了让dialog显示得更好, 先根据预先定义好的dialog尺寸, 以此测量出一个包裹dialog的宽度.</span></div><div class="line">            <span class="comment">// On large screens, we don't want to allow dialogs to just</span></div><div class="line">            <span class="comment">// stretch to fill the entire width of the screen to display</span></div><div class="line">            <span class="comment">// one line of text.  First try doing the layout at a smaller</span></div><div class="line">            <span class="comment">// size to see if it will fit.</span></div><div class="line">            <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</div><div class="line">            res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">int</span> baseSize = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</div><div class="line">                baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": baseSize="</span> + baseSize);</div><div class="line">            <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</div><div class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//打包成MeasureSpec</span></div><div class="line">                childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//开始第一次测量</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                        + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123; <span class="comment">//如果测量出来的大小太小的话, 会再进行测量</span></div><div class="line">                    goodMeasure = <span class="keyword">true</span>; <span class="comment">//对测量结果满意</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Didn't fit in that size... try expanding a bit.</span></div><div class="line">                    baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": next baseSize="</span></div><div class="line">                            + baseSize); <span class="comment">//需要的话, 扩大宽度,进行二次测量</span></div><div class="line">                    childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//再次打包成MeasureSpec</span></div><div class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//第二次测量</span></div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                            + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                    <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Good!"</span>);</div><div class="line">                        goodMeasure = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!goodMeasure) &#123; <span class="comment">//最后还是太小的话, 只能妥协,返回窗口的可能改变的标记</span></div><div class="line">            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">            <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</div><div class="line">                windowSizeMayChange = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DBG) &#123;</div><div class="line">            System.out.println(<span class="string">"======================================"</span>);</div><div class="line">            System.out.println(<span class="string">"performTraversals -- after measure"</span>);</div><div class="line">            host.debug();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> windowSizeMayChange;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>为了让View更优雅的显示出来, 比如dialog在大屏幕的情况下, 如果其内容太大并且测量模式为WRAP_CONTENT的话,有可能会出现这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7l94nxgj30hi0br3yi.jpg" alt=""></p>
<ul>
<li>考虑到上面dialog的宽度有可能太小,会出现下面这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7n6wvkcj30c809ka9y.jpg" alt=""></p>
<ul>
<li><p>所以在预测量阶段,每次测量后都会根据一个标记<code>(MEASURED_STATE_TOO_SMALL)</code>来判断是否要进行二次测量来扩大宽度.</p>
</li>
<li><p>如果进行了二次测量的话, 宽度还是大小,就只能妥协,放弃预测量.</p>
</li>
<li><p>预测量是针对悬浮窗口而言, 也就是对于非悬浮窗口而言, 是没有预测量阶段的.</p>
</li>
</ul>
<blockquote>
<h4 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h4></blockquote>
<p>一般测量阶段都会伴随一个布局阶段, 预测量也是如此, 窗口布局就是根据预测量阶段得出的结果来进行布局.</p>
<blockquote>
<h4 id="开始测量"><a href="#开始测量" class="headerlink" title="开始测量"></a>开始测量</h4></blockquote>
<p>分析完预测量和预布局, 我们来分析<code>&quot;真正&quot;</code>的测量阶段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG, <span class="string">"Ooops, something changed!  mWidth="</span></div><div class="line">                            + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</div><div class="line">                            + <span class="string">" mHeight="</span> + mHeight</div><div class="line">                            + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</div><div class="line">                            + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</div><div class="line"></div><div class="line"><span class="comment">// Ask host how big it wants to be</span></div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
<ul>
<li>在View的测量机制中, 是通过给子View传递MeasureSpec来进行的, 因此, 测量阶段会首先进行获取测量规格, 并传递给子View, 我们先来看看顶级View如何进行获取MeasureSpec.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码通过调用<code>getRootMeasureSpec(mWidth, lp.width)</code>来获取宽度的MeasureSpec, 传递给方法的参数分别为屏幕的窗口大小和顶级View的LayoutParams封装的宽度信息.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> measureSpec;</div><div class="line">        <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>如果宽度为<code>ViewGroup.LayoutParams.MATCH_PARENT</code>, 直接把将窗口的大小和<code>MeasureSpec.EXACTLY</code>打包成一个MeasureSpec; 当宽度为<code>ViewGroup.LayoutParams.WRAP_CONTENT</code>情况也是如此.</p>
</li>
<li><p>至于<code>getRootMeasureSpec(mHeight, lp.height)</code>跟上面的基本一致,这里不多说.</p>
</li>
<li><p>分析到这里, 也验证了,<code>顶级View的MeasureSpec是由窗口的大小和自身的LayoutParams所决定的</code></p>
</li>
</ul>
<p>我们接着继续分析<code>performMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个方法中只是简单的调用了View的measure(int, int)方法, 也就是从RootViewImppl调到了View中. 方法中的参数刚刚生成的两个测量规格.可见,测量规格是在父View中生成并传递给子View的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            <span class="keyword">int</span> oWidth  = insets.left + insets.right;</div><div class="line">            <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</div><div class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></div><div class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</div><div class="line">        <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// first clears the measured dimension flag</span></div><div class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">            resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</div><div class="line">                    mMeasureCache.indexOfKey(key);</div><div class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</div><div class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></div><div class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">                <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></div><div class="line">                setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</div><div class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></div><div class="line">            <span class="comment">// an exception to warn the developer</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></div><div class="line">                        + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></div><div class="line">                        + <span class="string">" measured dimension by calling"</span></div><div class="line">                        + <span class="string">" setMeasuredDimension()"</span>);</div><div class="line">            &#125;</div><div class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">        mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</div><div class="line">                (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法略长, 但是核心思路只有两个, 第一: 判断传入的大小和前一次测量的大小是否一样, 如果一样的话, 不进行测量, 如果不一样的话, 就开始测量. 第二:如果传入的大小和前一次测量的大小不一样的话, 会调用onMeasure(int, int),开始测量.</p>
</li>
<li><p>对于<code>onMeasure(int, int)</code>而言, View和ViewGroup的测量职责是不一样的. <code>对于View, 它只需测量自身的大小, 而对于ViewGroup, 它需要测量自己和测量自己的孩子, 一般都是先测量孩子,然后根据孩子的大小来设置自己的大小.</code></p>
</li>
<li><p>由于<code>measure()</code>方法是被final修饰的, 所以<code>measure(int, int)</code>是不允许被重写的, 需要我们重写的是onMeasure(int, int). 这样做的优点是:开发者无需关心View测量的其他细节, 只需关心测量View的大小就行, 减轻了开发者的开发难度.</p>
</li>
<li><p>既然View和ViewGroup的测量职责不一样, 那么View和ViewGroup中的onMeasure(int, int)的实现肯定不一样, 所以我们开始分情况来讨论</p>
</li>
</ul>
<blockquote>
<h5 id="View-onMeasure-int-int"><a href="#View-onMeasure-int-int" class="headerlink" title="View#onMeasure(int, int)"></a>View#onMeasure(int, int)</h5></blockquote>
<p>我们先从简单的View入手, 进入View的onMeasure(int, int):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>View的onMeasure(int, int)只是简单调用了setMeasureDimension(int size, int measureSpec),这个是保存测量得到的宽高.</p>
</li>
<li><p>setMeasureDimension(int, int), 其中的宽高是通过<code>getDefaultSize(int size, int measureSpec)</code>来获取的.我们进入该方法看看:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = size;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先根据传入的measureSpec来获得测量模式和测量大小, 如果测量模式是<code>AT_MOST</code>或者<code>EXACTLY</code>的话, 直接返回测量得到的大小.</p>
</li>
<li><p>从这个方法我们知道, View的onMeasure(int, int)的默认实现是根据传入的MeasureSpec来获取测量结果.那么这个MeasureSpec是怎么产生的? 前面我们说过, ViewGroup的onMeasure(int, int)中, 是需要测量孩子的, 这个MeasureSpec就是ViewGroup在测量子View时传递给子View的, 换句话说, 这个MeasureSpec是从ViewGroup传递下来的, 通过解包操作, 可以得到MeasureSpec中的大小, 这个大小究竟是ViewGroup的总体大小还是剩余大小? 这个得看具体的ViewGroup的具体实现.</p>
</li>
<li><p>上面的分析可能有点难以理解, 不过接下来分析完ViewGroup后, 自然会解开你的迷惑.</p>
</li>
</ul>
<blockquote>
<h5 id="ViewGroup-onMeasure-int-int"><a href="#ViewGroup-onMeasure-int-int" class="headerlink" title="ViewGroup#onMeasure(int, int)"></a>ViewGroup#onMeasure(int, int)</h5></blockquote>
<p>由于ViewGroup的子类对测量都有不同的策略, 因此, ViewGroup并没有重写onMeasure(int, int), 而是让其子类去重写.我们拿比较简单的FrameLayout来分析吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</div><div class="line">                MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</div><div class="line">                MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</div><div class="line">        mMatchParentChildren.clear();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> childState = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">            <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</div><div class="line">                measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">                maxWidth = Math.max(maxWidth,</div><div class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</div><div class="line">                maxHeight = Math.max(maxHeight,</div><div class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</div><div class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class="line">                <span class="keyword">if</span> (measureMatchParentChildren) &#123;</div><div class="line">                    <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</div><div class="line">                            lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                        mMatchParentChildren.add(child);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Account for padding too</span></div><div class="line">        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</div><div class="line">        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</div><div class="line"></div><div class="line">        <span class="comment">// Check against our minimum height and width</span></div><div class="line">        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</div><div class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line"></div><div class="line">        <span class="comment">// Check against our foreground's minimum height and width</span></div><div class="line">        <span class="keyword">final</span> Drawable drawable = getForeground();</div><div class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</div><div class="line">            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</div><div class="line">            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</div><div class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</div></pre></td></tr></table></figure>
<ul>
<li>我抽取了FrameLayout中onMeasure(int, int)的核心代码, 主要思路: 遍历子View,让子View测量自己,也就是触发子View的测量. 接着再根据子View的大小来计算自己的大小.我们先来看看measureChildrenWithMargins(View, int, int).</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该方法是ViewGroup提供的工具类, 关于View和ViewGroup提供的测量工具类, 后面的专门分析.</p>
</li>
<li><p>首先拿到View的LayoutParams, 然后调用getChildMeasureSpec来得到子View的MeasureSpec, 我们看看它是怎么得到的.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">                <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">                <span class="comment">// be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">                <span class="comment">// big it should be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先进行解包操作, 拿到父View传递下来的测量模式和测量大小, 在xml布局中的顶级View的MeasureSpec是由RootViewImpl传递下来的, 而对于顶级View(DecorView)来说, 其MeasureSpec是由窗口大小和自身的LayoutParams决定的.</p>
</li>
<li><p>接着进入switch语句:</p>
<ul>
<li><p>当父View的mode为<code>MeasureSpec.EXACTLY</code>时, 再根据子View的LayoutParams(也就是子View在xml文件中声明的layout_xx属性的容器), 又分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽(用宽来举例子)为确定的值, 那么resultSize为子View在xml文件中声明的宽度(也就是xxdp),resultMode为<code>MeasureSpec.EXACTLY</code>,然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占满父View的宽度, 因此, resultSize设置为父View的大小size, reslutMode为<code>MeasureSpec.EXACTLY</code></li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.WRAP_CONTENT)</code>时, 表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为<code>MeasureSpec.AT_MOST</code></li>
</ol>
</li>
<li><p>当父View的mode为<code>MeasureSpec.AT_MOST</code>时, 根据子View的LayoutParams, 分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽为确定的值时, resultSize为子View在xml文件中声明的宽度(也就是xxdp), resultMode为<code>MeasureSpec.EXACTLY</code>, 然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占有父View的宽度, 但是由于父View的测量模式为<figure class="highlight plain"><figcaption><span>所以resultMode只能为```MeasureSpec.AT_MOST``(因为父View自身也不知道自己多大), resultSize设置为父Viw的大小.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">   3. 当子View在xml文件中声明的宽为``LayoutParams.AT_MOST``时表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为``MeasureSpec.AT_MOST``.</div><div class="line"></div><div class="line">* 分析到这里, 我们可以总结出View的MeasureSpec是由哪些因素决定的</div><div class="line"> * 对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以会看之前分析的代码)</div><div class="line"> * 对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</div><div class="line"></div><div class="line">* 上面我们针对宽度来进行了分析, 对于高度而言, 过程跟宽度一样</div><div class="line"></div><div class="line">* 最后调用子View的``measure(int, int)``, 将在``getChildMeasureSpec``中得到的宽和高对应的MeasureSpec(也就是我们上面以宽度为例子来分析的情况),传递给子View,接下去的过程跟我们前面在分析子View的情况一样.</div><div class="line"></div><div class="line">* 现在我们可以更加确定了这样一个事实: View的onMeasure(int, int)中的widthMeasureSpec和heightMeasureSpec是由父View根据自身的MeasureSpec和子View的LayoutParams产生并传递给子View的.</div><div class="line"></div><div class="line">* 如果你仔细总结的话,会发现:只要子View的的宽或高设置为``LayoutParams``设置为WRAP_CONTENT时, 生成MeasureSpec中的size都是父View的size(一般是父View剩下的size),而mode为AT_MOST.</div><div class="line"></div><div class="line">* 我们现在继续调到子View的measure方法中的onMeasure(), 我们再来看看getDefaultSize()这个方法:</div><div class="line"></div><div class="line">```java</div><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">        int result = size;</div><div class="line">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>首先解包出由父View传递下来的MeasureSpec, 通过上面的分析, 当子View在xml文件中将layout_width设置为WRAP_CONTENT时, 对应的SpecMode为AT_MOST, 此时进入switch语句, 得到的大小其实是父View的大小, 这也解释了,在自定义View(继承View)时,如果没有重写onMeasure(int, int)时,当这个自定义View的宽度或者高度设置为<code>WRAP_CONTENT</code>时,会变成占有父View的全部高度和宽度.</p>
</li>
<li><p>分析到这里, 已经基本分析完了测量过程,我们还是总结一下,再进入下一个流程.</p>
</li>
</ul>
<blockquote>
<h4 id="测量过程总结"><a href="#测量过程总结" class="headerlink" title="测量过程总结"></a>测量过程总结</h4></blockquote>
<ul>
<li><p>onMeasure(int widthSpec, int heightSpec)中的这两个MeasureSpec是由父View传递下来的.MeasureSpec一旦确定了, 在这个方法中就可以确定View的测量宽高了.</p>
</li>
<li><p>如何确定MeasureSpec?</p>
<ul>
<li>对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以回看之前分析的代码)</li>
<li>对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</li>
</ul>
</li>
<li><p>父View的MeasureSpec和子View的LayoutParams如何确定MeasureSpec?</p>
<ul>
<li>在View测量的时候, 系统会将View的LayoutParams在父View的SpecMode的约束下再次打包为一个传递给子View的MeasureSpec.</li>
</ul>
</li>
<li><p>EXACTLY,AT_MOST和LayoutParams的关系</p>
<ul>
<li>EXACTLY: 父View已经检测出子View所需要的大小(通常是子View在xml文件中声明为精确的值,比如20dp),它对应于LayoutParams中的match_parent和具体的数值</li>
<li>AT_MOST: 子View不能超过父View给定的大小, 它对应与LayoutParams中的wrap_content.</li>
</ul>
</li>
<li><p>最后来看看流程图加深印象:</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8aodsxyj30nq0i2ta8.jpg" alt=""></p>
<blockquote>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3></blockquote>
<p>经过测量阶段后, View已经知道自己的宽和高, 接着就需要在布局阶段确定应该显示在哪个区域,也就是屏幕上的四个点.那我们回到VewiRootImpl中的performLayout()方法, 该方法是触发布局的起点, 在里面调用了View的layout方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</div></pre></td></tr></table></figure>
<ul>
<li><p>layout方法中的四个参数分别为屏幕上的四个点, 也就是整个屏幕的区域</p>
</li>
<li><p>我们进入View的layout方法:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们主要分析上面的两个核心操作:<ul>
<li>setFrame(left, top, right, bottom)这个方法主要是保存四个点的位置, 并且判断传入的位置跟之前的是不是一样, 不一样的话,会回调onSizeChange接口</li>
<li>调用onLayout(left, top, right, bottom), 但是这个方法View是一个空方法, 对于ViewGroup来说,具体的子类有其具体的实现方法.因此, <code>layout方法主要是view用于确定自己的位置的, 而onLayout是用于ViewGroup循环调用子类的layout方法来对子类进行布局的.</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>理解了上面的这两点, 其实布局过程就基本没什么了.</p>
</li>
<li><p>最后还是看看流程图, 加深理解.</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8dhsrxmj30kh0flwfa.jpg" alt=""></p>
<ul>
<li>分析到这里, 测量,布局都分析完了, 绘制流程就不讲了,</li>
</ul>
<h1 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h1><blockquote>
<h2 id="继承View重写onDraw方法和onMeasure方法"><a href="#继承View重写onDraw方法和onMeasure方法" class="headerlink" title="继承View重写onDraw方法和onMeasure方法"></a>继承View重写onDraw方法和onMeasure方法</h2></blockquote>
<p>这种方法一般用于实现基础控件和组合控件难以达到的效果. 所以需要重写onDraw方法来画出自己的图形, 重写onMeasure方法来支持wrap_content属性,和padding属性.</p>
<blockquote>
<h2 id="继承ViewGrroup派生特殊的Layout"><a href="#继承ViewGrroup派生特殊的Layout" class="headerlink" title="继承ViewGrroup派生特殊的Layout"></a>继承ViewGrroup派生特殊的Layout</h2></blockquote>
<p>当系统的基础布局容器不能满足我们的需求时, 我们可以继承ViewGroup来自定义一个布局容器. 这种方法需要合适处理ViewGroup的<code>测量(测量孩子和测量自己)</code>,布局这两个过程.</p>
<blockquote>
<h2 id="继承基础控件-如TextView"><a href="#继承基础控件-如TextView" class="headerlink" title="继承基础控件(如TextView)"></a>继承基础控件(如TextView)</h2></blockquote>
<p>这种方法一般用于扩展基础控件的功能,相对比较简单. 这种方法不需要自己处理wrap_content和padding.</p>
<blockquote>
<h2 id="继承基础容器-如LinearLayout"><a href="#继承基础容器-如LinearLayout" class="headerlink" title="继承基础容器(如LinearLayout)"></a>继承基础容器(如LinearLayout)</h2></blockquote>
<p>这种方法一般用于组合一些基础控件或者自定义View.</p>
<h1 id="自定义View的方法论"><a href="#自定义View的方法论" class="headerlink" title="自定义View的方法论"></a>自定义View的方法论</h1><blockquote>
<h2 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h2></blockquote>
<p>这种自定义方法,我们处理的主要有两个方法:</p>
<ul>
<li><p>在onMeasure(int, int)中处理wrap_content和padding</p>
</li>
<li><p>在onDraw(Canvas)中绘制你想要的UI和处理padding</p>
</li>
</ul>
<blockquote>
<h3 id="onMeasure-int-int-处理"><a href="#onMeasure-int-int-处理" class="headerlink" title="onMeasure(int, int)处理"></a>onMeasure(int, int)处理</h3></blockquote>
<p>在onMeasure(int, int)中需要处理的有两个: wrap_content和padding这两个属性.</p>
<blockquote>
<h4 id="支持wrap-content"><a href="#支持wrap-content" class="headerlink" title="支持wrap_content"></a>支持wrap_content</h4></blockquote>
<p>经过前面的分析, 我们知道对于一个继承View的控件, 如果没有重写onMeasure(int, int), 在xml布局中设置layout_width=”wrap_content”的时候, 会占满父View的宽度, 其中的原因前面已经分析了, 这里主要将如何支持wrap_content. 接下来我会讲解决这个问题的基本方法和另外一种快捷方法</p>
<ul>
<li>基本方法:</li>
</ul>
<p>当layout_width或者layout_height为wrap_content, 我们不用默认的高宽, 而是自己根据自己View的内容来决定View的高宽</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"><span class="comment">//1.首先拿到宽高的大小和测量模式</span></div><div class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">//2.接着判断宽高和mode是否为wrap_content, 如果是的话, 我们不用widthSize或者heightSize, 我们自己指定View的大小</span></div><div class="line">        <span class="comment">//wrap_content对应MeasureSpec.AT_MOST属性</span></div><div class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">  setMeasuredDimension(<span class="number">300</span>, <span class="number">300</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(<span class="number">300</span>, heightSize); <span class="comment">//只有width为wrap_content, 所以高直接用heightSize就行</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(widthSize, <span class="number">300</span>); <span class="comment">//只有height为wrap_content, 所以宽直接用widthSize就行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提供了解决wrap_content的基本思路.下面我们介绍另外一种快捷而且屏幕适配更好的方法.在介绍之前,我们先来看看View中的几个有用的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法返回一个建议的最小高度.如果View没有设置背景,那么返回值为mMinHeight(也就是在xml布局中声明的属性), 如果有的话, 会返回背景的Drawable对象的高度和mMinHeight中的最大值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法和前面的一样,这里不多说.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">                <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">                    result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    result = size;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">                result = specSize;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                result = size;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code>这个方法是View本身提供的一个支持wrap_content的一个方法(getDefaultSize()方法不支持wrap_content),这个方法除了支持wrap_content外, 还通过掩码操作添加了一些信息, 如果当size的大小大于父View的高度时, 会通过掩码操作将 MEASURED_STATE_TOO_SMALL和size打包成一个int值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resolveSizeAndState(size, measureSpec, <span class="number">0</span>) &amp; MEASURED_SIZE_MASK;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个是上个方法的重载版本, childMeasuredState属性传入0,表示不对标志做处理, 最后用MEASURED_SIZE_MASK这个掩码提取出想要是size值.</p>
<p>介绍完了上面的几个方法, 我们开始介绍另外一种快捷的适配wrap_content的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumWidth(), mTextSize); <span class="comment">//将默认的最小宽度和自己定义的字体大小比较, 取最大值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumHeight(), mTextSize); <span class="comment">//将默认的高度和自己定义的字体大小比较, 取最大值.</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们知道,支持wrap_content的实质就是根据内容来决定View的大小.那么我们可以利用<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>这个两个方法来获取最小的高度和宽度.当mode为wrap_content时, 怎么计算出最小的高度和宽度, 这个看你的自定View情况, 自己灵活选择.</p>
<blockquote>
<h4 id="支持padding"><a href="#支持padding" class="headerlink" title="支持padding"></a>支持padding</h4></blockquote>
<p>支持padding是需要在onDraw和onMeasure中实现, 思路都很简单, 在onMeasure中的宽高将padding考虑进去, 在onDraw中绘制图形时,除去padding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        maxWidth = maxWidth + getPaddingLeft() + getPaddingRight(); <span class="comment">//加上paddingLeft和paddingRight得到宽度</span></div><div class="line">        maxHeight = maxHeight + getPaddingBottom() + getPaddingTop(); <span class="comment">//加上paddingBottom和paddingTop得到高度</span></div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是onMeasure中支持padding, 下面看看onDraw中支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> wdith = getWidth() - getPaddingLeft() - getPaddingRight();</div><div class="line">        <span class="keyword">int</span> height = getHeight() - getPaddingTop() - getPaddingBottom();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在onDraw中, 用到宽高时, 先减去对应的padding就能支持padding了.</p>
<blockquote>
<h2 id="继承ViewGroup"><a href="#继承ViewGroup" class="headerlink" title="继承ViewGroup"></a>继承ViewGroup</h2></blockquote>
<p>继承ViewGroup的View, 相当于自定义一个布局容器, 需要我们处理的有两个:</p>
<ul>
<li><p>onMeaure(int, int)</p>
</li>
<li><p>onLayout(int, int, int, int)</p>
</li>
</ul>
<blockquote>
<h3 id="处理onMeasure-int-int"><a href="#处理onMeasure-int-int" class="headerlink" title="处理onMeasure(int, int)"></a>处理onMeasure(int, int)</h3></blockquote>
<p>自定义ViewGroup不同于自定义View, 自定义ViewGroup在onMeasure(int, int)中, 除了测量自己,还需要测量孩子, 通常是遍历孩子并触发孩子的测量方法, 然后根据孩子的宽高来决定自己的宽高. 我们下面来看看ViewGroup给我们提供的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过传入子View,父View的宽高测量规格, 该方法内部会帮我们调用view的measure方法去测量View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法内部遍历所有子View, 然后调用上一个方法测量View, 也就是帮我们测量了所有子View, 不用我们手动for循环去测量View. 你们可以根据自己的需要去调用其中的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法也是测量子View的方法, 不过这个方法把子View的margin考虑进去了.</p>
<p>下面说说ViewGroup测量的套路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxHeight = getPaddingTop() + getPaddingBottom(); <span class="comment">//支持padding</span></div><div class="line">    <span class="keyword">int</span> maxWidth = getPaddingLeft() + getPaddingRight(); <span class="comment">//支持padding</span></div><div class="line">    <span class="comment">//循环测量孩子</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>); <span class="comment">//考虑margin测量孩子</span></div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        maxHeight = maxHeight + child.getMeasuredHeight() + params.topMargin + params.bottomMargin; <span class="comment">//将支持margin</span></div><div class="line">        maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + params.leftMargin + params.rightMargin); <span class="comment">//将支持margin</span></div><div class="line">    &#125;</div><div class="line">    setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), resolveSize(maxHeight, heightMeasureSpec)); <span class="comment">//测量自己</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我模拟了LinearLayout中的vertical布局属性.注意记得考虑padding和margin.</p>
<p>首先考虑padding, 然后循环遍历子View并测量, 最后根据孩子测量得到的宽高和孩子的margin属性和自己的布局属性来进行测量自己的大小.</p>
<blockquote>
<h3 id="onLayout-int-int-int-int"><a href="#onLayout-int-int-int-int" class="headerlink" title="onLayout(int, int, int, int)"></a>onLayout(int, int, int, int)</h3></blockquote>
<p>onLayout的职责就是将根据子View测量得到的宽高将其摆放在合适的位置. 注意: 在onLayout阶段, 没有特殊情况的话, 子View的布局要根据其测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> i, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = getPaddingLeft(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> top = getPaddingTop(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> bottom;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; getChildCount(); j++) &#123;</div><div class="line">        View child = getChildAt(j);</div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        left = left + params.leftMargin;</div><div class="line">        top = top + params.topMargin;</div><div class="line">        bottom = params.bottomMargin;</div><div class="line">        <span class="keyword">int</span> width = child.getMeasuredWidth();</div><div class="line">        <span class="keyword">int</span> height = child.getMeasuredHeight();</div><div class="line">        child.layout(left, top, left + width, top + height + bottom);</div><div class="line">        top = top + height + bottom;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是简单的模仿LinearLayout的vertical布局属性, 思路: 遍历所有的子View, 然后确定四个点的位置, 一般都是确定left, top这两个点, 然后对应加上View的宽高再得到另外的right, bottom.注意:这里right和bottom这两个点的确定,如果没有特殊情况, 应该根据view的测量得到的宽高来确定, 不能随便指定特定的值, 这样会导致getMeasureXX和getXX不相等, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child.layout(left, top, left + width + <span class="number">100</span>, top + height + bottom + <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>如果你按照上面的操作, getWidth会比getMeasureWidth大100, getHeight会比getMeasureHeight大100. 原因就是你布局的时候没有根据测量阶段View的宽高来布局(也就是私自加多了100, 导致两个点相减时会多出100). 因此,如果没有特殊情况, 布局阶段请按照子View测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<blockquote>
<h3 id="定义你自己的LayoutParams"><a href="#定义你自己的LayoutParams" class="headerlink" title="定义你自己的LayoutParams"></a>定义你自己的LayoutParams</h3></blockquote>
<p>最后补充一个. 如果你的自定义ViewGroup需要自定义LayoutParams的话, 需要进行下面两个步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayoutParams</span> <span class="keyword">extends</span> <span class="title">MarginLayoutParams</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> attr;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(c, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(width, height);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(LayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在你的类中定义上面的内部类, 属性自己定义.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(LayoutParams p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(p);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后重载上面的方法.</p>
<p>如果理解了上面的方法轮, 那么自定义View也就没多大问题了, 最后剩下的就是绘制了.</p>
<p>剩下的两种情况都不怎么难, 这里多说了.</p>
<blockquote>
<h2 id="自定义View的步骤"><a href="#自定义View的步骤" class="headerlink" title="自定义View的步骤"></a>自定义View的步骤</h2></blockquote>
<p>1: 首先分析这个View是怎么绘制的? 哪些是需要抽象成参数</p>
<p>2: 将抽象出来的参数定义在attr资源文件</p>
<p>3: 重写onMeasure方法,并让你的View支持wrap_content,或者padding(如果有必要的话)</p>
<p>4: 重写onDraw方法, 主要在onDraw也是要处理padding(如果有必要的话)</p>
<p>5: 暴露接口给外部(例如监听接口, 动态改变属性的接口)</p>
<p>6: 如果存在滑动冲突的话, 需要解决滑动冲突</p>
<p>7: 根据实际情况优化你的View</p>
<blockquote>
<h2 id="自己的自定义View的习惯"><a href="#自己的自定义View的习惯" class="headerlink" title="自己的自定义View的习惯:"></a>自己的自定义View的习惯:</h2></blockquote>
<p>上面是标准的自定义View的步骤, 实际情况中, 不需要按照严格的顺序进行.下面说说我写的时候的套路:</p>
<p>1: 先分析这个自定义View是怎么话的?</p>
<p>2: 抽象出一些参数,定义在View中</p>
<p>3: 先在onDraw中把图形先画出来,</p>
<p>4: 图形出来后, 再重写onMeasure来支持wrap_content.padding等属性</p>
<p>5: 将抽象出来的参数定义在attr资源文件</p>
<p>6: 暴露接口给外部</p>
<p>7: 优化View</p>
<h2 id="自定义View的使用场景"><a href="#自定义View的使用场景" class="headerlink" title="自定义View的使用场景"></a>自定义View的使用场景</h2><blockquote>
<h3 id="优先考虑继承现有的空间来实现额外的功能"><a href="#优先考虑继承现有的空间来实现额外的功能" class="headerlink" title="优先考虑继承现有的空间来实现额外的功能"></a>优先考虑继承现有的空间来实现额外的功能</h3></blockquote>
<p>如果一些效果是继承现有控件能够实现的话, 那么优先继承现有的控件, 因为现有的控件都是经过官方多次的优化,性能肯定比我们自己写出来的好.</p>
<blockquote>
<h3 id="当一个View嵌套很多布局时-考虑自定义View的实现"><a href="#当一个View嵌套很多布局时-考虑自定义View的实现" class="headerlink" title="当一个View嵌套很多布局时, 考虑自定义View的实现."></a>当一个View嵌套很多布局时, 考虑自定义View的实现.</h3></blockquote>
<p>如果View嵌套太深, requesLayout触发时, 会导致整个布局都被测量和布局, 这样的消耗太大了, 更好的做法是,自定义一个View, 减少测量和布局阶段的消耗.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;﻿# CustomView总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;LayoutParams认知&quot;&gt;&lt;a href=&quot;#LayoutParams认知&quot; class=&quot;headerlink&quot; title=&quot;LayoutParams认知&quot;&gt;&lt;/a&gt;LayoutPa
    
    </summary>
    
      <category term="自定义View" scheme="http://cristianoro7.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="自定义View" scheme="http://cristianoro7.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构-栈</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://cristianoro7.github.io/2017/06/29/大话数据结构-栈/</id>
    <published>2017-06-29T14:40:50.497Z</published>
    <updated>2017-06-29T14:40:50.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*顺序储存结构*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> top;</div><div class="line">&#125;SqStack;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>入栈操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">push</span><span class="params">(SqStack &amp;S, ElemType elemType)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top == MAXSIZE - <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    S.data[++S.top] = elemType;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">pop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = S.data[S.top - <span class="number">1</span>];</div><div class="line">    S.top--;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈和入栈都没有涉及到循环语句,因此时间复杂度为0(1)</li>
</ul>
<h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><ul>
<li>适合一个栈同增加的同时另一个栈在减少</li>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 共享栈结构体</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> top1;</div><div class="line">    <span class="keyword">int</span> top2;</div><div class="line">&#125;SqShareStack;</div></pre></td></tr></table></figure>
<ul>
<li><p>当top1 + 1 == top2时视为栈满</p>
</li>
<li><p>入栈</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sharePush</span><span class="params">(SqShareStack &amp;S, ElemType e, <span class="keyword">int</span> stackNumber)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top1 + <span class="number">1</span> == S.top2) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (stackNumber == <span class="number">1</span>) &#123;</div><div class="line">        S.data[++S.top1] = e;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">2</span>) &#123;</div><div class="line">        S.data[--S.top2] = e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sharePop</span><span class="params">(SqShareStack &amp;S, ElemType &amp;e, <span class="keyword">int</span> stackNumber)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(S.top1 == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        e = S.data[S.top1--];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(S.top2 == MAXSIZE) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        e = S.data[S.top2++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链式储存结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> StackNode &#123;</div><div class="line">    ElemType data;</div><div class="line">    <span class="keyword">struct</span> StackNode *next;</div><div class="line">&#125;StackNode, *LinkStackPtr;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> LinkStack &#123;</div><div class="line">    LinkStackPtr top;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">&#125;LinkStack;</div></pre></td></tr></table></figure>
<ul>
<li>入栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sPush</span><span class="params">(LinkStack &amp;S, ElemType e)</span> </span>&#123;</div><div class="line">    LinkStackPtr ptr = (LinkStackPtr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</div><div class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    ptr-&gt;data = e;</div><div class="line">    ptr-&gt;next = S.top;</div><div class="line">    S.top = ptr;</div><div class="line">    S.count++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sPop</span><span class="params">(LinkStack &amp;S, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(S.top != <span class="literal">NULL</span>) &#123;</div><div class="line">        LinkStackPtr ptr;</div><div class="line">        ptr = S.top;</div><div class="line">        S.top = ptr-&gt;next;</div><div class="line">        e = ptr-&gt;data;</div><div class="line">        <span class="built_in">free</span>(ptr);</div><div class="line">        S.count--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>顺序栈与链栈的时间复杂度都是O(1)</li>
<li>空间上链栈没有空间限制,但是链栈要求每个元素都要有指针域,者也一定程度上增加了内存的开销.顺序栈需要事先规定一个固定长度，可能会造成内存浪费,但是它对于存取时定位很方便</li>
</ul>
<blockquote>
<p>参考资料:《大话数据结构》<br><a href="https://github.com/cristianoro7/data-structure-practice" target="_blank" rel="external">源码</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;h4 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*顺序储存结构*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ElemType data[MAXSIZE];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; top;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;SqStack;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://cristianoro7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://cristianoro7.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>可靠传输的工作原理</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/06/29/可靠传输的工作原理/</id>
    <published>2017-06-29T14:39:49.337Z</published>
    <updated>2017-06-29T14:39:49.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>可靠运输的实现</li>
<li>停止等待协议</li>
<li>连续ARQ协议</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>TCP发送的报文段是交给IP层传送的, 但是IP层只能提供尽最大努力交付的服务,也就是说网络层提供的是不可靠的传输.因此,TCP必须采用适当的措施才能使得两个运输层之间的传输信道变得可靠.</p>
<blockquote>
<h3 id="可靠运输的实现"><a href="#可靠运输的实现" class="headerlink" title="可靠运输的实现"></a>可靠运输的实现</h3></blockquote>
<p>怎么样的运输才算是可靠运输? 要回答这个问题,可以从三方面入手:</p>
<ol>
<li>保证传输的分组无出错,也就是二进制比特流没有出现差错.</li>
<li>保证分组在传输的过程中没有丢失.</li>
<li>分组能够按序达到.</li>
</ol>
<p>既然知道了怎么样才能实现可靠运输,那么下面,我们来一步一步实现可靠运输原理.</p>
<h4 id="可靠运输1-0"><a href="#可靠运输1-0" class="headerlink" title="可靠运输1.0"></a>可靠运输1.0</h4><p>现在我们假设分组的传输是在一个可靠的信道上面传输的,也就是二进制比特流在这条通道上传输是不会出现比特流差错的.如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>但是,实际环境中,由于信道会受到声噪等因素影响,会使得传输的信道变得不可靠, 那么这时也就不能保证比特流的无差错.有没有什么办法能够解决这个问题?</p>
<h4 id="可靠运输2-0"><a href="#可靠运输2-0" class="headerlink" title="可靠运输2.0"></a>可靠运输2.0</h4><p>如何保证接收方接收到的比特流的无出错的? 关于这个问题,我们在可靠运输2.0版本中,通过使用一个比特流的检验和方法来检验接收方接收到的比特是否产生了差错.</p>
<p>我们引入了比特的差错检验来查看接收方收到的比特流的情况. 如果检验得比特流无差错,那么接收方可以直接接收.但是检验的结果是出现错误的话,那么这时接收方应该怎么做?</p>
<p>分析到这里, 我们需要引入另外的一种机制来解决这个问题. 这里我们引入确认机制,即接收方应该在接收到比特流后,应该向发送方确认,确认收到的比特流是否出现错误,可以使用ACK代表无差错,NACK代表有差错.</p>
<p>如果发送方接收到接收方发送的NACK,代表比特流出现了错误,那么发送方该怎么做?</p>
<p>这个时候,我们得引入重传机制, 也就是当发送方接收到NACK时,发送方应该重传分组.</p>
<p>整个过程如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/可靠运输2.0.png" alt=""></p>
<p>为了在不可靠的信道上实现比特无差错,我们引入了检验和,确认(ACK/NACK)和重传机制来保证.但是我们如何解决ACK或NACK出现错误?</p>
<h4 id="可靠运输2-1"><a href="#可靠运输2-1" class="headerlink" title="可靠运输2.1"></a>可靠运输2.1</h4><p>为了应对ACK/NACK被破坏的情况,我们可以在ACK/NACK增加检验和机制来保证ACK/NACK不出现差错.</p>
<p>我们在2.0中引入了重传机制.因此,有可能出现分组的重复.在2.1中,我们将每个分组进行编号,保证分组不会因为重传而出现重复.</p>
<h4 id="可靠运输2-2"><a href="#可靠运输2-2" class="headerlink" title="可靠运输2.2"></a>可靠运输2.2</h4><p>为了提高确认机制的效率,我们采用累计确认机制.</p>
<p>所谓的累计确认是这样的: 收到分组后,需要给发送方发送一个ACK来表示已经收到分组.在发送分组的同时,附加上该分组的编号,来表示小于该编号之前的分组都已经被成功接收了.</p>
<p>既然引入了累计确认机制,NACK也就显得有点多余,在2.2中,我们把NACK去掉.</p>
<h4 id="可靠传输3-0"><a href="#可靠传输3-0" class="headerlink" title="可靠传输3.0"></a>可靠传输3.0</h4><p>前面的2.0~2.2版本都是针对如何解决保证分组在传输的过程中不出错,在3.0中,我们来考虑如何保证传输的分组不丢失?</p>
<p>为了保证分组在传输的时候不丢失,我们可以为每个传输的分组设置一个定时器,如果在定时器期限到达之前,没有收到ACK的话,就认为分组在传输的过程中丢失了,于是我们就重传该分组.</p>
<p>现在,我们基本可以保证分组不丢失了.但是,我们仔细想一下,会发现传输的信道利用率很低,因为,每次发送完一个分组,都得等待收到接收方的ACK后才能发送另外一个分组.由此看来,信道大部分时间都是处于等待状态的.</p>
<h4 id="可靠运输3-1"><a href="#可靠运输3-1" class="headerlink" title="可靠运输3.1"></a>可靠运输3.1</h4><p>为了解决3.0中信道利用率低的问题.我们可以采用流水线机制.即:每次发送完一个分组不必等待接收方的ACK才发送下一个分组.也就是可以连续发送多个分组.</p>
<p>由于我们引入了连续发送分组的这种协议,我们不得不面临多一个问题:如何解决分组乱序到达的情况?</p>
<h4 id="可靠运输3-2"><a href="#可靠运输3-2" class="headerlink" title="可靠运输3.2"></a>可靠运输3.2</h4><p>我们可以使用回退N步或者选择重传这两种机制来解决分组乱序的问题.</p>
<p>回退N步,本文下面会讲到,这里不多说.<br>选择重传: 对于乱序到达的分组,选择重传机制会将它们缓存起来,等待失序的分组到达后再发送ACK.</p>
<blockquote>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3></blockquote>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>上图为最简单的无差错情况. A发送分组M1,发完就暂停发送,等待B确认.当B收到了M1就向A发送确认.A收到了M1的确认后,就再次发送M2分组.同样, 在收到B对M2的确认后, A再发送M3.</p>
<h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p><img src="/uploads/计网/运输层/TCP/出现差错.png" alt=""></p>
<p>上图为分组在传输的过程中出现差错的情况. B接收M1时检测出了差错, 就丢弃M1,其他什么都不做.也可能是M1在传输的过程中丢失了. 这两种情况下, B都不会发送任何信息. 可靠传输协议是这样设计: A只要超过一段时间仍然没有接收到确认, 就认为刚才发送的分组丢失了, 因此重传前面发送过的分组,这叫做超时重传.为了实现超时重传, 要在每发送完一个分组设置一个超时计时器. 如果在超时计时器到期之前收到了对方的确认, 就撤销计时器.</p>
<p>注意:</p>
<ol>
<li>A发送完一个分组后, 必须暂时保存已发送的分组的副本.只有在收到相应的确认后才能清除暂时保留的分组副本.</li>
<li>分组和确认分组都必须进行编号. 这样才能明确是哪一个发送出去的分组收到了确认, 而哪一个分组没收到确认.</li>
<li>超时计时器设置的重传时间应当比数据在分组传送的平均往返时间更长一些.</li>
</ol>
<h4 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h4><p><img src="/uploads/计网/运输层/TCP/确认丢失.png" alt=""></p>
<p>上图为B发送的确认分组丢失的情况. A在设定的超时重传时间内没有收到确认, 但无法知道是自己发送的分组出错,丢失,或者是B发送的确认丢失了. 此时A必须重传M1分组. 假定B收到了重传M1,此时应采取两个行动.</p>
<ol>
<li>丢弃这个重复的分组M1,不向上层交付.</li>
<li>向A发送确认.</li>
</ol>
<p><img src="/uploads/计网/运输层/TCP/确认迟到.png" alt=""></p>
<p>上图为确认迟到的情况. 传输过程没有出错, 但B对M1的确认迟到了. A会收到重复的确认. 这时, A只要收下后丢弃.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述的确认和重传机制, 可以在不可靠的传输网路上实现可靠的通信. 这种可靠传输协议称为自动重传请求ARQ(Automatic Repeat Request).ARQ协议的优点是简单, 但是缺点是信道利用率太低了.</p>
<blockquote>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3></blockquote>
<p>为了提高信道的利用率, 发送方可以采用流水线传输.流水线传输就是发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认.</p>
<p><img src="/uploads/计网/运输层/TCP/发送窗口.png" alt=""></p>
<p>上图为发送方维护的发送窗口, 它表示位于发送窗口内的3个分组都可以连续发送出去,而不需要对方等待. 这样信道利用率就提高了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口.png" alt=""></p>
<p>发送方每接收到一个确认,就把滑动窗口向前滑动一个分组的位置.接收方一般都是采取累计确认的方式.也就是说, 接收方不必对收到的分组逐个发送确认,而是在收到几个分组后,对按序到达的最后一个分组发送确认, 这就表示: 到这个分组为止的所有分组都已经正确收到.</p>
<p>累计确认的缺点是不能向发送方反映接收方已经正确接收的所有分组信息.例如,如果发送了5个分组,而中间的3个分组丢失了. 这时接收方只能前两个分组发出确认.发送方无法知道后面三个分组的下落, 只好把后面三个分组都再传一次, 这叫做回退N步(Go Back N).</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br>计算机网络-自顶向下</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;可靠传输的工作原理&quot;&gt;&lt;a href=&quot;#可靠传输的工作原理&quot; class=&quot;headerlink&quot; title=&quot;可靠传输的工作原理&quot;&gt;&lt;/a&gt;可靠传输的工作原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>路由器工作原理</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/06/29/路由器工作原理/</id>
    <published>2017-06-29T14:39:37.889Z</published>
    <updated>2017-06-29T14:39:37.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>输入端口</li>
<li>交换结构</li>
<li>输出端口</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>路由器是一种具有多个输入和输出端口的专用计算机,其任务是转发分组.路由器的转发分组是网络层的主要工作之一. 下面给出典型的路由器构成图:</p>
<p><img src="/uploads/计网/路由选择协议/路由器工作原理.png" alt=""></p>
<blockquote>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3></blockquote>
<p><img src="/uploads/计网/路由选择协议/输入端口.png" alt=""></p>
<ul>
<li>输入端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层.</li>
<li>路由器使用转发表来查找输出端口,使得到达的分组将能经过交换结构转发到输出端口.</li>
<li>转发表是由路由器处理和更新的,但转发表的一份影子副本通常会被存放在每个输入端口, 有了影子副本,转发决策能在每个输入端口本地做出,无须调用中央路由选择处理器, 因此也避免了集中式处理的瓶颈.</li>
</ul>
<blockquote>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3></blockquote>
<p>交换结构位于一台路由器的核心部位.正是通过这种交换结构,分组才能实际从一个输入端口交换到一个输出端口.交换可以由下面的三种交换技术完成.</p>
<p><img src="/uploads/计网/路由选择协议/内存交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/纵横式交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/总线交换结构.png" alt=""></p>
<h4 id="内存交换结构"><a href="#内存交换结构" class="headerlink" title="内存交换结构"></a>内存交换结构</h4><ul>
<li>在输入端口和输出之间交换是在CPU的直接控制下完成的.</li>
<li>一个分组到达一个输入端口时, 该端口会先通过中断方式向路由选择处理器发送信号.于是,该分组从输入端口处被复制到处理器内存中.路由器选择处理器从其首部提取目的地址,在转发表中找出合适的输出端口,并将该分组复制到输出端口的缓存中.需要注意的是:不能同时发送两个分组,即使他们有不同的端口,因为经过共享系统总线一次仅能执行一次内存读/写.</li>
</ul>
<h4 id="总线交换"><a href="#总线交换" class="headerlink" title="总线交换"></a>总线交换</h4><ul>
<li>输入端口经过一根共享总线将分组直接传送到输出端口,不需要路由选择处理器的干预.</li>
<li>当一个分组到达路由器时, 输入端口为分组预先计划一个交换机内部标签, 用于指示本地输出端口,是分组在总线上传送和传输到输出端口.该分组能由所有输出端口收到, 但只有与该标签匹配的端口才能保存该分组.</li>
<li>如果多个分组同时到达路由器,每个位于不同的输出端口,除了正在总线上传输的分组外,其他分组必须等待,因为一次只有一个分组能够跨越总线.</li>
</ul>
<h4 id="纵横式交换结构"><a href="#纵横式交换结构" class="headerlink" title="纵横式交换结构"></a>纵横式交换结构</h4><ul>
<li>纵横式交换机是一种由2N条总线组成的互联网络.网络互联使得它能克服单一,共享式总宽带限制的缺点.</li>
<li>当某个分组到达A端口时, 需要转发到端口Y,交换机控制器闭合总线A和Y交叉部位的叉点,然后端口A在其总线上发送该分组, 该分组仅由总线Y安排接收.注意:来自端口B的一个分组在同一时间能够转发到端口X,因为A到Y和B到X的分组使用不同的输入和输出总线.然而,如果来自不同端口的两个分组其目的地为相同的输出端口,那么其中一个分组必须等待, 因为在某个时刻,总线上仅有一个分组能被传送.</li>
</ul>
<blockquote>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3></blockquote>
<p>输出端口处理取出存放在输出端口内存中的分组并将其发送到输出链路上.这包括选择和取出排队的分组进行传输,执行所需的链路层和物理层传输功能.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络自顶向下<br>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由器工作原理&quot;&gt;&lt;a href=&quot;#路由器工作原理&quot; class=&quot;headerlink&quot; title=&quot;路由器工作原理&quot;&gt;&lt;/a&gt;路由器工作原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>路由选择协议</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
    <id>http://cristianoro7.github.io/2017/06/29/路由选择协议/</id>
    <published>2017-06-29T14:39:27.777Z</published>
    <updated>2017-06-29T14:39:27.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>内部网关协议RIP</li>
<li>内部网关协议OSPF</li>
<li>外部网关协议BGP</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>从路由算法能否随网络的通信或者拓扑自适应地进行调整变化来划分, 可将路由选择分为两大类:静态路由选择策略和动态路由选择策略.<ul>
<li>静态路由选择策略: 也叫做非自适应路由选择, 其特点是简单和开销较小, 但不能及时适应网络状态变化, 适用于小型网络.</li>
<li>动态路由选择协议: 也叫做自适应路由选择, 其特点是能较好地适应网络状态的变化, 但实现起来复杂, 开销也较大. 因此, 动态路由选择适合复杂的大型网络.</li>
</ul>
</li>
<li>因特网采用的路由选择协议主要是自适应的分布式路由选择协议.</li>
<li>因特网采用分层次的路由选择协议的两个原因:<ul>
<li>因特网的规模宏大. 如果让所有的路由器知道所有的网络应怎么样到达,则这种路由表非常大, 处理起来也花费很多时间.</li>
<li>许多单位不愿意让外界了解自己单位网络的布局细节和本部门所采用的路由选择协议,同时还希望能接上因特网.</li>
</ul>
</li>
<li>基于上面的两个原因, 因特网将整个互联网划分为许多较小的自治系统(autonomous system),一般称为AS.</li>
<li>一个AS对外表现出是一个单一的和一致的路由选择策略.</li>
<li>一个大的ISP就是一个自治系统, 因特网把路由选择协议分为两大类:<ul>
<li>内部网关协议IGP: 在一个自治系统内使用的路由选择协议,而这与互联网中的其他自治系统选用什么路由选择协议无关,目前用得最多的内部网关协议有:RIP, OSPF.</li>
<li>外部网关协议EGP: 若元源主机和目的主机处于两个不同的自治系统内, 当数据报传到一个自治系统的边界时, 就需要使用一种协议将路由选择信息传递到另外一个自治系统中. 目前使用得最多的外部网关协议: BGP</li>
</ul>
</li>
<li>自治系统之间的路由选择也叫做域间路由选择, 而在自治系统内的路由选择叫做域间内部选择.</li>
</ul>
<blockquote>
<h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3></blockquote>
<p>RIP是一种分布式,异步,收敛,迭代的基于距离向量的路由选择协议.</p>
<ol>
<li>分布: 每个节点将自己的路由表发给自己直接相邻的节点.</li>
<li>异步: 节点不需要在某个固定的时间同时发送和交换信息.</li>
<li>收敛: 在有限次的信息交换次数内, 不管初始值是多少, 路由表中的每一项一定会收敛成某个固定值, 也就是真正的最短路径.</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>从一个路由器到直接连接的网络距离定义为1.</li>
<li>从路由器到非直接连接的网络距离定义为所经过的路由器数+1,</li>
<li>RIP允许一条路径只能包含15个路由器,因此,当距离等于16时,相当于不可达.</li>
<li>RIP不能在两个网络之间同时使用多条路由, RIP只会选择一条具有最少路由器的路径.</li>
</ul>
<p>RIP协议下的路由器都需要不断和其他的路由器交换路由信息,那么,是和哪些路由器交换信息?交换什么信息?在什么时候交换信息?</p>
<h5 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点:"></a>RIP协议的特点:</h5><ul>
<li>仅和相邻路由器交换信息</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息,即自己的路由表.也就是,交换的信息是: 一个路由器到本自治系统内所有网络的最短距离,以及到每个网络应经过的下一个路由器.</li>
<li>按固定时间交换路由信息.路由表中的最主要信息:到某个网络的距离,以及经过的下一跳地址和下一跳路由的地址.</li>
</ul>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p>对每个相邻路由器发来的RIP报文, 将进行一下步骤:</p>
<ol>
<li>对地址为X的相邻路由器发送过来的RIP报文, 先修改此报文中的所有项目, 把下一跳字段中的地址改为X, 把所有距离都+1.每个项目都有三个关键数据:到目的网络N, 距离d, 下一跳路由器X.</li>
<li>对修改的RIP报文中的每一个项目,进行一下步骤:<br><br>若原来的路由表没有目的网络N, 则把该项目添加到路由表.<br><br>否则,若下一跳路由器地址为X, 则把收到项目替换掉原来路由表中的项目.否则什么也不做</li>
<li>若3分钟还没有收到相邻路由器的更新路由表,则把此相邻路由器记录为不可到达网络,即把距离设置为16.</li>
<li>返回.</li>
</ol>
<h5 id="“坏消息传得慢”"><a href="#“坏消息传得慢”" class="headerlink" title="“坏消息传得慢”"></a>“坏消息传得慢”</h5><p>RIP存在一个缺点是当网络发生故障时, 要经过比较长的时间才能将信息传送到所有的路由器.例如:</p>
<p><img src="/uploads/计网/路由选择协议/RIP缺点.png" alt=""></p>
<p>假定路由器1到网1的链路出了故障, R1无法到达网1. 于是路由器R1把到网1的距离设置为16, 因而在R1的路由表中相应的项目变为”1, 16, 直接”. 但是很可能要经过30秒后才能把更新信息发给R2.然而R2可能已经先把自己的路由信息”1, 2, R1”发给R1, R1收到这个报文后,误认为可以通过R2到达网1, 于是更新”1, 2, R1”修改为”1, 3, R2”,并发给R2.同理,R2接着又更新自己的路由表信息为”1, 4, R1”.这样的更新一直持续到R1,R2到网1的距离都增大到16,R1, R2才知道网1原来不可达.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>RIP最大的优点是实现简单,开销小.</li>
<li>RIP只能使用的最大距离为15, 这样限制了网络的规模.</li>
<li>路由器之间的路由交换信息是路由器中完整的路由表,因而随着网络规模的扩大, 开销也就增加.</li>
<li>坏消息传播得慢,使得更新过程的收敛时间过长.</li>
<li>对于较大规模的网络应该换用OSPF协议.</li>
</ul>
<blockquote>
<h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3></blockquote>
<p>OSPF最主要的特征是使用了分布式的链路状态协议.</p>
<h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><h5 id="向本自治系统中的所有路由器发送信息"><a href="#向本自治系统中的所有路由器发送信息" class="headerlink" title="向本自治系统中的所有路由器发送信息"></a>向本自治系统中的所有路由器发送信息</h5><p>路由器通过所有输出端口向所有相邻路由器发送信息,也就是端口洪泛.而每个相邻路由器又再将此信息发往其所有的相邻路由器.这样整个区域中所有路由器都得到了这个信息的一个副本.</p>
<h5 id="发送的信息"><a href="#发送的信息" class="headerlink" title="发送的信息"></a>发送的信息</h5><p>发送的信息是与本路由器相邻的所有路由器的链路状态.所谓”链路状态”是本路由器都和哪些路由器相邻,以及该链路的度量.</p>
<h5 id="何时发送信息"><a href="#何时发送信息" class="headerlink" title="何时发送信息"></a>何时发送信息</h5><p>只有当链路状态发生改变时,路由器才向所有路由器洪泛此信息.</p>
<h5 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h5><p>由于各个路由器之间频繁进行链路状态交换,因此所有路由器最终都能建立一个链路状态数据库.这个数据库实际上就是全网的拓扑结构.链路状态数据库能较快地进行更新,使各个路由器能及时更新路由表.</p>
<h5 id="链路状态更新"><a href="#链路状态更新" class="headerlink" title="链路状态更新"></a>链路状态更新</h5><p>只有当链路状态发生变化时, 路由器才向所有路由器用洪泛法发送此消息.</p>
<h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><p>OFPS将一个自治系统再划分为几个更小的范围,叫作区域.划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是一个完整的自治系统.</p>
<blockquote>
<h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3></blockquote>
<p>不同自治系统之间的路由选择不使用RIP或者OSPF的原因:</p>
<ol>
<li>因特网的规模太大,使得AS之间的路由变得非常困难.如果使用链路状态协议, 则每个路由器需要维持一个很大的链路状态数据库.另外,不同的自治系统各自运行着自己选定的内部路由选择协议, 并使用本AS指明的路径度量.因此当一条路径通过不同的自治系统时,路径的度量可能会出歧义.例如:对某AS来说, 代价为1000可能表示一条比较长的路由, 但对另外一AS代价为1000, 可能表示不可接受的坏路由.</li>
<li>AS之间的路由选择必须考虑策略. 由于相连的网络性能相差很大, 如果根据最少跳数找出来的路径, 可能并不合适.也有的代价啊很高或不安全.</li>
</ol>
<p>基于上述的情况, 边界网关协议BGP只能力求寻找一条能够到达目的网络比较好的路由,而非寻找一条最佳路由.BGP采用了路径向量路由选择协议.</p>
<h4 id="BGP发言人"><a href="#BGP发言人" class="headerlink" title="BGP发言人"></a>BGP发言人</h4><ul>
<li><p>在配置BGP时, 每个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人.一般来说,这两个BGP发言人都是通过一个网络共享连接在一起的,而BGP发言人往往是边界路由器.</p>
</li>
<li><p>一个BGP发言人与其他AS的BGP发言人要交换路由信息,就要先建立TCP连接,然后在此连接上交换BGP报文以建立BGP会话,利用BGP会话交换路由信息,如增加了新的路由,或者撤销过时的路由,以及报告差错等.使用TCP连接交换路由信息的两个BGP发言人,彼此成为对方的邻站或对等站.</p>
</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由选择协议&quot;&gt;&lt;a href=&quot;#路由选择协议&quot; class=&quot;headerlink&quot; title=&quot;路由选择协议&quot;&gt;&lt;/a&gt;路由选择协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网际控制报文协议ICMP</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP/"/>
    <id>http://cristianoro7.github.io/2017/06/29/网际控制报文协议ICMP/</id>
    <published>2017-06-29T14:39:15.533Z</published>
    <updated>2017-06-29T14:39:15.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>ICMP报文种类</li>
<li>ICMP应用举例</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>为了更有效地转发IP数据报和提高交付成功的机会, 在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol). ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告.ICMP报文作为IP层的数据报的数据.</p>
<blockquote>
<h3 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h3></blockquote>
<ul>
<li>网际报文的种类有两种, 即ICMP差错报告报文和ICMP询问报文.</li>
<li>几种常用的ICMP报文类型</li>
</ul>
<table>
<thead>
<tr>
<th>ICMP报文类型</th>
<th>类型的值</th>
<th>ICMP报文的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>差错报告报文</td>
<td>3</td>
<td>终点不可达</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>4</td>
<td>源点抑制</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>11</td>
<td>时间超过</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>12</td>
<td>参数问题</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>5</td>
<td>改变路由</td>
</tr>
<tr>
<td>询问报文</td>
<td>8或0</td>
<td>回送请求或回答</td>
</tr>
<tr>
<td>询问报文</td>
<td>13或14</td>
<td>时间戳请求或回答</td>
</tr>
</tbody>
</table>
<h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p>当路由器或者主机不能交付数据报时就向源点发送终点不可达报文</p>
<h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p>当路由器或者主机因拥塞而丢弃数据报时, 就向源点发送源点抑制报文, 使源点知道应当把数据报的发送速率放慢.</p>
<h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p>当路由器收到生存时间为0的数据报时, 除了丢弃数据报外, 还要向源点发送时间超过报文.</p>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p>当路由器或者目的主机收到的数据报的首部中有的字段的值不正确时, 就丢弃该数据报,并向源点发送参数问题报文.</p>
<h4 id="改变路由-路由重定向"><a href="#改变路由-路由重定向" class="headerlink" title="改变路由(路由重定向)"></a>改变路由(路由重定向)</h4><p>路由器把改变路由报文发送给主机, 让主机知道下次应该将数据报发送给另外的路由器.</p>
<h4 id="回送请求和回答"><a href="#回送请求和回答" class="headerlink" title="回送请求和回答"></a>回送请求和回答</h4><p>ICMP回送请求报文是由主机或者路由器向一个特定的目的主机发送询问. 收到此报文的主机必须给源主机或者路由发送ICMP回送回答报文.</p>
<h4 id="时间戳请求和回答"><a href="#时间戳请求和回答" class="headerlink" title="时间戳请求和回答"></a>时间戳请求和回答</h4><p>ICMP时间戳请求报文是请某个主机或者路由器回答当前的日期和时间.</p>
<blockquote>
<h3 id="ICMP的应用举例"><a href="#ICMP的应用举例" class="headerlink" title="ICMP的应用举例"></a>ICMP的应用举例</h3></blockquote>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><ul>
<li>ICMP一个重要应用就是分组网间探测PING, 用来测试两个主机之间的连通性.</li>
<li>PING使用了ICMP的回送请求和回送回答报文.</li>
<li>PING是应用层直接使用网络层ICMP的例子, 它没有通过运输层的TCP或UDP.</li>
</ul>
<h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><ul>
<li>traceroute是用来跟踪一个分组从源点到终点的路径.</li>
<li>traceroute从源主机向目的主机发送一连串IP数据报, 数据报中封装的是无法交付的UDP用户数据报.第一个数据报P1的生存时间为TTL设置为1.当P1到达路径上的第一个路由器R1时, 路由器R1先收下它, 接着把TTL的值减1.由于TTL等于0了, R1就把P1丢弃了, 并向源主机发送一个ICMP时间超过的差错报告报文.</li>
<li>如此循环下去, 当最后一个数据报刚刚达到目的主机时, 数据报的TTL是1, 主机不转发数据, 也不把TTL减1.但因IP数据报封装的是无法交付的运输层UDP用户数据报, 因此目的主机要向源主机发送ICMP终点不可达差错报告报文.</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网际控制报文协议ICMP&quot;&gt;&lt;a href=&quot;#网际控制报文协议ICMP&quot; class=&quot;headerlink&quot; title=&quot;网际控制报文协议ICMP&quot;&gt;&lt;/a&gt;网际控制报文协议ICMP&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>子网的划分和构成超网</title>
    <link href="http://cristianoro7.github.io/2017/06/29/%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/"/>
    <id>http://cristianoro7.github.io/2017/06/29/子网的划分和构造超网/</id>
    <published>2017-06-29T14:39:04.513Z</published>
    <updated>2017-06-29T14:39:04.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子网的划分和构成超网"><a href="#子网的划分和构成超网" class="headerlink" title="子网的划分和构成超网"></a>子网的划分和构成超网</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>划分子网</li>
<li>使用子网时的分组转发</li>
<li>无分类编址CIDR</li>
</ul>
<blockquote>
<h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2></blockquote>
<h3 id="两级IP地址的不合理"><a href="#两级IP地址的不合理" class="headerlink" title="两级IP地址的不合理"></a>两级IP地址的不合理</h3><h4 id="IP空间利用率低"><a href="#IP空间利用率低" class="headerlink" title="IP空间利用率低"></a>IP空间利用率低</h4><p>一个A类网路可容纳的主机数超过1000W, 而B类网络可容纳主机超过6W.但是有些网络对连接在网络上的主机数量是有限制的, 这就导致了地址空间的利用率低下.</p>
<h4 id="路由表变大导致网络性能低下"><a href="#路由表变大导致网络性能低下" class="headerlink" title="路由表变大导致网络性能低下"></a>路由表变大导致网络性能低下</h4><p>给每个物理网络分配一个网络号的话, 会导致路由表中的项目大大增大, 同时查找路由的耗时也就变得更长.</p>
<p>为了解决二级IP带来的问题,从1985年起,将IP地址中增加了一个”子网号字段”, 使得二级IP地址变成三级IP地址.这种做法叫做划分子网.</p>
<blockquote>
<h3 id="划分子网的基本思路"><a href="#划分子网的基本思路" class="headerlink" title="划分子网的基本思路"></a>划分子网的基本思路</h3></blockquote>
<ul>
<li>一个拥有许多物理地址的单位, 可将所属的物理网络划分为多个子网.划分子网属于单位内部的事情,对外还是表现为一个网络.</li>
<li>划分子网的方法是从网路的主机号借用若干位作为子网号,于是二级IP地址在单位内部就变成了三级IP地址,即 network-id:subnet-id-host-id</li>
</ul>
<blockquote>
<h3 id="子网划分实例"><a href="#子网划分实例" class="headerlink" title="子网划分实例"></a>子网划分实例</h3></blockquote>
<p><img src="/uploads/计网/划分子网/子网.png" alt=""></p>
<p>上图的网络被划分为三个子网, 整个网络对外表现为一个网络, 其网络地址为145.13.0.0.但是网络145.13.0.0上的路由器R1在收到外来的数据报后, 再根据数据报的目的地址将它转发到对应的子网.</p>
<blockquote>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3></blockquote>
<p>我们知道, 从IP数据报的首部无法看出源主机或目的主机是否进行了子网的划分,路由器是如何将数据报转发到子网?使用子网掩码可以解决这个问题.</p>
<h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><ul>
<li>子网掩码是一个32位2进制数, 对应的网络地址全为1,主机地址全为0.</li>
<li>A类网络的默认子网掩码为:255.0.0.0, B类为255.255.0.0, C类为255.255.255.0</li>
</ul>
<h4 id="通过目的IP地址和子网掩码计算子网的网络地址"><a href="#通过目的IP地址和子网掩码计算子网的网络地址" class="headerlink" title="通过目的IP地址和子网掩码计算子网的网络地址"></a>通过目的IP地址和子网掩码计算子网的网络地址</h4><ul>
<li>将数据报的目的IP地址与子网掩码逐位相”与”.</li>
</ul>
<p>例如: IP地址为141.14.72.24, 子网掩码为255.255.192.0,求网络地址<br>解析: 子网掩码为11111111 11111111 11000000 00000000, 由于子网掩码的前两个字节的位全为1, 最后一个字节的位全为0,因此, 可暂时推断网络地址为: 141.14.X.0. 此时, 只需要将72对应的二进制数与11000000逐位相”与”,就可得出完整的网络地址: 141.14.64.0.</p>
<h4 id="利用子网数来计算子网掩码"><a href="#利用子网数来计算子网掩码" class="headerlink" title="利用子网数来计算子网掩码"></a>利用子网数来计算子网掩码</h4><p>在求子网掩码时, 必须弄清楚划分子网的数目,以及每个子网内所需的主机数目.<br><br><br>1)将子数目转为二进制<br><br>2)取得二进制的位数N<br><br>3)取得该IP地址的类子网掩码, 将其主机号的前N位置1,即可得该IP地址划分子网的子网掩码<br></p>
<p>eg: 将B类IP地址168.192.0.0划分为27个子网.<br><br>1) 27 = 11011<br><br>2) N = 5<br><br>3) B类子网掩码: 255.255.0.0<br><br>4) 该IP地址划分的子网掩码: 255.255.248.0.</p>
<h4 id="子网的划分选择"><a href="#子网的划分选择" class="headerlink" title="子网的划分选择"></a>子网的划分选择</h4><p>下面给出B类子网的划分选择(使用固定的长度子网)</p>
<table>
<thead>
<tr>
<th>子网号位数</th>
<th>子网掩码</th>
<th>子网数</th>
<th>每个子网的主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>255.255.192.0</td>
<td>2^2-2</td>
<td>2^14-2</td>
</tr>
<tr>
<td>3</td>
<td>255.255.224.0</td>
<td>2^3-2</td>
<td>2^13-2</td>
</tr>
<tr>
<td>4</td>
<td>255.255.240.0</td>
<td>2^4-2</td>
<td>2^12 -2</td>
</tr>
<tr>
<td>5</td>
<td>255.255.248.0</td>
<td>2^5-2</td>
<td>2^11-2</td>
</tr>
<tr>
<td>6</td>
<td>255.255.252.0</td>
<td>2^6-2</td>
<td>2^10-2</td>
</tr>
<tr>
<td>7</td>
<td>255.255.254.0</td>
<td>2^7-2</td>
<td>2^9-2</td>
</tr>
<tr>
<td>8</td>
<td>255.255.255.0</td>
<td>2^8-2</td>
<td>2^8-2</td>
</tr>
<tr>
<td>9</td>
<td>255.255.255.128</td>
<td>2^9-2</td>
<td>2^7-2</td>
</tr>
<tr>
<td>10</td>
<td>255.255.248.192</td>
<td>2^10-2</td>
<td>2^6-2</td>
</tr>
<tr>
<td>11</td>
<td>255.255.252.224</td>
<td>2^11-2</td>
<td>2^5-2</td>
</tr>
<tr>
<td>12</td>
<td>255.255.254.240</td>
<td>2^12-2</td>
<td>2^4-2</td>
</tr>
<tr>
<td>13</td>
<td>255.255.255.248</td>
<td>2^13-2</td>
<td>2^3-2</td>
</tr>
<tr>
<td>14</td>
<td>255.255.255.252</td>
<td>2^14-2</td>
<td>2^2-2</td>
</tr>
</tbody>
</table>
<p><br><br>上面-2是因为去掉全0和全1的情况, 子网号位数没有0,1,15,16这四种情况是因为这几种情况没有意义.</p>
<blockquote>
<h3 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h3></blockquote>
<p>使用子网划分后, 路由表必须包含这三项内容:目的网络地址,子网掩码和下一跳地址.</p>
<h4 id="路由转发算法"><a href="#路由转发算法" class="headerlink" title="路由转发算法"></a>路由转发算法</h4><ol>
<li>从收到的数据报的首部提取目的IP地址D.</li>
<li>先判断是否可以直接交付. 对路由器相连的网络逐个检查:用各个网络的子网掩码与D逐位相”与”, 看结果是否和相应的网络地址匹配.若匹配,则把分组直接交付, 否则执行(3).</li>
<li>若路由器表中有目的地址为D的特定主机路由, 则把数据报传送给下一跳的路由器,否则执行(4)</li>
<li>对路由表中的每一行,用其中的子网掩码和D逐位相”与”,若结果与目的网络地址匹配,把数据报传送下一跳的路由器, 否则执行(5).</li>
<li>若路由表中有一个默认的路由, 则把数据报传给默认路由, 否则执行(6)</li>
<li>报告转发分组时出错.</li>
</ol>
<h4 id="转发实例"><a href="#转发实例" class="headerlink" title="转发实例"></a>转发实例</h4><p><img src="/uploads/计网/划分子网/子网转发分组.png" alt=""></p>
<p>讨论R1收到H1向H2发送分组后,查找路由表的过程</p>
<ol>
<li>H1把本子网的子网掩码 255.255.255.128 与目的主机的ip地址逐位相”与”, 得出 128.30.33.128,它不等于H1的网络地址,说明H1与H2不在同一个子网内, 因此H1不能把分组直接交付给H2,必须交给子网上的默认路由器R1,由R1来进行转发</li>
<li>R1收到一个分组后, 就在路由表中寻找有无匹配的网络地址.(1)计算出目的网络地址为128.30.33.128, 与路由表中的第二行的目的网络地址匹配, 说明这个网络就是分组想要寻找的目的网络, 于是R1将分组从接口1,直接交付给主机H2.</li>
</ol>
<blockquote>
<h2 id="无分类编址CIDR-构成超网"><a href="#无分类编址CIDR-构成超网" class="headerlink" title="无分类编址CIDR(构成超网)"></a>无分类编址CIDR(构成超网)</h2></blockquote>
<p>无分类域间路由选择CIDR解决的问题:</p>
<ol>
<li>B类地址眼看就快要分配完了</li>
<li>因特网主干网上的路由表项目数急剧增长.</li>
</ol>
<blockquote>
<h3 id="CIDR的两个主要的特点"><a href="#CIDR的两个主要的特点" class="headerlink" title="CIDR的两个主要的特点"></a>CIDR的两个主要的特点</h3></blockquote>
<ul>
<li>CIDR消除了传统的A类,B类,C类地址以及子网的划分的概念,把32位的IP地址划分了两个部分.前一部分用来表示网络前缀,以表示网络. 后一部分则用来表主机.</li>
<li>CIDR把网络前缀相同的连续IP地址组成一块”CIDR地址块”.</li>
</ul>
<blockquote>
<h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3></blockquote>
<ul>
<li><strong>由于一个CIDR地址块中有很多地址,所以在路由表中就利用CIDR地址块来查找目的网络. 这种地址的聚合称为路由聚合.</strong></li>
<li>它使得一个路由表可以表示更多地址. 路由聚合也称为构成子网.</li>
</ul>
<blockquote>
<h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3></blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在使用CIDR时, 由于采用了网络前缀这种记法, 因此在路由表中的项目也要有相应的改变.在查找路由表时, 可能会得到不止一个匹配结果, 那么我们应该选择哪条结果?</p>
<h4 id="最长匹配"><a href="#最长匹配" class="headerlink" title="最长匹配"></a>最长匹配</h4><p>为了解决上述问题, 应该从匹配结果中选择具有最长网络前缀的路由, 这叫做最长前缀匹配.</p>
<h4 id="使用二叉线索查找路由表"><a href="#使用二叉线索查找路由表" class="headerlink" title="使用二叉线索查找路由表"></a>使用二叉线索查找路由表</h4><p>使用CIDR后, 由于要查找最长前缀匹配, 使路由表的查找过程变得更加复杂.为了更有效的查找, 通常是把无分类编址的路由表存放在一种层次的数据结构中, 然后,自上而下进行查找.这里最常用的是二叉线索.为了提高二叉线索的查找速度,可以使用压缩技术.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.360doc.com/content/10/0205/11/276520_15184122.shtml" target="_blank" rel="external">http://www.360doc.com/content/10/0205/11/276520_15184122.shtml</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;子网的划分和构成超网&quot;&gt;&lt;a href=&quot;#子网的划分和构成超网&quot; class=&quot;headerlink&quot; title=&quot;子网的划分和构成超网&quot;&gt;&lt;/a&gt;子网的划分和构成超网&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; cl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>IP地址分类</title>
    <link href="http://cristianoro7.github.io/2017/06/29/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/"/>
    <id>http://cristianoro7.github.io/2017/06/29/IP地址分类/</id>
    <published>2017-06-29T14:38:02.913Z</published>
    <updated>2017-06-29T14:38:02.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分类</li>
<li>特殊IP地址</li>
<li>共有IP地址</li>
<li>私有IP地址</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>IP地址是连接在因特网上的主机的唯一标识, 通过特定的IP地址能找到被该IP地址标识的主机.例如:我们的家地址可以看作一个IP地址, 通过这个地址,可以找到我们,也就是主机.</li>
<li>在TCP/IP协议中, IP地址是以二进制数字形式出现, 共32Bit, 1Bit就是二进制中的1位, 由于二进制的形式不适合人们阅读.因此换用一种”点分十进制法”表示IP地址.</li>
<li>例如:<br><br>点分十进制: 192.168.1.1<br><br>二进制: 11000000.10101000.00000001.00000001</li>
</ul>
<blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></blockquote>
<table>
<thead>
<tr>
<th></th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class A</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class B</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class C</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
</tr>
<tr>
<td>Class D</td>
<td>多播</td>
</tr>
<tr>
<td>Class E</td>
<td>科研用</td>
</tr>
</tbody>
</table>
<h4 id="Class-A"><a href="#Class-A" class="headerlink" title="Class A"></a>Class A</h4><ul>
<li>A类地址的第一个8 Bit 表示网络位, 且<code>网络位的第一个Bit为0</code>, 1-7Bit表示网络标识,格式为:0XXXXXXXX.</li>
<li>后3个8 Bit 表示主机位.</li>
<li>A类地址的网络范围:00000001~01111111, 用十进制表示: 1.0.0.0到126.0.0.0,一共有126个网络.</li>
<li>主机标识为2的24次幂-2个(去掉全0和全1的地址), 全0的主机号字段表示该IP地址是”本机”连接到的单个网络地址,而1的主机号表示该网络上的所有主机.每个网络可容纳的主机数为16777214个.</li>
<li>A类地址支持巨型网络,一般分给有大量主机的网络使用.</li>
</ul>
<h4 id="Class-B"><a href="#Class-B" class="headerlink" title="Class B"></a>Class B</h4><ul>
<li>B类地址的前两个8 Bit表示网络标位, 且网络位的前两个Bit总是10, 即格式为: 10XXXXXX XXXXXXXX.</li>
<li>B类地址可指派的网络数为: 2的14次幂-1, -1的原因是128.0.0.0是不指派的.</li>
<li>后两个8 Bit表示主机位.</li>
<li>B类的每个网络可容纳的主机数是2的16次幂-2, 即65534.</li>
</ul>
<h4 id="Class-C"><a href="#Class-C" class="headerlink" title="Class C"></a>Class C</h4><ul>
<li>C类地址的前3个字节表示网路号, 且开头必须为<code>110</code>, 可以指派的最小网络地址为:192.0.1.0, 指派的网络范围为2的21次幂-1, -1的原因是192.0.0.0是不指派的.</li>
<li>每个C类地址可容纳的主机数为:2的8次幂-2.</li>
</ul>
<blockquote>
<h3 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h3></blockquote>
<h4 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h4><ul>
<li>它表示所有不清楚的主机和目的网络.</li>
<li>不清楚的是意思是本机路由表中没有指定如何到达.</li>
<li>如果在网络设置中设置了缺省网关, 那么系统会自动生成一个目的地址为0.0.0.0的缺省路由,所有不清楚的目的网络和主机都会被送到这里.</li>
</ul>
<h4 id="255-255-255-255"><a href="#255-255-255-255" class="headerlink" title="255.255.255.255"></a>255.255.255.255</h4><ul>
<li>对本机来说, 这个地址指本网段内的所有主机. 这个地址不能被路由器所转发.</li>
</ul>
<h4 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h4><ul>
<li>A类网络中的127是一个保留地址, 用于网络软件测试和本机进程间的通信.</li>
<li>无论什么程序, 只要发送了该地址的数据, 就会被立刻发送回本机.</li>
<li>127网络号的分组不能出现在网络传输上.</li>
</ul>
<h4 id="局域网内的IP"><a href="#局域网内的IP" class="headerlink" title="局域网内的IP"></a>局域网内的IP</h4><ul>
<li>当主机号的全为0时,表示一个网络本身.</li>
<li>当主机号全为1时, 表示网络中的全部主机.</li>
<li>网络号代表一个网络本身, 同时也是一个网段的第一个地址. 广播地址是网段的最后一个地址,这两个地址是不能配在主机上的.</li>
</ul>
<blockquote>
<h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3></blockquote>
<ul>
<li>属于非注册地址, 专门为组织机构(学校,企业)内部使用, 简单来说私有地址不能直接上网.</li>
<li>私有IP的范围:<ul>
<li>A类私有IP地址: 10.0.0.0~10.255.255.255</li>
<li>B类私有IP地址: 172.16.0.0~172.31.255.255</li>
<li>C类私有地址: 192.168.0.0~192.168.255.255</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="公有IP"><a href="#公有IP" class="headerlink" title="公有IP"></a>公有IP</h3></blockquote>
<ul>
<li>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Internet NIC提出申请的组织机构。通过它直接访问因特网，它是广域网范围内的。</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45337405" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45337405</a></li>
<li><a href="http://blog.csdn.net/txx9010/article/details/7712438" target="_blank" rel="external">http://blog.csdn.net/txx9010/article/details/7712438</a></li>
<li><a href="https://www.zhihu.com/question/27714563" target="_blank" rel="external">https://www.zhihu.com/question/27714563</a></li>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45226275" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45226275</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP地址分类&quot;&gt;&lt;a href=&quot;#IP地址分类&quot; class=&quot;headerlink&quot; title=&quot;IP地址分类&quot;&gt;&lt;/a&gt;IP地址分类&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#网络层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP滑动窗口</title>
    <link href="http://cristianoro7.github.io/2017/06/29/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://cristianoro7.github.io/2017/06/29/TCP滑动窗口/</id>
    <published>2017-06-29T14:37:18.384Z</published>
    <updated>2017-06-29T14:37:18.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>以字节流为单位的滑动窗口</li>
<li>TCP数据流的类别</li>
<li>接收窗口的确认机制</li>
<li>窗口缩放</li>
<li>缓冲区</li>
<li>超时重传时间的选择</li>
<li>选择确认SACK</li>
</ul>
<blockquote>
<h3 id="以字节流为单位的滑动窗口"><a href="#以字节流为单位的滑动窗口" class="headerlink" title="以字节流为单位的滑动窗口"></a>以字节流为单位的滑动窗口</h3></blockquote>
<p>现假定A收到B发来的确认报文,其中窗口是20,而确认号为31.根据这两个数据,A就构造出了自己的发送窗口:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/滑动窗口.png" alt=""></p>
<ul>
<li>在没有收到B的确认的情况下,A可以连续把窗口内的数据都发送出去.凡是已经发送过去的数据,在未收到确认之前都必须暂时保留,以便在超时重传时使用.</li>
<li>窗口后沿的后面部分表示已经确认接收.这些数据不需要再保留了.</li>
<li>窗口的前沿部分表示不允许发送,因为接收方都没有为这部分数据保留缓存空间.</li>
</ul>
<blockquote>
<h3 id="TCP数据流的类别"><a href="#TCP数据流的类别" class="headerlink" title="TCP数据流的类别"></a>TCP数据流的类别</h3></blockquote>
<p>现在假定A发送序号为31到41的数据.此时, 发送窗口位置并未改变,如图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/数据流分类.png" alt=""></p>
<p>从上图,可以得来的信息:</p>
<p>小于P1的是已经发送并已经收到确认的部分.而大于P3的是不允许发送的部分.<br>P3-P1 = A 的发送窗口.</p>
<p>P2-P1 = 已发送但尚未确认的字节数</p>
<p>P3-P2 = 允许发送但尚未发送的字节数.又称为可用窗口.</p>
<blockquote>
<h3 id="接收窗口的确认机制"><a href="#接收窗口的确认机制" class="headerlink" title="接收窗口的确认机制"></a>接收窗口的确认机制</h3></blockquote>
<p>B的接收窗口大小是20. 在接收窗口外面,到30号为止的数据是已经发送过确认.接收窗口内的序号31~50是允许接收的. 下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/接收窗口确认机制.png" alt=""></p>
<p>B收到了序号为32和33的数据.这些数据没有按序到达,因为序号31还没有到达.此时,B只能对按序到达的数据中的最高序号给出确认,因此B发送的确认报文段中的确认号仍然为31.</p>
<blockquote>
<h3 id="窗口缩放"><a href="#窗口缩放" class="headerlink" title="窗口缩放"></a>窗口缩放</h3></blockquote>
<p>现在假定B收到了序号为31的数据,并把序号为31~33的数据交付主机,然后B删除这些数据.接着把接收窗口向前移动3个序号,如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/B的接收窗口.png" alt=""></p>
<p>同时给A发送确认,其中窗口值为20,但确认号为34.我们注意到, B收到了序号为37,38,40的数据,但这些数据没有按序到达,只能暂时存放在接收窗口中.</p>
<p>A收到B的确认后,就可以把发送窗口向前移动3个序号,但指针P2不动.可以看出,现在A的可用窗口增大了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/A的可用窗口增大.png" alt=""></p>
<p>A在继续发送完序号42~53的数据后,指针P2和P3重合.发送窗口内的序号已经用完,但还没有收到确认.这时A必须停止发送.如果一段时间后,A还没有收到B发来的确认,那么A必须重传这部分数据.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/发送窗口满.png" alt=""></p>
<blockquote>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3></blockquote>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/sliding_window-900x358.jpg" alt=""></p>
<p>上图中，我们可以看到：</p>
<ul>
<li><p>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</p>
</li>
<li><p>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</p>
</li>
</ul>
<blockquote>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3></blockquote>
<p>由于TCP的下层是互联网环境, 发送的报文段可能经过一个高速率的局域网, 也可能经过多个低速率的网络.如果把超时重传时间设置得太短, 就会引起很多报文的不必要重传. 如果把超时重传的时间设置得过长, 则会使得网络的空闲时间太长,从而降低了传输效率.</p>
<p>TCP采用了一种自适应的算法, 它记录一个报文段的发出时间, 以及收到相应的确认时间.这两个时间之差就是报文段的往返时间 RTT. TCP保留了RTT的一个加权平均往返时间RTTs.每当第一次测量到样本RTT样本时,RTTs的值就取为所测量到的RTT样本值.但以后每测量到一个新的RTT样本时,就按照下面的公式计算RTTs:</p>
<p>新的RTTs = (1 - a) <em> (旧的RTTs) + a </em> (新的RTT样本)</p>
<p>RFC推荐a的值为1/8.用这种方法测出的加权平均往返时间RTTs会比测量的RTT值更加平滑.</p>
<p>显然超时重传时间应略大于RTTs. RCF推荐使用下面公式计算:</p>
<p>RTO = RTTs+= + 4 * RTTD</p>
<p>RTTD是RTT的偏差加权平均值,它与RTTs和新的RTT样本的差有关.当第一次测量时, RTTD取为测量到的RTT样本值的一半.在以后的测量中,可以使用下面的公式计算出RTTD</p>
<p>新的RTTD = (1 - B) <em> (旧的RTTD) + B </em> |RTTs - 新的RTT样本 |</p>
<blockquote>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3></blockquote>
<p>现在假设接收方收到的报文段无差错, 只是未按序号,中间还缺少一些序号的数据,通过选择确认SACK可以实现只传送缺少的数据而不重传已经正确到达接收方的数据.下面使用一个例子来理解SACK的工作原理.</p>
<p>TCP接收方在接收对方发送过来的数据字节流的序号不连续,结果就形成了不连续的字节块:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/SACK.png" alt=""></p>
<p>从上图可以看出, 序号1~1000收到了,但序号1001~1500没有收到,接下来的字节又收到了,但是缺少3001~3500.后面序号4501起也没有收到.换句话说,接收方收到了和前面的字节流不连续的两个字节块.如果这些字节块都在接收窗口的范围内,那么接收方就先收下这些数据,但要把这些信息发给发送方,防止发送方重传接收方已经接收到的数据.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">http://coolshell.cn/articles/11609.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP滑动窗口&quot;&gt;&lt;a href=&quot;#TCP滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;TCP滑动窗口&quot;&gt;&lt;/a&gt;TCP滑动窗口&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP首部</title>
    <link href="http://cristianoro7.github.io/2017/06/29/TCP%E9%A6%96%E9%83%A8/"/>
    <id>http://cristianoro7.github.io/2017/06/29/TCP首部/</id>
    <published>2017-06-29T14:36:59.572Z</published>
    <updated>2017-06-29T14:36:59.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></blockquote>
<p>TCP的全部功能都体现在其首部中的各个字段的作用.因此, 只有弄清TCP首部各个字段的作用才能理解TCP的工作原理.</p>
<p>TCP首部的前20个字节是固定的,后面有4n字节是根据需要而增加的选项.因此,TCP首部的最小长度为20字节.</p>
<h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占2个字节, 分别写入源端口号和目的端口号. TCP的分用和复用功能是通过端口实现的.</p>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占4个字节.TCP是面向字节流的,在一个TCP连接中传送的字节流中的每一个字节都按顺序编号.序号字段值是用来指定本报文段所发送的数据的第一个字节的序号.</p>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占4字节.是接收方期望收到发送方下一个报文段的第一个数据字节序号.例如:B正确接收了A发送过来的一个报文段,其序号字段为501,数据长度为200字节,表明B正确接收了501~700的序号的数据.因此,B期望收到A的下一个数据序号是701, 于是B在发送给A的确认报文中把确认号置为701.</p>
<h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占4位, 它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远.这个字段实际上是指出TCP首部的长度.</p>
<h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占6位, 保留为今后使用, 但目前应置为0</p>
<h3 id="紧急URG"><a href="#紧急URG" class="headerlink" title="紧急URG"></a>紧急URG</h3><p>当URG = 1时, 表明紧急指针字段有效.它告诉系统,当前报文段有紧急数据,应当尽快传送.</p>
<h3 id="确认ACK"><a href="#确认ACK" class="headerlink" title="确认ACK"></a>确认ACK</h3><p>仅当ACK = 1时确认号字段才有效.当ACK = 0时,确认号无效. TCP规定,在连接建立后所有传送的报文段都必须把ACK置为1.</p>
<h3 id="推送PSH"><a href="#推送PSH" class="headerlink" title="推送PSH"></a>推送PSH</h3><p>当发送方将PSH置为1,并立即创建一个报文段发送出去.接收方TCP收到PSH = 1的报文段时,就尽快地交付接收应用程序,而不再等到整个缓存填满了再向上交付.</p>
<h3 id="复位-RST"><a href="#复位-RST" class="headerlink" title="复位(RST)"></a>复位(RST)</h3><p>当RST = 1 时, 表明TCP连接出现严重错误,必须释放连接,然后再重新建立连接.</p>
<h3 id="同步SYN"><a href="#同步SYN" class="headerlink" title="同步SYN"></a>同步SYN</h3><p>在连接建立时用来同步序号. 当SYN = 1 时而ACK = 0 时表示这是一个连接请求报文段.若对方同意连接后, 则应在响应报文中使SYN = 1和ACK = 1.实际上SYN = 1 时表示这是一个连接请求或接受报文.</p>
<h3 id="终止FIN"><a href="#终止FIN" class="headerlink" title="终止FIN"></a>终止FIN</h3><p>用来释放一个连接. 当FIN = 1 时, 表明此报文段的发送数据已发送完毕,并要求释放连接.</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占2字节.窗口指的是发送报文段一方的接收窗口.窗口值告诉对方:接收方目前允许对方发送的数据量.</p>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>检验和字段检验的范围包括首部和数据这两部分.</p>
<h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占2字节. 当URG = 1 时才有意义, 它指出本报文段中的紧急数据字节数.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP首部&quot;&gt;&lt;a href=&quot;#TCP首部&quot; class=&quot;headerlink&quot; title=&quot;TCP首部&quot;&gt;&lt;/a&gt;TCP首部&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-储存系统和结构</title>
    <link href="http://cristianoro7.github.io/2017/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    <id>http://cristianoro7.github.io/2017/06/07/计算机组成原理-储存系统和结构/</id>
    <published>2017-06-06T16:20:46.280Z</published>
    <updated>2017-06-06T16:20:46.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="储存系统和结构"><a href="#储存系统和结构" class="headerlink" title="储存系统和结构"></a>储存系统和结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>储存器的分类</li>
<li>随机储存器</li>
<li>高速储存缓冲器</li>
<li>虚拟储存器</li>
</ul>
<blockquote>
<h3 id="储存器的分类"><a href="#储存器的分类" class="headerlink" title="储存器的分类"></a>储存器的分类</h3></blockquote>
<p>下面针对常见的储存器分类进行讨论</p>
<h4 id="按储存器在计算机系统中的作用分类"><a href="#按储存器在计算机系统中的作用分类" class="headerlink" title="按储存器在计算机系统中的作用分类"></a>按储存器在计算机系统中的作用分类</h4><h5 id="高速缓冲储存器"><a href="#高速缓冲储存器" class="headerlink" title="高速缓冲储存器"></a>高速缓冲储存器</h5><p>位于CPU和主储存器之间, 用来缓存正在执行的程序段和数据,以便CPU能高速使用它们.高速缓冲器的速度与CPU匹配.</p>
<h5 id="主储存器"><a href="#主储存器" class="headerlink" title="主储存器"></a>主储存器</h5><p>用来存放正在运行的程序和数据,CPU可以直接随机地进行访问主存.由于访问主存的速度与CPU运算的速度差别很大,因此,主存的性能一定程度上影响了整个计算机的性能.</p>
<h5 id="辅助储存器"><a href="#辅助储存器" class="headerlink" title="辅助储存器"></a>辅助储存器</h5><p>用来存放当前暂不参与运行的程序和数据以及一些需要永久性保存的数据.辅助储存器的存取速度很慢并且CPU不能直接访问它.辅助储存器中的信息需要先读入主存后,才能被CPU访问.</p>
<h4 id="按存取分类"><a href="#按存取分类" class="headerlink" title="按存取分类"></a>按存取分类</h4><h5 id="随机存取储存器-RAM"><a href="#随机存取储存器-RAM" class="headerlink" title="随机存取储存器(RAM)"></a>随机存取储存器(RAM)</h5><p>随机储存指的是CPU能够随机对储存器中的内容进行操作, CPU对任何一个储存单元的操作时间都一样,与储存单元的物理位置无关.</p>
<h5 id="只读储存器-ROM"><a href="#只读储存器-ROM" class="headerlink" title="只读储存器(ROM)"></a>只读储存器(ROM)</h5><p>ROM可以看做是RAM的一种特殊形式, 其特殊在:储存器的内容只能随机读取而不能写入.这类储存器常用来储存那些不需要改变的信息.</p>
<h4 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a>按信息的可保存性分类</h4><h5 id="非易失性储存器"><a href="#非易失性储存器" class="headerlink" title="非易失性储存器"></a>非易失性储存器</h5><p>断电后信息仍然能够保存的储存器称为非易失性储存器.</p>
<h5 id="易失储存器"><a href="#易失储存器" class="headerlink" title="易失储存器"></a>易失储存器</h5><p>断电后信息不能够保存的储存器称为易失性储存器.</p>
<blockquote>
<h3 id="随机储存器RAM"><a href="#随机储存器RAM" class="headerlink" title="随机储存器RAM"></a>随机储存器RAM</h3></blockquote>
<p>RAM细分为静态RAM(SRAM)和动态RAM(DRAM).</p>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>SRAM的记忆单元为双稳态触发器.由于双稳态触发器的工作特性,SRAM中保存的信息一直处于充电状态,这使得SRAM不像DRAM那样需要定时刷新电路来保存信息.因此,SRAM的存取速度要比DRAM快.但SRAM的集成度较低,功耗也较大,所以一般用来组成高速缓冲储存器.</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>DRAM的记忆单元为3个MOS管组成的记忆单元.DRAM中的信息是靠MOS管中的栅极电容保存的,因此需要定时给电容充电,以保证信息不丢失.DRAM虽然储存速度没有SRAM快,但是其集成度高,功耗较小.</p>
<blockquote>
<h3 id="高速缓冲器"><a href="#高速缓冲器" class="headerlink" title="高速缓冲器"></a>高速缓冲器</h3></blockquote>
<p>由于主存的存取速度跟不上CPU的运算速度,主存的速度影响了计算机的整体性能.出于各个方面的考虑,计算机的设计者在主存和CPU之间架设由SRAM组成的高速缓冲器,利用高速缓冲器的运行速度接近CPU的特点,来解决主存的性能瓶颈.</p>
<h4 id="高速缓冲器的工作原理"><a href="#高速缓冲器的工作原理" class="headerlink" title="高速缓冲器的工作原理"></a>高速缓冲器的工作原理</h4><p>首先介绍一下程序局部性原理这个概念. 程序局部性包含两个方面:时间局部性和空间局部性.</p>
<p>时间局部性指的是如果一个储存单元被访问,则可能该储存单元很快会被访问到,这是因此程序中存在循环.</p>
<p>空间局部性指的是如果一个储存单元被访问,则该储存单元邻近的单元很可能很快就被访问, 这是因此程序中大部分指令是顺序储存,顺序执行,数据一般也是以数组,向量,树,表等形式簇聚在一起.</p>
<p>高速缓冲技术就是利用程序局部性原理,把程序中正在使用的部分存放在一个高速但容量较小的Cache中,使得CPU的访存操作大部分都针对Cache进行,从而提高程序的执行速度.</p>
<h4 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h4><h5 id="Cache的读操作"><a href="#Cache的读操作" class="headerlink" title="Cache的读操作"></a>Cache的读操作</h5><p>当CPU发出读请求时,如果请求的数据存在Cache时,就直接对Cache进行操作.否则访问主存,并把该块信息一次从主存调入Cache内.若此时Cache的容量已满的话,则需要根据某些替换算法来替换.</p>
<h5 id="Cache的写操作"><a href="#Cache的写操作" class="headerlink" title="Cache的写操作"></a>Cache的写操作</h5><p>当CPU发出写请求时, 如果要写入的数据存在Cache中的话,需要进行一定的写处理,比如:写直达法和写回法.如果写Cache不命中的话,就直接把信息写入主存,并有两种处理方法:</p>
<ul>
<li>不按写分配法,即只把要写的信息写入主存.</li>
<li>按写分配法,即把要写的信息写入主存后还需要写入Cache中.</li>
</ul>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>当Cache的空间被占满后,就需要进行数据的替换.常用的替换算法有如下三种:</p>
<h5 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h5><p>简单的根据一个随机数来进行替换</p>
<h5 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h5><p>按照调入Cache的顺序来决定替换的顺序.先Cache的数据会先被替换掉.这种方法容易实现并且系统开销小.其缺点是当遇到循环程序块时,效率会不高.</p>
<h5 id="近期最少使用算法-LRU"><a href="#近期最少使用算法-LRU" class="headerlink" title="近期最少使用算法(LRU)"></a>近期最少使用算法(LRU)</h5><p>LRU算法是把CPU近期最少使用的块作为被替换的目标.LRU算法相对上面两种方法合理,但是实现起来比较复杂,系统开销也大.</p>
<h4 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h4><p>为了保证Cache与主存的内容一致,必须选择合适的更新策略.</p>
<h5 id="写直达法"><a href="#写直达法" class="headerlink" title="写直达法"></a>写直达法</h5><p>在CPU执行写操作时,必须同时把数据写入Cache和主存中.这种方法实现简单,而且能够随时保证主存数据的正确性.但是由于每次进行写操作时,都得写入主存,这一定程度上会降低存取速度.</p>
<blockquote>
<h3 id="虚拟储存器"><a href="#虚拟储存器" class="headerlink" title="虚拟储存器"></a>虚拟储存器</h3></blockquote>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>虚拟储存器是将主存或者辅助储存的地址空间进行统一的编址,形成一个庞大的储存空间.这样一来,可以不必考虑程序在主存中是否装得下以及这些程序在主存中的存放位置.</p>
<p>虚拟地址:通常程序员编写程序用到的地址称为虚拟地址.<br><br>物理地址:实际主存单元地址称为物理地址.</p>
<p>虚地址和物理地址是一一对应的关系,实现这个一一映射的关系需要硬件和操作系统的协助.在操作系统的管理下,程序和数据会先存放在磁盘,然后操作系统将当前需要的程序和数据调入主存中,供CPU使用,还没使用到的程序和数据都存放在磁盘中.</p>
<p>当程序运行时,CPU以虚地址来访问主存,在硬件找出虚地址和物理地址之间对应的关系后,判断该虚地址对应的内容是否已经调入主存.如果已经装入主存的话,则通过CPU变址来访问主存中的内容.如果不存在主存中,则将虚拟地址对应的数据从磁盘中装入内存,再由CPU访问.如果此时主存已满,根据替换算法将主存中暂时不需要的数据调回辅存中,再从辅存中调入需要的数据.</p>
<h4 id="页式虚拟储存器"><a href="#页式虚拟储存器" class="headerlink" title="页式虚拟储存器"></a>页式虚拟储存器</h4><p>以页为基本单位的虚拟储存器称为页式虚拟储存器.主存空间和虚拟空间都被分为若干个大小相等的页.主存的页称为实页,虚存的页称为虚页.</p>
<p><img src="/uploads/计算机组成原理/页式虚拟储存.png" alt=""></p>
<p>上图为虚拟地址到物理地址的映射过程.</p>
<p>虚地址是由虚页号和页内地址所组成的.虚页号为页表中的索引号,页表是用于虚地址到物理地址的转换,简单的说就是虚页号的集合.每个虚页号和储存在页面基址寄存器的页表起始地址组成一个页表地址,页表地址指向页表中的一项,项目中含有装入位和实页号.如果装入位1为的话,说明该页面已经被调入主存,实页号和虚地址中的页内地址组成物理地址.如果装入位为0的话,证明该页面还没有被调入主存,需要启动IO系统,将该页从辅存中主存后再拱CPU使用.</p>
<h4 id="段式虚拟储存"><a href="#段式虚拟储存" class="headerlink" title="段式虚拟储存"></a>段式虚拟储存</h4><p>段式虚拟储存中的段是按照程序中的逻辑结构划分的,各个段的长度是因程序而异.在页式虚拟储存中,虚地址到物理地址的映射需要一个页表,同样的,在段式储存中,虚地址到物理地址的转换也需要一个段表.段表中的每一个项目记录了段号,装入位,段起点和段长度等.</p>
<p><img src="/uploads/计算机组成原理/段式储存.png" alt=""></p>
<p>上图为段式虚拟储存中,虚地址到物理地址的映射过程,原理跟虚拟地址差不多,这里不多做记录.</p>
<h4 id="段页式虚拟储存"><a href="#段页式虚拟储存" class="headerlink" title="段页式虚拟储存"></a>段页式虚拟储存</h4><p>结合段式和页式虚拟储存的特点,这种虚拟储存方式为段页式虚拟储存.段页式将程序其逻辑结构分段,每段再划分为若干个大小相同的页,主存空间也划分为若干同样大小的页.</p>
<p>虚存和实存之间以页为基本单位进行传送,每个程序对应一个段表,每段对应一个页表.</p>
<p>CPU访问时,虚地址包括段号,段内页号,页内地址3部分.</p>
<p>首先将段表起始地址和段号合成,得到页表地址,然后从段表中取出该段的页表起始地址,与段内页号合成,得到页表地址.最后从页表中得到实页号,与页内地址拼接成主存的实地址.</p>
<p>段页式虚拟储存整合了前面两种结构的优点.但是要经过两级查询才能完成地址转换,费时自然也会增多.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机组成原理</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;储存系统和结构&quot;&gt;&lt;a href=&quot;#储存系统和结构&quot; class=&quot;headerlink&quot; title=&quot;储存系统和结构&quot;&gt;&lt;/a&gt;储存系统和结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理概述</title>
    <link href="http://cristianoro7.github.io/2017/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <id>http://cristianoro7.github.io/2017/06/04/计算机组成原理概述/</id>
    <published>2017-06-04T08:37:00.429Z</published>
    <updated>2017-06-04T08:37:00.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理概述"><a href="#计算机组成原理概述" class="headerlink" title="计算机组成原理概述"></a>计算机组成原理概述</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>储存程序概念</li>
<li>计算机硬件的组成</li>
<li>储存器的设计思想</li>
<li>计算机的主要性能指标</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>最近,突然对操作系统感兴趣,于是提前看了网上关于操作系统的视频. 但是在看的过程中对操作系统启动时从实模式到保护模式的切换,分段机制和分页机制, CPU的工作模型和总线等概念不怎么熟悉. 于是Google了一番, 发现这些大都是涉及到计算机组成原理的知识,刚好这学期学校有开设计算机组成原理课程.于是乎, 系统的学习了一波计算机组成原理的知识.</p>
<p>由于自己的方向是偏软件开发的, 因此,在学习的过程中,主要理解计算机的工作原理以及设计思想, 对于硬件的设计和工作原理就基本没深入了解. 接下来关于计算机组成原理的文章,都是偏向与理论并且不涉及到硬件的具体工作原理等.</p>
<blockquote>
<h3 id="储存程序概念"><a href="#储存程序概念" class="headerlink" title="储存程序概念"></a>储存程序概念</h3></blockquote>
<p>储存程序是由冯*诺依曼为首的研究小组提出来的概念.储存程序的诞生主要是为了解决使用线路连接编程的缺点.</p>
<p>储存程序的要点可以概括为下面三点:</p>
<ul>
<li>计算机应由运算器,储存器,控制器,输入设备和输出设备5大基本部件组成.</li>
<li>计算机内部统一使用二进制表示指令和数据.</li>
<li>将编好的程序和原始数据事先存入储存器中,然后再启动计算机工作.</li>
</ul>
<p>但是随着计算机的高速发展, 访问CPU的速度远远快于访问主存的速度.因此,储存器的访问成为了计算机性能的瓶颈.</p>
<blockquote>
<h3 id="计算机硬件的组成"><a href="#计算机硬件的组成" class="headerlink" title="计算机硬件的组成"></a>计算机硬件的组成</h3></blockquote>
<h4 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h4><h5 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h5><p>输入设备的作用是将编好的程序和数据输入到计算机,并且将他们转换为计算机内部能够识别和接受的信息.</p>
<h5 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h5><p>输出设备的任务是将计算机内部处理的结果以数字,字符,图像等方式展示给人们看.</p>
<h5 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h5><p>储存器是用来存放程序和数据的部件,是实现”储存程序”的基础.</p>
<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>运算器是对信息进行处理和运算的部件.进行的运算有:算术运算和逻辑运算.</p>
<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>控制器的主要工作是指挥各个部件工作.</p>
<h4 id="连接各个部件的总线"><a href="#连接各个部件的总线" class="headerlink" title="连接各个部件的总线"></a>连接各个部件的总线</h4><p>总线可以实现各个部件之间的信息共享.例如:主存中的数据通过总线传递到CPU.</p>
<p>最简单的总线结构为单总线结构,也称为系统总线:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Computer_system_bus.svg/350px-Computer_system_bus.svg.png" alt=""></p>
<p>各个部件都连接在总线上, CPU与主存,CPU与外部设备之间可以直接通信.主存与外部设备,外部设备和外部设备之间可以直接通信,而无须经过CPU的干预.</p>
<p>系统总线的结构限定了同一时刻只允许一对设备之间传递信息.</p>
<p>系统总线按传递信息的不同,可以细分为:</p>
<ul>
<li>数据总线: CPU可以沿数据总线从主存或者外部设备读入信息,也可以向主存或者外部设备写入信息.</li>
<li>地址总线: 用于CPU向主存,外部设备传输地址信息.</li>
<li>控制总线: 传递CPU发出的控制命令和主存返回给CPU的信号.</li>
</ul>
<blockquote>
<h3 id="储存器的设计思想"><a href="#储存器的设计思想" class="headerlink" title="储存器的设计思想"></a>储存器的设计思想</h3></blockquote>
<p>储存器的设计思想可以分为:冯*诺依曼结构和哈佛结构.</p>
<h4 id="冯-诺依曼结构"><a href="#冯-诺依曼结构" class="headerlink" title="冯*诺依曼结构"></a>冯*诺依曼结构</h4><p>在冯诺依曼结构下的储存器结构,指令和数据是不加以区分地储存在储存器中,并共享数据总线.</p>
<p><img src="/uploads/计算机组成原理/冯诺依曼.png" alt=""></p>
<p>由于指令和数据存放在同一储存器中,因此,在这种结构下,不能同时进行取指令和取操作数.</p>
<p>又由于储存器的访问速度远远慢于CPU的运算速度,从而使得计算机运算速度受到了很大的影响.</p>
<h4 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h4><p>哈佛结构的指令和数据是分开的.储存器分为两部分:程序储存器和数据储存器.前者是用来存放指令,而后者则是存放数据.</p>
<p><img src="/uploads/计算机组成原理/哈佛结构.png" alt=""></p>
<blockquote>
<h3 id="计算机的主要性能指标"><a href="#计算机的主要性能指标" class="headerlink" title="计算机的主要性能指标"></a>计算机的主要性能指标</h3></blockquote>
<h4 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h4><p>机器字长是指运算器进行一次运算所处理的位数,它通常是由寄存器,加法器的位数决定的,所以机器字长一般等于寄存器的位数.</p>
<h4 id="数据通路宽度"><a href="#数据通路宽度" class="headerlink" title="数据通路宽度"></a>数据通路宽度</h4><p>数据总线一次并行传送信息的位数,称为数据通路宽度.它影响到信息传送能力,从而影响到计算机的有效处理速度.</p>
<h4 id="储存容量"><a href="#储存容量" class="headerlink" title="储存容量"></a>储存容量</h4><p>一个主储存器所能储存的全部信息量成为主存容量.计算机的主存容量越大,存放的信息就越多,处理问题的能力就越强.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机组成原理<br><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%8C%AF%E6%B5%81%E6%8E%92" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%8C%AF%E6%B5%81%E6%8E%92</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机组成原理概述&quot;&gt;&lt;a href=&quot;#计算机组成原理概述&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理概述&quot;&gt;&lt;/a&gt;计算机组成原理概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-运输层</title>
    <link href="http://cristianoro7.github.io/2017/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://cristianoro7.github.io/2017/05/30/计算机网络-运输层/</id>
    <published>2017-05-30T15:17:35.464Z</published>
    <updated>2017-05-30T15:17:35.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-运输层"><a href="#计算机网络-运输层" class="headerlink" title="计算机网络-运输层"></a>计算机网络-运输层</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分用和复用</li>
<li>UDP协议</li>
<li>运输层梳理</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>当网络的边缘部分中的两个主机使用网络的核心部分功能进行通信时,只有主机的协议栈才有运输层,而网络的核心部分中的路由器在转发分组时都只用到下三层的功能.</p>
<p>网络层是为主机之间提供逻辑通信,而运输层为应用进程之间提供端到端的逻辑通信.</p>
<p>在网络层中, IP数据报首部的检验和字段只检验首部是否出现差错而不检查数据部分.而在运输层中, 应当进行首部和数据的差错检验.</p>
<blockquote>
<h3 id="分用和复用"><a href="#分用和复用" class="headerlink" title="分用和复用"></a>分用和复用</h3></blockquote>
<p>复用是指发送方不同的应用程序都可以使用同一个运输层协议传送数据.</p>
<p>分用是指接收方的运输层去掉报文的首部后能够把数据正确交付到目的进程中.</p>
<blockquote>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3></blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>UDP协议只在IP数据报服务上增加了很少的功能,这些功能是分用和复用还有差错检验.</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>UDP是无连接的,因此减少了开销和发送数据之前的时延</li>
<li>UDP使用尽最大努力交付,即不保证可靠交付.</li>
<li>UDP是面向报文的.应用层交给UDP多长的报文,UDP就照样发送,一次发一个报文.</li>
<li>UDP没有拥塞控制.</li>
<li>UDP支持1对1,1对多,多对1,多对多的交互通信.</li>
<li>UDP的首部开销小,只有8字节.</li>
</ol>
<blockquote>
<h3 id="运输层梳理"><a href="#运输层梳理" class="headerlink" title="运输层梳理"></a>运输层梳理</h3></blockquote>
<p>运输层主要有两个协议:</p>
<ol>
<li>UDP</li>
<li>TCP</li>
</ol>
<p>UDP是面向无连接的协议,只是在IP数据报上添加复用,分用和差错检验的功能,UDP协议本身比较简单.</p>
<p>TCP协议是面向连接的一种协议,在进程之间的通信中提供一种可靠交付的服务.相比于UDP协议, TCP协议比较复杂.</p>
<p>下面给出运输层的知识梳理图:</p>
<p><img src="/uploads/计网/运输层/运输层梳理.png" alt=""></p>
<p>其中TCP协议涉及的内容比较多,归纳起来可以分为:</p>
<p><a href="https://cristianoro7.github.io/2017/05/22/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">可靠传输的工作原理</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/22/TCP%E9%A6%96%E9%83%A8/">TCP首部</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/23/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">TCP滑动窗口</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/23/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">TCP流量控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/24/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/24/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/">TCP连接管理</a></p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-运输层&quot;&gt;&lt;a href=&quot;#计算机网络-运输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-运输层&quot;&gt;&lt;/a&gt;计算机网络-运输层&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制</title>
    <link href="http://cristianoro7.github.io/2017/05/24/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://cristianoro7.github.io/2017/05/24/TCP拥塞控制/</id>
    <published>2017-05-24T10:57:37.640Z</published>
    <updated>2017-05-24T10:57:37.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>慢开始和拥塞避免</li>
<li>快重传和快恢复</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>在计算机网络中, 链路的容量,交换节点中的缓存和处理机等都是网络的资源.在某段时间内,若对网络中的某一资源的需求超过本身能提供的资源,这时网络性能就会变差.这种情况成为网络拥塞.</p>
<p>所谓拥塞控制就是要防止过多的数据注入到网络中,这样可以使网络的路由器或者链路不致于过载.拥塞控制是一个全局性的过程,涉及到所有主机,所有的链路,以及与降低网络传输性能有关的所有因素.</p>
<blockquote>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3></blockquote>
<p>发送方维护一个拥塞窗口的状态变量.拥塞窗口的大小取决于网络的拥塞程度,并且动态改变.发送方让自己的发送窗口等于拥塞窗口.</p>
<h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>主机在发送数据的时候,不是直接把大量的数据字节注入网络, 而是先探测一下网络,即由小到大逐渐增大发送窗口,也就是由小到大逐渐增大拥塞窗口.增大的原则是每经过一个传输轮次,拥塞窗口就加倍.而一个传输轮次指的是发送方连续发送报文段后到收到这些连续报文段的确认所经历的时间.</p>
<p>为了防止拥塞窗口增大过大引起网络拥塞,还需要设置一个慢开始门限状态变量.慢开始门限用法:</p>
<ul>
<li>当拥塞窗口 &lt; 慢开始门限时,使用慢开始算法.</li>
<li>当拥塞窗口 &gt; 慢开始门限时,停止使用慢开始算法,改用拥塞避免算法.</li>
<li>当拥塞窗口 = 慢开始门限时,可以使用慢开始算法或者拥塞避免算法.</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞避免算法让拥塞窗口缓慢增大,即每经过一个往返时间RTT就把发送窗口+1,而不是加倍.这样,拥塞窗口按线性规律缓慢增长.</p>
<h4 id="乘法减小"><a href="#乘法减小" class="headerlink" title="乘法减小"></a>乘法减小</h4><p>不论在慢开始阶段还是拥塞避免阶段,只要出现拥塞情况,就把慢开始门限设置为当前拥塞窗口的一半.</p>
<p>当网络频繁出现拥塞时, 慢开始门限的值就下降得很快, 这样可以大大减少注入到网络的分组数.</p>
<h4 id="加法增大"><a href="#加法增大" class="headerlink" title="加法增大"></a>加法增大</h4><p>是指拥塞避免算法后, 使拥塞窗口缓慢增大,防止网络过早出现拥塞.</p>
<blockquote>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3></blockquote>
<h4 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h4><p>快重传算法规定: 发送方连续收到三个重复确认就立即重传该确认对应的分组,不必等待重传计时器到期.</p>
<h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><p>由于发送方连续收到三个重复的确认,此时很可能不是因为网络拥塞,否则也不会连续收到三个重复的确认,因此,不执行慢开始算法,而是执行快恢复算法,即:把拥塞窗口设置为慢开始门限减半后的数值,然后执行拥塞避免算法.</p>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>计算机网路</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP拥塞控制&quot;&gt;&lt;a href=&quot;#TCP拥塞控制&quot; class=&quot;headerlink&quot; title=&quot;TCP拥塞控制&quot;&gt;&lt;/a&gt;TCP拥塞控制&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接管理</title>
    <link href="http://cristianoro7.github.io/2017/05/24/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/05/24/TCP连接管理/</id>
    <published>2017-05-24T10:57:29.308Z</published>
    <updated>2017-05-24T10:57:29.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>TCP连接</li>
<li>TCP连接释放</li>
</ul>
<blockquote>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3></blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdilnjr84mj30zk0lk788.jpg" alt=""></p>
<p>上图为TCP连接建立的过程</p>
<p>B的TCP服务器进程首先创建传输控制块,准备接收客户端进程的连接请求.</p>
<p>A的TCP客户端进程首先创建传输控制块, 然后向B发送连接请求的报文段,此时首部SYN = 1,同时选择一个seq = x. TCP规定,SYN报文段不能携带数据,但要也要消耗一个序号.这次TCP客户端进程进入SYN-SEND状态.</p>
<p>B收到连接请求后, 如同意连接, 则向A发送确认. 在确认的报文段中应把SYN和ACK都置为1,确认号ack = x + 1, 同时也为自己选定一个序号seq = y.注意:这个报文段也不能携带数据,但是要消耗一个序号.此时TCP服务器进入SYN-RCVD状态.</p>
<p>TCP客户端收到B的确认后, 还要向B确认.确认的报文段的ACK置1,确认号ack = y+1,而自己的序号seq = x + 1.注意:ACK报文可以携带数据.如果不携带数据就不用消耗序号.此时TCP连接已经建立.A进入ESTALISHED状态.</p>
<p>当B收到A的确认后, 也进入ESTABLISHED状态.</p>
<p>上面的连接建立过程叫做三次握手.</p>
<p>三次握手的原因是为了防止已失效的连接请求报文段突然又传送到B,因此产生错误.</p>
<p>现在假定A发送出去的第一个连接请求报文段在某些网络结点长时间滞留了,以致延误到连接释放后的某个时间才到达B.本来这个是一个已经失效的报文段.但是B收到此有效的报文段后, 就误认为A又发出了<br>一次连接请求.于是向A发送确认报文段,同意建立连接.如果假设不采用三次握手, 那么B发出确认,新的连接就建立了.由于A并没有发出建立连接的请求, 因此不理睬B的确认,也不会向B发送数据.但B却以为新的连接已经建立,一直等待A发送数据.这样B的许多资源就白白浪费了.</p>
<p>如果采用三次握手的话, A不会向B发出确认.B由于收不到确认,就不知道A并没有要求建立连接.</p>
<blockquote>
<h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3></blockquote>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdilpjw72ej31180ou43x.jpg" alt=""></p>
<p>上图为TCP连接释放过程</p>
<p>A的应用首先让其TCP发出连接释放的报文段, 并停止发送数据,主动关闭连接.A把连接释放报文段首部FIN置为1,其序号seq = u.这时A进入FIN-WAIT-1状态,等待B的确认.注意:FIN报文段即使不携带数据也要消耗一个序号.</p>
<p>B收到连接释放的请求后即发出确认,确认号为ack = u + 1,而这个报文段的序号为v.然后B进入CLOSE-WAIT状态.TCP服务器此时通知应用进程, 因此A到B的连接已经释放掉了.这时TCP连接处于半释放状态.即A已经没有要传送数据了.但A仍然接收数据,因为B到A的连接还没有释放.</p>
<p>A收到B的确认后.进入FIN-WAIT-2状态,等待B发送连接释放报文段.</p>
<p>若B已经没有数据要发送了, 其应用进程会通知TCP释放连接.这时B发出的来连接释放报文段必须时FIN = 1.这时B就进入了LAST-ACK状态,等待A的确认.</p>
<p>A收到B的连接释放报文后,必须对此报文发出确认.然后进入TIME-WAIT状态.现在TCP连接还没有释放.必须经过时间等待计时器设置的时间2MSL后, A才进入CLOSED状态.</p>
<p>TIME-WAIT必须等待两个MSL的原因:</p>
<ul>
<li>保证A的最后一个确认报文段能够到达B</li>
<li>防止已失效的连接请求报文段出现在本地连接中.</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
<p><a href="http://blog.csdn.net/lihao21/article/details/52095980" target="_blank" rel="external">http://blog.csdn.net/lihao21/article/details/52095980</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP连接管理&quot;&gt;&lt;a href=&quot;#TCP连接管理&quot; class=&quot;headerlink&quot; title=&quot;TCP连接管理&quot;&gt;&lt;/a&gt;TCP连接管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP流量控制</title>
    <link href="http://cristianoro7.github.io/2017/05/23/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://cristianoro7.github.io/2017/05/23/TCP流量控制/</id>
    <published>2017-05-23T14:35:49.905Z</published>
    <updated>2017-05-23T14:35:49.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>利用滑动窗口实现流量控制</li>
<li>零窗口</li>
<li>传输效率</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>一般来说,我们总希望数据传输得快一点, 但是如果发送方把数据发送得太快, 接收方就可能来不及接收,这就会造成数据的丢失.流量控制其实就是让发送方的发送速率不要太快, 要让接收方来得及接收.</p>
<blockquote>
<h3 id="利用TCP滑动窗口实现流量控制"><a href="#利用TCP滑动窗口实现流量控制" class="headerlink" title="利用TCP滑动窗口实现流量控制"></a>利用TCP滑动窗口实现流量控制</h3></blockquote>
<p>其实TCP流量控制本质上是利用滑动窗口机制来实现的.接下来,结合例子来解释TCP的流量控制.</p>
<p>如图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/流量控制.png" alt=""></p>
<p>现在假设A向B发送数据. 在连接建立时, B告诉A:我的接收窗口为400.因此A的发送窗口不能超过B的发送窗口不能超过接收方窗口的数值.现在假设每个报文段的字节为100, 而报文段的初始值为1.</p>
<p>仔细观察上图, 接收方B进行了3次的流量控制. 第一次吧窗口值缩小到了300.第二次又减到100.最后减到0.即不允许对方再发送数据了.</p>
<blockquote>
<h3 id="零窗口"><a href="#零窗口" class="headerlink" title="零窗口"></a>零窗口</h3></blockquote>
<p>现在考虑一种情况. B向A发送了0窗口报文段不久后, B的接收缓存又有了一些空间.于是B向A发送了rwnd = 400的报文段. 然而这个报文在传送的过程中丢失了. 于是A只能一直等待B发送非零窗口的通知,而B一直等待A发送数据.此时如果没有其他措施,这种相互等待的局面会一直持续下去.</p>
<p>为了解决这个问题, TCP为每个连接设有一个持续计时器.只要TCP连接接收到零窗口,就启动持续计时器.若持续计时器时间一到,就发送一个零窗口探测报文段.而对方就在确认这个探测报文段时给出现在的窗口值.如果窗口值不是零的话,那么死索界面将会被打破,否则就重新启动持续计时器.</p>
<blockquote>
<h3 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h3></blockquote>
<h4 id="发送效率"><a href="#发送效率" class="headerlink" title="发送效率"></a>发送效率</h4><p>应用程序把数据传送给TCP的发送缓存后, 剩下的任务就由TCP来控制了.此时,TCP可以采用不同的机制来控制发送的时机.例如:</p>
<ul>
<li>TCP维护一个变量,它等于最大报文长度MSS.只要缓存中存放的数据达到MSS字节时,就组装成一个报文发送出去.</li>
<li>由发送方的应用程序指明要求发送报文段,也就是TCP的PSH操作.</li>
<li><p>第三种机制是发送方的计时器期限到了,就把当前已缓存的数据组装成报文发送出去.</p>
<p>在TCP的实现中, 广泛是使用Nagle算法.该算法如下:若发送应用程序把要发送的数据逐个字节都送到TCP缓存中, 则发送方会把第一个字节先发送出去,把后面到达的字节缓存起来.当发送方收到对第一个数据的确认时,再把缓存的字节组装成报文段发送出去,同时继续对后来到达的数据进行缓存.这样做,可以有效的提高网络的吞吐量.</p>
</li>
</ul>
<h4 id="接收效率"><a href="#接收效率" class="headerlink" title="接收效率"></a>接收效率</h4><p>现在假设TCP接收方的缓存已经满了,而应用进程一次只从接收缓存中读取1个字节,然后向发送方发送确认, 并把窗口值设置为1.如此循环下去, 会使网络的效率很低.</p>
<p>要解决上面的问题,可以有下面两种方法:</p>
<ol>
<li>让接收方等待一段时间,使得接收缓存有足够空间容纳一个MSS再发送确认.</li>
<li>让接收方等待一段时间,使得接收缓存已有一半的空闲的空间.</li>
</ol>
<p>上面的两种方法可以交替使用.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP流量控制&quot;&gt;&lt;a href=&quot;#TCP流量控制&quot; class=&quot;headerlink&quot; title=&quot;TCP流量控制&quot;&gt;&lt;/a&gt;TCP流量控制&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://cristianoro7.github.io/2017/05/22/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://cristianoro7.github.io/2017/05/22/Class类文件结构/</id>
    <published>2017-05-22T09:04:17.354Z</published>
    <updated>2017-05-22T09:04:17.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>Class类文件结构<ul>
<li>特殊字符串概念</li>
<li>魔数与Class文件的版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引,父类索引与接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="类文件结构-1"><a href="#类文件结构-1" class="headerlink" title="类文件结构"></a>类文件结构</h3></blockquote>
<p>Class文件结构只有两种数据类型:无符号和表.<br>无符号数属于基本的数据类型,以u1,u2,u4,u8分别代表1个字节,2个字节,4个字节和8个字节的无符号数,它用来描述数字,索引引用,数量值或者UTF-8编码构成字符串值.<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型,所有表都习惯以”_info” 结尾<br>整个class文件本质就是一张表:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count</td>
</tr>
<tr>
<td>u2</td>
<td>access_flag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface</td>
<td>interface_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h4 id="特殊字符串的概念"><a href="#特殊字符串的概念" class="headerlink" title="特殊字符串的概念"></a>特殊字符串的概念</h4><ul>
<li>全限定名: 把类的全名中的”.”替换成”/“,最后再加上”;”</li>
<li>简单名称: 没有类型和参数修饰的方法或者字段名称.</li>
<li>方法和字段的描述符: 描述符的作用是用来描述字段的数据类型,方法参数列表和返回值.</li>
<li>描述符标识字符含义:</li>
</ul>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>特殊类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型</td>
</tr>
</tbody>
</table>
<h4 id="魔数与Class文件版本"><a href="#魔数与Class文件版本" class="headerlink" title="魔数与Class文件版本"></a>魔数与Class文件版本</h4><ul>
<li>每个Class文件的头4个字节称为魔数,它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件.</li>
<li>紧接魔数后面的4个字节储存的是Class文件的版本号: 第5,6个字节是此版本号(Minor Version),第7和第8个字节是主版本号.JDK的版本号是从45开始的.</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li>常量池可以理解为Class文件之中的资源仓库,它同时是Class文件关联其他项目最多的数据类型,也是占用Class文件空间最大的数据项目之一.</li>
<li>由于常量池中的常量是不固定的,所以需要在常量池入口放置一项u2类型的数据,代表常量池容量计数值.</li>
<li>常量池中主要储存两大类常量:字面量和符号引用．字面量比较接近Java语言层面的常量概念,如字符串,声明为final常量值等. 而符号引用则属于编译原理方面的概念,主要包含了下面三类常量:<ul>
<li>类和接口的全称限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>常量池的项目类型:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或者方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标识方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeType_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><ul>
<li>access_flags用于识别一些类或者接口层次的访问信息.例如:这个class是类还是接口;是否定义为public类型;是否定义为abstract类型等. 具体标记:</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final,只有类可设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令心新语意</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstact类型, 对于接口或者抽象类来说, 这个标志为真,其他值为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识这个类并非由用户代码生成</td>
</tr>
<tr>
<td>ACC_ANNOTION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这个一个枚举</td>
</tr>
</tbody>
</table>
<h4 id="类索引-父类索引与接口索引集合"><a href="#类索引-父类索引与接口索引集合" class="headerlink" title="类索引,父类索引与接口索引集合"></a>类索引,父类索引与接口索引集合</h4><ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名</li>
<li>接口索引集合用于描述这个类实现了哪些接口</li>
</ul>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><ul>
<li>字段表集合用于描述接口或者类中声明的变量.</li>
<li>字段包括类级变量和实例级变量, 但不包括在方法内的局部变量</li>
</ul>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><ul>
<li>方法表结构:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<ul>
<li>方法表集合结构跟字段表结构大致相同</li>
<li>如果父类分方法没有被子类重写,方法表集合中就不会出现父类方法的信息.</li>
</ul>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><ul>
<li>虚拟机规范预定义的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量值</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类,方法表字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EbcloseingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性,这个属性用于标识这个类所在的外围方法.</td>
</tr>
<tr>
<td>InnerClasses</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令对应的关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部属性描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性, 供新的类型检查验证器检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配.</td>
</tr>
<tr>
<td>Signature</td>
<td>类,方法表,字段表</td>
</tr>
</tbody>
</table>
<p>待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类文件结构&quot;&gt;&lt;a href=&quot;#类文件结构&quot; class=&quot;headerlink&quot; title=&quot;类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="JVM" scheme="http://cristianoro7.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://cristianoro7.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构-队列</title>
    <link href="http://cristianoro7.github.io/2017/05/21/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>http://cristianoro7.github.io/2017/05/21/大话数据结构-队列/</id>
    <published>2017-05-21T05:36:30.311Z</published>
    <updated>2017-05-21T05:36:30.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h3><ul>
<li>由于队列的顺序储存本身会由于删除等操作而发生假溢出.因此使用循环队列可以解决这个问题<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4>把队列的头尾相接的顺序储存结构称为循环队列</li>
</ul>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li>在使用循环队列时,会出现front == rear 对应队列为空或者队列满的情况</li>
</ul>
<h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><ul>
<li>设置一个标志位： 当队列为空时，flag = 0，当队列满时，flag = 1;</li>
<li>当队列为空时，front == rear，当队列满时，修改其条件，空出一个元素空间</li>
</ul>
<a id="more"></a>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 循环队列的顺序结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> front;</div><div class="line">    <span class="keyword">int</span> rear;</div><div class="line">&#125;SqQueue;</div></pre></td></tr></table></figure>
<ul>
<li>初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">init</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</div><div class="line">    Q.front = <span class="number">0</span>;</div><div class="line">    Q.rear = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>队列长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">length</span><span class="params">(SqQueue Q)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">enQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    Q.data[Q.rear] = e;</div><div class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">deQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q.front == Q.rear) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = Q.data[Q.front];</div><div class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><ul>
<li>结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 链队列</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> QNode &#123;</div><div class="line">    ElemType data;</div><div class="line">    <span class="keyword">struct</span> QNode *next;</div><div class="line">&#125;QNode, *QueuePrt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    QueuePrt front, rear;</div><div class="line">&#125;LinkQueue;</div></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sEnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType e)</span> </span>&#123;</div><div class="line">    QueuePrt p = (QueuePrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    p-&gt;data = e;</div><div class="line">    p-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    Q.rear-&gt;next = p;</div><div class="line">    Q.rear = p;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sDeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q.front == Q.rear) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    QueuePrt p = Q.front-&gt;next;</div><div class="line">    e = p-&gt;data;</div><div class="line">    Q.front-&gt;next = p-&gt;next;</div><div class="line"></div><div class="line">    <span class="comment">/*如果被删除的结点是最后一个的话，将尾指针指向头结点*/</span></div><div class="line">    <span class="keyword">if</span>(Q.rear == p) &#123;</div><div class="line">        Q.rear = Q.front;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><h4 id="时间上："><a href="#时间上：" class="headerlink" title="时间上："></a>时间上：</h4><ul>
<li>两者的基本操作的时间复度都是O(1)</li>
<li>对于循环队列来说，事先申请好空间，试用期间不释放</li>
<li>对于链队列来说，每次申请和释放结点也会存在一些时间开销</li>
<li>如果入队频繁的话，两者还是有细微差别</li>
</ul>
<h4 id="空间上"><a href="#空间上" class="headerlink" title="空间上"></a>空间上</h4><ul>
<li>循环队列需要事先确定一个长度，所以就有了储存个数和空间浪费的问题</li>
<li>链队列则不存在上述问题，但是它需要指针域，也会在空间上产生一定的开销</li>
<li>总体来说，链队列在空间上更加灵活</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>在确定队列长度的最大值的情况下，使用循环队列较为适宜，否则使用链队列比较适合</li>
</ul>
<blockquote>
<p>参考资料：《大话数据结构》<br><a href="https://github.com/cristianoro7/data-structure-practice" target="_blank" rel="external">源码</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;h3 id=&quot;顺序循环队列&quot;&gt;&lt;a href=&quot;#顺序循环队列&quot; class=&quot;headerlink&quot; title=&quot;顺序循环队列&quot;&gt;&lt;/a&gt;顺序循环队列&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;由于队列的顺序储存本身会由于删除等操作而发生假溢出.因此使用循环队列可以解决这个问题&lt;h4 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; title=&quot;定义：&quot;&gt;&lt;/a&gt;定义：&lt;/h4&gt;把队列的头尾相接的顺序储存结构称为循环队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在使用循环队列时,会出现front == rear 对应队列为空或者队列满的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;解决：&quot;&gt;&lt;a href=&quot;#解决：&quot; class=&quot;headerlink&quot; title=&quot;解决：&quot;&gt;&lt;/a&gt;解决：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;设置一个标志位： 当队列为空时，flag = 0，当队列满时，flag = 1;&lt;/li&gt;
&lt;li&gt;当队列为空时，front == rear，当队列满时，修改其条件，空出一个元素空间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://cristianoro7.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://cristianoro7.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://cristianoro7.github.io/2017/05/18/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://cristianoro7.github.io/2017/05/18/Java内存区域/</id>
    <published>2017-05-17T16:37:11.834Z</published>
    <updated>2017-05-17T16:37:11.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>运行时数据区<ul>
<li>程序计数器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>运行时常量池</li>
</ul>
</li>
<li>HotSpot虚拟机对象探秘<ul>
<li>对象的创建</li>
<li>对象的内存布局</li>
<li>对象的访问定位</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3></blockquote>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。</li>
<li>如果线程正在执行的是一个Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的方法是一个Native方法的，程序计数器的值为空（Undefine）。</li>
<li>此内存是JVM唯一没有规定任何OOM的区域。</li>
<li>程序计数器是线程私有的。</li>
</ul>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul>
<li>Java虚拟机栈是线程私有的。</li>
<li>Java虚拟机栈指的是Java方法执行的内存模型：即每个方法在执行时都会创建一个栈帧（是方法运行时的一种基础数据结构），用于储存局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机栈的入栈到出栈的过程。</li>
<li>局部变量表存放了编译期可知的各种基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用和returnAddress类型。</li>
<li>局部变量表所需的内存空间在编译期完成分配，在方法运行期间不会改变局部变量表的大小。</li>
<li>该区域会出现两种异常情况<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>发挥的作用与Java虚拟机栈相似。</li>
<li>与Java虚拟机栈之间的区别：<ul>
<li>虚拟机栈执行Java方法服务。</li>
<li>本地方法栈执行本地方法服务。</li>
</ul>
</li>
</ul>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul>
<li>Java虚拟机所管理的内存区域最大的一块。</li>
<li>Java堆是在虚拟机启动时被创建，是被所有线程所共享。</li>
<li>一般情况下：几乎所有对象实例和数组都是在堆上分配。</li>
<li>如果在堆上没有内存完成实例分配，并且堆也无法扩展时，将抛出OOM。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>与堆一样，是各个线程共享的内存区域。</li>
<li>它用于储存已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。</li>
<li>当方法区无法满足内存分配的需求时，将会抛出OOM。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>运行时常量池是方法区的一部分。</li>
<li>当运行时常量池无法满足内存分配的需求时，将会抛出OOM。</li>
</ul>
<hr>
<blockquote>
<h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3></blockquote>
<h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ul>
<li>当虚拟机遇到new指令时，首先检查这个指令的参数是否在常量池能定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析，初始化过。如果没有的话，那必须先进行类的加载</li>
<li>类加载检查通过后，虚拟机将为新生对象分配内存。</li>
<li>对象所需的内存在类加载完成后便完全可确定，为对象分配空间相当于在堆上划分一块内存出来。</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作在TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码可以不赋值就直接使用。程序能访问到这些字段的零值。</li>
<li>接下来，虚拟机需要为对象进行必要的设置。例如：类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：对象头，实例数据和对齐填充。</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><ul>
<li>对象头包含两部分信息。</li>
<li>第一部分用于储存对象自身的运行时数据，如哈希码，GC分代年龄，锁标记，线程持有的锁，偏向线程ID，偏向时间戳等。考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构，它会根据对象的状态来复用自己的内存空间。例如，在32位的虚拟机中，如果对象处于未被锁定的情况下，那么 Mark Word的32bit空间中的25bit用于储存哈希码，4bit用于储存对象分代年龄，2bit储存锁标志，1bit固定为0。</li>
<li>对象头的另一部分为类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><ul>
<li>实例数据为对象真正储存的有效信息，也是代码中所定义的各种类型的字段内容。</li>
</ul>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><ul>
<li>对齐填充不是必然存在的，它仅仅起到占位符的作用</li>
<li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。</li>
<li>对象头部分正好是8字节的倍数。</li>
<li>当实例数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ul>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><ul>
<li>Java程序需要通过栈上的reference数据来操作堆上的具体对象。</li>
<li>目前主流的访问方法有使用句柄和直接指针两种。</li>
<li>如果使用句柄的话，那么Java堆将划分出一块内存来作为句柄池，reference中储存的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</li>
</ul>
<p><img src="/uploads/jvm/java内存区域/句柄指针.png" alt=""></p>
<ul>
<li><p>如果使用指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中储存的直接就是对象地址。<br><img src="/uploads/jvm/java内存区域/直接指针.png" alt=""></p>
</li>
<li><p>两种访问方式的优缺：</p>
<ul>
<li>使用句柄的最大好处就是reference中储存的是稳定的句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference不需要修改。</li>
<li>直接使用指针的最大好处就是速度更快，它节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="JVM" scheme="http://cristianoro7.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://cristianoro7.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
