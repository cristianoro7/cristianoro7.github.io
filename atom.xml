<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Desperado</title>
  <subtitle>Do one thing every day that scares you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cristianoro7.github.io/"/>
  <updated>2018-03-02T08:28:53.283Z</updated>
  <id>http://cristianoro7.github.io/</id>
  
  <author>
    <name>Desperado</name>
    <email>424494431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP连接管理</title>
    <link href="http://cristianoro7.github.io/2018/03/02/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2018/03/02/TCP连接管理/</id>
    <published>2018-03-02T08:28:53.283Z</published>
    <updated>2018-03-02T08:28:53.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li><p>TCP连接</p>
</li>
<li><p>TCP连接释放</p>
</li>
<li><p>TCP三次握手的原因</p>
</li>
<li><p>初始序号的选择</p>
</li>
<li><p>同时打开和关闭</p>
</li>
<li><p>连接建立超时</p>
</li>
<li><p>TIME-WAIT</p>
</li>
</ul>
<blockquote>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm8jblqwjvj30kl0fc3zp.jpg" alt=""></p>
<p>上图为TCP连接建立的过程</p>
<p>TCP服务器进程首先创建传输控制块,准备接收客户端进程的连接请求.</p>
<p><code>TCP</code>客户端进程首先创建传输控制块, 然后向<code>TCP</code>服务器发送连接请求的报文段,此时首部标志位<code>SYN = 1</code>,同时选择一个初始序号<code>seq = x</code>. <code>TCP</code>规定,<code>SYN</code>报文段不能携带数据,但要也要消耗一个序号.这次TCP客户端进程进入SYN-SEND状态.</p>
<p><code>TCP</code>服务器收到连接请求后, 如同意连接, 则向客户端发送确认. 并且为<code>TCP</code>连接分配缓存和变量. 在确认的报文段中<code>SYN</code>和<code>ACK</code>都置为1,确认号<code>ack = x + 1</code>, 同时也为自己选定一个初始序号<code>seq = y</code>.注意:这个报文段也不能携带数据,但是要消耗一个序号.此时<code>TCP</code>服务器进入<code>SYN-RCVD</code>状态.</p>
<p><code>TCP</code>客户端收到服务器的确认后, 还要向服务器发送<code>ACK</code>确认, 然后为<code>TCP</code>连接分配缓存和变量. 确认的报文段的<code>ACK</code>置1,确认号<code>ack = y+1</code>,而自己的序号<code>seq = x + 1</code>. 注意:<code>ACK</code>报文可以携带数据.如果不携带数据就不用消耗序号.此时<code>TCP</code>连接已经建立.客户端进入<code>ESTALISHED</code>状态.</p>
<p>当服务器收到客户端的<code>ACK</code>确认后, 也进入<code>ESTABLISHED</code>状态.</p>
<p>上面的连接建立过程叫做三次握手.</p>
<blockquote>
<p>注意: TCP连接前两次握手是不可以携带数据的. 因为此时双方都还没准备好缓存和变量. 第三次握手是可以携带数据的, 因为此时双方的缓存和变量已经分配好了.</p>
</blockquote>
<p><br></p>
<blockquote>
<p>关于服务端缓存变量分配的时机. 为了防止SYN攻击. 服务端通常会维护一个半连接队列. 如果该队列没满的话, 收到一个连接请求时, 会为该连接发送一个SYNACK报文并且分配缓存和变量. 如果这个队列满后, 服务端为了防止SYN攻击, 是不会为该连接请求分配缓存和变量. 它会先将源和目的IP和端口经过一个hash函数后得到一个数(称为cookie), 然后将这个数作为服务端的初始序号发送给客户端. 如果此时客户端不是恶意攻击的话, 它会返回会一个ACK报文. 然后服务端将初始序号-1, 得到上次发送的Cookie, 最后经过解析, 得到源和目的端口和IP, 最后分配缓存和变量.</p>
</blockquote>
<p><br></p>
<blockquote>
<h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm8jbxmhz5j30lp0mtgnk.jpg" alt=""></p>
<p>上图为TCP连接释放过程</p>
<p><code>TCP</code>客户端的应用首先让其<code>TCP</code>发出连接释放的报文段, 并停止发送数据,主动关闭连接.客户端把连接释放报文段首部<code>FIN</code>置为1,其序号<code>seq = u</code>.这时客户端进入<code>FIN-WAIT-1</code>状态,等待<code>TCP</code>服务器的确认.注意:<code>FIN</code>报文段即使不携带数据也要消耗一个序号.</p>
<p><code>TCP</code>服务器收到连接释放的请求后即发出确认,确认号为<code>ack = u + 1</code>,而这个报文段的序号为<code>y</code>.然后服务器进入<code>CLOSE-WAIT</code>状态. <code>TCP</code>服务器此时通知应用进程, 因此客户端到服务器的连接已经释放掉了,即客户端到服务器的这条连接已经没有数据要发送了. 这时<code>TCP</code>连接处于半释放状态. 但A仍然接收数据,因为服务器到客户端的连接还没有释放.</p>
<p>客户端收到服务器的确认后.进入<code>FIN-WAIT-2</code>状态,等待服务器发送连接释放报文段, 以此来关闭服务器到客户端的这条连接.</p>
<p>若服务器已经没有数据要发送了, 其应用进程会通知<code>TCP</code>释放连接.这时服务器发出的来连接释放报文段必须时<code>FIN</code>被置1. 这时服务器就进入了<code>LAST-ACK</code>状态,等待客户端的确认.</p>
<p>客户端收到服务器的连接释放报文后,必须对此报文发出确认<code>ACK</code>. 然后进入<code>TIME-WAIT</code>状态. 现在<code>TCP</code>连接还没有释放.必须经过时间等待计时器设置的时间2MSL后, 客户端才进入<code>CLOSED</code>状态.</p>
<p>上面的连接释放过程也称为4次挥手.</p>
<blockquote>
<h3 id="TCP三次握手的原因"><a href="#TCP三次握手的原因" class="headerlink" title="TCP三次握手的原因"></a>TCP三次握手的原因</h3></blockquote>
<p><code>TCP</code>连接为什么是3次? 而不是2次, 1次或者是大于3次?</p>
<p>回答这个问题, 可以从下面的两个角度来考虑.</p>
<ul>
<li><p>可靠性: 确保双方都收到连接建立的请求.</p>
</li>
<li><p>高效性: 在确保可靠的情况下, 也需要注重一下性能的问题.</p>
</li>
</ul>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性:"></a>可靠性:</h4><p>三次握手的原因是为了防止延迟的客户端连接请求报文段传送到服务器,因此产生错误.</p>
<p>现在假定客户端发送出去的第一个连接请求报文段在某些网络结点长时间滞留了,以致延误到连接释放后的某个时间才到达服务器. 本来这个是一个已经失效的报文段.但是服务器收到此有效的报文段后, 就误认为客户端又发出了<br>一次连接请求. 于是向客户端发送确认报文段,同意建立连接. 如果假设不采用三次握手, 那么服务器发出确认, 新的连接就建立了. 由于客户端并没有发出建立连接的请求, 因此不理睬服务器的确认, 也不会向服务器发送数据. 但服务器却以为新的连接已经建立,一直等待客户端发送数据.这样服务器的许多资源就白白浪费了.</p>
<p>如果采用三次握手的话, 客户端不会向服务器发出确认.服务器由于收不到确认, 过一定的时间后, 就会释放缓存和变量等资源.</p>
<h4 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h4><p>从表面上看: TCP建立时, 需要告知双方的初始序号. 为了保证可靠性, 发送方发送一个初始序号给接收方, 然后接收方发送一个<code>ACK</code>来表示请求接收到. 这样一来一回, 总共需要4次握手. 那么为什么<code>TCP</code>是3次? 这是因为接收方把<code>SYN</code>和<code>ACK</code>一起发送出去了. 这样就把4次握手优化为3次握手. 因此为了保证高效性, 3次握手就可以保证连接已经连接. 不必再协商4次或者5次握手.</p>
<blockquote>
<h3 id="初始序号的选择"><a href="#初始序号的选择" class="headerlink" title="初始序号的选择"></a>初始序号的选择</h3></blockquote>
<p>在一个连接中, 报文段可能会存在延迟到达的问题, 这样延迟到达的报文段有可能会被同一个连接的另外一个实例给错误的接收了. 为了解决这个问题, 需要仔细选择初始序号.</p>
<p>[RFC0793]指出初始序号可以看做是一个32位的计数器. 该计数器每4微妙加1. 这样做的目的是为了防止一个连接的序号与其他连接的序号重叠. 尤其是同一个连接的不同实例.</p>
<blockquote>
<h3 id="同时打开和同时关闭"><a href="#同时打开和同时关闭" class="headerlink" title="同时打开和同时关闭"></a>同时打开和同时关闭</h3></blockquote>
<p>假如主机A的一个应用程序通过本地端口7777向主机B的8888端口发出一个主动连接的请求, 于此同时, 主机B通过8888端口向主机A的7777端口发送一个主动连接的请求. 这种情况称为同时打开. 同时打开需要交换4个报文, 并且没有客户端和服务器之分. 同时关闭跟同时打开没有太大区别. 下面是同时关闭和打开的示意图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm9fdgmqatj30bb0ntdgs.jpg" alt=""></p>
<blockquote>
<h3 id="连接建立超时"><a href="#连接建立超时" class="headerlink" title="连接建立超时"></a>连接建立超时</h3></blockquote>
<p>当客户端主动发起一个<code>TCP</code>连接时, 如果在规定的时间没有收到对方的回应的话, 客户端会重新发送<code>SYN</code>报文.</p>
<p>发送的时间间隔规律: 每一次重试的时间会前一个的2倍.</p>
<blockquote>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME-WAIT"></a>TIME-WAIT</h3></blockquote>
<p>主动关闭的一方收到被动关闭的<code>FIN</code>报文段时, 会进入<code>TIME-WAIT</code>状态, 该状态的语义: 等待<code>2MSL</code>的时间后才进入<code>CLOSE</code>状态.</p>
<p><code>MSL</code>是报文段的最大生存时间. [RFC0793]将<code>MSL</code>设置为2分钟. 然而在实际的实现中, <code>MSL</code>可被设置为30秒, 1分钟.</p>
<p><code>TIME-WAIT</code>状态存在的原因:</p>
<ul>
<li><p>确保发送<code>ACK</code>能够被对方收到. 这样在最后发送的<code>ACK</code>丢失的话, 被动关闭方会重发<code>FIN</code>报文. 此时处于<code>TIME-WAIT</code>状态的主动关闭方可以重传<code>ACK</code>. 如果没有该状态的话, 当被动关闭方重传<code>FIN</code>时, 主动关闭方是不能识别该报文的.</p>
</li>
<li><p>防止延迟失效的报文段被相同的连接给接收. 假设有A发送给B的报文被延迟了, 然后A断开和B的连接, 接着又以相同的<code>IP</code>和端口进行重连. 此时延迟失效的报文就有可能被新的连接给接收. 如果有<code>TIME-WAIT</code>这个状态的话, 等待<code>2MSL</code>后, 所有延迟的报文都会失效, 因此在新的连接中不会收到延迟的报文.</p>
</li>
</ul>
<h4 id="TIME-WAIT产生的影响"><a href="#TIME-WAIT产生的影响" class="headerlink" title="TIME-WAIT产生的影响"></a>TIME-WAIT产生的影响</h4><p>由于处于<code>TIME-WAIT</code>状态的连接(客户端ip和端口 服务器ip和端口)是不可用的. 所以当主机处于该状态时, 会对主机有一定的影响.</p>
<ul>
<li><p>对服务器: 一般而言, 服务器都是使用一些系统端口(例如HTTP使用80端口), 所以当服务器关闭后, 是不能被立刻重启的, 因为端口处于<code>TIME-WAIT</code>状态, 必须等待2<code>MSL</code>后才能重启.</p>
</li>
<li><p>对客户端: 一般而言, 该状态对客户端是没什么影响的, 因为客户端的并发连接数不多, 并且端口都是操作系统随机分配的. 但是如果客户端在短时间内向同一个服务器建立大量连接后断开, 此时就有可能出现端口耗尽. 因为客户端短时间出现了大量的<code>TIME-WAIT</code>状态. 处于<code>TIME-WAIT</code>状态的端口是不能被使用的, 由于无法找到新的端口来建立新的连接, 因此会出现端口耗尽的现象.</p>
</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></blockquote>
<ul>
<li><p>计算机网络(谢希仁)</p>
</li>
<li><p>计算机网络-自顶向下的方法</p>
</li>
<li><p>TCP/IP协议详解</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP连接管理&quot;&gt;&lt;a href=&quot;#TCP连接管理&quot; class=&quot;headerlink&quot; title=&quot;TCP连接管理&quot;&gt;&lt;/a&gt;TCP连接管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://cristianoro7.github.io/2018/01/19/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://cristianoro7.github.io/2018/01/19/Class类文件结构/</id>
    <published>2018-01-19T12:47:25.812Z</published>
    <updated>2018-01-19T12:47:25.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>Class类文件结构<ul>
<li>特殊字符串概念</li>
<li>魔数与Class文件的版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引,父类索引与接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="类文件结构-1"><a href="#类文件结构-1" class="headerlink" title="类文件结构"></a>类文件结构</h3></blockquote>
<ul>
<li>Class文件结构只有两种数据类型:无符号数和表.</li>
</ul>
<p>无符号数属于基本的数据类型,以<code>u1</code>, <code>u2</code>, <code>u4</code>, <code>u8</code>分别代表1个字节,2个字节,4个字节和8个字节的无符号数,它用来描述数字,索引引用,数量值或者UTF-8编码构成字符串值.<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型,所有表都习惯以<code>_info</code>结尾.</p>
<p>整个<code>class</code>文件本质就是一张表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u4</code></td>
<td style="text-align:center"><code>magic</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>minor_version</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>major_version</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>constant_pool_count</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>cp_info</code></td>
<td style="text-align:center"><code>constant_pool</code></td>
<td style="text-align:center"><code>constant_pool_count</code>-1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>access_flag</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>this_class</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>super_class</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>interface_count</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>interface</code></td>
<td style="text-align:center"><code>interface_count</code></td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>fields_count</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>field_info</code></td>
<td style="text-align:center"><code>fields</code></td>
<td style="text-align:center"><code>fields_count</code></td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>methods_count</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>method_info</code></td>
<td style="text-align:center"><code>methods</code></td>
<td style="text-align:center"><code>methods_count</code></td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>attributes_count</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>attribute_info</code></td>
<td style="text-align:center"><code>attributes</code></td>
<td style="text-align:center"><code>attributes_count</code></td>
</tr>
</tbody>
</table>
<h4 id="特殊字符串的概念"><a href="#特殊字符串的概念" class="headerlink" title="特殊字符串的概念"></a>特殊字符串的概念</h4><ul>
<li><p>全限定名: 把类的全名中的<code>.</code>替换成<code>/</code>,最后再加上<code>;</code></p>
</li>
<li><p>简单名称: 没有类型和参数修饰的方法或者字段名称.</p>
</li>
<li><p>方法和字段的描述符: 描述符的作用是用来描述字段的数据类型,方法参数列表和返回值.</p>
</li>
<li><p>描述符标识字符含义:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">标识字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>B</code></td>
<td style="text-align:center">基本类型<code>byte</code></td>
</tr>
<tr>
<td style="text-align:center"><code>C</code></td>
<td style="text-align:center">基本类型<code>char</code></td>
</tr>
<tr>
<td style="text-align:center"><code>D</code></td>
<td style="text-align:center">基本类型<code>double</code></td>
</tr>
<tr>
<td style="text-align:center"><code>F</code></td>
<td style="text-align:center">基本类型<code>float</code></td>
</tr>
<tr>
<td style="text-align:center"><code>I</code></td>
<td style="text-align:center">基本类型<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>J</code></td>
<td style="text-align:center">基本类型<code>long</code></td>
</tr>
<tr>
<td style="text-align:center"><code>S</code></td>
<td style="text-align:center">基本类型<code>short</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Z</code></td>
<td style="text-align:center">基本类型<code>boolean</code></td>
</tr>
<tr>
<td style="text-align:center"><code>V</code></td>
<td style="text-align:center">特殊类型<code>void</code></td>
</tr>
<tr>
<td style="text-align:center"><code>L</code></td>
<td style="text-align:center">对象类型</td>
</tr>
</tbody>
</table>
<h4 id="魔数与Class文件版本"><a href="#魔数与Class文件版本" class="headerlink" title="魔数与Class文件版本"></a>魔数与Class文件版本</h4><ul>
<li><p>每个<code>Class</code>文件的头4个字节称为魔数,它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件.</p>
</li>
<li><p>紧接魔数后面的4个字节储存的是<code>Class</code>文件的版本号: 第5,6个字节是此版本号<code>(Minor Version)</code>,第7和第8个字节是主版本号. <code>JDK</code>的版本号是从45开始的.</p>
</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li><p>常量池可以理解为<code>Class</code>文件之中的资源仓库,它同时是<code>Class</code>文件关联其他项目最多的数据类型,也是占用<code>Class</code>文件空间最大的数据项目之一.</p>
</li>
<li><p>由于常量池中的常量是不固定的,所以需要在常量池入口放置一项<code>u2</code>类型的数据,代表常量池容量计数值.</p>
</li>
<li><p>常量池中主要储存两大类常量:字面量和符号引用．字面量比较接近<code>Java</code>语言层面的常量概念,如字符串,声明为<code>final</code>常量值等. 而符号引用则属于编译原理方面的概念,主要包含了下面三类常量:</p>
<ul>
<li><p>类和接口的全称限定名</p>
</li>
<li><p>字段的名称和描述符</p>
</li>
<li><p>方法的名称和描述符</p>
</li>
</ul>
</li>
<li><p>常量池的项目类型:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">标志</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>CONSTANT_Utf_info</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>UTF-8</code>编码的字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_Integer_info</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">整型字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_Float_info</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_Long_info</code></td>
<td style="text-align:center">5</td>
<td style="text-align:center">长整类型字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_Double_info</code></td>
<td style="text-align:center">6</td>
<td style="text-align:center">双精度浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_Class_info</code></td>
<td style="text-align:center">7</td>
<td style="text-align:center">类或接口的符号引用</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_String_info</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">字符串类型字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_Fieldref_info</code></td>
<td style="text-align:center">9</td>
<td style="text-align:center">字段的符号引用</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_Methodref_info</code></td>
<td style="text-align:center">10</td>
<td style="text-align:center">类中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_InterfaceMethodref_info</code></td>
<td style="text-align:center">11</td>
<td style="text-align:center">接口中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_NameAndType_info</code></td>
<td style="text-align:center">12</td>
<td style="text-align:center">字段或者方法的部分符号引用</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_MethodHandle_info</code></td>
<td style="text-align:center">15</td>
<td style="text-align:center">表示方法句柄</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_MethodType_info</code></td>
<td style="text-align:center">16</td>
<td style="text-align:center">标识方法类型</td>
</tr>
<tr>
<td style="text-align:center"><code>CONSTANT_InvokeType_info</code></td>
<td style="text-align:center">18</td>
<td style="text-align:center">表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><ul>
<li><code>access_flags</code>用于识别一些类或者接口层次的访问信息.例如:这个<code>class</code>是类还是接口;是否定义为<code>public</code>类型;是否定义为<code>abstract</code>类型等. 具体标记:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">标志名称</th>
<th style="text-align:center">标志值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ACC_PUBLIC</code></td>
<td style="text-align:center">0x0001</td>
<td style="text-align:center">是否为<code>public</code>类型</td>
</tr>
<tr>
<td style="text-align:center"><code>ACC_FINAL</code></td>
<td style="text-align:center">0x0010</td>
<td style="text-align:center">是否被声明为<code>final</code>,只有类可设置</td>
</tr>
<tr>
<td style="text-align:center"><code>ACC_SUPER</code></td>
<td style="text-align:center">0x0020</td>
<td style="text-align:center">是否允许使用<code>invokespecial</code>字节码指令新语意</td>
</tr>
<tr>
<td style="text-align:center"><code>ACC_INTERFACE</code></td>
<td style="text-align:center">0x0200</td>
<td style="text-align:center">标识这是一个接口</td>
</tr>
<tr>
<td style="text-align:center"><code>ACC_ABSTRACT</code></td>
<td style="text-align:center">0x0400</td>
<td style="text-align:center">是否为<code>abstact</code>类型, 对于接口或者抽象类来说, 这个标志为真,其他值为假</td>
</tr>
<tr>
<td style="text-align:center"><code>ACC_SYNTHETIC</code></td>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">标识这个类并非由用户代码生成</td>
</tr>
<tr>
<td style="text-align:center"><code>ACC_ANNOTION</code></td>
<td style="text-align:center">0x2000</td>
<td style="text-align:center">标识这是一个注解</td>
</tr>
<tr>
<td style="text-align:center"><code>ACC_ENUM</code></td>
<td style="text-align:center">0x4000</td>
<td style="text-align:center">标识这个一个枚举</td>
</tr>
</tbody>
</table>
<h4 id="类索引-父类索引与接口索引集合"><a href="#类索引-父类索引与接口索引集合" class="headerlink" title="类索引,父类索引与接口索引集合"></a>类索引,父类索引与接口索引集合</h4><ul>
<li><p>类索引用于确定这个类的全限定名</p>
</li>
<li><p>父类索引用于确定这个类的父类的全限定名</p>
</li>
<li><p>接口索引集合用于描述这个类实现了哪些接口</p>
</li>
</ul>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><ul>
<li><p>字段表集合用于描述接口或者类中声明的变量.</p>
</li>
<li><p>字段包括类级变量和实例级变量, 但不包括在方法内的局部变量</p>
</li>
<li><p>字段表结构:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>access_flags</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>name_index</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>descriptor</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>attributes_count</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>attribute_info</code></td>
<td style="text-align:center"><code>attributes</code></td>
<td style="text-align:center"><code>attributes_count</code></td>
</tr>
</tbody>
</table>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><ul>
<li>方法表结构:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>access_flags</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>name_index</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>descriptor</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>u2</code></td>
<td style="text-align:center"><code>attributes_count</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><code>attribute_info</code></td>
<td style="text-align:center"><code>attributes</code></td>
<td style="text-align:center"><code>attributes_count</code></td>
</tr>
</tbody>
</table>
<ul>
<li>方法表集合结构跟字段表结构大致相同</li>
<li>如果父类分方法没有被子类重写,方法表集合中就不会出现父类方法的信息.</li>
</ul>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><ul>
<li><p>在<code>Class</code>文件, 字段表, 方法表都可以携带自己的属性表集合, 用于描述特定场景的专有信息.</p>
</li>
<li><p>虚拟机规范预定义的属性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Code</code></td>
<td>方法表</td>
<td style="text-align:center"><code>Java</code>代码编译成的字节码指令</td>
</tr>
<tr>
<td><code>ConstantValue</code></td>
<td>字段表</td>
<td style="text-align:center"><code>final</code>关键字定义的常量值</td>
</tr>
<tr>
<td><code>Deprecated</code></td>
<td>类,方法表字段表</td>
<td style="text-align:center">被声明为<code>deprecated</code>的方法和字段</td>
</tr>
<tr>
<td><code>Exceptions</code></td>
<td>方法表</td>
<td style="text-align:center">方法抛出的异常</td>
</tr>
<tr>
<td><code>EncloseingMethod</code></td>
<td>类文件</td>
<td style="text-align:center">仅当一个类为局部类或者匿名类时才能拥有这个属性,这个属性用于标识这个类所在的外围方法.</td>
</tr>
<tr>
<td><code>InnerClasses</code></td>
<td>类文件</td>
<td style="text-align:center">内部类列表</td>
</tr>
<tr>
<td><code>LineNumberTable</code></td>
<td><code>Code</code>属性</td>
<td style="text-align:center">Java源码的行号与字节码指令对应的关系</td>
</tr>
<tr>
<td><code>LocalVariableTable</code></td>
<td><code>Code</code>属性</td>
<td style="text-align:center">方法的局部属性描述</td>
</tr>
<tr>
<td><code>StackMapTable</code></td>
<td><code>Code</code>属性</td>
<td style="text-align:center"><code>JDK1.6</code>中新增的属性, 供新的类型检查验证器检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配.</td>
</tr>
<tr>
<td><code>Signature</code></td>
<td>类,方法表,字段表</td>
<td style="text-align:center">用于支持泛型情况下的方法签名, 记录这泛型中的相关信息.</td>
</tr>
<tr>
<td><code>SourceFile</code></td>
<td>类文件</td>
<td style="text-align:center">记录源文件的名称</td>
</tr>
<tr>
<td><code>SourceDebugFile</code></td>
<td>类文件</td>
<td style="text-align:center">储存额外的调试信息</td>
</tr>
<tr>
<td><code>Synthetic</code></td>
<td>类, 方法表, 字段表</td>
<td style="text-align:center">标识方法和字段为编译器生成</td>
</tr>
<tr>
<td><code>LocalVariableTypeTable</code></td>
<td>类</td>
<td style="text-align:center">为了引入泛型语法之后能够描述泛型参数化类型而添加的</td>
</tr>
<tr>
<td><code>RuntimeVisibleAnnotations</code></td>
<td>类, 方法表,字段表</td>
<td style="text-align:center">为动态注解提供支持, 用于指定哪些注解运行时是可见的</td>
</tr>
<tr>
<td><code>RuntimeInvisibleAnnotations</code></td>
<td>类, 方法表, 字段表</td>
<td style="text-align:center">与<code>RuntimeVisibleAnnotations</code>的作用相反</td>
</tr>
<tr>
<td><code>RuntimeVisibleParameterAnnotations</code></td>
<td>方法表</td>
<td style="text-align:center">与<code>RuntimeVisibleAnnotations</code>的作用相似</td>
</tr>
<tr>
<td><code>RuntimeInvisibleParameterAnnotations</code></td>
<td>方法表</td>
<td style="text-align:center">与<code>RuntimeInvisibleAnnotations</code>的作用相似</td>
</tr>
<tr>
<td><code>AnnotationDefault</code></td>
<td>方法表</td>
<td style="text-align:center">记录注解类的默认值</td>
</tr>
<tr>
<td><code>BootstrapMethods</code></td>
<td>类文件</td>
<td style="text-align:center">用于保存<code>invokedynamic</code>指令引用的引导方法限定符</td>
</tr>
</tbody>
</table>
<p>待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类文件结构&quot;&gt;&lt;a href=&quot;#类文件结构&quot; class=&quot;headerlink&quot; title=&quot;类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#JVM" scheme="http://cristianoro7.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收器</title>
    <link href="http://cristianoro7.github.io/2018/01/19/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://cristianoro7.github.io/2018/01/19/java垃圾回收器/</id>
    <published>2018-01-19T11:19:26.721Z</published>
    <updated>2018-01-19T11:19:26.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>判定对象存活<ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
<li>再谈引用<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
</li>
<li>生存还是死亡</li>
<li>回收方法区</li>
</ul>
</li>
<li>垃圾收集算法<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-整理算法</li>
<li>分代收集算法</li>
</ul>
</li>
<li>HotSpot的算法实现<ul>
<li>枚举根节点</li>
<li>安全点</li>
<li>安全区域</li>
</ul>
</li>
<li>垃圾收集器<ul>
<li>Serial收集器</li>
<li>ParNew收集器</li>
<li>Parallel收集器</li>
<li>Serial Old 收集器</li>
<li>Parallel Old 收集器</li>
<li>CMS收集器</li>
<li>G1收集器</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="判定对象的存活"><a href="#判定对象的存活" class="headerlink" title="判定对象的存活"></a>判定对象的存活</h3></blockquote>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li>给一个对象添加一个计数器,每当有一处地方引用对象时,计数器值加1; 当引用失效时, 计数器值就减1; 任何时刻计数器为0对象就是不可能再被使用的.</li>
<li>引用计数算法最大的缺点就是很难解决对象之间的循环引用.</li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li>通过一系列的称为 “ GC Root “ 对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链, 当一个对象到” GC Root “ 没有任何引用链相连时,则证明此对象是不可用的.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收-1.png" alt=""></p>
<ul>
<li>在Java语言中, 可作为 GC Root的对象包括下面几种:<ul>
<li>虚拟机栈(栈帧中的本地变量表)引用的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(一般指Native方法)引用的对象</li>
</ul>
</li>
</ul>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK1.2后,Java对引用进行了扩充,将引用分强引用, 软引用, 弱引用和虚引用四种.</p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>程序代码中普遍存在的,类似”Object obj = new Object()”这类引用, 只要强引用存在的话, 对象就永远不会被回收</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用用于描述一些还有用但是又是非必需对象. 对于软引用关联着的对象, 在系统将要发生内存溢出之前, 将会把对象列进回收范围之中进行第二次回收, 如果这次回收没有足够的内存,才抛出内存溢出异常</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用也是用来描述非必需对象, 但是它的强度比软引用弱一些, 被弱引用关联的对象只能生存到下次垃圾收集发生之前.<br>当垃圾收集器工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象.</p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><ul>
<li>它是最弱的一种引用关系.</li>
<li>一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象的实例</li>
<li>一个对象虚引用关联的目的就是这个对象被收集器回收时收到一个系统通知.</li>
</ul>
<h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><ul>
<li>一个对象需要至少经历两次标记才能宣告死亡</li>
<li>如果一个对象在可达性分析后发现没有GC Roots相连接时, 那么它第一次被标记并且进行一次筛选, 筛选的条件是该对象是否有必要执行finalize()方法.当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过一次, 这两种情况虚拟机都是视为不必要调用.</li>
<li>如果这个对象被判定为需要执行finalize()方法的话, 那么对象将会被放置在F-Queue队列中, 稍后虚拟机会启动一个优先级较低的线程去执行它.</li>
<li>执行finalize()方法时, 虚拟机并不会等待它执行结束, 这样做是为了避免执行finalize()方法缓慢或者发生死循环. 这样可能会导致F-Queue队列中的对象处于永久等待中,甚至导致整个内存回收崩溃.</li>
<li>finalize()方法是对象逃脱死亡命运的最后一次机会, GC会在finalize()中进行第二次小规模的标记, 如果对象被第二次标记后,那么就宣告了一个对象的死亡.</li>
</ul>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><ul>
<li>方法区的回收主要回收两部分内容:废弃常量和无用的类.</li>
<li>回收废弃常量和回收Java堆很相似.例如: 字符串 “abc” 已经进入了常量池, 但是当前系统没有一个String对象叫做”abc”的,也就是没有任何String对象引用常量池之中的”abc”, 如果这时候发生内存回收, 而且必要的话, 这个”abc”会被清除出常量池.常量池中的其他类(接口),方法,字段的符号引用也与此类似.</li>
<li>一个类被视为无用的条件<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用, 无法通过反射获取类的方法.</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3></blockquote>
<h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><ul>
<li>首先标记出所有需要回收的对象,在完成标记后统一回收所有被标记的对象</li>
<li>不足的地方<ul>
<li>效率问题, 标记和清除的两个过程效率都不是很高</li>
<li>空间问题, 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时, 无法找到足够的连续内存而不得不提前触发另外一次GC</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/mark-sweep.png" alt=""></p>
<h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><ul>
<li>复制算法是为了解决标记-清除算法的效率问题而出现的</li>
<li>它将内存按照容量划分为相等的两块, 每次只用其中一块.当这一块内存快用完了, 就将还存活的对象复制到另一块内存,然后再把空间一次清理掉</li>
<li>复制算法的代价是将内存空间缩小为原来的一半.</li>
<li>HotSpot虚拟机默认Eden和Survivor的大小比例为8:1,只有10%的内存空间会被浪费.</li>
<li>如果另外一块Survivor空间没有足够的内存放上次新生代存活下来的对象时, 这些对象将直接通过分配担保直接进入老年代.</li>
<li>使用于对象存活率低的场景, 例如新生代.</li>
</ul>
<h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><ul>
<li><p>复制算法在对象存活率高时就要进行较多的复制操作, 效率会变低.</p>
</li>
<li><p>如果不想浪费50%的空间的话, 就需要额外的空间进行担保, 以应对所有对象都存活的极端场景.</p>
</li>
<li><p>标记过程仍然与”标记-清除”算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉边界以外的内存.</p>
</li>
<li><p>该算法适用于老年代.</p>
</li>
<li><p>该算法解决了<code>标记-清除</code>算法的内存碎片问题.</p>
</li>
</ul>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ul>
<li>一般将Java堆划分为新生代和老年代, 这样就可以根据各个年代的特点采用适当的算法</li>
<li>在新生代中,每次GC时,都发现大量对象死去, 只有少量对象存活, 那就选用复制算法.</li>
<li>而老年代中因为对象的存活率高, 没有额外的空间进行担保,就必须使用”标记-清除”或者”标记-整理”.</li>
</ul>
<blockquote>
<h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3></blockquote>
<p>在HotSpot上实现垃圾收集算法, 必须对算法的执行效率必须经过严格的考证, 才能保证虚拟机的执行效率</p>
<h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><ul>
<li><p>利用可达性算法来判定对象的存活, 首先得找出所有的全局引用, 也就是<code>GC-Root</code>.</p>
</li>
<li><p>另外, 可达性分析这项工作必须在一个一致性的快照中进行(引用关系不变), 这样才能够保证分析结果的准确性.</p>
</li>
<li><p>目前主流的Java虚拟机使用的都是标准式的GC, 所以当执行系统停顿下来时, 并不需要一个不漏的检查完所有执行上下文和全局的引用位置, 虚拟机使用一组称为OopMap的数据结构来得知哪些地方存放着对象引用.</p>
</li>
</ul>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><ul>
<li><p>HotSpot没有为每条指令都生成OopMap, 它只是在特定的位置记录了”这些信息”,这些位置被称为安全点(Safepoint),即程序并非在所有的地方都能停下来GC, 只有在安全点时才能停下来</p>
</li>
<li><p>安全点的选定基本上是以程序”是否具有让程序长时间执行的特征”为标准选定.”长时间执行”的最明显特征就是指令序列复用,例如方法调用,循环引用,循环跳转,异常跳转等,具有这些功能的指令才会生成Safepoint.</p>
</li>
<li><p>对于Safepoint,需要考虑的另外一个问题是如何让GC发生时停止所有线程时,所有线程都跑到安全点. 这里有两种方案可供选择:抢先式中断和主动式中断.</p>
<ul>
<li><p>抢先式中断不需要线程的配合,在发生GC时,首先把所有线程全部中断,如果发现有线程中断在不安全点上, 就恢复线程,让它跑到安全点上. 现在几乎没有虚拟机是这样实现的.</p>
</li>
<li><p>主动式的中断是思想是当GC需要中断线程的时候, 不直接对线程进行操作,仅仅简单的设置一个标志, 各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己挂起.轮询标志的地方和安全点是重合的.</p>
</li>
</ul>
</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><ul>
<li><p>安全区域是指在一段代码之中,引用关系不会发生变化. 在这个区域中的任何地方开始GC都是安全的.</p>
</li>
<li><p>线程执行到Safe Region时, 首先标识自己已经进入安全区域, 那样当在这段时间内JVM要发起GC时,就不用管已经标识为安全区域状态的线程. 在线程要离开安全区域时, 它首先要检查系统是否已经完成了根节点枚举, 如果完成了,就继续执行,否则它就要等到收到安全离开的信号为止.</p>
</li>
</ul>
<blockquote>
<h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></blockquote>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收器.png" alt=""></p>
<h4 id="Senial-收集器"><a href="#Senial-收集器" class="headerlink" title="Senial 收集器"></a>Senial 收集器</h4><ul>
<li>Serial 收集器在进行垃圾回收时,必须暂停其他所有的工作线程,直到它收集结束</li>
<li>下面是Serial/Serial Old收集器的工作过程</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/Serial.png" alt=""></p>
<ul>
<li>优点: 简单高效, 对于限定单CPU的环境来说, Serial收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率.</li>
<li>使用场景: 在用户的桌面应用场景中, 分配给虚拟机管理内存不会很大, 停顿时间可控制在10几到100多毫秒, 只要不频繁发生,这点的停顿还是可以接受的. 因此, Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择.</li>
</ul>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><ul>
<li>ParNew收集器其实就是多线程版本的Serial收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParNew.png" alt=""></p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul>
<li>Parallel Scavenge收集器的特点是它关注点与其他的收集器不同, CMS等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间, 而Parallel Scavenge收集器目的是达到一个可控的吞吐量, 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值.</li>
<li>停顿时间越短越适合需要与用户交互的程序; 高吞吐量则可以高效率地利用CPU时间, 尽快完成程序运算任务, 主要适合后台运算而不需要太多交互的任务.</li>
</ul>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ul>
<li>Serial Old是Serial收集器的老年代版本, 使用”标记-整理”算法, 这个收集器的主要意义是给Client模式下的虚拟机使用.</li>
<li>如果在Server模式下, 那么它有两大主要用途:<ul>
<li>在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用.</li>
<li>作为CMS收集器的后备预案,在并发收集发生 Concurrent Mode Failure时使用.</li>
</ul>
</li>
</ul>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ul>
<li>Parallel Old 是Parallel Scavenge收集器的老年代版本.</li>
<li>在吞吐量以及CPU资源敏感的场合, 都可以优先考虑Parallel Scavenge加Parallel Old收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParallelOld.png" alt=""></p>
<h4 id="CMS-收集器-Concurrent-Mark-Sweep"><a href="#CMS-收集器-Concurrent-Mark-Sweep" class="headerlink" title="CMS 收集器(Concurrent Mark Sweep)"></a>CMS 收集器(Concurrent Mark Sweep)</h4><ul>
<li>CMS收集器是一种以获取最短回收停顿时间为目标的收集器.</li>
<li>CMS 收集器是基于 “标记-清除”算法实现,整个过程分为4个步骤:<ul>
<li>初始化标记:仅仅只是标记一下GC Roots能直接关联到的对象, 速度很快.</li>
<li>并发标记:进行GC Roots Tracing的过程.</li>
<li>重新标记:为了修正并发标记期间因用户程序继续运行导致标记产生变动的那一部分对象标记记录,这个阶段的停顿时间一般会比初始化阶段稍微长一些,但远比并发标记的时间短.</li>
<li>并发清除: 清除标记.</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/cms.png" alt=""></p>
<ul>
<li><p>CMS 收集器明显的3个缺点:</p>
<ul>
<li><p>CMS收集器对CPU资源非常敏感,在并发阶段,它虽然不会导致用户线程中断,但是会因为占用了一部分CPU资源而导致应用程序变慢,总吞吐量降低.</p>
</li>
<li><p>CMS 收集器无法处理浮动垃圾, 可能出现 “Concurrent Mode Failure”失败而导致另一次Full GC产生.浮动垃圾指的是CMS并发清理阶段用户线程还在运行, 这期间产生的垃圾.CMS无法像其他收集器那样等到老年代几乎完全被填满时才收集, 需要预留一部分的空间提供并发手机时的程序运行使用.要是CMS运行期间预留内存无法满足程序需要, 就会出现一次”Concurrent Mode Failure” 失败. 这时虚拟机启动后备预案: 临时启动Serial Old收集器重新进行老年代垃圾收集, 这样停顿的时间就变长了.</p>
</li>
<li><p>由于CMS是基于”标记-清除”算法实现的, 这意味者收集结束时会有大量空间碎片产生.空间碎片太多会给大对象分配带来麻烦,因为无法找到连续足够大的空间来给大对象分配,这就不得不提前触发一次Full GC 了. 为了解决这个问题, CMS收集器提供了一个 -XX:+UseCMSCompactAtFullCollection开关参数,用户在CMS收集器顶不住要进行FullGC时开启内存碎片的合并过程整理, 内存整理无法并发进行, 因此会导致停顿时间变长. 虚拟机设计者还提供了一个参数-XX:CMSFullGCsBeforeCompaction,这个参数用于设置执行多少次不压缩的Full GC后,就跟着一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)</p>
</li>
</ul>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器的使命是在未来替代掉JDK1.5之中发布的CMS收集器,与其他收集器相比, G1具有的特点:</p>
<h5 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h5><p>G1能充分利用多CPU,多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World停顿时间</p>
<h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>虽然G1可以不需要其他收集器配合就能管理整个GC堆,但他能够采用不同的方式去处理新创建的对象和已经存活一段时间,熬过多次GC的旧对象以获取更好的收集效果.</p>
<h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><p>G1整体来看是基于”标记-整理”算法实现的收集器,从局部上来看是基于复制算法实现的.</p>
<h5 id="可预测的停顿"><a href="#可预测的停顿" class="headerlink" title="可预测的停顿"></a>可预测的停顿</h5><p>G1除了要求停顿降低外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒.</p>
<p>如果不计算维护Remembered Set操作,G1收集器的运作大致可划分为以下几个步骤:</p>
<ul>
<li>初始标记:标记一下GC Roots能直接关联到的对象并且修改TAMS的值,让下一阶段用户程序并发运行时,能在正确可用的Region中创建新对象,这个阶段需要停顿线程,但耗时很短.</li>
<li>并发标记:从GC Roots开始对堆中对象进行可达性分析, 找出存活对象,这阶段耗时很长,但可用与用户程序并发运行.</li>
<li>最终标记:为了修正在并发标记期间因用户程序继续运作而导致标记产生百年动的那一部分标记记录,虚拟机将这阶段对象变化记录在线程Remembered Set中, 这阶段需要停顿线程,但可并行执行.</li>
<li>筛选回收:首先对各个Region的回收价值和成本进行排行,根据用户所期望的GC停顿时间来指定回收计划.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/g1.png" alt=""></p>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#JVM" scheme="http://cristianoro7.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java知识体系</title>
    <link href="http://cristianoro7.github.io/2017/12/15/Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    <id>http://cristianoro7.github.io/2017/12/15/Java知识体系/</id>
    <published>2017-12-15T15:08:12.341Z</published>
    <updated>2017-12-15T15:08:12.341Z</updated>
    
    <content type="html"><![CDATA[<p>总结自己的编程知识体系. 该体系动态更新.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fmhurvwykpj30p8120q5l.jpg" alt=""></p>
<blockquote>
<h3 id="抽象和接口"><a href="#抽象和接口" class="headerlink" title="抽象和接口"></a>抽象和接口</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3></blockquote>
<p>未启动</p>
<blockquote>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3></blockquote>
<p><a href="https://cristianoro7.github.io/2017/12/15/Java%E5%86%85%E9%83%A8%E7%B1%BB%E6%95%B4%E7%90%86/">内部类整理</a></p>
<blockquote>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3></blockquote>
<p>注解主要分为两个部分:</p>
<ul>
<li><p>内置注解: <code>Java</code>提供给我们的三个内置注解</p>
</li>
<li><p>自定义注解: 这个包括元注解和注解元素支持的类型</p>
</li>
<li><p>注解处理器: 开发一个处理器分为两个步骤: 1. 继承<code>AbstractProcessor</code>并重写其中的4个方法. 2. 注册注解处理器.</p>
</li>
</ul>
<p>详情:</p>
<ul>
<li><p><a href="https://cristianoro7.github.io/2017/11/22/Java%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">java注解基础</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/11/30/Java%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/">Java注解处理器实战</a></p>
</li>
</ul>
<blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3></blockquote>
<p>反射也是分为两部分:</p>
<ul>
<li><p>基础: 主要描述如何在运行时, 检查一个类的元素. 这些元素可以是: <code>Class</code>对象, <code>Method</code>对象等.</p>
</li>
<li><p>应用: 反射的一个强大用法: 动态代理和运行时处理注解(这个在PC端用得比较多.). 反射的缺点: 破坏性强. 比如: 破坏单例或者是绕开编译时的泛型类型限定.</p>
</li>
</ul>
<p>详情:</p>
<ul>
<li><p><a href="https://cristianoro7.github.io/2017/11/24/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/">Java反射基础</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/11/25/Java%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8/">Java反射的运用</a></p>
</li>
</ul>
<blockquote>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fmgmhamgyrj31r3216b29.jpg" alt=""></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><p><a href="https://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-ArrayList/">ArrayList</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkedList/">LinkedList</a></p>
</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li><p><a href="https://cristianoro7.github.io/2017/12/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88-HashMap/">HashMap</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkHashMap/">LinkHashMap</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-TreeMap/">TreeMap</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-WeakHashMap,%20IdentityHashMap%20和%20HashTable/">WeakHashMap, IdentityHashMap 和 HashTable</a></p>
</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><a href="https://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set%E5%AE%B6%E6%97%8F/">Set家族</a></li>
</ul>
<blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="IO系统"><a href="#IO系统" class="headerlink" title="IO系统"></a>IO系统</h3></blockquote>
<p>未完成…</p>
<blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3></blockquote>
<p>差不多完成…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结自己的编程知识体系. 该体系动态更新.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fmhurvwykpj30p8120q5l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=
    
    </summary>
    
      <category term="知识体系" scheme="http://cristianoro7.github.io/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    
      <category term="知识体系#Java" scheme="http://cristianoro7.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类整理</title>
    <link href="http://cristianoro7.github.io/2017/12/15/Java%E5%86%85%E9%83%A8%E7%B1%BB%E6%95%B4%E7%90%86/"/>
    <id>http://cristianoro7.github.io/2017/12/15/Java内部类整理/</id>
    <published>2017-12-15T14:50:58.912Z</published>
    <updated>2017-12-15T14:50:58.912Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fmhu5d40r1j30m80b41ck.jpg" alt=""></p>
<blockquote>
<h3 id="内部类的定义"><a href="#内部类的定义" class="headerlink" title="内部类的定义"></a>内部类的定义</h3></blockquote>
<p>将一个类置于另外一个类内部, 这就是内部类.</p>
<blockquote>
<h3 id="内部类存在的意义"><a href="#内部类存在的意义" class="headerlink" title="内部类存在的意义"></a>内部类存在的意义</h3></blockquote>
<ul>
<li><p>提供一种代码隐藏机制: 因为它允许将逻辑相关的类组织到一起, 并且可以控制内部类的可见性.</p>
</li>
<li><p>有效地实现了”多重继承”: 每个内部类都能独立地继承一个普通类, 抽象类或者实现一个接口.</p>
</li>
</ul>
<blockquote>
<h3 id="内部类的特性"><a href="#内部类的特性" class="headerlink" title="内部类的特性:"></a>内部类的特性:</h3></blockquote>
<ul>
<li><p>内部类可以拥有多个实例, 每个实例都拥有自己的状态信息.</p>
</li>
<li><p>在单个外围类内, 可以让多个内部类以不同的方式实现同一个接口或者继承同一个类.</p>
</li>
</ul>
<blockquote>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3></blockquote>
<ul>
<li><p>成员内部类</p>
</li>
<li><p>静态内部类</p>
</li>
<li><p>匿名内部类</p>
</li>
<li><p>局部内部类</p>
</li>
</ul>
<blockquote>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4></blockquote>
<p>成员内部类指的是: 像定义成员变量地定义一个类,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面通过一个例子来说明创建成员内部类的两种方法以及它的一些特性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object[] items;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        items = <span class="keyword">new</span> Object[size];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (next &lt; items.length) &#123;</div><div class="line">            items[next++] = x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> i == items.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> items[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (i &lt; items.length) &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            sequence.add(i);</div><div class="line">        &#125;</div><div class="line">        Selector selector = sequence.new SequenceSelector();</div><div class="line">        <span class="keyword">while</span> (!selector.end()) &#123;</div><div class="line">            System.out.println(selector.current().toString() + <span class="string">""</span>);</div><div class="line">            selector.next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子是一个简单的迭代器, <code>SequenceSelector</code>作为内部类实现了<code>Selector</code>接口. 然后在<code>Main</code>中创建了内部类. 这个例子我们需要关注的有两点:</p>
<ul>
<li><p><code>SequenceSelector</code>内部类具有访问其外围类的成员信息的权限.</p>
</li>
<li><p>创建一个成员内部类时, 必须要先拥有外围类的实例才能创建.</p>
</li>
</ul>
<p>成员内部类之所以能访问外围类的信息是: 因为在创建内部类时, 编译器会将外围类实例作为参数传入内部类中, 这个过程对程序员是不可见的. 这也解释了为什么创建内部类时, 需要先获得外围类的实例.</p>
<p>由于成员内部类是建立在外围类的层次上的, 所以, 成员内部类不能含有<code>static</code>字段或者<code>static</code>方法.</p>
<p>创建成员内部类的方式: xxx.new InnerClass. 但是这样的方式不怎么优雅, 这种方法使得外部还是可以感知内部类的存在. 更好的做法是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object[] items;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        items = <span class="keyword">new</span> Object[size];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (next &lt; items.length) &#123;</div><div class="line">            items[next++] = x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> i == items.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> items[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (i &lt; items.length) &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            sequence.add(i);</div><div class="line">        &#125;</div><div class="line">        Selector selector = sequence.selector();</div><div class="line">        <span class="keyword">while</span> (!selector.end()) &#123;</div><div class="line">            System.out.println(selector.current().toString() + <span class="string">""</span>);</div><div class="line">            selector.next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面改动的地方有两处: 将内部类的权限改为<code>private</code>. 添加<code>selector()</code>方法来创建内部类.</p>
<p>经过上面的改动, 外部不能感知<code>SequenceSelector</code>的存在, 这样就防止了外部对其进行依赖, 并且完全隐藏了实现的细节.</p>
<blockquote>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4></blockquote>
<p>与成员内部类相反, 静态内部类指的是将内部类声明为<code>static</code>, 它与外围类之间没有什么联系, 因此, 静态内部类不能访问外围类的非<code>static</code>字段或者方法.</p>
<p>静态内部类与成员内部类的另外一个区别: 静态内部类可以含有<code>static</code>字段或者<code>static</code>方法. 下面是一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> v = <span class="number">11</span>;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>ParcelContents</code>不需要对外围类进行引用, 所以将<code>ParcelContents</code>可以声明为静态内部类.</p>
<blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4></blockquote>
<p>匿名内部类是指创建一个继承或者实现XX的类并且它是没有名字的, 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123; <span class="comment">//匿名内部类</span></div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于匿名类是没有名字的, 所以如果我们需要做一些构造器行为的时候便无能为力(因为匿名内部类没有名字). 这时候, 我们可以用实例初始化块来解决这个问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Base constructor: "</span> + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(i) &#123;</div><div class="line"></div><div class="line">            &#123;</div><div class="line">                System.out.println(<span class="string">"run after"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"func"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Base base = getBase(<span class="number">11</span>);</div><div class="line">        base.func();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出:</div><div class="line">Base constructor: <span class="number">11</span></div><div class="line">run after</div><div class="line">func</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4></blockquote>
<p>局部内部类是指: 将一个类定义在一个方法或者是方法内的一个代码块.</p>
<p>局部内部类不能有访问说明符, 因为它不是外围类的一部分. 但是它可以访问当前代码块内的<code>常量</code>以及外围类的所有成员.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  Base <span class="title">fun1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> aFinal = <span class="number">1</span>;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LocalClass</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">                <span class="keyword">super</span>(i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(aFinal); <span class="comment">//访问方法内的常量</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalClass(x); <span class="comment">//访问成员变量</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h3></blockquote>
<p>因为成员内部类会默认持有外部类的引用, 因此, 当继承一个内部类时, 编译器强制要求继承内部类的类中必须要有一个构造器, 这个构造器必须将外部类作为参数, 并且调用外部类的<code>super</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExBase</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest</span> <span class="keyword">extends</span> <span class="title">Test</span>.<span class="title">ExBase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendsTest</span><span class="params">(Test sequence)</span> </span>&#123;</div><div class="line">        sequence.<span class="keyword">super</span>(<span class="number">11</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="内部类是不能被覆盖的"><a href="#内部类是不能被覆盖的" class="headerlink" title="内部类是不能被覆盖的"></a>内部类是不能被覆盖的</h3></blockquote>
<p>当继承一个类时, 被继承的类的内部类是不能被覆盖的, 两个类中的两个内部类是完全独立的两个实体, 各自在自己的命名空间内.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Yolk yolk;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"egg.yolk"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"new egg"</span>);</div><div class="line">        yolk = <span class="keyword">new</span> Yolk();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"BigEgg.yolk"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> BigEgg();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出:</div><div class="line"><span class="keyword">new</span> egg</div><div class="line">egg.yolk</div></pre></td></tr></table></figure>
<p>这个例子说明被继承的类的内部类是不能被覆盖的, 两个类中的两个内部类是完全独立的两个实体.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fmhu5d40r1j30m80b41ck.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;内部类的定义&quot;&gt;&lt;a href=&quot;#内部类的定义&quot; cl
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://cristianoro7.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合-HashMap</title>
    <link href="http://cristianoro7.github.io/2017/12/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88-HashMap/"/>
    <id>http://cristianoro7.github.io/2017/12/14/深入理解Java集合-HashMap/</id>
    <published>2017-12-14T12:56:56.468Z</published>
    <updated>2017-12-14T12:56:56.468Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章分别介绍了<code>ArrayList</code>和<code>LinkedList</code>, 这次我们来分析另外一个key-value键值对的映射集合-HashMap.按照前面的习惯,我们先来看看<code>HashMap</code>的UML</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimu0do73tj30ii0cv3z0.jpg" alt=""></p>
<p><code>HashMap</code>实现了<code>Cloneable</code>, <code>Serializable</code>, 所以<code>HashMap</code>支持克隆(浅克隆)和序列化. <code>Map</code>接口提供了一系列接口和三个视图. <code>AbstractMap</code>则是实现了<code>Map</code>接口, 并且实现了<code>Map</code>接口中的一些方法, 换句话说<code>AbstractMap</code>是<code>Map</code>家族里面的一个基本骨架, 具体的子类根据需要重写<code>AbstractMap</code>中的方法即可.</p>
<blockquote>
<h2 id="回顾Hash表"><a href="#回顾Hash表" class="headerlink" title="回顾Hash表"></a>回顾Hash表</h2></blockquote>
<p>学过数据结构的都应该清楚, Hash表是将一个key的hash值取模后映射到一个数组中的特定位置. 但是, 随着Hash表中的键值对的增多, 会出现冲突. 所谓的冲突是两个key的hash值取模后得到的数定位到了数组中的相同位置.对于冲突这种情况, 常用的解决方法有:开放地址法和链地址法.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>回顾完了Hash表的基础知识后, 我们来讲讲<code>HashMap</code>的实现方式.</p>
<p>总体来说, <code>HashMap</code>的实现为: 数组+链表+红黑树. 当出现冲突时, <code>HashMap</code>是使用链地址法来解决冲突.但是如果冲突越来越多, 链表就会变得越来越长.这样导致的结果是:原本访问一个Key对应的value的时间复杂度会从O(1)退化为O(n).因此, <code>HashMap</code>使用一种名为红黑树的数据结构来解决时间复杂度退化的这个问题.红黑树查找key值对应的value的时间复杂度为O(log n)(优于O(n)).</p>
<p>下面, 先来看看<code>HashMap</code>中的字段, 我们将重点介绍两个字段. 这两个字段影响着<code>HashMap</code>的性能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The table, initialized on first use, and resized as</div><div class="line"> * necessary. When allocated, length is always a power of two.</div><div class="line"> * (We also tolerate length zero in some operations to allow</div><div class="line"> * bootstrapping mechanics that are currently not needed.)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//内部的数组</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</div><div class="line"> * for keySet() and values().</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//返回包含key-value的视图</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of key-value mappings contained in this map.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//内部储存的key-value的个数</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of times this HashMap has been structurally modified</div><div class="line"> * Structural modifications are those that change the number of mappings in</div><div class="line"> * the HashMap or otherwise modify its internal structure (e.g.,</div><div class="line"> * rehash).  This field is used to make iterators on Collection-views of</div><div class="line"> * the HashMap fail-fast.  (See ConcurrentModificationException).</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//记录内部数据结构发生变化的次数, 主要用来实现fail-fast</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next size value at which to resize (capacity * load factor).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></div><div class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></div><div class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></div><div class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The load factor for the hash table.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<p>loadFactor是负载因子, 这个字段表示<code>HashMap</code>内部容量满载的一个界限. threshold为扩容的界限,它的计算公式为: threshold = capacity * loadFactor.当size &gt; threshold时, <code>HashMap</code>内部就会扩容.</p>
<p><code>loadFactor</code>内部默认实现为0.75. 这个数值是时间和空间的一个折中值.<code>loadFactor</code>如果设置为比较大, 也就是<code>threshold</code>会比较大, 那么空间的利用率就会变大, 但是空间利用率变大的代价是查找速度变慢了, 因因为冲突率会提高. 如果<code>loadFactor</code>设置为比较小的话, <code>threshold</code>会比较小, 虽然冲突率会变小, 因为会频繁扩容.但这也一定程度上浪费空间内存.</p>
<blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote>
<p><code>HashMap</code>的构造函数有几个重载, 我们既可以使用无参的构造方法, 使用内部默认指定的<code>capacity</code>和<code>loadFactor</code>.也可以调用指定这两个参数的构造函数.</p>
<p>如果没有特殊情况.我们一般调用无参的构造函数.它会帮我们指定默认的<code>loadFactor</code>.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>put</code>函数是往<code>HashMap</code>中添加元素, 在分析添加元素的实现之前, 我们先来看看<code>hash(key)</code>函数,得到的hash值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4></blockquote>
<p><code>hash</code>函数的实现思路: 将key的hashCode的高16位和低16位作异或操作.至于为什么是要这样操作?</p>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<p>分析完了<code>hash(int key)</code>函数, 我们回到<code>put(K key)</code>, 来看看真正的添加操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//检查HashMap是否为空</span></div><div class="line">        n = (tab = resize()).length; <span class="comment">//空的话, 先进行扩容</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断HashMap中有没有存该Key</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//没有存该值, 直接赋值.</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//HashMap不为空的情况.</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//判断HashMap有没存该Key对应的值</span></div><div class="line">            e = p; <span class="comment">//有的话直接替换原来的值</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断这个结点是不是红黑树结点</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); 是的话, 插入到红黑树结构中</div><div class="line">        <span class="keyword">else</span> &#123; <span class="comment">//插入到链表结构中</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash); <span class="comment">//如果链表的结点个数为8的话, 将链表转化为红黑树, 这样提高查找的速度</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e); <span class="comment">//hock函数, 用于LinkHashMap中</span></div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//如果size &gt; threshold的话, 需要进行扩容</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面注释已经将函数解析得挺清楚了, 下面主要介绍这个<code>hash &amp; (n - 1)</code>操作. <code>hash &amp; (n - 1)</code>其实等价于取模操作, 但是比普通的 % 操作高效, 因为<code>hash &amp; (n - 1)</code>运用的位运算.</p>
<p>前面说过<code>HashMap</code>内部的长度总是为2的次方, <code>n</code>为<code>HashMap</code>的长度,<code>hash &amp; (n - 1)</code>的操作如下:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimz01cbwzj30d60dm74h.jpg" alt=""></p>
<p><code>afterNodeAccess(e);</code>和<code>afterNodeInsertion(evict);</code>是hock函数, 是预留给<code>LinkedHashMap</code>使用的.</p>
<p>链表的构造使用的是头插法, 后插入的会在链表头.</p>
<p>如果一直向<code>HashMap</code>中添加元素的话, 其内部会扩容, 扩容通俗地说就是用更大的数组来代替之前的小数组以装下更多的元素.1.8的<code>HashMap</code>内部的扩容机制做了一些优化, 接下来, 我们来详细分析其中的优化.</p>
<blockquote>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩大为原来的两倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>resize()</code>函数为<code>HashMap</code>的扩容机制,扩容的情况有两种, 一种的初始化默认的容量, 另外一种是扩大为原来的两倍.</p>
<p>扩大容量后, 还需要把原来的数据搬到新的数组中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">            oldTab[j] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//定位到新的位置, 并且赋值</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">//如果结点是红黑树的结点的话, 会进行修剪树的操作</span></div><div class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order 头结点后面有元素,且为链表的结构</span></div><div class="line">              <span class="comment">//重新定位链表的策略: 定义两条链表, 构造完链条链表后, 再将他们的头结点定位到数组对应的index</span></div><div class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">//留在原来的位置的链表</span></div><div class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">//移动在原来位置+2的n次方位置的链表</span></div><div class="line">                Node&lt;K,V&gt; next;</div><div class="line">                do &#123;</div><div class="line">                    next = e.next;</div><div class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//新增位为0</span></div><div class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                            loHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            loTail.next = e;</div><div class="line">                        loTail = e;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//新增位为1</span></div><div class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                            hiHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            hiTail.next = e;</div><div class="line">                        hiTail = e;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    loTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    hiTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合代码中的注释, 我们来解析这个扩容机制, 首先遍历原来的数组, 然后拿到每个位置的头结点, 再判断头结点后面有没有元素, 没有的话, 直接用<code>&amp;</code>运算定位到新的位置.如果有的话, 先判断这个结点是不是红黑树的结点, 是的话做修剪树的操作.不是的话, 说明后面的结点的结构是链表.</p>
<p>前面说过, <code>HashMap</code>的每次扩容为原来的2倍, 这样的话, 原来的元素不是定位到原地, 就是在原地移动2的次幂.我们结合扩容前和扩容后的图来解释:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin22vrzufj30nb0c50tb.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin27c3g43j30o10bpmxq.jpg" alt=""></p>
<p>扩容后,决定位置的位数多了一位, 拿16扩容到32来说, 16的时候, 决定位置是由结果的后4位来决定, 如果扩容为32位后, 决定位置是由结果的后5位.如果新增的那一位为0的话,表示新的位置是原来的位置, 如果为1的话, 新的位置为原来的位置 + 原来的容量(原来的容量为2的n次方).</p>
<p>所以代码中<code>e.hash &amp; oldCap</code>就是为了取得新增的那一位, 如果为0的话, 说明新的位置为原来的位置, 如果为1的话,则需要移动2的n次幂(也就是 原来的位置 + 旧的容量).</p>
<p>上面重新组装链表的时候, 思路是这样的: 因为新的位置不是在原来的位置, 就是需要在原来的位置上移动2的次幂.所以, 定义两条链表, 一条表示新位置是原来的位置的链表(简称L1), 另外一条表示新的位置在原来的位置移动2的次幂(简称L2). 接着会先遍历原来的链表, 再进行<code>e.hash &amp; oldCap</code>, 如果为0的话, 将该结点插入到L1, 如果为1的话, 插入到L2. 插入的方法为尾插法, 这样重构后的链表不会乱序(1.7之前的版本是会乱序的). 最后,将新构造的两条链表定位到对应的位置,也就是下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">    loTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">    hiTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.8的扩容机制的优化主要是不需要再重新计算hash值, 只是做个<code>&amp;</code>操作就行了, 并且重构后的链表不会乱序. 这种优化的一个重要的前提是容量为2的n次幂. 因此 <code>HashMap</code>内部的容量为什么不定义为素数而是定义为2的n次幂. 这样做是为了减少扩容时的<code>rehash</code>操作.</p>
<p>到这里, 我们已经把<code>HashMap</code>内部的精华都分析完了, 其他操作都挺简单的, 也没什么好讲的.最后, 做个总结</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>hash</code>函数</li>
<li>扩容机制</li>
<li>冲突优化</li>
<li>其他</li>
</ul>
<blockquote>
<h3 id="hash函数-1"><a href="#hash函数-1" class="headerlink" title="hash函数"></a><code>hash</code>函数</h3></blockquote>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<blockquote>
<h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3></blockquote>
<ul>
<li><p><code>HashMap</code>的扩容后的长度总是2的次幂, 这个设置主要是为了优化扩容机制. <code>HashMap</code>内部扩容时,不需要重新计算hash值,并且链表的顺序还是保持原来的顺序.</p>
</li>
<li><p>频繁进行扩容会一定程度上影响<code>HashMap</code>性能.因此,如果预先知道需要储存的数据有很多的话, 可以直接设置一个较大的容量来减少扩容的次数.</p>
</li>
</ul>
<blockquote>
<h3 id="冲突优化"><a href="#冲突优化" class="headerlink" title="冲突优化"></a>冲突优化</h3></blockquote>
<p>对于hash冲突的情况, 如果冲突的链表结点个数大于8的话, <code>HashMap</code>会将链表转化为红黑树的结构, 将查找的复杂度从O(N)优化为O(logN).</p>
<blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></blockquote>
<ul>
<li><p><code>HashMap</code>既支持<code>Key</code>为<code>null</code>, 也支持<code>value</code>为<code>null</code>.</p>
</li>
<li><p>遍历<code>HashMap</code>时, 顺序是不保证的, 如果需要有序的遍历, 应该使用<code>LinkedHashMap</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章分别介绍了&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;, 这次我们来分析另外一个key-value键值对的映射集合-HashMap.按照前面的习惯,我们先来看看&lt;code&gt;HashMap&lt;/code&gt;的UML&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>TCP首部</title>
    <link href="http://cristianoro7.github.io/2017/12/07/TCP%E9%A6%96%E9%83%A8/"/>
    <id>http://cristianoro7.github.io/2017/12/07/TCP首部/</id>
    <published>2017-12-07T12:23:11.399Z</published>
    <updated>2017-12-07T12:23:11.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></blockquote>
<p>TCP的全部功能都体现在其首部中的各个字段. 因此, 只有弄清TCP首部各个字段的作用才能理解TCP的工作原理.</p>
<p>TCP首部的前20个字节是固定的,后面有4n字节是根据需要而增加的选项, TCP首部的最小长度为20字节, 最多为60字节.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm87lbwl34j30fd0flt98.jpg" alt=""></p>
<h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占2个字节, 分别写入源端口号和目的端口号. TCP的分用和复用功能是通过端口实现的.</p>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占4个字节.TCP是面向字节流的,在一个TCP连接中传送的字节流中的每一个字节都按顺序编号.序号字段值是用来指定本报文段所发送的数据的第一个字节的序号.</p>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占4字节.是接收方期望收到发送方下一个报文段的第一个数据字节序号.例如:B正确接收了A发送过来的一个报文段,其序号字段为501,数据长度为200字节,表明B正确接收了501~700的序号的数据.因此,B期望收到A的下一个数据序号是701, 于是B在发送给A的确认报文中把确认号置为701.</p>
<h3 id="首部长度"><a href="#首部长度" class="headerlink" title="首部长度"></a>首部长度</h3><p>占4位, 该字段是以32位Bit为单位, 它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远.这个字段实际上是指出TCP首部的长度. 所以<code>TCP</code>的首部长度为最多60字节.</p>
<h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占4位, 保留为今后使用, 目前应置为0</p>
<h3 id="8个标志位"><a href="#8个标志位" class="headerlink" title="8个标志位"></a>8个标志位</h3><ul>
<li><p>拥塞创窗口减<code>CWR</code>: 告知发送方, 降低发送速率.</p>
</li>
<li><p><code>CEC</code>: 发送方接收到了一个更早的拥塞通告.</p>
</li>
<li><p>紧急URG: 当URG = 1时, 表明紧急指针字段有效.它告诉系统,当前报文段有紧急数据,应当尽快传送.</p>
</li>
<li><p>确认<code>ACK</code>: 仅当ACK = 1时确认号字段才有效.当ACK = 0时,确认号无效. TCP规定,在连接建立后所有传送的报文段都必须把ACK置为1.</p>
</li>
<li><p>推送<code>PSH</code>: 当发送方将PSH置为1,并立即创建一个报文段发送出去.接收方TCP收到PSH = 1的报文段时,就尽快地交付接收应用程序,而不再等到整个缓存填满了再向上交付.</p>
</li>
<li><p>复位(RST): 当RST = 1 时, 表明TCP连接出现严重错误,必须释放连接,然后再重新建立连接.</p>
</li>
<li><p>同步<code>SYN</code>: 在连接建立时用来同步序号. 当SYN = 1 时而ACK = 0 时表示这是一个连接请求报文段.若对方同意连接后, 则应在响应报文中使SYN = 1和ACK = 1.实际上SYN = 1 时表示这是一个连接请求或接受报文.</p>
</li>
<li><p>终止<code>FIN</code>: 用来释放一个连接. 当FIN = 1 时, 表明此报文段的发送数据已发送完毕,并要求释放连接.</p>
</li>
</ul>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占2字节.窗口指的是发送报文段一方的接收窗口.窗口值告诉对方:接收方目前允许对方发送的数据量. 由于窗口占2个字节, 所以窗口最大为: 65535. 但这不是绝对的, 因为在<code>TCP</code>的选项字段中, 含有一个窗口缩放字段, 可以用来扩大窗口的值.</p>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>检验和字段检验的范围包括首部和数据这两部分.</p>
<h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占2字节. 当URG = 1 时才有意义, 它指出本报文段中的紧急数据字节数.</p>
<h3 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h3><p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm87xjwuqbj30t00ji759.jpg" alt=""></p>
<p><code>TCP</code>的每一个选项字段的头字节为<code>种类(kind)</code>, 它指明了选项的类型. 除了<code>无操作</code>和<code>选项表结束</code>没有长度字段外, 其他的选项都有一个<code>len</code>字段来说明该选项的长度.</p>
<ul>
<li><p>选项列表结束(EOL): 指出了选项列表的结尾, 说明无需对此选项列表再进行处理.</p>
</li>
<li><p>无操作(NOP): 填充字段. 因为TCP的首部单位是4个字节. 所以当选项字段不是4字节的倍数时, 可以用NOP来进行字段的填充.</p>
</li>
<li><p>最大报文段长度(MSS): 告知通信方, 自己接受的最大报文的长度(不包括TCP和IP的首部). 默认情况下, 最大段大小为: 536. 因为任务主机能够处理至少为576字节的<code>IPV4</code>报文段. 由于536是不包括<code>TCP</code>首部和<code>IP</code>首部的, 所以当加上<code>TCP</code>20字节和<code>IP</code>首部20字节的话, 刚好是576.</p>
</li>
<li><p>窗口缩放(WSCALE或WSOPT): 能够将窗口字段从14位扩大到30位. 该选项字段只能出现于一个<code>SYN</code>报文段中. 主动打开连接的一方可以在<code>SYN</code>指定这个字段, 被动打开的一方可以在<code>ACK SYN</code>报文中指定该选项. 假设现在正在使用该字段. 发送出去的<code>WSCALE</code>为<code>s</code>的话, 并且接收到对方的<code>WSCALE</code>为<code>r</code>. 这样, 当接收到通信方的窗口时, 我们需要将该窗口值左移<code>r</code>为得到真正的窗口大小. 当我们要告知对方窗口值的大小时, 会将实际的大小右移<code>s</code>位, 然后再发送出去.</p>
</li>
<li><p>时间戳选项(TSOPT): 该字段指用于记录每收到一个<code>ACK</code>的往返时间(RTT). 该选项必须在双方建立连接时协商好, 并且需要双方都开启才有效.</p>
</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></blockquote>
<ul>
<li><p>计算机网络(谢希仁)</p>
</li>
<li><p>计算机网络-自顶向下方法</p>
</li>
<li><p>TCP/IP详解</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;TCP的全部功能都体现在其首部中的各个字段. 因此, 只有弄清TCP首部各个字段的作用
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#运输层" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Java注解处理器实战</title>
    <link href="http://cristianoro7.github.io/2017/11/30/Java%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cristianoro7.github.io/2017/11/30/Java注解处理器详解/</id>
    <published>2017-11-30T11:42:21.159Z</published>
    <updated>2017-11-30T11:42:21.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm0c4an974j30m80b4qhy.jpg" alt=""></p>
<blockquote>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3></blockquote>
<p>注解强大的地方在于: 我们可以在运行时或者编译时处理注解. 在编译时或者运行时处理注解的机制都可以称为一个注解处理器.</p>
<blockquote>
<h3 id="注解处理器的类型"><a href="#注解处理器的类型" class="headerlink" title="注解处理器的类型"></a>注解处理器的类型</h3></blockquote>
<p>注解处理器的类型分为两大类:</p>
<ul>
<li><p>运行时处理器: 这种机制是在程序运行时利用<code>反射</code>机制去处理注解.</p>
</li>
<li><p>编译时处理器: 这种机制是在程序编译时利用<code>javac</code>提供的一个<code>apt</code>工具来处理注解.</p>
</li>
</ul>
<p>运行时处理器的特点: 该机制基于反射机制, 因此灵活性很大, 但是却相对耗性能. 编译时处理器的特点:这种方法是在编译时处理注解, 因此不存在性能的问题, 但是灵活性也相对比较低.</p>
<p>在已有的开源库实现中, 普遍是结合<code>编译时处理器</code>和<code>反射机制</code>这两种方法. 举个例子: <code>ButterKnife</code>. 它是一个<code>View</code>注入的库. 内部实现的原理: 编译时利用<code>apt</code>生成<code>findViewById</code>等一些列模板代码, 然后在运行时利用反射去实例生成的模板代码类, 这样完成了一次注入. 从这里可以看出, <code>ButterKnife</code>并没有完全基于编译时注解处理器. 而是加了反射.</p>
<p>这样做的好处: 开发者不需要手动实例<code>apt</code>生成的类. 换句话说: 开发者不需要了解生成类的命令规则. 也许你可能会觉得利用反射会耗性能. 但是仔细想想, 如果没有利用反射的话, 开发者都需要手动编译, 然后再实例化生成的类. 这个过程也是挺繁琐的. 而且, 库内部是有做相应的缓存的, 所以耗的性能还是相对比较低的.</p>
<p>对于反射的利用, 应该适当使用, 而不是避而不用或者滥用.</p>
<p>接下来, 讲讲<code>APT</code>的一些知识, 最后再仿写一个简单的<code>ButterKnife</code>作为实战.</p>
<blockquote>
<h3 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h3></blockquote>
<p>开发注解处理器的第一个步骤就是继承<code>AbstractProcessor</code>. 然后重写其四个方法:</p>
<ul>
<li><p><code>public synchronized void init(ProcessingEnvironment processingEnvironment)</code>: 这个方法一般是做一些初始化的工作.</p>
</li>
<li><p><code>public SourceVersion getSupportedSourceVersion()</code>: 该处理器所支持的<code>JDK</code>版本, 一般是支持到最新: <code>SourceVersion.latestSupported()</code>.</p>
</li>
<li><p><code>public Set&lt;String&gt; getSupportedAnnotationTypes()</code>: 你所要处理的注解的类型.</p>
</li>
<li><p><code>public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</code>: 处理注解的方法. 这个是我们主要实现的方法. 返回值表示当前这个注解类型是否需要被随后的注解处理器处理. <code>true</code>表示不需要, <code>false</code>表示后面的注解处理器可能会对本次处理的注解.</p>
</li>
</ul>
<p>认识这4个方法后, 我们还需要熟悉一下编写处理器涉及到的一些概念和<code>API</code>.</p>
<h4 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h4><p><code>ProcessingEnvironment</code>是在<code>init</code>方法传入的. 它表示<code>APT</code>框架的一个处理时上下文. 这个类主要是提供一些工具类. 详细看下面代码注释:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessingEnvironment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//获取外部配置的参数</span></div><div class="line">    <span class="function">Map&lt;String,String&gt; <span class="title">getOptions</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Messager对象, 用于打印一些日志</span></div><div class="line">    <span class="function">Messager <span class="title">getMessager</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Filer对象, 该对象用于创建文件</span></div><div class="line">    <span class="function">Filer <span class="title">getFiler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Elements, 它包含处理Element的一些工具方法</span></div><div class="line">    <span class="function">Elements <span class="title">getElementUtils</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Types, 它包含处理TypeMirror的一些工具方法</span></div><div class="line">    <span class="function">Types <span class="title">getTypeUtils</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">SourceVersion <span class="title">getSourceVersion</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="RoundEnvironment"><a href="#RoundEnvironment" class="headerlink" title="RoundEnvironment"></a>RoundEnvironment</h4><p>当<code>APT</code>启动时, 它将会扫描源文件, 然后进入<code>process</code>方法处理, 如果这个过程生成了新的文件的话, 新文件会被<code>APT</code>再次作为输入, 接着<code>process</code>会被<code>apt</code>再次调用, 如此循环下去, 直到没有新的文件产生. <code>RoundEnvironment</code>为处理轮次的上下文环境. 下面是<code>RoundEnvironment</code>的方法简单介绍:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoundEnvironment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//用于判断是否处理完了, 只有当没有新文件生成时, 证明已经处理完了, 才会返回true</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">processingOver</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//上一次处理是否存在错误</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">errorRaised</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取前一次处理的根元素集合</span></div><div class="line">    Set&lt;? extends Element&gt; getRootElements();</div><div class="line"></div><div class="line">    <span class="comment">//获取被指定的类型元素标注的元素集</span></div><div class="line">    Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a);</div><div class="line"></div><div class="line">    <span class="comment">//获取被指定的注解标注的元素集</span></div><div class="line">    Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><p><code>Element</code>代表<code>Java</code>静态语言结构的元素. 这样听起来可能有点难以理解, 不过看下面的例子就会很好理解了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.desperado.processors; <span class="comment">//PackageElement</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; <span class="comment">//TypeElement: 代表类或接口元素</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> xixi; <span class="comment">//VariableElement:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; <span class="comment">//ExecutableElement</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">(String arg)</span> </span>&#123; <span class="comment">//haha方法为TExecutableElement</span></div><div class="line">        <span class="keyword">int</span> v; <span class="comment">//VariableElement</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>TypeElement</code>: 代表类或接口元素</p>
</li>
<li><p><code>VariableElement</code>: 代表字段, 枚举常量, 方法或构造函数的参数, 局部变量, 资源变量和异常参数.</p>
</li>
<li><p><code>PackageElement</code>: 代表包元素</p>
</li>
<li><p><code>ExecutableElement</code>: 代表的方法, 构造方法,和接口或者类的初始化块.</p>
</li>
</ul>
<h4 id="DeclaredType-TypeElement和TypeMirror"><a href="#DeclaredType-TypeElement和TypeMirror" class="headerlink" title="DeclaredType, TypeElement和TypeMirror"></a>DeclaredType, TypeElement和TypeMirror</h4><p><code>TypeElement</code>表示类或接口元素, 可以从中获取类名, 但是不能获得类本身的信息, 比如父类.</p>
<p><code>TypeMirror</code>: 表示<code>Java</code>语言中的类型, 其中包括: 基本类型, 声明类型(类类型和接口类型), 数组类型, 类型变量和空类型. 也代表通配类型参数，可执行文件的签名和返回类型.</p>
<p><code>DeclaredType</code>: 代表声明的类型, 类类型还是接口类型，当然也包括参数化类型，比如Set<string>，也包括原始类型.</string></p>
<blockquote>
<h3 id="开发一个注解处理器"><a href="#开发一个注解处理器" class="headerlink" title="开发一个注解处理器"></a>开发一个注解处理器</h3></blockquote>
<p>掌握了上面的概念后, 我们开始来开发一个仿<code>ButterKnife</code>的注解处理器.</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li><p>继承<code>AbstractProcessor</code>并重写其中的四个方法.</p>
</li>
<li><p>注册注解处理器.</p>
</li>
</ul>
<h5 id="继承AbstractProcessor"><a href="#继承AbstractProcessor" class="headerlink" title="继承AbstractProcessor"></a>继承<code>AbstractProcessor</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Types types;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Filer filer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messager messager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Elements elements;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(processingEnvironment);</div><div class="line">        types = processingEnvironment.getTypeUtils();</div><div class="line">        filer = processingEnvironment.getFiler();</div><div class="line">        messager = processingEnvironment.getMessager();</div><div class="line">        elements = processingEnvironment.getElementUtils();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line">        <span class="comment">//process</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">        annotations.add(BindView.class.getCanonicalName());</div><div class="line">        <span class="keyword">return</span> annotations;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>getSupportedAnnotationTypes()</code>中, 我们直接返回了需要处理的注解的全限定名称集合.</p>
<h5 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h5><p>写好的处理器还需要处理告诉<code>Javac</code>, 让它编译时运行我们的处理器. 注册的步骤为: 在项目新建一个<code>resources</code>目录, 然后在<code>resources</code>内新建这样的目录结构: <code>/META-INF/services/</code>. 最后在<code>services</code>中新建文件: <code>javax.annotation.processing.Processor</code>. 并且在文件上填写你的处理器的全路径名称. 例如: <code>com.desperado.processors.ViewBindingProcessor</code>.</p>
<p>其实还有一种更为简单的方法. 添加<code>com.google.auto.service:auto-service:1.0-rc2</code>这个库(Google开源的). 然后在你的处理器上添加注解: <code>@AutoService(Processor.class)</code>. 这样, 编译时就会自动帮我们生成注册文件.</p>
<blockquote>
<h4 id="如何组织处理器结构"><a href="#如何组织处理器结构" class="headerlink" title="如何组织处理器结构"></a>如何组织处理器结构</h4></blockquote>
<p>为了不将注解处理器的代码打包进<code>APK</code>. 我们需要将注解和注解处理器分开. 具体的组织如下:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm07qpsw5qj30cw047aa1.jpg" alt=""></p>
<ul>
<li><p><code>annotations</code>: <code>annotations</code>是一个<code>java lib</code>. 是我们自定义的注解</p>
</li>
<li><p><code>processors</code>: <code>processors</code>也是一个<code>java lib</code>. 是我们的注解处理器</p>
</li>
<li><p><code>viewbinding</code>: 为提供为<code>app</code>的api.</p>
</li>
</ul>
<blockquote>
<h4 id="annotations"><a href="#annotations" class="headerlink" title="annotations"></a>annotations</h4></blockquote>
<p>首先我们在<code>annotation</code>模块定义一个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="processors"><a href="#processors" class="headerlink" title="processors"></a>processors</h4></blockquote>
<p>在讲处理器模块前, 我们先看看期望生成的代码模板:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>$<span class="title">ViewBinding</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> MainActivity$ViewBinding(MainActivity activity, View view) &#123;</div><div class="line">    <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    activity.mTvTextView = view.findViewById(<span class="number">2131165249</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的代码的类名为: XXXX$ViewBinding</p>
<p>然后在构造函数中对传入的<code>activity</code>中的<code>View</code>进行赋值.</p>
<h5 id="定义处理规则"><a href="#定义处理规则" class="headerlink" title="定义处理规则."></a>定义处理规则.</h5><ul>
<li><p><code>BindView</code>只能标注字段.</p>
</li>
<li><p><code>BindView</code>不能标注接口中的字段, 只能标注类中的字段.</p>
</li>
<li><p><code>BindView</code>不能标注抽象类中的字段.</p>
</li>
<li><p><code>BindView</code>不能标注被<code>private</code>, <code>static</code>或者<code>final</code>修饰的字段</p>
</li>
<li><p><code>BindView</code>标注字段所属的类必须是<code>Activity</code>的子类.</p>
</li>
<li><p><code>BindView</code>标注的字段必须是<code>View</code>的子类</p>
</li>
</ul>
<p>定义好这些规则后, 我们就可以来看处理器的代码了.</p>
<h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Types types;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Filer filer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messager messager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Elements elements;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, ViewClass&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_ACTIVITY = <span class="string">"android.app.Activity"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_VIEW = <span class="string">"android.view.View"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(processingEnvironment);</div><div class="line">        types = processingEnvironment.getTypeUtils();</div><div class="line">        filer = processingEnvironment.getFiler();</div><div class="line">        messager = processingEnvironment.getMessager();</div><div class="line">        elements = processingEnvironment.getElementUtils();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line">        map.clear(); <span class="comment">//该方法会被调用多次, 所以每次进入时, 首先清空之前的脏数据</span></div><div class="line">        logNote(<span class="string">"start process"</span>);</div><div class="line">        <span class="keyword">for</span> (Element e : roundEnvironment.getElementsAnnotatedWith(BindView.class)) &#123;</div><div class="line">            <span class="keyword">if</span> (!isValid(e)) &#123; <span class="comment">//首先判断被标注的元素是否符合我们上面定的规则</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//出现错误, 停止编译</span></div><div class="line">            &#125;</div><div class="line">            logNote(<span class="string">"start parse annotations"</span>);</div><div class="line">            performParseAnnotations(e); <span class="comment">//开始解析注解</span></div><div class="line">        &#125;</div><div class="line">        logNote(<span class="string">"start generate code"</span>);</div><div class="line">        generateCode(); <span class="comment">//生成代码</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Element element)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> VariableElement)) &#123;</div><div class="line">            logError(<span class="string">"BindView只能标注字段"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        VariableElement variableElement = (VariableElement) element;</div><div class="line">        TypeElement typeElement = (TypeElement) variableElement.getEnclosingElement();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (typeElement.getKind() != ElementKind.CLASS) &#123;</div><div class="line">            logError(<span class="string">"只能标注类中的字段"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (typeElement.getModifiers().contains(Modifier.ABSTRACT)) &#123;</div><div class="line">            logError(<span class="string">"不能标注抽象类中的字段"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Modifier modifier : element.getModifiers()) &#123;</div><div class="line">            <span class="keyword">if</span> (modifier == Modifier.PRIVATE || modifier == Modifier.STATIC ||</div><div class="line">                    modifier == Modifier.FINAL) &#123;</div><div class="line">                logError(<span class="string">"BindView不能标注被static,"</span> +</div><div class="line">                        <span class="string">"private或者final的字段"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isSubtype(typeElement.asType(), TYPE_ACTIVITY)) &#123; <span class="comment">//判断被标注的字段的类是不是Activity的子类</span></div><div class="line">            logError(typeElement.getSimpleName() + <span class="string">"必须是 Activity的子类"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!isSubtype(variableElement.asType(), TYPE_VIEW)) &#123; <span class="comment">//判断被标注的字段是不是View的子类</span></div><div class="line">            logError(<span class="string">"BindView只能标注View的子类"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtype</span><span class="params">(TypeMirror tm, String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isSubType = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span> (tm != <span class="keyword">null</span>) &#123; <span class="comment">//循环获取父类信息</span></div><div class="line">            <span class="keyword">if</span> (type.equals(tm.toString())) &#123; <span class="comment">//通过全路径是否相等</span></div><div class="line">                isSubType = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            TypeElement superTypeElem = (TypeElement) types.asElement(tm);</div><div class="line">            <span class="keyword">if</span> (superTypeElem != <span class="keyword">null</span>) &#123;</div><div class="line">                tm = superTypeElem.getSuperclass();</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果为空, 说明没了父类, 所以直接退出</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> isSubType;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performParseAnnotations</span><span class="params">(Element element)</span> </span>&#123;</div><div class="line"></div><div class="line">        VariableElement variableElement = (VariableElement) element;</div><div class="line">        TypeElement typeElement = (TypeElement) variableElement.getEnclosingElement();</div><div class="line"></div><div class="line">        String className = typeElement.getSimpleName().toString();</div><div class="line"></div><div class="line">        ViewClass viewClass = map.get(className);</div><div class="line">        ViewField field = <span class="keyword">new</span> ViewField(variableElement);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (viewClass == <span class="keyword">null</span>) &#123;</div><div class="line">            viewClass = <span class="keyword">new</span> ViewClass(elements.getPackageOf(variableElement).getQualifiedName().toString(),</div><div class="line">                    className, typeElement);</div><div class="line">            map.put(className, viewClass);</div><div class="line">        &#125;</div><div class="line">        viewClass.addField(field);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (ViewClass vc : map.values()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                vc.generateCode().writeTo(filer);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                logError(<span class="string">"error in parse"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">        annotations.add(BindView.class.getCanonicalName());</div><div class="line">        <span class="keyword">return</span> annotations;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        log(Diagnostic.Kind.ERROR, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logNote</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        log(Diagnostic.Kind.NOTE, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Diagnostic.Kind kind, String msg)</span> </span>&#123;</div><div class="line">        messager.printMessage(kind, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了使代码结构更为清晰, 这里将注解标注的字段的信息抽象为<code>ViewField</code>类, 字段所属的类的信息抽象为<code>ViewClass</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewField</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String fieldName;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewField</span><span class="params">(VariableElement variableElement)</span> </span>&#123;</div><div class="line">        id = variableElement.getAnnotation(BindView.class).value();</div><div class="line">        fieldName = variableElement.getSimpleName().toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFieldName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> fieldName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String packName;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String className;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;ViewField&gt; fields = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TypeElement typeElement;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewClass</span><span class="params">(String packName, String className, TypeElement typeElement)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.packName = packName;</div><div class="line">        <span class="keyword">this</span>.className = className;</div><div class="line">        <span class="keyword">this</span>.typeElement = typeElement;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addField</span><span class="params">(ViewField viewField)</span> </span>&#123;</div><div class="line">        fields.add(viewField);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> JavaFile <span class="title">generateCode</span><span class="params">()</span> </span>&#123; <span class="comment">//为了方便, 这里生成代码用了JavaPoet库来生成代码</span></div><div class="line">        MethodSpec.Builder con = MethodSpec.constructorBuilder()</div><div class="line">                .addModifiers(Modifier.PUBLIC)</div><div class="line">                .addParameter(TypeName.get(typeElement.asType()), <span class="string">"activity"</span>)</div><div class="line">                .addParameter(ClassName.get(<span class="string">"android.view"</span>, <span class="string">"View"</span>), <span class="string">"view"</span>)</div><div class="line">                .beginControlFlow(<span class="string">"if (activity == null)"</span>)</div><div class="line">                .addStatement(<span class="string">"return"</span>)</div><div class="line">                .endControlFlow();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (ViewField f : fields) &#123;</div><div class="line">            con.addStatement(<span class="string">"activity.$N = view.findViewById($L)"</span>, f.getFieldName(), f.getId());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        FieldSpec.Builder fid = FieldSpec.builder(TypeName.get(typeElement.asType()), <span class="string">"activity"</span>);</div><div class="line">        TypeSpec typeSpec = TypeSpec.classBuilder(className + <span class="string">"$ViewBinding"</span>)</div><div class="line">                .addModifiers(Modifier.PUBLIC)</div><div class="line">                .addField(fid.build())</div><div class="line">                .addMethod(con.build())</div><div class="line">                .build();</div><div class="line">        <span class="keyword">return</span> JavaFile.builder(packName, typeSpec).build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理过程其实并不复杂, 只是需要我们熟悉<code>API</code>而已, 因此, 接下来总结一下获取一些常用信息的方法:</p>
<h5 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Types types;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Filer filer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messager messager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Elements elements;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_ACTIVITY = <span class="string">"android.app.Activity"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_VIEW = <span class="string">"android.view.View"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(processingEnvironment);</div><div class="line">        types = processingEnvironment.getTypeUtils();</div><div class="line">        filer = processingEnvironment.getFiler();</div><div class="line">        messager = processingEnvironment.getMessager();</div><div class="line">        elements = processingEnvironment.getElementUtils();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Element e : roundEnvironment.getElementsAnnotatedWith(BindView.class)) &#123;</div><div class="line">            String packName = elements.getPackageOf(e).getQualifiedName().toString(); <span class="comment">//获取包名</span></div><div class="line"></div><div class="line">            <span class="comment">//2: 获取类名.</span></div><div class="line">            <span class="comment">//如果标注的是类的话</span></div><div class="line">            TypeElement t = (TypeElement)e;</div><div class="line">            String className = t.getSimpleName().toString();</div><div class="line"></div><div class="line">            <span class="comment">//如果被标注的是字段或者是方法</span></div><div class="line">            TypeElement t = (TypeElement)e.getEnclosingElement();</div><div class="line">            String className = t.getSimpleName().toString();</div><div class="line"></div><div class="line">            <span class="comment">//3. 获取方法名字, 或者字段名字</span></div><div class="line">            String name = e.getSimpleName().toString();</div><div class="line"></div><div class="line">            <span class="comment">//4: 获取标注的注解</span></div><div class="line">            BindView annotation = e.getAnnotation(BindView.class);</div><div class="line">            <span class="keyword">int</span> id = annotation.value();</div><div class="line"></div><div class="line">            <span class="comment">//5: 判断被标注的元素类型, 以字段类型为例子</span></div><div class="line">            ElementKind kind = e.getKind();</div><div class="line">            <span class="keyword">if</span> (kind == ElementKind.FIELD) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//6: 获取元素的修饰符. 我们以被修饰的字段为例子.</span></div><div class="line">            <span class="keyword">for</span> (Modifier modifier : e.getModifiers()) &#123;</div><div class="line">                <span class="keyword">if</span> (modifier == Modifier.PRIVATE || modifier == Modifier.STATIC ||</div><div class="line">                modifier == Modifier.FINAL) &#123;</div><div class="line">                  logError(<span class="string">"BindView不能标注被static,"</span> +</div><div class="line">                    <span class="string">"private或者final的字段"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//7: 判读被标注的元素的是不是某个类的子类, 以View类为例子, 判读被修饰的字段是否是View的子类</span></div><div class="line">            TypeMirror tm = e.asType();</div><div class="line">            <span class="keyword">boolean</span> isSubType = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">while</span> (tm != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="string">"android.view.View"</span>.equals(tm.toString())) &#123;</div><div class="line">                    isSubType = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                TypeElement t = (TypeElement)types.asElement(tm);</div><div class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">                    tm = t.getSuperclass(); <span class="comment">//获取父类信息</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果为空, 说明没了父类, 所以直接退出</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="viewbinding"><a href="#viewbinding" class="headerlink" title="viewbinding"></a>viewbinding</h4></blockquote>
<p>模板代码已经生成了, 但是我们还需要实例化这些类. 这个工作交由<code>viewbinding</code>. 它提供一些绑定的<code>API</code>给<code>app</code>. 这样我们就不需要手动调用了.</p>
<p>实现的思路: 运行时利用反射去实例化对应的模板类. 为了降低反射的消耗, 内部会做响应的缓存操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBinding</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String LATTER_NAME = <span class="string">"$ViewBinding"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Constructor&lt;?&gt;&gt; CACHE = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Activity&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(T target)</span> </span>&#123;</div><div class="line">        View sourceView = target.getWindow().getDecorView();</div><div class="line">        bind(target, sourceView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(T target, View sourceView)</span> </span>&#123;</div><div class="line">        Class&lt;? extends Activity&gt; cl = target.getClass();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; bindClass = findBindClass(cl);</div><div class="line">            Constructor&lt;?&gt; constructor = findBindConstructor(bindClass, cl);</div><div class="line">            constructor.newInstance(target, sourceView);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; findBindClass(Class&lt;?&gt; targetClass) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        <span class="keyword">return</span> targetClass.getClassLoader().loadClass(targetClass.getName() + LATTER_NAME);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;?&gt; findBindConstructor(Class&lt;?&gt; bindClass, Class&lt;? extends Activity&gt; targetClass) <span class="keyword">throws</span> NoSuchMethodException &#123;</div><div class="line">        Constructor&lt;?&gt; constructor = CACHE.get(bindClass);</div><div class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</div><div class="line">            constructor = bindClass.getConstructor(targetClass, View.class);</div><div class="line">            CACHE.put(bindClass, constructor);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> constructor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4></blockquote>
<p>注解处理器现在算是开发好了. 最后的步骤就是在<code>app</code>中添加依赖, 然后实现绑定.</p>
<p>在<code>app</code>的<code>build.gradle</code>添加下面的依赖:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">implementation <span class="title">project</span><span class="params">(<span class="string">':viewbinding'</span>)</span></span></div><div class="line">implementation <span class="title">project</span><span class="params">(<span class="string">':annotations'</span>)</span></div><div class="line">annotationProcessor <span class="title">project</span><span class="params">(<span class="string">':processors'</span>)</span></div></pre></td></tr></table></figure>
<p>然后在<code>MainActivity</code>中实现注入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.main_tv_hello)</div><div class="line">    TextView mTvTextView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        ViewBinding.bind(<span class="keyword">this</span>);</div><div class="line">        mTvTextView.setText(<span class="string">"xuixi"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完…</p>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></blockquote>
<p><a href="http://jinchim.com/2017/08/23/JBind/" target="_blank" rel="external">http://jinchim.com/2017/08/23/JBind/</a></p>
<p><a href="http://blog.csdn.net/dd864140130/article/details/53875814" target="_blank" rel="external">http://blog.csdn.net/dd864140130/article/details/53875814</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fm0c4an974j30m80b4qhy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;注解处理器&quot;&gt;&lt;a href=&quot;#注解处理器&quot; clas
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java反射的应用</title>
    <link href="http://cristianoro7.github.io/2017/11/25/Java%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8/"/>
    <id>http://cristianoro7.github.io/2017/11/25/Java反射应用/</id>
    <published>2017-11-25T09:49:50.475Z</published>
    <updated>2017-11-25T09:49:50.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fluguov7y5j30m80b4wux.jpg" alt=""></p>
<blockquote>
<h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3></blockquote>
<p>代理模式是在不改变被代理类的代码的情况下, 对被代理的方法进行扩展, 这些扩展可以是打印日志, 控制访问等.</p>
<p>代理模式又分为静态代理和动态代理. 静态代理是指代理类在编译时, 就能够生成字节码被<code>JVM</code>识别. 而动态代理则是在运行时, 运用反射生成代理类字节码,最后被<code>JVM</code>识别.</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理比较简单, 下面给出一个例子, 然后分析它的缺点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"I am XiaoMing, I`am going to school!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMingProxy</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Student student;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoMingProxy</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.student = student;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"goodbye mom!"</span>);</div><div class="line">        student.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        XiaoMingProxy proxy = <span class="keyword">new</span> XiaoMingProxy(<span class="keyword">new</span> XiaoMing());</div><div class="line">        proxy.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>XiaoMingProxy</code>代理对象<code>XiaoMing</code>, 在他去上学之前打印日志.</p>
<p>上面就是一个简单的静态代理. 静态代理, 有一个很明显的缺点: 必须我们自己手动写代理类, 并且<code>代理类的复用性不强</code>. <code>代理类复用性不强</code>指的是: 本来打印日志这个功能是通用的, 但是静态代理的代理类不能被其他类复用. 比如现在我们添加一个教师类, 我们也要给她添加一个打印日志的功能, 那么我们必须重新写代理类, 不能复用之前的代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Teacher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungTeacher</span> <span class="keyword">implements</span> <span class="title">Teacher</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"go to school!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherProxy</span> <span class="keyword">implements</span> <span class="title">Teacher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Teacher teacher;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TeacherProxy</span><span class="params">(Teacher teacher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.teacher = teacher;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"goodbye mon!"</span>);</div><div class="line">        teacher.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原本一样的逻辑, 我们却得再次写代理类.</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理可以解决静态代理的缺点.  它的原理是: 在运行时, 运用反射自动帮你生成实现了接口的代理类, 并且将扩展方法的逻辑都分发到了一个<code>InvocationHandler</code>中的<code>invoke</code>方法. 这样就能实例代理方法的复用. 下面我们运用动态代理来解决之前静态代理出现的问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(Object tar)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = tar;</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(tar.getClass().getClassLoader(),</div><div class="line">                tar.getClass().getInterfaces(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"goodbye mom!"</span>);</div><div class="line">        <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LoggerHandler handler = <span class="keyword">new</span> LoggerHandler();</div><div class="line"></div><div class="line">        Student student = handler.bind(<span class="keyword">new</span> XiaoMing());</div><div class="line">        student.goToSchool();</div><div class="line"></div><div class="line">        Teacher teacher = handler.bind(<span class="keyword">new</span> YoungTeacher());</div><div class="line">        teacher.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是一个动态代理的例子, 我们将打印日志的功能放在<code>LoggerHandler</code>中, 这样其他的代理类就可以通过复用这个<code>LoggerHandler</code>来复用打印日志的功能.</p>
<h4 id="动态代理原理解析"><a href="#动态代理原理解析" class="headerlink" title="动态代理原理解析"></a>动态代理原理解析</h4><p>动态代理之所以能克服静态代理的缺点, 主要是: 它是在运行时通过反射创建代理类(这个代理类实现了我们被代理类的接口), 然后返回这个代理类的引用, 每个代理类都会绑定一个<code>InvocationHandler</code>的实例. 接着每次对这个代理类的方法调用, 都会被分发到<code>InvocationHandler</code>中的<code>invoke</code>方法来统一处理. 因此<code>InvocationHandler</code>常常是我们写扩展逻辑的地方. 在<code>LoggerHandler</code>中, 它就是扩展了打印日志的功能. 这样不同被代理类如果需要扩展这个打印日志的功能的话, 就可以共享这个<code>LoggerHandler</code>来实现.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flubhp8380j30nx0bz3zp.jpg" alt=""></p>
<blockquote>
<h3 id="利用反射来获取注解"><a href="#利用反射来获取注解" class="headerlink" title="利用反射来获取注解"></a>利用反射来获取注解</h3></blockquote>
<p>反射另外一个应用是: 在运行时获取注解信息. 下面是利用反射实现的一个<code>View</code>的绑定.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.main_tv_hello_world)</div><div class="line">    <span class="keyword">private</span> TextView mTvextView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ViewInjection.inject(<span class="keyword">this</span>);</div><div class="line">        Log.d(TAG, <span class="string">"onCreate: "</span> + mTvextView.getText().toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewInjection</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> &lt;T extends Activity&gt;  <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(T activity)</span> </span>&#123;</div><div class="line">        Class activityClass = activity.getClass();</div><div class="line"></div><div class="line">        Field[] fields = activityClass.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">            BindView bindView = f.getAnnotation(BindView.class);</div><div class="line">            <span class="keyword">if</span> (bindView != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> id = bindView.value();</div><div class="line">                View view = activity.findViewById(id);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    f.setAccessible(<span class="keyword">true</span>);</div><div class="line">                    f.set(activity, view);</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3></blockquote>
<p>反射能够在运行时调用一个类的方法,或者访问其字段等, 包括被<code>private</code>修饰的字段或者方法, 这一定程度上说明了反射是具有一定的破坏性.</p>
<h4 id="利用反射绕开编译时的泛型限定"><a href="#利用反射绕开编译时的泛型限定" class="headerlink" title="利用反射绕开编译时的泛型限定"></a>利用反射绕开编译时的泛型限定</h4><p><code>Java</code>泛型是在编译期由编译器检查和实现的. 如果我们运用反射绕开编译期的泛型限定的话, 我们可以破坏泛型机制.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</div><div class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        strings.add(<span class="string">"xixi"</span>);</div><div class="line">        Method method = strings.getClass().getDeclaredMethod(<span class="string">"add"</span>, Object.class);</div><div class="line">        method.invoke(strings, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (String s : strings) &#123;</div><div class="line">            System.out.println(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>main</code>方法中, 我们在运行时, 利用反射给<code>strings</code>添加了一个<code>int</code>类型, 这样就绕开了泛型的限定. 所以当遍历<code>strings</code>时,会报异常.</p>
<h4 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="反射破坏单例"></a>反射破坏单例</h4><p>既然反射能够访问<code>private</code>字段和<code>private</code>方法, 那么我们就可以利用反射来破坏单例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</div><div class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        Singleton singleton = Singleton.getInstance();</div><div class="line">        System.out.println(singleton.hashCode());</div><div class="line"></div><div class="line">        Class c = Singleton.class;</div><div class="line">        Constructor constructor = c.getDeclaredConstructor(<span class="keyword">null</span>); <span class="comment">//获取Singleton的私有构造方法</span></div><div class="line">        constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Singleton newInstance = (Singleton) constructor.newInstance(<span class="keyword">null</span>); <span class="comment">//然后再实例化另一个</span></div><div class="line">        System.out.println(newInstance.hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行上面的代码, 最后打印出来的<code>HashCode</code>不一样, 说明单例被破坏了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fluguov7y5j30m80b4wux.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;什么是代理模式&quot;&gt;&lt;a href=&quot;#什么是代理模式&quot; 
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java反射基础</title>
    <link href="http://cristianoro7.github.io/2017/11/24/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://cristianoro7.github.io/2017/11/24/Java反射基础/</id>
    <published>2017-11-24T15:54:14.613Z</published>
    <updated>2017-11-24T15:54:14.613Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fltld849k4j30m80b47gy.jpg" alt=""></p>
<blockquote>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3></blockquote>
<p>在<code>Java</code>中, 每一个对象都对应有一个<code>Class</code>对象, 这个<code>Class</code>对象记录着对象的类型信息, 也就是类的内部结构.</p>
<p>我们知道, 我们编写的<code>.java</code>文件, 是需要被编译成<code>.class</code>文件, 然后才能被虚拟机加载执行. 正常情况下, <code>.class</code>是在编译期生成并且被<code>JVM</code>识别. 而反射机制则将<code>.class</code>文件的打开和检查推迟到运行时.</p>
<p>简单的说, 反射机制能让你在运行时操作一个类, 这些操作可以是: 实例化该类的对象, 调用对象方法和修改对象的属性值. 至于操作的类的<code>.class</code>文件可以是编译期未知.</p>
<blockquote>
<h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3></blockquote>
<p>一个类的元素可以被拆分为下面几个元素:</p>
<ul>
<li><p><code>Class</code>: 一个类对象</p>
</li>
<li><p><code>Constructor</code>: 构造器对象, 可以通过<code>Class</code>对象获得</p>
</li>
<li><p><code>Method</code>: 方法对象, 可以通过<code>Class</code>对象获得</p>
</li>
<li><p><code>Fields</code>: 字段对象, 可以通过<code>Class</code>对象获得</p>
</li>
<li><p><code>Annotation</code>: 注解对象, 可以通过<code>Class</code>对象获得</p>
</li>
</ul>
<p>从上面的元素可以看出, 我们如果要进行反射的话, 首先得获得类的<code>Class</code>对象, 进而才可以操作类的字段, 方法和构造器等.</p>
<blockquote>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3></blockquote>
<p>要进行反射, 我们首先要获得需要反射的类的<code>Class</code>对象. 而获取的方法有下面三种:</p>
<ul>
<li><p><code>Class class2 = Class.forName(&quot;com.desperado.reflaction.Bean&quot;)</code>: 调用<code>Class</code>类的<code>forName(String)</code>方法, 参数为类的全限定符号. 如果运行时找不到该类的话, 会报<code>ClassNotFoundException</code>异常. 这种方法一般用于编译期不能获得<code>.class</code>文件的情形.</p>
</li>
<li><p><code>Class class1 = Bean.class</code>: 通过类字面量来获取<code>Class</code>对象.</p>
</li>
<li><p><code>Bean bean = new Bean(); Class class3 = bean.getClass();</code>: 通过对象来获取<code>Class</code>对象.</p>
</li>
</ul>
<blockquote>
<h3 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h3></blockquote>
<p>得到<code>Class</code>对象后, 我们可以利用这个<code>Class</code>对象来获取类的构造函数, 以此来创建实例.</p>
<p>获取构造方法的方法有:</p>
<ul>
<li><p><code>getConstructors()</code>: 获取所有被<code>public</code>修饰的构造方法.</p>
</li>
<li><p><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code>: 返回指定参数类型的构造方法, 并且构造方法是被<code>public</code>修饰的.</p>
</li>
<li><p><code>getDeclaredConstructors()</code>: 获取所有的构造方法, 与权限修饰符无关.</p>
</li>
<li><p><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>: 获取指定类型的构造方法, 与权限修饰符无关.</p>
</li>
</ul>
<blockquote>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class beanClass = Bean.class;</div><div class="line">Bean  b = (Bean) beanClass.newInstance();</div></pre></td></tr></table></figure>
<p><code>newInstance()</code>这个方法会调用类无参的构造函数, 如果类没有无参构造函数的话, 会报异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Human</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class&lt;?&gt; c = Human.class;</div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line">Human human = (Human) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">Constructor priCon = c.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</div><div class="line">priCon.setAccessible(<span class="keyword">true</span>);</div><div class="line">Human h = (Human) priCon.newInstance(<span class="string">"xiaohong"</span>, <span class="number">18</span>);</div></pre></td></tr></table></figure>
<p>利用<code>getConstructor</code>方法, 调用了<code>Human</code>中带有<code>String</code>参数的构造方法.<code>getDeclaredConstructor</code>可以获取私有构造方法.</p>
<blockquote>
<h3 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h3></blockquote>
<p>利用<code>Class</code>对象, 我们可以获得<code>Method</code>来调用Class的方法. 获得<code>Method</code>的方法有:</p>
<ul>
<li><p><code>getMethods()</code>: 获取所有被<code>public</code>修饰的方法, 包含父类和接口中的方法</p>
</li>
<li><p><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 获取指定<code>name</code>的<code>public</code>方法. 包含父类的方法.</p>
</li>
<li><p><code>getDeclaredMethods()</code>:  获取所有的方法, 包括<code>private</code>. 但是不包括父类的方法</p>
</li>
<li><p><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 获取指定的方法, 包括<code>private</code>. 但是不包括父类的方法.</p>
</li>
</ul>
<blockquote>
<h4 id="getMethods和getMethod"><a href="#getMethods和getMethod" class="headerlink" title="getMethods和getMethod"></a>getMethods和getMethod</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Human</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">humanPubMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"humanPubMethod"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">humanPriMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"humanPriMethod"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoHong</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"xiaohong"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoHong</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"priMethod"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException,</span></div><div class="line">              InstantiationException, NoSuchMethodException,InvocationTargetException &#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Method method = c.getMethod(<span class="string">"humanPubMethod"</span>, <span class="keyword">null</span>);</div><div class="line">    method.invoke(xiaoHong, <span class="keyword">null</span>); <span class="comment">//调用方法</span></div><div class="line"></div><div class="line">    Method[] methods = c.getMethods();</div><div class="line">    <span class="keyword">for</span> (Method m : methods) &#123; <span class="comment">//遍历方法</span></div><div class="line">        System.out.println(m.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="getDeclaredMethod和getDeclaredMethods"><a href="#getDeclaredMethod和getDeclaredMethods" class="headerlink" title="getDeclaredMethod和getDeclaredMethods"></a>getDeclaredMethod和getDeclaredMethods</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Method method = c.getDeclaredMethod(<span class="string">"priMethod"</span>, <span class="keyword">null</span>);</div><div class="line">    method.setAccessible(<span class="keyword">true</span>);</div><div class="line">    method.invoke(xiaoHong, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    Method[] methods = c.getDeclaredMethods();</div><div class="line">    <span class="keyword">for</span> (Method m : methods)&#123;</div><div class="line">        System.out.println(m.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="获取Fields"><a href="#获取Fields" class="headerlink" title="获取Fields"></a>获取Fields</h3></blockquote>
<p>利用<code>Class</code>对象, 我们同样可以获得类的字段, 并且可以<code>set</code>和<code>get</code>字段的值. 我们可以通过下面的方法获取<code>Field</code>对象</p>
<ul>
<li><p><code>getFields()</code>: 获取类的所有被<code>public</code>修饰的字段, 包括父类中的.</p>
</li>
<li><p><code>getField(String name)</code>: 获取类的指定被<code>public</code>修饰的字段, 包括父类中的.</p>
</li>
<li><p><code>getDeclaredFields()</code>: 获取类的所有字段, 包括被<code>private</code>修饰的字段. 但是不包括父类中的.</p>
</li>
<li><p><code>getDeclaredField(String name)</code>: 获取类的指定字段, 包括被<code>private</code>修饰的字段. 但是不包括父类中的.</p>
</li>
</ul>
<blockquote>
<h4 id="getFields和getField"><a href="#getFields和getField" class="headerlink" title="getFields和getField"></a>getFields和getField</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Field field = c.getField(<span class="string">"pubName"</span>);</div><div class="line">    String pubName = (String) field.get(xiaoHong);</div><div class="line">    System.out.println(pubName);</div><div class="line"></div><div class="line">    Field[] fields = c.getFields();</div><div class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">      System.out.println(f.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="getDeclaredFields和getDeclaredField"><a href="#getDeclaredFields和getDeclaredField" class="headerlink" title="getDeclaredFields和getDeclaredField"></a>getDeclaredFields和getDeclaredField</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Field field = c.getDeclaredField(<span class="string">"name"</span>);</div><div class="line">    field.setAccessible(<span class="keyword">true</span>);</div><div class="line">    System.out.println(field.get(xiaoHong));</div><div class="line"></div><div class="line">    Field[] fields = c.getDeclaredFields();</div><div class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">      System.out.println(f.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="获得Annotation"><a href="#获得Annotation" class="headerlink" title="获得Annotation"></a>获得Annotation</h3></blockquote>
<p>由于注解可以用来标注类, 方法, 字段, 参数, 所以, <code>Annotation</code>可以通过这些来获取.下面以<code>Class</code>对象为例子. 可以通过下面两个方法获取:</p>
<ul>
<li><p><code>getAnnotation(Class&lt;A&gt; annotationClass)</code>: 获取类指定的注解</p>
</li>
<li><p><code>getAnnotations()</code>: 获取类标注的所有注解</p>
</li>
</ul>
<blockquote>
<h4 id="getAnnotations和getAnnotation-Class-annotationClass"><a href="#getAnnotations和getAnnotation-Class-annotationClass" class="headerlink" title="getAnnotations和getAnnotation(Class annotationClass)"></a>getAnnotations和getAnnotation(Class<a> annotationClass)</a></h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    BindView bindView = c.getAnnotation(BindView.class);</div><div class="line">    <span class="keyword">if</span> (bindView != <span class="keyword">null</span>) &#123;</div><div class="line">        System.out.println(bindView.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Annotation[] annotations = c.getAnnotations();</div><div class="line">    <span class="keyword">for</span> (Annotation a : annotations) &#123;</div><div class="line">        <span class="keyword">if</span> (a.annotationType().equals(BindView.class)) &#123;</div><div class="line">            System.out.println(<span class="string">"equal"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="利用反射处理数组"><a href="#利用反射处理数组" class="headerlink" title="利用反射处理数组"></a>利用反射处理数组</h3></blockquote>
<p><code>Java</code>反射机制通过<code>java.lang.reflect.Array</code>这个类来处理数组。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] ints = (<span class="keyword">int</span>[]) Array.newInstance(<span class="keyword">int</span>.class, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>上面是一个创建数组的例子, <code>newInstance</code>方法的第一个参数为: 数组存放的类型, 第二个为数组的长度.</p>
<h4 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = Array.getInt(ints, <span class="number">0</span>);</div><div class="line">Array.setInt(ints,<span class="number">1</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>对于基本类型, <code>Array</code>中提供了<code>setXX</code>和<code>getXX</code>方法来访问数组, 对于普通对象, 可以调用<code>get</code>和<code>set</code>方法.</p>
<h4 id="数组Class对象"><a href="#数组Class对象" class="headerlink" title="数组Class对象"></a>数组Class对象</h4><p>对于获取数组的<code>Class</code>对象, 可以先实例化对于的数组, 再得到它的<code>Class</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class aClass = Class.forName(<span class="string">"com.desperado.reflaction.XiaoHong"</span>); <span class="comment">//先获得class对象</span></div><div class="line">Class classArray = Array.newInstance(aClass, <span class="number">0</span>).getClass(); <span class="comment">//再创建class对象数组, 最后获取数组class对象</span></div></pre></td></tr></table></figure>
<blockquote>
<h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3></blockquote>
<p>由于泛型会在编译期被擦除, 所以我们是不能在运行时获得泛型类的参数类型的. 但是我们却可以通过使用了参数类型的字段或者返回了带有类型参数的方法来获得一个泛型类的类型信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stringList = list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取方法返回值的参数类型"><a href="#获取方法返回值的参数类型" class="headerlink" title="获取方法返回值的参数类型"></a>获取方法返回值的参数类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Method method = TClass.class.getMethod(<span class="string">"getList"</span>, <span class="keyword">null</span>);</div><div class="line">Type type = method.getGenericReturnType();</div><div class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</div><div class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">    Type[] ts = parameterizedType.getActualTypeArguments();</div><div class="line">    <span class="keyword">for</span> (Type t : ts) &#123;</div><div class="line">        Class c = (Class) t;</div><div class="line">        System.out.println(c.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取方法参数的参数类型"><a href="#获取方法参数的参数类型" class="headerlink" title="获取方法参数的参数类型"></a>获取方法参数的参数类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Field field = TClass.class.getDeclaredField(<span class="string">"stringList"</span>);</div><div class="line">Type t = field.getGenericType();</div><div class="line"><span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</div><div class="line">    ParameterizedType pt = (ParameterizedType) t;</div><div class="line">    Type[] types = pt.getActualTypeArguments();</div><div class="line">    <span class="keyword">for</span> (Type ty : types) &#123;</div><div class="line">        Class c = (Class) ty;</div><div class="line">        System.out.println(c.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取字段的参数类型"><a href="#获取字段的参数类型" class="headerlink" title="获取字段的参数类型"></a>获取字段的参数类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Method method = TClass.class.getMethod(<span class="string">"setList"</span>, List.class);</div><div class="line">Type[] type = method.getGenericParameterTypes();</div><div class="line"><span class="keyword">for</span> (Type parT : type) &#123;</div><div class="line">    <span class="keyword">if</span> (parT <span class="keyword">instanceof</span> ParameterizedType) &#123;</div><div class="line">        ParameterizedType parameterizedType = (ParameterizedType) parT;</div><div class="line">        Type[] types = parameterizedType.getActualTypeArguments();</div><div class="line">        <span class="keyword">for</span> (Type ty: types) &#123;</div><div class="line">            Class c = (Class) ty;</div><div class="line">            System.out.println(c.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3></blockquote>
<h3 id="Java核心编程思想"><a href="#Java核心编程思想" class="headerlink" title="Java核心编程思想"></a>Java核心编程思想</h3><h3 id="http-ifeve-com-java-reflection-9-generics"><a href="#http-ifeve-com-java-reflection-9-generics" class="headerlink" title="http://ifeve.com/java-reflection-9-generics/"></a><a href="http://ifeve.com/java-reflection-9-generics/" target="_blank" rel="external">http://ifeve.com/java-reflection-9-generics/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fltld849k4j30m80b47gy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;什么是反射&quot;&gt;&lt;a href=&quot;#什么是反射&quot; clas
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java注解基础</title>
    <link href="http://cristianoro7.github.io/2017/11/22/Java%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/"/>
    <id>http://cristianoro7.github.io/2017/11/22/Java注解基础/</id>
    <published>2017-11-22T12:34:53.714Z</published>
    <updated>2017-11-22T12:34:53.714Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flr4xe3496j30m80b47mn.jpg" alt=""></p>
<blockquote>
<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3></blockquote>
<p>注解是一种元数据, 它能够让我们在代码中添加信息, 使得我们可以在稍后的某个时刻非常方便地使用这些数据.</p>
<blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3></blockquote>
<ul>
<li><p>编译时生成一些配置文件或者部署文件</p>
</li>
<li><p>可以根据注解中的数据来生成模板代码, 从而减轻编写模板代码的负担</p>
</li>
</ul>
<blockquote>
<h3 id="Java内置的3个注解"><a href="#Java内置的3个注解" class="headerlink" title="Java内置的3个注解"></a>Java内置的3个注解</h3></blockquote>
<p><code>Java</code>内置了3个注解, 他们是:</p>
<ul>
<li><p><code>Override</code>: 表示当前方法定义将覆盖父类的方法. 如果你不小心拼写错误的话, 编译器会报警提示.</p>
</li>
<li><p><code>Deprecated</code>: 如果使用了被该注解标注的元素的话, 编译器会发出警告.</p>
</li>
<li><p><code>SuppressWarning</code>: 关闭编译器的报警提示.</p>
</li>
</ul>
<p>上面的3个注解是<code>Java</code>内置的注解, 主要是帮助编译器来检查和规范代码.</p>
<blockquote>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3></blockquote>
<p><code>Java</code>内置的注解一般是不满足我们平常开发的需求的, 因此我们需要自己自定义注解. 下面说说用于描述注解的<code>元注解</code>, 接着再谈谈注解元素支持的类型.</p>
<blockquote>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4></blockquote>
<p><code>元注解</code>是描述注解的注解, 他们负责定义创建的注解的一些信息:</p>
<ul>
<li><p><code>@Target</code>: 表示该注解是用于什么地方的, 可选的字段有:</p>
<ol>
<li><code>CONSTRUCTOR</code>: 用于注解构造器</li>
<li><code>FIELD</code>: 用于注解实例域</li>
<li><code>METHOD</code>: 用于注解方法</li>
<li><code>PACKAGE</code>: 用于注解包</li>
<li><code>PARAMETER</code>: 用于注解参数</li>
<li><code>TYPE</code>: 用于注解类, 接口(包括注解类型)或者枚举.</li>
</ol>
</li>
<li><p><code>@Retention</code>: 用于描述注解的声明周期, 或者说是需要在什么时候保留注解信息, 什么时候丢弃注解信息. 可选的字段有:</p>
<ol>
<li><code>SOURCE</code>: 注解在源文件内有效, 但是会被编译器丢弃.</li>
<li><code>CLASS</code>: 注解在<code>.class</code>文件内有效, 但是会被<code>VM</code>丢弃.</li>
<li><code>RUNTIME</code>: 注解在运行时有效, 因此可以在运行时通过反射来获取注解的信息.</li>
</ol>
</li>
<li><p><code>@Document</code>: 将此注解包含在<code>Javadoc</code>中.</p>
</li>
<li><p><code>@Inherit</code>: 允许子类继承父类拥有的注解, 注意: 这里并不是说注解支持继承.</p>
</li>
</ul>
<blockquote>
<h4 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h4></blockquote>
<p>注解内的元素可用的类型如下:</p>
<ul>
<li><p>所有基本类型.</p>
</li>
<li><p><code>String</code></p>
</li>
<li><p><code>Class</code></p>
</li>
<li><p><code>enum</code></p>
</li>
<li><p><code>Annotation</code></p>
</li>
<li><p>以上类型的所有数组形式.</p>
</li>
</ul>
<blockquote>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</div><div class="line">    <span class="function">String <span class="title">date</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">    <span class="function">String <span class="title">describe</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Author</span>(</div><div class="line">        name = &#123;<span class="string">"xiaoming, xiaohong"</span>&#125;,</div><div class="line">        describe = <span class="string">"注册器"</span>,</div><div class="line">        date = <span class="string">"2017/11/22"</span></div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterController</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Author</code>是一个自定义的注解. 定义注解的语法跟定义接口很像, 只不过多了在<code>interface</code>之前加<code>@</code>符号的这个步骤. 在<code>Author</code>中, <code>@Target</code>的元素值为:<code>ElementType.TYPE</code>和<code>ElementType.METHOD</code>, 表示该注解用于标注类或者方法. <code>@Retention</code>的元素值为: <code>RetentionPolicy.CLASS</code>表示在<code>.class</code>文件中仍然保持注解, 但是在运行时, 注解会被丢弃.</p>
<p><code>Author</code>中的元素值都有被<code>default</code>标注, 这个关键字可以为元素值设置一个默认值. 需要注意的是, 注解是不支持不确定的值的, 所以在使用注解时, 要么给出注解的确定值, 要么在定义注解给定默认值. 注解不支持<code>null</code>. 在定义注解时, 最好都给每个元素标注要默认值, 用于表示特殊的状态. 例如, <code>int</code>类型可以用<code>-1</code>来表示默认值; <code>String</code>类型可以用<code>&quot;&quot;</code>空字符串来表示默认值.</p>
<blockquote>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3></blockquote>
<p>定了注解后, 我们会运用反射或者注解处理器去获取注解元素的值, 然后生成一些配置文件或者模板代码.</p>
<p>反射是在运行时获取注解的元素值, 会比较耗性能. 所以在移动端会比较少用反射. 后端用得比较多.</p>
<p>注解处理器则是在编译时, 通过扫描源文件来获取注解元素的值, 不存在性能的问题, 最多是增加编译的时长. 因此, 注解处理器在移动端会用得比较多.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1flr4xe3496j30m80b47mn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; clas
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android动画框架总结</title>
    <link href="http://cristianoro7.github.io/2017/11/21/Android%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://cristianoro7.github.io/2017/11/21/Android动画框架总结/</id>
    <published>2017-11-21T09:32:34.677Z</published>
    <updated>2017-11-21T09:32:34.677Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flpsxet776j30m80b4tf9.jpg" alt=""></p>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>在<code>Android</code>中, 动画分为两种: <code>Animation</code>和<code>Transition</code>. 其中<code>Animation</code>分为<code>View Animation</code>和<code>Property Animation</code>.</p>
<p><code>Transition</code>是用于<code>Activity</code>和<code>Fragment</code>的转场动画.</p>
<p><code>View Animation</code>的作用对象是整个<code>View</code>对象, 它只支持4种动画效果: 平移, 缩放, 旋转和透明度动画. 另外, <code>View Animation</code>的一种特殊表现为: 逐帧动画. 它是通过缓慢的播放一组图像来到达一种动画效果. 需要注意的是: 由于逐帧动画是播放一组图像, 如果图片太大的话, 容易导致<code>OOM</code>.</p>
<p><code>Property Animation</code>中文意思为: 属性动画. 它是<code>Android 3.0</code>推出的全新动画. 它主要是为了弥补<code>View Animation</code>的缺陷. <code>View Animation</code>只能支持<code>View</code>的四中动画. 除了这四种外的动画, <code>View Animation</code>都无能为力. 例如: 颜色的渐变动画.</p>
<p>下面主要总结一下<code>Android</code>中的属性动画.</p>
<blockquote>
<h3 id="动画的简单原理"><a href="#动画的简单原理" class="headerlink" title="动画的简单原理"></a>动画的简单原理</h3></blockquote>
<p>假设现在有一个<code>View</code>, 它的<code>X</code>坐标为0. 如果我们想让它移动到<code>X</code>坐标为100的地方. 我们可以调用<code>view.setTranslationX()</code>. 但是出来的效果是: <code>View</code>在一瞬间跳跃到了100那里, 给人一种非常突然的感觉. 基于这种情况, 我们要让<code>View</code>移动到100的地方这个过程更符合人类的感官. 所以我们可以在一定的时间内, 每一帧改变<code>View</code>的位置, 当最后一帧的时候, 让<code>View</code>处于最终位置. 这样会比较符合人类的感官.</p>
<p>简单的来讲, 动画的整个过程可以这么概括: 给定一个动画完成的时间<code>S</code>, 动画每一帧的时间<code>Sa</code>, 根据经过的帧数来计算出动画完成的时间度(n*Sa / S). 接着根据这个时间完成度, 计算出动画完成度<code>D</code>. 最后根据<code>D</code>来计算出此时对应的属性为多少, 然后根据这个值来重新绘制.</p>
<p>时间完成度通过一个<code>TimeInterpolator</code>来计算出来动画的完成度. 而动画完成度通过<code>TypeEvaluator</code>计算出此刻的属性.</p>
<blockquote>
<h3 id="属性动画API"><a href="#属性动画API" class="headerlink" title="属性动画API"></a>属性动画API</h3></blockquote>
<p>在使用属性动画时, 我们可以用这三个类:</p>
<ul>
<li><p><code>ValueAnimator</code>: 最基础的动画类, 它只负责根据时间完成度来计算出动画完成度. API最难使用, 但是最为灵活.</p>
</li>
<li><p><code>ObjectAnimator</code>: <code>ValueAnimator</code>的子类, 对<code>ValueAnimator</code>进一步的封装. 内部会根据传入的属性值来调用其对应的<code>set</code>和<code>get</code>方法来更新界面. API比较简单, 但是灵活性不如<code>ValueAnimator</code>.</p>
</li>
<li><p><code>ViewPropertyAnimator</code>: 针对<code>Android View</code>控件的动画的封装. 该类的使用场景: 多个动画需要同时进行. 该类内部会只调用一个重绘操作. 这也是该类的一个主要优化. 它的API调用最为简单. 但是只支持<code>View</code>的四种动画, 灵活性不大.</p>
</li>
</ul>
<blockquote>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3></blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>ViewPropertyAnimator</code>的使用最为简单:</p>
<ul>
<li>执行单个动画:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.animate().translationX(<span class="number">50</span>);  <span class="comment">//向右平移50</span></div></pre></td></tr></table></figure>
<ul>
<li>多个动画同时执行:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">view.animate()</div><div class="line">    .setDuration(<span class="number">400</span>)</div><div class="line">    .setInterpolator(<span class="keyword">new</span> LinearInterpolator())</div><div class="line">    .translationX(<span class="number">50</span>)</div><div class="line">    .scaleX(<span class="number">0.5f</span>);</div></pre></td></tr></table></figure>
<p>由于<code>ViewPropertyAnimator</code>在播放多个动画时, 只支持同时播放, 所以播放同时播放多个动画时, 各个动画是共享<code>Interpolator</code>和播放时间的.</p>
<h4 id="设置监听器"><a href="#设置监听器" class="headerlink" title="设置监听器"></a>设置监听器</h4><p><code>ViewPropertyAnimator</code>支持设置三种类型的监听器:</p>
<ul>
<li><p><code>ViewPropertyAnimator.setListener()</code></p>
</li>
<li><p><code>ViewPropertyAnimator.setUpdateListener()</code></p>
</li>
<li><p><code>ViewPropertyAnimator.withStartAction/EndAction()</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">propertyAnimator.setListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画开始时被回调</span></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画完成的时候被回调, 注意: 当动画被取消后, 该方法也会回调.</span></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画被取消的时候被会回调</span></div><div class="line">                            &#125;   </div><div class="line"></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画重复执行的时候被回调</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line"></div><div class="line">propertyAnimator.setListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</div><div class="line">                          <span class="comment">//如果不想重写那么多方法的话, 可以利用这个适配器</span></div><div class="line">                          <span class="comment">//根据需要重写对应的方法</span></div><div class="line">                        &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">propertyAnimator.setUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">                          <span class="meta">@Override</span></div><div class="line">                          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                          <span class="comment">//动画更新时被调用, 默认更新的时间为10ms</span></div><div class="line">                          &#125;&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">propertyAnimator.withEndAction(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="comment">//动画结束的时候被调用(被取消的时候不会被调用), 该监听器是一次性的, 只要被调用过一次的话, 后面就不会再被调用了</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line"></div><div class="line">                        propertyAnimator.withEndAction(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画开始的时候被调用, 该监听器是一次性的, 只要被调用过一次的话, 后面就不会再被调用了</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div></pre></td></tr></table></figure>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p><code>ViewPropertyAnimator</code>的动画只支持<code>View</code>的四种动画. 还有只支持多个动画同时播放. 所以它的适用场景:</p>
<ul>
<li><p>需要的动画类型为: <code>View</code>的四种动画.(因此API调用简单)</p>
</li>
<li><p>需要的是<code>View</code>动画类型, 并且多个动画同时播放. (因此内部会只进行一次重绘的优化)</p>
</li>
</ul>
<blockquote>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3></blockquote>
<p>如果你有一个自定义<code>View</code>, 它是一个自定义的圆形进度条. 你想对它的进度进行动画, 但是进度的类型为<code>float</code>, 因此, <code>ViewPropertyAnimator</code>不能胜任. 此时就要用<code>ObjectAnimator</code>了.</p>
<p><code>ObjectAnimator</code>支持对任何类型值进行动画. 但是有一个前提: 在自定义<code>View</code>的内部添加<code>setter</code>和<code>getter</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"progress"</span>, <span class="number">0</span>, <span class="number">75</span>);</div><div class="line">animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</div><div class="line">animator.start();</div></pre></td></tr></table></figure>
<h4 id="Interpolator"><a href="#Interpolator" class="headerlink" title="Interpolator"></a>Interpolator</h4><p>前面说过, <code>Interpolator</code>是计算动画完成度的依据. 它本质上是一个算法, 动画的完成度由时间完成度根据这个算法算出来的.</p>
<p>系统自带了它的很多子类. 这里不多说, 可以参考这<a href="http://hencoder.com/ui-1-6/" target="_blank" rel="external">篇文章</a></p>
<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p><code>ObjectAnimator</code>支持三种监听器</p>
<ul>
<li><p><code>ObjectAnimator.addListener()</code></p>
</li>
<li><p><code>ObjectAnimator.addUpdateListener()</code></p>
</li>
<li><p><code>ObjectAnimator.addPauseListener()</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">animator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画开始时被回调</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画完成的时候被回调, 注意: 当动画被取消后, 该方法也会回调.</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画被取消的时候被会回调</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画重复执行的时候被回调</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line"></div><div class="line">animator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</div><div class="line">                  <span class="comment">//如果不想重写那么多方法的话, 可以利用这个适配器</span></div><div class="line">                  <span class="comment">//根据需要重写对应的方法</span></div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画更新时被调用, 默认更新的时间为10ms</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">animator.addPauseListener(<span class="keyword">new</span> Animator.AnimatorPauseListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationPause</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                        <span class="comment">//动画被暂停的时候回调</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationResume</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                        <span class="comment">//动画被恢复的时候调用</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>当动画类型不是<code>View</code>的四种动画类型, 并且你有权利给你的<code>View</code>添加<code>setter</code>和<code>getter</code></li>
</ul>
<p>但是如果你没有权利给<code>View</code>添加<code>setter</code>和<code>getter</code>方法呢? 比如你正在用一个第三方的<code>View</code>. 这时候有两种选择:</p>
<ul>
<li><p>用一个类来包装你的<code>View</code>, 为包装<code>View</code>添加<code>setter</code>和<code>getter</code>方法.</p>
</li>
<li><p>使用<code>ValuesAnimator</code>来自己手动更新.</p>
</li>
</ul>
<blockquote>
<h3 id="ValuesAnimator"><a href="#ValuesAnimator" class="headerlink" title="ValuesAnimator"></a>ValuesAnimator</h3></blockquote>
<p><code>ValuesAnimator</code>是<code>ViewPropertyAnimator</code>和<code>ObjectAnimator</code>的父类, 这两个类都是对<code>ValuesAnimator</code>的进一步封装, 以此来提供更为便利的<code>API</code>调用. 因此这两个类的灵活性也下降了. 当上面的两个类都不能满足你的需求时, 你可以使用<code>ValuesAnimator</code>, 让它帮你计算每一帧后的属性值, 然后你监听这个属性的变化, 最后设置对应的属性, 并且重绘<code>View</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">100</span>);</div><div class="line">valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                        <span class="keyword">int</span> value = (<span class="keyword">int</span>) animation.getAnimatedValue();</div><div class="line">                        <span class="comment">//设置 value属性, 并且重绘View</span></div><div class="line">              &#125;</div><div class="line">&#125;);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure>
<p>从上面的代码, 我们发现, <code>ValueAnimator</code>的<code>API</code>调用相比前两个类, 要复杂一点, 但是它最为灵活. 前两个类只不过是对<code>ValueAnimator</code>的封装, 以便提供更为方便的<code>API</code>.</p>
<blockquote>
<h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a>TypeEvaluator</h3></blockquote>
<p><code>TypeEvaluator</code>为估值器, 前面说到, 算出动画的完成度后, 我们可以根据这个动画完成度来计算出当前属性的值. 那怎么算呢? <code>TypeEvaluator</code>就是来完成这个计算工作的.</p>
<p>在<code>ObjectAnimator</code>中, 我们常用的是<code>ofInt</code>和<code>ofFloat</code>方法, 但是如果你的属性是一个对象呢? 比如<code>PointF</code>对象, 这时, 应该使用<code>ofObject</code>方法.</p>
<p>下面以官方提供的一个<code>PontFEvaluator</code>为例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofObject(view, <span class="string">"point"</span>, <span class="keyword">new</span> PointFEvaluator(), <span class="keyword">new</span> PointF(<span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                       <span class="keyword">new</span> PointF(<span class="number">100</span>, <span class="number">100</span>));</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointFEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">PointF</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> PointF mPoint;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PointFEvaluator</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PointFEvaluator</span><span class="params">(PointF reuse)</span> </span>&#123;</div><div class="line">      mPoint = reuse;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> PointF <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, PointF startValue, PointF endValue)</span> </span>&#123;</div><div class="line">      <span class="keyword">float</span> x = startValue.x + (fraction * (endValue.x - startValue.x)); <span class="comment">//根据动画完成度算出X坐标</span></div><div class="line">      <span class="keyword">float</span> y = startValue.y + (fraction * (endValue.y - startValue.y)); <span class="comment">//根据动画完成度算出Y坐标</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (mPoint != <span class="keyword">null</span>) &#123;</div><div class="line">          mPoint.set(x, y);</div><div class="line">          <span class="keyword">return</span> mPoint; <span class="comment">//返回对应的新对象</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> PointF(x, y);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="多个属性的动画同时执行"><a href="#多个属性的动画同时执行" class="headerlink" title="多个属性的动画同时执行"></a>多个属性的动画同时执行</h3></blockquote>
<p><code>ViewPropertyAnimator</code>调用多个属性进行动画时, 是同时进行的. 那么对于<code>ObjectAnimator</code>呢? 它如何让多个属性进行配合? 答案是使用<code>PropertyValuesHolder</code>. 用法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(<span class="string">"scaleX"</span>, <span class="number">1.5f</span>);</div><div class="line">PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(<span class="string">"scaleY"</span>, <span class="number">1.5f</span>);</div><div class="line">PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(<span class="string">"alpha"</span>, <span class="number">0.4f</span>);</div><div class="line"></div><div class="line">ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3);</div><div class="line">objectAnimator.start();</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="多个动画配合执行"><a href="#多个动画配合执行" class="headerlink" title="多个动画配合执行"></a>多个动画配合执行</h3></blockquote>
<p>有时候, 我们需要的效果可能是多个动画配合执行, 这时候, 我们可以用<code>AnimatorSet</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator1 = ObjectAnimator.ofInt(...);</div><div class="line">ObjectAnimator animator2 = ObjectAnimator.ofInt(...);</div><div class="line">ObjectAnimator animator3 = ObjectAnimator.ofInt(...);</div><div class="line"></div><div class="line">AnimatorSet set = <span class="keyword">new</span> AnimatorSet();</div><div class="line"></div><div class="line">set.playSequentially(animator1, animator2, animator3); <span class="comment">//按顺序播放</span></div><div class="line">set.start();</div><div class="line"></div><div class="line">set.playTogether(animator1, animator2); <span class="comment">//同时播放</span></div><div class="line">set.start();</div><div class="line"></div><div class="line">set.play(animator1).with(animator2);</div><div class="line">set.play(animator2).after(animator3); <span class="comment">//进行精准控制播放</span></div><div class="line">set.start();</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li><p>当你的动画类型是<code>View</code>四种动画的其中一种或者两种以上的话, 优先使用<code>ViewPropertyAnimator</code> 因为<code>API</code>调用很简单.</p>
</li>
<li><p>当<code>ViewPropertyAnimator</code>不能满足你的需求时, 使用<code>ObjectAnimator</code>.</p>
</li>
<li><p>如果使用的<code>View</code>的属性没有对应的<code>setter</code>和<code>getter</code>方法的话, 可以使用<code>ValueAnimator</code>.</p>
</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></blockquote>
<p><a href="http://hencoder.com/ui-1-6/" target="_blank" rel="external">HenCoder</a></p>
<p>Android开发艺术探索</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1flpsxet776j30m80b4tf9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;hea
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="Android#自定义View" scheme="http://cristianoro7.github.io/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发机制总结</title>
    <link href="http://cristianoro7.github.io/2017/11/21/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://cristianoro7.github.io/2017/11/21/Android事件分发机制总结/</id>
    <published>2017-11-21T09:32:31.885Z</published>
    <updated>2017-11-21T09:32:31.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fll5g8ssmmj30m80b4aiv.jpg" alt=""></p>
<p>关于<code>Andorid</code>事件分发机制的解析, 网上一堆文章, 并且写得很详细, 因此这里只写写一些总结, 不涉及原理的解析.</p>
<blockquote>
<h2 id="分发对象"><a href="#分发对象" class="headerlink" title="分发对象"></a>分发对象</h2></blockquote>
<p>在<code>Android</code>中, 点击手势被封装成<code>MotionEvent</code>对象. 因此对于点击事件的分发, 实质上是对<code>MotionEvent</code>对象的分发.</p>
<p>对于单点触控, 有下面两种情况的手势对应<code>MotionEvent</code>的状态:</p>
<ul>
<li><p>点击 -&gt; 松开 : <code>ACTION_DOWN</code> -&gt; <code>ACTION_UP</code></p>
</li>
<li><p>点击 -&gt; 移动 -&gt; 移动 -&gt; …-&gt; 松开 :　<code>ACTION_DOWN</code> -&gt; <code>ACTION_MOVE</code> -&gt; <code>ACTION_MOVE</code> -&gt; … -&gt; <code>ACTION_UP</code></p>
</li>
</ul>
<blockquote>
<h2 id="事件的传递顺序"><a href="#事件的传递顺序" class="headerlink" title="事件的传递顺序"></a>事件的传递顺序</h2></blockquote>
<p>点击事件发生后, 事件的传递顺序为: <code>Activity</code> -&gt; <code>PhoneWindow</code> -&gt; <code>DecorView</code> -&gt; <code>ViewGroup</code> …. -&gt; <code>View</code></p>
<blockquote>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2></blockquote>
<p><code>Android</code>事件分发机制的设计思想是基于责任链模式. 事件在传递的过程中, 先从上层传递到下层, 在这个过程中, 如果该事件你需要处理的话, 可以拦截下来处理, 如果不需要的话, 交给下层处理. 当事件传递到底层且底层不处理事件的话, 事件会从底层往上层传递. 如果上传的过程中, 事件没有被消费的话, 最终由<code>Activity</code>消费.</p>
<blockquote>
<h2 id="分发过程中涉及的方法"><a href="#分发过程中涉及的方法" class="headerlink" title="分发过程中涉及的方法"></a>分发过程中涉及的方法</h2></blockquote>
<p>事件分发的过程中, 事件需要被传递, 被分发, 分消费, 这些操作涉及到下面的方法:</p>
<p><code>public boolean dispatchTouchEvent(MotionEvent ev)</code> : 用来分发事件</p>
<p><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code> : 用来判断是否拦截事件, 如果当前<code>View</code>拦截了某个事件, 那么同一个事件序列当中, 此方法不会被调用. 换句话说, 该方法不是每次都会被调用.</p>
<p><code>public boolean onTouchEvent(MotionEvent ev)</code> : 用来处理点击事件.</p>
<p>上面的三个方法的关系可以用下面的伪代码来表示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> isConsume = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123; <span class="comment">//判断是否要拦截</span></div><div class="line">      isConsume = onTouchEvent(ev); <span class="comment">//是的话, 自己处理点击事件</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      isConsume = child.dispatchTouchEvent(ev); <span class="comment">//不是的话, 传递给下一层处理</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isConsume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: 事件的消费与否是通过<code>boolean</code>来标识的, <code>true</code>表示消费事件, <code>false</code>表示不消费事件. 事件的消费与否与是否使用了<code>MotionEvent</code>对象无关.</p>
</blockquote>
<p>前面说过, 事件的传递顺序为 : <code>Activity</code> -&gt; <code>PhoneWindow</code> -&gt; <code>DecorView</code> -&gt; <code>ViewGroup</code> …. -&gt; <code>View</code>. 下面我们来看看<code>Activity</code>, <code>ViewGroup</code>和<code>View</code>中是否有上面的三个方法:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>方法</th>
<th>Activity</th>
<th>ViewGroup</th>
<th>View</th>
</tr>
</thead>
<tbody>
<tr>
<td>事件分发</td>
<td>dispatchTouchEvent</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>事件拦截</td>
<td>onInterceptTouchEvent</td>
<td>不存在</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>事件消费</td>
<td>onTouchEvent</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody>
</table>
<blockquote>
<p>从上表可以看出: <code>Activity</code>和<code>View</code>是不存在事件拦截的.</p>
<h2 id="事件分发的总体流程"><a href="#事件分发的总体流程" class="headerlink" title="事件分发的总体流程"></a>事件分发的总体流程</h2></blockquote>
<p>一个点击时事件总是先到达<code>Activity</code>, 然后传给<code>Window</code>, 接着<code>Window</code>传给顶级<code>View</code>, 最后按照事件分发机制去分发. 分发的流程图如下:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fll2pjny8dj30jb0u3jtj.jpg" alt=""></p>
<blockquote>
<h2 id="监听器的优先级"><a href="#监听器的优先级" class="headerlink" title="监听器的优先级"></a>监听器的优先级</h2></blockquote>
<p>当一个<code>View</code>设置了<code>OnTouchListener</code>, 那么<code>OnTouchListener</code>的<code>onTouch</code>会先被调用. 如果<code>OnTouch</code>返回<code>true</code>的话, 事件被消费. 如果返回<code>false</code>的话, 当前<code>View</code>的<code>onTouEvent</code>会被调用. 而在<code>onTouchEvent</code>中, 会根据事件类型来调用<code>OnLongClickListener</code>或者<code>OnClickListener</code>监听器的监听方法.</p>
<p>换句话说, 监听器的优先级为: <code>OnTouchListener</code> -&gt; <code>OnLongClickListener</code> -&gt; <code>OnClickListener</code>.</p>
<blockquote>
<h2 id="View默认的消费事件行为"><a href="#View默认的消费事件行为" class="headerlink" title="View默认的消费事件行为"></a>View默认的消费事件行为</h2></blockquote>
<p>如果<code>View</code>的<code>clickable</code>属性为<code>true</code>的话, 该<code>View</code>会默认消费事件.</p>
<p>如果给<code>View</code>设置了<code>onClickListener</code>、<code>onLongClickListener</code>、<code>OnContextClickListener</code>其中一个监听器, 或者<code>android:clickable=&quot;true&quot;</code>的话, 该<code>View</code>是可点击的, 也就是<code>clickable</code>为<code>true</code>.</p>
<p>有些控件默认是可点击的, 比如:<code>Button</code>. 不可点击的控件: <code>TextView</code>.</p>
<blockquote>
<p>注意: <code>View</code>的<code>enable</code>属性并不会影响事件的分发.</p>
</blockquote>
<h2 id="事件分发小总结"><a href="#事件分发小总结" class="headerlink" title="事件分发小总结"></a>事件分发小总结</h2><ul>
<li><p>正常情况下, 一个事件序列, 只能被一个<code>View</code>拦截并且消费. 因为如果一个<code>View</code>拦截了一个事件, 那么后续的事件将交给它处理.</p>
</li>
<li><p>如果一个<code>View</code>不消费<code>ACTION_DOWN</code>事件的话, 后续的事件就不会传递给它. 事件将交给父元素处理, 即使父元素的<code>OnTouchEvent</code>会被调用.</p>
</li>
<li><p><code>ViewGroup</code>默认不拦截任何事件.</p>
</li>
<li><p>事件总是先传给父元素, 再传给子元素. 子元素可以通过<code>requestDisallowInterceptTouchEvent</code>来干预父元素的拦截, 但是对于<code>ACTION_DOWN</code>事件, 子元素不能干预父元素的拦截.</p>
</li>
</ul>
<blockquote>
<h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2></blockquote>
<p>常见的滑动冲突有三种:</p>
<ol>
<li><p>外部和内部的滑动方向不一样</p>
</li>
<li><p>外部和内部的滑动方向一样.</p>
</li>
<li><p>上面两种情况的嵌套.</p>
</li>
</ol>
<blockquote>
<h3 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h3></blockquote>
<p>场景1: 当用户左右滑动时, 让外部的<code>View</code>拦截点击事件; 当用户上下滑动时, 让内部的<code>View</code>拦截点击事件. 可以根据<code>View</code>滑动的水平距离和垂直距离差或角度差来判断用户是左右还是水平滑动.</p>
<p>场景2: 这种情况只能根据业务逻辑来拦截事件.</p>
<p>场景3: 跟场景2一样.</p>
<blockquote>
<h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3></blockquote>
<p>处理冲突的方法可以分为两种:</p>
<ul>
<li><p>外部拦截法: 事件总是先经过父元素, 如果父元素需要的话, 就拦截下来.</p>
</li>
<li><p>内部拦截法: 父容器默认不拦截事件, 所有事件先交给子元素处理, 如果子元素需要的话, 就消费掉, 不需要的话, 交给父元素处理.</p>
</li>
</ul>
<p>下面是这两种方法的模板代码:</p>
<blockquote>
<p>外部拦截法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">            <span class="keyword">if</span> (父容器需要当前点击事件) &#123;</div><div class="line">                intercepted = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        mLastXIntercepted = x;</div><div class="line">        mLastYIntercepted = y;</div><div class="line">        <span class="keyword">return</span> intercepted;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>内部拦截法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//子元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">            <span class="keyword">if</span> (父容器需要此点击事件) &#123;</div><div class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    mLastX = x;</div><div class="line">    mLastY = y;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//父元素:</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> action = ev.getAction();</div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Android开发艺术探索</p>
<p><a href="http://www.gcssloop.com/customview/dispatch-touchevent-source" target="_blank" rel="external">http://www.gcssloop.com/customview/dispatch-touchevent-source</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fll5g8ssmmj30m80b4aiv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Andorid&lt;/code&gt;事件分发机制的解析, 网上一堆文章, 并且写得很
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="Android#自定义View" scheme="http://cristianoro7.github.io/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>SP解析</title>
    <link href="http://cristianoro7.github.io/2017/11/14/SP%E8%A7%A3%E8%AF%BB/"/>
    <id>http://cristianoro7.github.io/2017/11/14/SP解读/</id>
    <published>2017-11-14T08:00:59.799Z</published>
    <updated>2017-11-14T08:00:59.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhnrmq40dj30m80b4q9b.jpg" alt=""></p>
<blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></blockquote>
<p><code>SharedPreferences</code>是<code>Android</code>中的数据持久化技术中的一种. 它将<code>Key-Value</code>键值对储存在一个<code>XMl</code>文件中. 它比较适用储存小量的数据. 比如一些应用的配置信息.</p>
<blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></blockquote>
<p><code>SharedPreferences</code>的被设计成<code>读写分离</code>的模式,  <code>SharedPreferences</code>用来读取数据, <code>SharedPreferences.Editor</code>则是用来写数据.</p>
<blockquote>
<h3 id="获取SharedPreferences"><a href="#获取SharedPreferences" class="headerlink" title="获取SharedPreferences"></a>获取SharedPreferences</h3></blockquote>
<p>关于如何获取<code>SharedPreferences</code>, 可以通过下面这三种方法来获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPreferences = Activity.getPreferences(MODE_PRIVATE); <span class="comment">//在Activity中调用</span></div><div class="line">SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);</div><div class="line">SharedPreferences sharedPreferences = context.getSharedPreferences(<span class="string">"cr7"</span>, MODE_APPEND);</div></pre></td></tr></table></figure>
<p>前面两种都是第三种的封装. 第三种的函数原型为: <code>Context.getSharedPreferences(String name, int mode)</code>. 其中<code>name</code>为文件的名字, <code>mode</code>为操作模式. 操作模式可选有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_PRIVATE = <span class="number">0x0000</span>; <span class="comment">//默认的模式, 每次写都会覆盖之前的数据. 并且只允许本应用内或者拥有用一个userId的应用进行读写文件</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_WORLD_READABLE = <span class="number">0x0001</span>; <span class="comment">//允许多个应用进行读, 由于安全性问题, 已被弃用.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_WORLD_WRITEABLE = <span class="number">0x0002</span>; <span class="comment">//允许多个应用进行写, 由于安全性问题, 已被弃用.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_APPEND = <span class="number">0x8000</span>; <span class="comment">//如果文件已经存在的话, 写不会覆盖之前的数据, 会直接写到文件的末尾.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MULTI_PROCESS = <span class="number">0x0004</span>; <span class="comment">//多进程模式, 该模式不安全, 不建议使用.</span></div></pre></td></tr></table></figure>
<p>上面有些是由于安全性的问题被弃用的. 而<code>MODE_MULTI_PROCESS</code>用于多进程读写的模式, 但是不能保证可靠性, 有可能会出现脏读现象, 已被官方弃用.</p>
<p><code>SharedPreferences</code>的文件储存在<code>/data/data/shared_prefs/</code>. <code>Activity.getPreferences(MODE_PRIVATE)</code>默认的文件名: 调用的<code>Activity</code>的名字, 比如在<code>SpActivity</code>中调用, 得到的文件名字为: <code>SpActivity.xml</code>. 至于调用<code>PreferenceManager.getDefaultSharedPreferences(context)</code>得到的文件名字为: <code>包名+ _preferences.xml</code>.</p>
<p>获取完<code>SharedPreferences</code>后, 我们就可以调用其中的<code>getXX</code>来获取数据.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sharedPreferences.getString(<span class="string">"cr7"</span>, <span class="string">""</span>); <span class="comment">//如果不存在cr7这个key的话, 返回默认值""</span></div></pre></td></tr></table></figure>
<blockquote>
<h3 id="获取SharedPreferences-Editor"><a href="#获取SharedPreferences-Editor" class="headerlink" title="获取SharedPreferences.Editor"></a>获取SharedPreferences.Editor</h3></blockquote>
<p>获得<code>SharedPreferences</code>实例后, 我们可以调用它的<code>editor()</code>方法拿到<code>Editor</code>对象, 注意, 每次调用<code>editor()</code>方法都是新建一个<code>Editor</code>对象. 拿到对象后, 就可以进行写数据了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">editor.putString(<span class="string">"cr7"</span>, <span class="string">"good and best"</span>);</div><div class="line">editor.apply();</div></pre></td></tr></table></figure>
<p>要将数据写入文件中的话, 最后还得调用<code>apply()</code>或者<code>commit()</code>方法.</p>
<blockquote>
<h3 id="监听Key的对应的Value值的变化"><a href="#监听Key的对应的Value值的变化" class="headerlink" title="监听Key的对应的Value值的变化"></a>监听Key的对应的Value值的变化</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sharedPreferences.registerOnSharedPreferenceChangeListener(<span class="keyword">new</span> SharedPreferences.OnSharedPreferenceChangeListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSharedPreferenceChanged</span><span class="params">(SharedPreferences sharedPreferences, String key)</span> </span>&#123;</div><div class="line">        Log.d(TAG, <span class="string">"onSharedPreferenceChanged: "</span> + key);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">sharedPreferences.unregisterOnSharedPreferenceChangeListener(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>如果我们需要监听<code>Key</code>对应的<code>Value</code>的变化的话, 可以调用<code>sharedPreferences</code>中的注册方法. 每当<code>Key</code>值对应的<code>Value</code>发生变化时, 都会回调这个接口. 但是不用的时候, 记得调用注销接口.</p>
<blockquote>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhc48le84j312h0hodhv.jpg" alt=""></p>
<p>上图为<code>sharedPreferences</code>的UML设计图, <code>sharedPreferences</code>和<code>sharedPreferences.Editor</code>只是一个接口, 对应的实现由<code>SharedPreferencesImpl</code>和<code>SharedPreferencesImpl.EditorImpl</code>来负责.</p>
<p><code>SharedPreferencesImpl</code>被设计成单例的形式, 是由<code>ContextImpl</code>负责创建和维护. 在<code>ContextImpl</code>中有字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</div></pre></td></tr></table></figure>
<p>这个字段是负责维护<code>SharedPreferences</code>的. 并且为静态字段,证明同一进程中只有一个实例.</p>
<blockquote>
<h3 id="创建SharedPreferences"><a href="#创建SharedPreferences" class="headerlink" title="创建SharedPreferences"></a>创建SharedPreferences</h3></blockquote>
<p><code>SharedPreferences</code>的创建是由<code>ContextImpl</code>负责的, 对应实现方法为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="comment">// At least one application in the world actually passes in a null</span></div><div class="line">    <span class="comment">// name.  This happened to work because when we generated the file name</span></div><div class="line">    <span class="comment">// we would stringify it to "null.xml".  Nice.</span></div><div class="line">    <span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">            Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">            name = <span class="string">"null"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    File file;</div><div class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</div><div class="line">        <span class="keyword">if</span> (mSharedPrefsPaths == <span class="keyword">null</span>) &#123;</div><div class="line">            mSharedPrefsPaths = <span class="keyword">new</span> ArrayMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        file = mSharedPrefsPaths.get(name); <span class="comment">//根据路径得到文件</span></div><div class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123; <span class="comment">//如果没有缓存的话, 创建对应的文件</span></div><div class="line">            file = getSharedPreferencesPath(name); <span class="comment">//创建文件</span></div><div class="line">            mSharedPrefsPaths.put(name, file); <span class="comment">//添加入缓存</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getSharedPreferences(file, mode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合注释: 首先根据传入的文件名, 先从缓存中拿, 如果不存在的话, 说明该文件还没有被创建, 因此会创建文件后添加进缓存中. 接着调用<code>getSharedPreferences(file, mode)</code>获取<code>SharedPreferences</code>实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    checkMode(mode); <span class="comment">//检查模式</span></div><div class="line">    <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</div><div class="line">        <span class="keyword">if</span> (isCredentialProtectedStorage()</div><div class="line">                &amp;&amp; !getSystemService(StorageManager.class).isUserKeyUnlocked(</div><div class="line">                        UserHandle.myUserId())</div><div class="line">                &amp;&amp; !isBuggy()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"SharedPreferences in credential encrypted "</span></div><div class="line">                    + <span class="string">"storage are not available until after user is unlocked"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    SharedPreferencesImpl sp;</div><div class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</div><div class="line">        <span class="keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</div><div class="line">        sp = cache.get(file); <span class="comment">//从缓存中获取SP</span></div><div class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123; <span class="comment">//不存在的话, 创建实例并添加进缓存.</span></div><div class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</div><div class="line">            cache.put(file, sp);</div><div class="line">            <span class="keyword">return</span> sp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置了MODE_MULTI_PROCESS模式后, 会重新加载文件. 但是这不能解决多进程的脏读现象</span></div><div class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</div><div class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></div><div class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></div><div class="line">        <span class="comment">// historical (if undocumented) behavior.</span></div><div class="line">        sp.startReloadIfChangedUnexpectedly();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>getSharedPreferences(File file, int mode)</code>中的逻辑, 会先调用<code>checkMode(int)</code>来检查模式.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkMode</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.N) &#123;</div><div class="line">        <span class="keyword">if</span> ((mode &amp; MODE_WORLD_READABLE) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"MODE_WORLD_READABLE no longer supported"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ((mode &amp; MODE_WORLD_WRITEABLE) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"MODE_WORLD_WRITEABLE no longer supported"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Android N</code>后, 出于安全性的考虑, 开始不支持<code>MODE_WORLD_READABLE</code>和<code>MODE_WORLD_WRITEABLE</code>.</p>
<p>检查完模式后, 接着从缓存中获取该文件对应的<code>SharedPreferences</code>, 如果存在的话, 返回. 不存在的话, 创建实例并添加进缓存.</p>
<p>经过上面的步骤就创建并缓存了<code>SharedPreferences</code>. 那么我们下面来看看<code>SharedPreferences</code>创建的时候内部都做了什么.</p>
<blockquote>
<h3 id="SharedPreferencesImpl"><a href="#SharedPreferencesImpl" class="headerlink" title="SharedPreferencesImpl"></a>SharedPreferencesImpl</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SharedPreferencesImpl(File file, <span class="keyword">int</span> mode) &#123;</div><div class="line">    mFile = file;</div><div class="line">    mBackupFile = makeBackupFile(file); <span class="comment">//备份文件, 用于文件读写失败时恢复</span></div><div class="line">    mMode = mode;</div><div class="line">    mLoaded = <span class="keyword">false</span>;</div><div class="line">    mMap = <span class="keyword">null</span>;</div><div class="line">    startLoadFromDisk(); <span class="comment">//开始从硬盘中加载文件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>SharedPreferencesImpl</code>的构造方法中, 首先备份文件, 用于文件读写失败时的恢复. 最后调用<code>startLoadFromDisk</code>从硬盘中加载文件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        mLoaded = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            loadFromDisk();</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先将加载标记<code>mLoad</code>设置为<code>false</code>表示文件还没有加载完. 然后开一条线程去加载文件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        <span class="keyword">if</span> (mLoaded) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</div><div class="line">            mFile.delete();</div><div class="line">            mBackupFile.renameTo(mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Debugging</span></div><div class="line">    <span class="keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"Attempt to read preferences file "</span> + mFile + <span class="string">" without permission"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Map map = <span class="keyword">null</span>;</div><div class="line">    StructStat stat = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        stat = Os.stat(mFile.getPath());</div><div class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</div><div class="line">            BufferedInputStream str = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                str = <span class="keyword">new</span> BufferedInputStream(</div><div class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span>*<span class="number">1024</span>);</div><div class="line">                map = XmlUtils.readMapXml(str); <span class="comment">//将文件内容读进Map中</span></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                Log.w(TAG, <span class="string">"Cannot read "</span> + mFile.getAbsolutePath(), e);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                IoUtils.closeQuietly(str);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</div><div class="line">        <span class="comment">/* ignore */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        mLoaded = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            mMap = map;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        mLock.notifyAll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法主要做了两件事, 1: 从<code>XML</code>文件中读出数据, 并存放在<code>Map</code>中. 2: 将加载标记设置为<code>true</code>表示已经加载完成. 然后调用<code>notifyAll()</code>通知正在等待读写的线程.</p>
<blockquote>
<h3 id="利用SharedPreferences读数据"><a href="#利用SharedPreferences读数据" class="headerlink" title="利用SharedPreferences读数据"></a>利用SharedPreferences读数据</h3></blockquote>
<p>创建完<code>SharedPreferences</code>后, 我们就可以拿到它的实例来进行读数据, 下面通过其中的<code>getString(String key, String defValue)</code>来分析.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">        String v = (String)mMap.get(key);</div><div class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</div><div class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></div><div class="line">        <span class="comment">// thread, since the real read will be in a different</span></div><div class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></div><div class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mLock.wait();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次读数据时, 都会判断文件是否加载完, 没有的话, 会调用<code>wait()</code>挂起线程, 直到文件加载完才被唤醒.</p>
<p>前面说过文件的内容都是加载进了<code>mMap</code>中, 所以<code>getXXX</code>方法获取的数据都是从<code>mMap</code>中获取.</p>
<blockquote>
<h3 id="Editor写数据"><a href="#Editor写数据" class="headerlink" title="Editor写数据"></a>Editor写数据</h3></blockquote>
<p>前面分析过, <code>SharedPreferences</code>的读写是分离的. 要进行写数据的话, 我们需要拿到<code>Editor</code>对象, 这个对象可以通过<code>SharedPreferences</code>中的<code>editor()</code>方法拿到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove the need to call awaitLoadedLocked() when</span></div><div class="line">    <span class="comment">// requesting an editor.  will require some work on the</span></div><div class="line">    <span class="comment">// Editor, but then we should be able to do:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// ... all without blocking.</span></div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意: 每次调用这个方法的方法都是新建一个实例, 所以在使用的时候,最好缓存起来, 避免多次调用生成多个对象.</p>
<p>下面也是通过<code>Editor</code>中的<code>putString(String key, String value)</code>为例子来分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">putString</span><span class="params">(String key, @Nullable String value)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        mModified.put(key, value);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写数据时, 并没有直接操作<code>SharedPreferences</code>中的<code>mMap</code>, 而是自己新建一个<code>mModified</code>的<code>Map</code>对象来记录修改的数据.</p>
<p>从上面可以看出, 调用<code>putXXX</code>方法, 数据只是存在内存中, 此时还没有写进磁盘. 需要调用<code>commit()</code>或者<code>apply()</code>方法.</p>
<blockquote>
<h3 id="提交数据commit"><a href="#提交数据commit" class="headerlink" title="提交数据commit()"></a>提交数据commit()</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        startTime = System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MemoryCommitResult mcr = commitToMemory(); <span class="comment">//将修改的数据写进mMap中</span></div><div class="line"></div><div class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(</div><div class="line">        mcr, <span class="keyword">null</span> <span class="comment">/* sync write on this thread okay */</span>); <span class="comment">//写进磁盘</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mcr.writtenToDiskLatch.await();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</div><div class="line">                    + <span class="string">" committed after "</span> + (System.currentTimeMillis() - startTime)</div><div class="line">                    + <span class="string">" ms"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    notifyListeners(mcr);</div><div class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>commit()</code>方法总体逻辑: 1: 将写的数据同步到<code>SharedPreferences</code>中的<code>mMap</code>中; 2: 将<code>mMap</code>写进磁盘. 3: 回到<code>Key</code>监听器.</p>
<blockquote>
<h4 id="commitToMemory"><a href="#commitToMemory" class="headerlink" title="commitToMemory"></a>commitToMemory</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> MemoryCommitResult <span class="title">commitToMemory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> memoryStateGeneration;</div><div class="line">    List&lt;String&gt; keysModified = <span class="keyword">null</span>;</div><div class="line">    Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="keyword">null</span>;</div><div class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>.mLock) &#123;</div><div class="line">        <span class="comment">// We optimistically don't make a deep copy until</span></div><div class="line">        <span class="comment">// a memory commit comes in when we're already</span></div><div class="line">        <span class="comment">// writing to disk.</span></div><div class="line">        <span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// We can't modify our mMap as a currently</span></div><div class="line">            <span class="comment">// in-flight write owns it.  Clone it before</span></div><div class="line">            <span class="comment">// modifying it.</span></div><div class="line">            <span class="comment">// noinspection unchecked</span></div><div class="line">            mMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(mMap);</div><div class="line">        &#125;</div><div class="line">        mapToWriteToDisk = mMap;</div><div class="line">        mDiskWritesInFlight++;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> hasListeners = mListeners.size() &gt; <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (hasListeners) &#123;</div><div class="line">            keysModified = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">            listeners = <span class="keyword">new</span> HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            <span class="keyword">boolean</span> changesMade = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mClear) &#123; <span class="comment">//如果在调用了Editor的clear()方法的话, 会将mMap中的数据先清除</span></div><div class="line">                <span class="keyword">if</span> (!mMap.isEmpty()) &#123;</div><div class="line">                    changesMade = <span class="keyword">true</span>;</div><div class="line">                    mMap.clear();</div><div class="line">                &#125;</div><div class="line">                mClear = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123; <span class="comment">//将mModified的数据添加到mMap中</span></div><div class="line">                String k = e.getKey();</div><div class="line">                Object v = e.getValue();</div><div class="line">                <span class="comment">// "this" is the magic value for a removal mutation. In addition,</span></div><div class="line">                <span class="comment">// setting a value to "null" for a given key is specified to be</span></div><div class="line">                <span class="comment">// equivalent to calling remove on that key.</span></div><div class="line">                <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!mMap.containsKey(k)) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    mMap.remove(k);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (mMap.containsKey(k)) &#123;</div><div class="line">                        Object existingValue = mMap.get(k);</div><div class="line">                        <span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    mMap.put(k, v);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                changesMade = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span> (hasListeners) &#123;</div><div class="line">                    keysModified.add(k);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mModified.clear();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (changesMade) &#123;</div><div class="line">                mCurrentMemoryStateGeneration++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            memoryStateGeneration = mCurrentMemoryStateGeneration;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</div><div class="line">            mapToWriteToDisk);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先判断<code>mClear</code>字段是否被设置, 是的话, 清除<code>mMap</code>中的数据. 接着将<code>mModified</code>的数据添加到<code>mMap</code>中.</p>
<blockquote>
<h4 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></div><div class="line">                              <span class="keyword">final</span> Runnable postWriteRunnable) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>); <span class="comment">//由于传入的postWriteRunnable为null, 所以该字段为true</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr, isFromSyncCommit); <span class="comment">//写入文件</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></div><div class="line">    <span class="comment">// the current thread.</span></div><div class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于传入的<code>postWriteRunnable</code>为<code>null</code>, <code>isFromSyncCommit</code>为<code>true</code>. 然后调用<code>writeToFile(mcr, isFromSyncCommit)</code>将数据写进磁盘.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> existsTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> backupExistsTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> outputStreamCreateTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> writeTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> fsyncTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> setPermTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> fstatTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> deleteTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        startTime = System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> fileExists = mFile.exists();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        existsTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="comment">// Might not be set, hence init them to a default value</span></div><div class="line">        backupExistsTime = existsTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Rename the current file so it may be used as a backup during the next read</span></div><div class="line">    <span class="keyword">if</span> (fileExists) &#123;</div><div class="line">        <span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Only need to write if the disk state is older than this commit</span></div><div class="line">        <span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</div><div class="line">            <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">                needsWrite = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                    <span class="comment">// No need to persist intermediate states. Just wait for the latest state to</span></div><div class="line">                    <span class="comment">// be persisted.</span></div><div class="line">                    <span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</div><div class="line">                        needsWrite = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!needsWrite) &#123;</div><div class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            backupExistsTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!backupFileExists) &#123;</div><div class="line">            <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                Log.e(TAG, <span class="string">"Couldn't rename file "</span> + mFile</div><div class="line">                      + <span class="string">" to backup file "</span> + mBackupFile);</div><div class="line">                mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mFile.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attempt to write the file, delete the backup and return true as atomically as</span></div><div class="line">    <span class="comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span></div><div class="line">    <span class="comment">// from the backup.</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            outputStreamCreateTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</div><div class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str); <span class="comment">//将数据写入文件</span></div><div class="line"></div><div class="line">        writeTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        FileUtils.sync(str);</div><div class="line"></div><div class="line">        fsyncTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            setPermTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</div><div class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                mStatTimestamp = stat.st_mtime;</div><div class="line">                mStatSize = stat.st_size;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</div><div class="line">            <span class="comment">// Do nothing</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            fstatTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Writing was successful, delete the backup file if there is one.</span></div><div class="line">        mBackupFile.delete(); <span class="comment">//删除备份文件</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            deleteTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mDiskStateGeneration = mcr.memoryStateGeneration; <span class="comment">//更新磁盘状态代数</span></div><div class="line"></div><div class="line">        mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>); <span class="comment">//设置结果</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            Log.d(TAG, <span class="string">"write: "</span> + (existsTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (backupExistsTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (outputStreamCreateTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (writeTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (fsyncTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (setPermTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (fstatTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (deleteTime - startTime));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</div><div class="line">        mSyncTimes.add(Long.valueOf(fsyncDuration).intValue());</div><div class="line">        mNumSync++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG || mNumSync % <span class="number">1024</span> == <span class="number">0</span> || fsyncDuration &gt; MAX_FSYNC_DURATION_MILLIS) &#123;</div><div class="line">            mSyncTimes.log(TAG, <span class="string">"Time required to fsync "</span> + mFile + <span class="string">": "</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Clean up an unsuccessfully written file</span></div><div class="line">    <span class="keyword">if</span> (mFile.exists()) &#123;</div><div class="line">        <span class="keyword">if</span> (!mFile.delete()) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"Couldn't clean up partially-written file "</span> + mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>writeToFile</code>方法是<code>commit()</code>和<code>apply()</code>公用的. 接下来说说<code>commit()</code>会走的流程: 首先将当前文件备份, 接着写入磁盘, 最后删除备份文件.</p>
<p>经过前面的分析, 我们可以看出, <code>commit()</code>方法是以同步的方式将数据写入磁盘.</p>
<blockquote>
<h3 id="提交数据apply"><a href="#提交数据apply" class="headerlink" title="提交数据apply"></a>提交数据apply</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory(); <span class="comment">//将数据提交到内存</span></div><div class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    mcr.writtenToDiskLatch.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;</div><div class="line">                    Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</div><div class="line">                            + <span class="string">" applied after "</span> + (System.currentTimeMillis() - startTime)</div><div class="line">                            + <span class="string">" ms"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    QueuedWork.addFinisher(awaitCommit);</div><div class="line"></div><div class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                awaitCommit.run();</div><div class="line">                QueuedWork.removeFinisher(awaitCommit);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable); <span class="comment">//写入磁盘</span></div><div class="line"></div><div class="line">    <span class="comment">// Okay to notify the listeners before it's hit disk</span></div><div class="line">    <span class="comment">// because the listeners should always get the same</span></div><div class="line">    <span class="comment">// SharedPreferences instance back, which has the</span></div><div class="line">    <span class="comment">// changes reflected in memory.</span></div><div class="line">    notifyListeners(mcr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>apply()</code>的逻辑跟<code>commit()</code>一样, 只不过, 写入磁盘的方式不一样, 下面我们只分析写入磁盘的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></div><div class="line">                              <span class="keyword">final</span> Runnable postWriteRunnable) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr, isFromSyncCommit);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></div><div class="line">    <span class="comment">// the current thread.</span></div><div class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于传入的<code>Runnable</code>不为<code>null</code>, 所以<code>isFromSyncCommit</code>为<code>false</code>. 最后会调用<code>QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(Runnable work, <span class="keyword">boolean</span> shouldDelay)</span> </span>&#123;</div><div class="line">    Handler handler = getHandler();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (sLock) &#123;</div><div class="line">        sWork.add(work);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (shouldDelay &amp;&amp; sCanDelay) &#123;</div><div class="line">            handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>QueueWork</code>封装了<code>HandlerThread</code>和<code>Handler</code>. 用来处理<code>apply()</code>的异步写入的请求.</p>
<p>在<code>queue</code>方法中, 发送了一条延迟消息. 延迟时间为100毫秒.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWorkHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_RUN = <span class="number">1</span>;</div><div class="line"></div><div class="line">    QueuedWorkHandler(Looper looper) &#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.what == MSG_RUN) &#123;</div><div class="line">            processPendingWork();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>QueuedWorkHandler</code>接受到消息时, 调用<code>processPendingWork()</code>处理异步写入请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPendingWork</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        startTime = System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (sProcessingWork) &#123;</div><div class="line">        LinkedList&lt;Runnable&gt; work;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</div><div class="line">            work = (LinkedList&lt;Runnable&gt;) sWork.clone();</div><div class="line">            sWork.clear();</div><div class="line"></div><div class="line">            <span class="comment">// Remove all msg-s as all work will be processed now</span></div><div class="line">            getHandler().removeMessages(QueuedWorkHandler.MSG_RUN);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (work.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (Runnable w : work) &#123;</div><div class="line">                w.run(); <span class="comment">//调用Runnable的run方法</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                Log.d(LOG_TAG, <span class="string">"processing "</span> + work.size() + <span class="string">" items took "</span> +</div><div class="line">                        +(System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>processPendingWork()</code>中会循环调用<code>Runnable</code>中的<code>run</code>方法. 现在我们回到之前的<code>Runnable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</div><div class="line">                writeToFile(mcr, isFromSyncCommit); <span class="comment">//写入文件</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                mDiskWritesInFlight--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                postWriteRunnable.run();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;</div><div class="line">     <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> existsTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> backupExistsTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> outputStreamCreateTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> writeTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> fsyncTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> setPermTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> fstatTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> deleteTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">         startTime = System.currentTimeMillis();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">boolean</span> fileExists = mFile.exists();</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">         existsTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">         <span class="comment">// Might not be set, hence init them to a default value</span></div><div class="line">         backupExistsTime = existsTime;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Rename the current file so it may be used as a backup during the next read</span></div><div class="line">     <span class="keyword">if</span> (fileExists) &#123;</div><div class="line">         <span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">         <span class="comment">// Only need to write if the disk state is older than this commit</span></div><div class="line">         <span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</div><div class="line">             <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">                 needsWrite = <span class="keyword">true</span>;</div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                     <span class="comment">// No need to persist intermediate states. Just wait for the latest state to</span></div><div class="line">                     <span class="comment">// be persisted.</span></div><div class="line">                     <span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123; <span class="comment">//如果有多次提交的话, 只处理最后一次提交的数据</span></div><div class="line">                         needsWrite = <span class="keyword">true</span>;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (!needsWrite) &#123;</div><div class="line">             mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             backupExistsTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (!backupFileExists) &#123;</div><div class="line">             <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                 Log.e(TAG, <span class="string">"Couldn't rename file "</span> + mFile</div><div class="line">                       + <span class="string">" to backup file "</span> + mBackupFile);</div><div class="line">                 mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             mFile.delete();</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Attempt to write the file, delete the backup and return true as atomically as</span></div><div class="line">     <span class="comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span></div><div class="line">     <span class="comment">// from the backup.</span></div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         FileOutputStream str = createFileOutputStream(mFile);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             outputStreamCreateTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</div><div class="line">             mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line"></div><div class="line">         writeTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">         FileUtils.sync(str);</div><div class="line"></div><div class="line">         fsyncTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">         str.close();</div><div class="line">         ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             setPermTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</div><div class="line">             <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                 mStatTimestamp = stat.st_mtime;</div><div class="line">                 mStatSize = stat.st_size;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</div><div class="line">             <span class="comment">// Do nothing</span></div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             fstatTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// Writing was successful, delete the backup file if there is one.</span></div><div class="line">         mBackupFile.delete();</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             deleteTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         mDiskStateGeneration = mcr.memoryStateGeneration;</div><div class="line"></div><div class="line">         mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             Log.d(TAG, <span class="string">"write: "</span> + (existsTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (backupExistsTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (outputStreamCreateTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (writeTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (fsyncTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (setPermTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (fstatTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (deleteTime - startTime));</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</div><div class="line">         mSyncTimes.add(Long.valueOf(fsyncDuration).intValue());</div><div class="line">         mNumSync++;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG || mNumSync % <span class="number">1024</span> == <span class="number">0</span> || fsyncDuration &gt; MAX_FSYNC_DURATION_MILLIS) &#123;</div><div class="line">             mSyncTimes.log(TAG, <span class="string">"Time required to fsync "</span> + mFile + <span class="string">": "</span>);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</div><div class="line">         Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">         Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Clean up an unsuccessfully written file</span></div><div class="line">     <span class="keyword">if</span> (mFile.exists()) &#123;</div><div class="line">         <span class="keyword">if</span> (!mFile.delete()) &#123;</div><div class="line">             Log.e(TAG, <span class="string">"Couldn't clean up partially-written file "</span> + mFile);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>apply()</code>中将数据写入磁盘跟<code>commit()</code>是有区别的. 前者的写入方式是异步写入, 也就是在<code>QueueWork</code>所在的线程. 所以当进行多次提交时, 只会将最后一次提交的数据写入磁盘.</p>
<blockquote>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhmk9nwkfj30dc09nt95.jpg" alt=""></p>
<p><code>SharedPreferences</code>内部对数据的储存是经过内存-硬盘这样的两级缓存. 每次<code>commit</code>或者<code>apply</code>的时候, 都会先写入内存, 接着再将内存写入硬盘.</p>
<p><code>commit()</code>方法是以同步的方式提交到内存. 具体如下图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhmznz2a7j30el0ahwf0.jpg" alt=""></p>
<p>两次<code>commit</code>的提交是串行化的, <code>commit#2</code>必须要等待<code>commit#1</code>写入磁盘后才能写.</p>
<p>与<code>commit()</code>方法不同. <code>apply()</code>是以异步的形式将数据写入磁盘, 也就是说: 写进内存是同步的, 但是内存写进磁盘是异步的, 当进行多次提交时, 后提交的会覆盖前面提交到内存的数据, 最后只有最后一次的提交才会被写进磁盘. 具体如下图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhnaf4orxj30ga0anaak.jpg" alt=""></p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><p><code>SharedPreferences</code>适合储存一些小数据的情景. 如果储存的数据太大的话, 第一次加载时, 有可能会阻塞到主线程.</p>
</li>
<li><p><code>editor()</code>每次调用都会生成一个<code>Editor</code>实例, 所以在封装的时候要注意, 最好缓存起来, 不然频繁调用的话, 有可能会出现内存抖动.</p>
</li>
<li><p><code>commit</code>是在当前线程以同步的方法写入磁盘, 如果在主线程连续多次提交的话, 有可能阻塞主线程.</p>
</li>
<li><p><code>apply</code>是先将数据同步写到内存, 然后将内存的数据异步写入磁盘, 并且只会写入最后一次提交的数据, 这样磁盘的读写次数就减少了, 所以<code>apply</code>会比<code>commit</code>高效.</p>
</li>
<li><p><code>SharedPreferences</code>是不支持多进程的, 如果在多进程下读写的话, 可能出现脏读现象. 如果需要在多进程下读写数据的话, 可以借用<code>ContentProvider</code>来实现, 数据源设置为<code>SharedPreferences</code>即可.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1flhnrmq40dj30m80b4q9b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;hea
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="Android#数据持久化#SP" scheme="http://cristianoro7.github.io/tags/Android-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-SP/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C中的并发工具类</title>
    <link href="http://cristianoro7.github.io/2017/10/31/J.U.C%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://cristianoro7.github.io/2017/10/31/J.U.C中的并发工具类/</id>
    <published>2017-10-31T15:33:44.648Z</published>
    <updated>2017-10-31T15:33:44.648Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fl1ikq8wyhj30m80b4qi7.jpg" alt=""></p>
<p>在<code>Java</code>的<code>J.U.C</code>包中提供了几个并发编程中非常有用工具类, 例如: <code>Semaphore</code>, <code>CountDownLatch</code>和<code>CyclicBarrier</code>. 这次准备来介绍这三个工具类.</p>
<blockquote>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2></blockquote>
<p><code>Semaphore</code>中文意思为: 信号量. 它主要用来维护一组有限的资源. 比如数据库连接, <code>Socket</code>连接. 信号量的使用方式很简单, 在构造函数中, 传入你需要维护的有限资源的数量, 每次需要申请资源时, 调用<code>acquire()</code>, 接着做一些业务逻辑, 完成后, 再调用<code>release()</code>归还有限资源. 如果有限资源被申请完了后, 还调用<code>acquire()</code>的话, 调用的线程会被阻塞, 直到其他线程归还资源后, 才从阻塞中返回.</p>
<blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>Semaphore</code>的原理很简单. 基于<code>AQS</code>构建的. 它内部维护一个状态计数器, 每次调用申请资源时, 都会递减状态计数器值, 归还资源时, 会增加状态计数器的值. 当状态计数器为负数时, 说明有限资源已经被申请完了, 这时<code>AQS</code>会将申请不到资源的线程添加进同步队列中, 并挂起线程, 直到其他线程唤醒.</p>
<p>由于<code>Semaphore</code>也是基于<code>AQS</code>实现的, 所以它支持不响应中断, 响应中断和响应中断且超时获取资源这三种类型. 同时获取资源的方式支持公平性和非公平性的获取. 默认的实现是非公平的获取方式.</p>
<blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面给出一个简单的例子: 数据库连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DBPool pool = <span class="keyword">new</span> DBPool(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        doSomeWork();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</div><div class="line">        Connection connection = pool.get();</div><div class="line">        <span class="comment">//访问数据库</span></div><div class="line">        pool.release(connection);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBPool</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Semaphore semaphore;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Connection[] pool;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] connectionFlags;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(size, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">boolean</span> isFair)</span> </span>&#123;</div><div class="line">        semaphore = <span class="keyword">new</span> Semaphore(size, isFair);</div><div class="line">        initPool(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        pool = <span class="keyword">new</span> Connection[size];</div><div class="line">        connectionFlags = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            pool[i] = DBDriver.create();</div><div class="line">            connectionFlags[i] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        semaphore.acquireUninterruptibly();</div><div class="line">        <span class="keyword">return</span> fetchConnection();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">fetchConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pool.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!connectionFlags[i]) &#123;</div><div class="line">                connectionFlags[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span> pool[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection connection)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectionFlags.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (pool[i] == connection &amp;&amp; connectionFlags[i]) &#123;</div><div class="line">                connectionFlags[i] = <span class="keyword">false</span>;</div><div class="line">                semaphore.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DBDriver</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">static</span> Connection <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//fake connection</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2></blockquote>
<p>当一个或者多个线程的执行需要等待其他线程执行完后才能执行的话, <code>CountDownLatch</code>能够很好的完成任务.</p>
<p><code>CountDownLatch</code>的使用方式很简单, 只要在构造函数中传入需要等待执行完的线程数, 在需要等待其他线程执行完才执行的线程调用<code>await()</code>, 如果此时其他线程还没执行完的话, 该操作会阻塞, 直到每个线程中调用<code>countDown()</code>方法来表示自己已经完成了, 最后被阻塞的线程才会从<code>await()</code>中返回.</p>
<blockquote>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面是<code>CountDownLatch</code>的一个例子: 工头要带搬砖工去搬砖, 所以工头必须得等他们都上车了才可以开车.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); <span class="comment">//需要等待10个搬砖工上车</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(countDownLatch)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            countDownLatch.await(); <span class="comment">//等待搬砖工上车完才开车.</span></div><div class="line">            System.out.println(<span class="string">"OK, 搬砖工已经上车了, 开车去搬砖"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            getOnBus();</div><div class="line">            countDownLatch.countDown(); <span class="comment">//执行完了.</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getOnBus</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"搬砖工上车了!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>CountDownLatch</code>内部实现的原理很简单. 它基于<code>AQS</code>, 通过构造函数传入的<code>int</code>数值, 来维护一个计数器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sync(<span class="keyword">int</span> count) &#123;</div><div class="line">    setState(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入<code>count</code>被设置为<code>AQS</code>内部的状态值.</p>
<p>接下来看看<code>await()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>await()</code>中最终会回调<code>tryAcquireShared(int acquires)</code>. 该方法实现的逻辑: 如果状态不为0的话, 说明还有其他线程还没执行完, 所以返回-1告诉<code>AQS</code>阻塞当前线程. 如果状态为0, 说明全部线程已经执行完, 此时返回1, 告诉<code>AQS</code>不用阻塞线程.</p>
<p>当线程被阻塞后, 需要它等待的线程执行完才会被唤醒. 被等待的线程调用<code>countDown()</code>表示自己已经完成.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>countDown()</code>通过循环和<code>CAS</code>来更新同步状态, 当最后一个线程也调用了该方法的话, 同步状态为0. 此时被阻塞的线程会得以唤醒.</p>
<blockquote>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2></blockquote>
<p><code>CyclicBarrier</code>允许一组线程互相等待其到达一个同步点的时候才继续执行. 同时<code>CyclicBarrier</code>具有重用性, 当等待的一组线程被释放后(成功或者失败), 它能够被继续使用. 这点和<code>CountDownLatch</code>不一样, <code>CountDownLatch</code>只能够使用一次.</p>
<p><code>CyclicBarrier</code>遵循<code>all-or-none</code>的损坏模式, 相互等待的一组线程如果其中一个线程被中断的或者等待超时的话, 其他线程也将失败. 简单来讲, 要么全部成功, 要么全部失败.</p>
<p><code>CyclicBarrier</code>还支持一组等待的线程被释放后, 执行传入的<code>Runnable</code>.</p>
<blockquote>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面给出一个例子. 游戏玩家都必须等待各自准备好才能开始.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(<span class="string">"玩家-"</span> + i, cyclicBarrier)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, CyclicBarrier cyclicBarrier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name + <span class="string">"已经准备好"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cyclicBarrier.await(); <span class="comment">//等待其他玩家</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还可以在<code>CyclicBarrier</code>的构造函数中传入一个<code>Runnable</code>, 当所有线程都到达同步点后, 该任务会被执行, 默认是最后一个到达的线程执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> ReadyFinish());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(<span class="string">"玩家-"</span> + i, cyclicBarrier)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, CyclicBarrier cyclicBarrier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name + <span class="string">"已经准备好"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cyclicBarrier.await(); <span class="comment">//等待其他玩家</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadyFinish</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"所以玩家已经准备完了, 开始游戏"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>CyclicBarrier</code>内部基于<code>ReentrantLock</code>和<code>Condition</code>实现的. 到达同步点的线程会被暂时挂在条件队列中等待.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//支持重用性, 表示第几代</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> broken = <span class="keyword">false</span>; <span class="comment">//是否成功等待所有线程到达同步点</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//确保线程安全</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition(); <span class="comment">//到达安全点的线程会被挂在等待队列中</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties; <span class="comment">//互相等待的一组线程</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand; <span class="comment">//全部线程到达后, 执行的一个任务</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//记录还有多少个线程没到达同步点</span></div></pre></td></tr></table></figure>
<p>上面是<code>CyclicBarrier</code>中的实例域, 具体讲解看注释.</p>
<p>下面我们来看看线程到达同步点时的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</div><div class="line">           TimeoutException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">//失败</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//线程被中断了, 失败</span></div><div class="line">            breakBarrier();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> index = --count; <span class="comment">//获得还没到达的线程数</span></div><div class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                    command.run();</div><div class="line">                ranAction = <span class="keyword">true</span>;</div><div class="line">                nextGeneration();</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!ranAction)</div><div class="line">                    breakBarrier();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!timed)</div><div class="line">                    trip.await(); <span class="comment">//挂起线程</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</div><div class="line">                    nanos = trip.awaitNanos(nanos); <span class="comment">//挂起线程</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; <span class="comment">//中断失败</span></div><div class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> ie;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                    <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">//有一个线程失败了, 所有线程也跟着失败</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">//如果当前代对象不相等的话, 证明已经更新代数了.</span></div><div class="line">                <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得还没到达的线程数, 如果不为0的话, 说明还有线程没到达, 这时, 应该阻塞线程. 当最后一个线程到达时, <code>index</code>为0, 此时说明全部线程已经到达, 所以进入唤醒等待线程的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">    <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">            command.run();</div><div class="line">        ranAction = <span class="keyword">true</span>;</div><div class="line">        nextGeneration();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!ranAction)</div><div class="line">            breakBarrier();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</div><div class="line">    trip.signalAll(); <span class="comment">//唤醒在条件队列中等待的线程</span></div><div class="line">    <span class="comment">//重置CyclicBarrier, 使得它可以被复用</span></div><div class="line">    count = parties;</div><div class="line">    generation = <span class="keyword">new</span> Generation();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果构造函数中有传入<code>Runnable</code>对象的话, 最后一个线程会执行该<code>Runnable</code>对象, 然后进入<code>nextGeneration()</code>中唤醒在同步点等待的线程, 最后更新当前年代.</p>
<p>如果等待线程在等待的过程中有被中断或者等待超时的话, 会执行<code>breakBarrier()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</div><div class="line">    generation.broken = <span class="keyword">true</span>;</div><div class="line">    count = parties;</div><div class="line">    trip.signalAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先设置当代已经被破坏了, 这样可以让其他线程都失败.然后唤醒在等待队列上等待的线程. 被唤醒的线程会检查<code>broken</code>字段, 最后抛出异常.</p>
<p>如果等待的过程中没有超时或者被中断的话, 其他线程从阻塞的方法中返回后, 当前的<code>generation</code>是否相等, 不是的话, 说明已经进入下一代了,所以返回一个<code>index</code>, 该<code>index</code>表示这线程是第几个到达同步点的.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<p><code>Semaphore</code>用来维护一组有限的资源, 每次申请资源时, 都会递减资源数, 如果资源没了的话, 会阻塞当前线程, 直到有可用的资源为止. 有限的资源可以是: 数据库连接, <code>Socket</code>连接.</p>
<p><code>CountDownLatch</code>适用于 : 当一个或者多个线程的执行需要等待其他线程执行完后才可以执行的场景.</p>
<p>多个线程需要等待彼此到达一个同步点时, 才继续执行, 这种情况下, 可以用<code>CyclicBarrier</code>. 而且它具有重用行, 可被多次使用, 这点和<code>CountDownLatch</code>不一样, 后者只能被使用一次.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fl1ikq8wyhj30m80b4qi7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;J.U.C&lt;/code&gt;包中提供了几个并发
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#工具类" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock和ReentrantReadWriteLock详解</title>
    <link href="http://cristianoro7.github.io/2017/10/31/ReentrantLock%E5%92%8CReentrantReadWriteLock%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cristianoro7.github.io/2017/10/31/ReentrantLock和ReentrantReadWriteLock详解/</id>
    <published>2017-10-31T15:33:33.368Z</published>
    <updated>2017-10-31T15:33:33.368Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkz6p5rdydj30m80b47at.jpg" alt=""></p>
<p><code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>是<code>Java</code>并发包中提供的锁, 他们都属于可重入锁.但是<code>ReentrantLock</code>是一种悲观锁, 它总是假设竞争条件总是会发生, 所以它同一时刻只能有一个线程获得锁, 而<code>ReentrantReadWriteLock</code>是属于乐观锁, 它假设竞争条件并不会经常发生, 所以同一时刻能让多个线程执行.</p>
<p>他们的一个共同点是: 都支持公平和非公平性的获取锁.</p>
<blockquote>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h2></blockquote>
<p>前面分析过<code>AQS</code>, 它是并发包中的锁的基本骨架. 所以<code>ReentrantLock</code>内部也是基于<code>AQS</code>实现的. <code>ReentrantLock</code>内部将获取锁和释放锁的方法都代理给其内部类: <code>Sync</code>, 而<code>Sync</code>是继承<code>AQS</code>的, 为了支持公平性和非公平性的锁, <code>Sync</code>有两个子类, 分别为<code>NonfairSync</code>和<code>FairSync</code>, 他们都重写了<code>tryAcquire(int)</code>方法来实现自己公平和非公平获取锁的逻辑, 由于释放锁的逻辑都一样, 因此<code>tryRelease(int)</code>由<code>Sync</code>重写.</p>
<p>既然<code>ReentrantLock</code>基于<code>AQS</code>实现的, 所以它支持三种方式获取锁:</p>
<ul>
<li><p><code>lock()</code>: 不支持中断的获取锁</p>
</li>
<li><p><code>lockInterruptibly()</code>: 响应中断地获取锁</p>
</li>
<li><p><code>tryLock(long timeout, TimeUnit unit)</code>: 响应中断并且支持超时获取锁.</p>
</li>
</ul>
<p>由于三种方式在<code>AQS</code>中已经分析过, 所以这里只分析<code>lock()</code>. 主要分析公平性和非公平性地获取锁的逻辑</p>
<blockquote>
<h3 id="NonfairSync-非公平锁"><a href="#NonfairSync-非公平锁" class="headerlink" title="NonfairSync: 非公平锁"></a>NonfairSync: 非公平锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是非公平性获取锁的逻辑: 如果同步状态为0的话, 证明锁还没被获取, 所以利用<code>CAS</code>来获取同步状态, 成功的话, 设置当前线程持有锁. 如果同步状态不为0的话, 判断获取锁的线程是否为当前线程, 如果是的话, 更新同步状态, 从这里也可以看出来<code>ReentrantLock</code>是可重入锁.</p>
<blockquote>
<h3 id="FairSync-公平锁"><a href="#FairSync-公平锁" class="headerlink" title="FairSync: 公平锁"></a>FairSync: 公平锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平和非公平的区别是: 公平性意味着哪个线程等待的时间更长, 就应该首先让它获取锁, 也就是获取锁的顺序必须是<code>FIFO</code>. 所以每次获取同步状态时, 都会调用<code>hasQueuedPredecessors()</code>判断当前节点是不是有前驱节点, 如果有的话, 证明已经有线程在等待, 因此不获取同步状态, 这样就实现了公平性地获取锁.<br>至于其他逻辑和前面的大致一样.</p>
<blockquote>
<h3 id="tryRelease-int-releases"><a href="#tryRelease-int-releases" class="headerlink" title="tryRelease(int releases)"></a>tryRelease(int releases)</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平锁和非公平锁的释放锁的逻辑都是一样的, 由于<code>ReentrantLock</code>是可重入的, 因此只有当同步状态为0的时候才需要将当前持有锁的线程设置为<code>null</code>, 也就是释放锁.</p>
<blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></blockquote>
<p><code>ReentrantLock</code>内部默认是非公平锁, 因为非公平锁的吞吐量会比公平锁高, 这是由于非公平锁每次获取锁的时候, 不需要理会当前节点是否有前驱节点, 也就是前面有线程在等待, 只要被唤醒了, 并且能够获取同步状态的话, 就可以获取. 而公平锁每次获取锁时, 当前节点必须是头节点, 也就是它的前面没有线程在等待. 在这种情况下, 如果非头结点的线程被唤醒的话或者是刚刚释放锁的线程又立刻获取锁, 是不能获取锁的, 只能再进行多一次调度. 因此, 非公平锁的吞吐量会比公平锁的高.</p>
<blockquote>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2></blockquote>
<p>与<code>ReentrantLock</code>不同,  <code>ReentrantReadWriteLock</code>的伸缩性要强一些, 因为它将读写锁分离. 在进行读操作的时候, 多个线程是可以同时获取锁的, 这样能更大地提高并发度. 下面是<code>ReentrantReadWriteLock</code>的特性</p>
<ul>
<li><p>公平性: 与<code>ReentrantLock</code>一样, <code>ReentrantReadWriteLock</code>内部也是支持公平性和非公平性锁, 默认是非公平性的锁.</p>
</li>
<li><p>可重入: <code>ReentrantReadWriteLock</code>支持一个线程多次获取锁.</p>
</li>
<li><p>读写分离: <code>ReentrantReadWriteLock</code>内部维护两个锁, 一个是读锁, 另外一个是写锁. 在读多写少的情况下, <code>ReentrantReadWriteLock</code>能发挥更大的并发度.  因为<code>ReentrantReadWriteLock</code>支持多个读线程同时获取锁. <code>ReentrantReadWriteLock</code>的读写规则: 当一个写线程获得锁后, 其他线程不能获取锁. 当读线程获得锁后, 其他的读线程可以获得锁, 但是写线程不能.</p>
</li>
<li><p>锁降级: 当一个线程持有写锁后, 再获取读锁, 然后释放写锁, 这个过程称为一个锁的降级. <code>ReentrantReadWriteLock</code>不支持锁的升级, 因为锁的升级有可能带来竞争条件的问题.</p>
</li>
</ul>
<blockquote>
<h3 id="读写同步状态设计"><a href="#读写同步状态设计" class="headerlink" title="读写同步状态设计"></a>读写同步状态设计</h3></blockquote>
<p><code>ReentrantReadWriteLock</code>内部也是基于<code>AQS</code>实现的, 但是<code>AQS</code>内只有一个<code>int</code>类型的变量, 那么<code>ReentrantReadWriteLock</code>怎么表示两个同步状态呢? 答案是通过位运算来处理.</p>
<p><code>int</code>类型有32位, <code>ReentrantReadWriteLock</code>将高16位作为读状态, 低16位作为写状态. 这样每次通过一定的位运算来获取高16位或者低16位.</p>
<blockquote>
<h3 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h3></blockquote>
<p>写锁是一种互斥锁, 同一个时刻锁只能被一个线程获取.</p>
<blockquote>
<h4 id="非公平性写锁"><a href="#非公平性写锁" class="headerlink" title="非公平性写锁"></a>非公平性写锁</h4></blockquote>
<p>跟<code>ReentrantLock</code>一样, <code>ReentrantReadWriteLock</code>内部支持三种类型的获取, 因此下面只分析一种.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>lock()</code>方法中, 会调用<code>AQS</code>的<code>acquire(int)</code>, 在<code>acquire(int)</code>中又会回调子类重写的模板方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Walkthrough:</div><div class="line">     * 1. If read count nonzero or write count nonzero</div><div class="line">     *    and owner is a different thread, fail.</div><div class="line">     * 2. If count would saturate, fail. (This can only</div><div class="line">     *    happen if count is already nonzero.)</div><div class="line">     * 3. Otherwise, this thread is eligible for lock if</div><div class="line">     *    it is either a reentrant acquire or</div><div class="line">     *    queue policy allows it. If so, update state</div><div class="line">     *    and set owner.</div><div class="line">     */</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">//获取写的同步状态</span></div><div class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></div><div class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        <span class="comment">// Reentrant acquire</span></div><div class="line">        setState(c + acquires);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>c != 0</code>且 <code>w(写状态)</code>为0的话, 证明读状态不为0, 说明此时获得锁的是读线程, 所以会直接返回<code>false</code>来表示获取失败. 如果<code>w != 0</code>的话, 说明此时写线程拥有锁, 此时如果拥有锁是当前线程的话, 会更新同步状态来支持可重入的特性, 可重入的次数为65535.</p>
<p>如果<code>c == 0</code>的话, 说明同步状态还没被获取, 此时应该会先调用<code>writerShouldBlock()</code>, 在非公平的写锁的实现为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非公平性的写锁默认是返回<code>false</code>, 接着利用<code>CAS</code>更新同步状态, 如果成功的话, 设置当前线程为执行线程, 否则的话返回<code>false</code>, 进入<code>AQS</code>中排队.</p>
<blockquote>
<h4 id="非公平性写锁-1"><a href="#非公平性写锁-1" class="headerlink" title="非公平性写锁"></a>非公平性写锁</h4></blockquote>
<p>公平锁和非公平锁获取锁的基本一样, 不一样的话<code>writerShouldBlock()</code>的实现不一样.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></div><div class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></div><div class="line">    <span class="comment">// thread is first in queue.</span></div><div class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></div><div class="line">    Node h = head;</div><div class="line">    Node s;</div><div class="line">    <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平锁每次获取锁时, 为了保证公平性, 都需要看看同步队列中是否有比当前线程等待时间更长的线程, 如果有的话, 就不能获取.</p>
<blockquote>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4></blockquote>
<p><code>ReentrantReadWriteLock</code>释放锁的逻辑跟<code>ReentrantLock</code>一样.</p>
<blockquote>
<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3></blockquote>
<p>读锁是一种共享锁, 多个读线程可以同时获取锁. 但是当读线程持有锁时, 写线程是不能持有锁的.</p>
<blockquote>
<p>非公平读锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Walkthrough:</div><div class="line">     * 1. If write lock held by another thread, fail.</div><div class="line">     * 2. Otherwise, this thread is eligible for</div><div class="line">     *    lock wrt state, so ask if it should block</div><div class="line">     *    because of queue policy. If not, try</div><div class="line">     *    to grant by CASing state and updating count.</div><div class="line">     *    Note that step does not check for reentrant</div><div class="line">     *    acquires, which is postponed to full version</div><div class="line">     *    to avoid having to check hold count in</div><div class="line">     *    the more typical non-reentrant case.</div><div class="line">     * 3. If step 2 fails either because thread</div><div class="line">     *    apparently not eligible or CAS fails or count</div><div class="line">     *    saturated, chain to version with full retry loop.</div><div class="line">     */</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</div><div class="line">        getExclusiveOwnerThread() != current)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> r = sharedCount(c);</div><div class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</div><div class="line">        r &lt; MAX_COUNT &amp;&amp;</div><div class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">            firstReader = current;</div><div class="line">            firstReaderHoldCount = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</div><div class="line">            firstReaderHoldCount++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            HoldCounter rh = cachedHoldCounter;</div><div class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</div><div class="line">                cachedHoldCounter = rh = readHolds.get();</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</div><div class="line">                readHolds.set(rh);</div><div class="line">            rh.count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取写状态, 如果写状态为不0且持有写锁的线程是当前执行的线程, 说明这是一个锁降级的操作, 因此允许继续获取同步状态.</p>
<p>如果写状态为0且<code>getExclusiveOwnerThread() != current</code>为<code>true</code>的话, 表示持有写锁的不是当前执行的线程, 所以返回-1表示失败.</p>
<p>在尝试获取同步状态前, 会先调用<code>readerShouldBlock()</code>判断是否应该阻塞读线程, 这个方法在公平和非公平锁的实现不一样.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></div><div class="line">      * block if the thread that momentarily appears to be head</div><div class="line">      * of queue, if one exists, is a waiting writer.  This is</div><div class="line">      * only a probabilistic effect since a new reader will not</div><div class="line">      * block if there is a waiting writer behind other enabled</div><div class="line">      * readers that have not yet drained from the queue.</div><div class="line">      */</div><div class="line">     <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</div><div class="line">     Node h, s;</div><div class="line">     <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">         (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</div><div class="line">         !s.isShared()         &amp;&amp;</div><div class="line">         s.thread != <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在非公平锁的实现中, 只要同步状态队列中有写线程正在等待的话, 就应该阻塞读线程, 不让其获取同步状态. 这样做是为了防止写线程出现饥饿现象.</p>
<blockquote>
<p>公平读锁</p>
</blockquote>
<p>公平读锁和非公平读锁的实现也是基本一样, 不一样的就是<code>readerShouldBlock()</code>实现不同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></div><div class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></div><div class="line">    <span class="comment">// thread is first in queue.</span></div><div class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></div><div class="line">    Node h = head;</div><div class="line">    Node s;</div><div class="line">    <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了保持公平性, 每次都是让同步队列中的队头线程获取锁, 因为队头线程等待的时间最长.</p>
<blockquote>
<p>释放读锁</p>
</blockquote>
<p>忽略一些其他的操作的话, 读锁的释放逻辑跟写锁的差不多, 都是<code>CAS</code>来更新同步状态, 不同的是, 读锁是共享锁, 必须通过循环<code>CAS</code>来保证线程安全.</p>
<blockquote>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3></blockquote>
<p><code>ReentrantReadWriteLock</code>内部维护两个锁, 一个是写锁, 另外一个是读锁. 通过将读写锁分离, 在读多写少的情况下, 更够提高程序的并发程度, 因此, <code>ReentrantReadWriteLock</code>的伸缩性要好于<code>ReentrantLock</code>. 在读多写少的情况下, 应该使用<code>ReentrantReadWriteLock</code>更为合适.</p>
<p><code>ReentrantReadWriteLock</code>只支持锁降级, 不支持锁升级. 因为锁升级有可能会出现条件竞争. 由于读锁是可以被多个线程持有的, 如果进行锁升级的话, 当写线程改变共享变量的状态时, 其他读线程有可能感知不到.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fkz6p5rdydj30m80b47at.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;和&lt;code&gt;ReentrantRead
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#Lock" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-Lock/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer中的ConditionObject剖析</title>
    <link href="http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer%E4%B8%AD%E7%9A%84ConditionObject%E5%89%96%E6%9E%90/"/>
    <id>http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer中的ConditionObject剖析/</id>
    <published>2017-10-31T15:33:18.156Z</published>
    <updated>2017-10-31T15:33:18.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer中的ConditionObject剖析"><a href="#AbstractQueuedSynchronizer中的ConditionObject剖析" class="headerlink" title="AbstractQueuedSynchronizer中的ConditionObject剖析"></a>AbstractQueuedSynchronizer中的ConditionObject剖析</h1><p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktlv07v17j30jg0dwngp.jpg" alt=""></p>
<p>在多线程环境中, 有时候, 一个线程的执行是需要等待一个条件发生后才能执行的. 在经典的生产者和消费者模式中, 如果缓冲区满后, 生产者是不能向缓冲区投放<code>item</code>的, 它需要等待一个条件: <code>缓冲区不为满的状态</code>. 同理, 如果缓冲区为空时, 消费者是不能消费<code>item</code>的, 它需要等待一个条件: <code>缓冲区不为空</code>. 一个线程需要等待一定的条件发生, 这个条件往往是别的线程触发的, 这就是经典的<code>等待/唤醒</code>模式.</p>
<p>在<code>JDK1.5</code>之前要实现这种模式的话, 只能够借助<code>synchronized</code>关键字和<code>Object</code>的对象锁来实现. 在<code>1.5</code>之后, 可以利用基于<code>AQS</code>实现的锁和<code>AQS</code>内部的<code>ConditionObject</code>来实现. 下面以<code>ReentrantLock</code>为例实现一个等待/唤醒模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObjectTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Condition isEmpty = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Condition isFull = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        ReentrantLock reentrantLock = lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">if</span> (count &gt;= MAX_LENGTH) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                isEmpty.await(); <span class="comment">//等待一个缓冲区不为满的条件</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        queue.add(i);</div><div class="line">        count++;</div><div class="line">        isFull.signal(); <span class="comment">//通知缓冲区已经不为空</span></div><div class="line">        reentrantLock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</div><div class="line">        ReentrantLock reentrantLock = lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                isFull.await(); <span class="comment">//等待缓冲区不为空的条件</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = queue.peek(); <span class="comment">//消费</span></div><div class="line">        count--;</div><div class="line">        isEmpty.signal(); <span class="comment">//通知缓冲区不为满</span></div><div class="line">        reentrantLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中定义了两个条件, 一个是缓冲区为空的条件, 另外一个是缓冲区为满的条件. 当队列达到最大长度时, 也就是缓冲区满了, 此时生产者调用了<code>isEmpty.await()</code>来等待一个缓冲区不为满的条件, 因此线程会暂时被挂起. 这个条件是由消费者消费了一个<code>item</code>后调用<code>isEmpty.signal()</code>是触发的. 触发了这个条件后, 会唤醒处于等待的生产者线程, 使它从<code>isEmpty.await()</code>中返回. 至于当缓冲区为满时的情况原理是一样的, 这里不多分析. 下面主要分析<code>AQS</code>内部怎么实现等待通知模式的.</p>
<blockquote>
<h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2></blockquote>
<p>一般而言, 线程是否需要等待一个条件的判断, 这个判断往往是访问一个共享变量, 在前面的例子中, 这个共享变量是<code>缓冲区</code>. 因此, 每次等待一个条件或者触发一个条件时, 都必须先获得锁. 这也解释为什么<code>ConditionObject</code>会作为<code>AQS</code>的内部类.</p>
<blockquote>
<h2 id="ConditionObject的等待-通知方法"><a href="#ConditionObject的等待-通知方法" class="headerlink" title="ConditionObject的等待/通知方法"></a>ConditionObject的等待/通知方法</h2></blockquote>
<p><code>ConditionObject</code>中的等待方法支持的类型跟<code>AQS</code>中一样, 都支持不可中断, 可中断, 超时三种类型.</p>
<blockquote>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4></blockquote>
<ul>
<li><p><code>awaitUninterruptibly()</code>: 不可中断的等待一个条件</p>
</li>
<li><p><code>await()</code>: 响应中断的等待一个条件</p>
</li>
<li><p><code>awaitNanos(long nanosTimeout)</code>: 超时等待一个条件, 如果超过指定的等待时间的话, 会直接返回. 超时等待还有两个重载方法, 这里只列出一个.</p>
</li>
</ul>
<blockquote>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4></blockquote>
<ul>
<li><p><code>signal()</code>: 从等待队列中唤醒一个正在等待的线程</p>
</li>
<li><p><code>signalAll()</code>: 唤醒等待队列中的全部线程.</p>
</li>
</ul>
<blockquote>
<h4 id="awaitUninterruptibly-解读"><a href="#awaitUninterruptibly-解读" class="headerlink" title="awaitUninterruptibly()解读"></a><code>awaitUninterruptibly()</code>解读</h4></blockquote>
<p>三种类型的等待方法的实现逻辑跟<code>AQS</code>中的获取同步状态的三种类型差不多, 这里只分析<code>awaitUninterruptibly()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node node = addConditionWaiter(); <span class="comment">//添加进等待队列, 等待队列不是AQS中的同步队列</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放同步状态, 相当于释放锁</span></div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//判断节点是不是在同步队列中, 也就是等待获取同步状态的队列</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">//不在同步队列的话, 证明已经在等待队列了, 需要等待一个条件, 因此挂起线程, 等待其他线程唤醒</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">//被唤醒后, 重新竞争同步状态, 也就是竞争锁</span></div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于每次调用这个方法时, 必定时已经获取了锁的, 所以不用控制同步, 实现起来比较简单. 首先将当前节点添加进等待队列, 接着释放同步状态, 也就是释放锁, 它准备要被挂起了, 挂起前必须释放同步状态, 不然有可能引起死锁. 然后, 判断节点是否存在同步队列中, 如果不存在的话,证明已经被添加进等待队列中, 此时进入<code>While</code>循环挂起线程. 接下来执行到这里就停了. 需要等待其他线程触发它等待的条件.</p>
<blockquote>
<h4 id="signal-解读"><a href="#signal-解读" class="headerlink" title="signal()解读"></a><code>signal()</code>解读</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    Node first = firstWaiter;</div><div class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">        doSignal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次都是释放等待队列中的第一个节点, 说明等待队列是一个<code>FIFO</code>队列. 释放的主要逻辑都在<code>doSignal(first)</code>中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">    do &#123;</div><div class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</div><div class="line">            lastWaiter = <span class="keyword">null</span>;</div><div class="line">        first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</div><div class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>doSignal()</code>中会调用<code>transferForSignal(first)</code>将等待队列中的节点移动到同步队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If cannot change waitStatus, the node has been cancelled.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Splice onto queue and try to set waitStatus of predecessor to</div><div class="line">     * indicate that thread is (probably) waiting. If cancelled or</div><div class="line">     * attempt to set waitStatus fails, wake up to resync (in which</div><div class="line">     * case the waitStatus can be transiently and harmlessly wrong).</div><div class="line">     */</div><div class="line">    Node p = enq(node);</div><div class="line">    <span class="keyword">int</span> ws = p.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">        LockSupport.unpark(node.thread);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过<code>CAS</code>设置节点的状态, 如果设置失败的话, 说明节点已经被取消. 接着调用<code>enq(node)</code>方法, 将节点移动到同步队列中, 然后设置节点的状态为<code>SIGNAL</code>.最后唤醒线程. 唤醒后, 在之前的等待方法中, 会被执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node node = addConditionWaiter(); <span class="comment">//添加进等待队列, 等待队列不是AQS中的同步队列</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放同步状态, 相当于释放锁</span></div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//判断节点是不是在同步队列中, 也就是等待获取同步状态的队列</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">//不在同步队列的话, 证明已经在等待队列了, 需要等待一个条件, 因此挂起线程, 等待其他线程唤醒</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">//被唤醒后, 重新竞争同步状态, 也就是竞争锁</span></div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于节点已经被移动到同步队列中, 所以<code>isOnSyncQueue(node)</code>会返回<code>true</code>跳出循环, 接着调用<code>acquireQueued(node, savedState)</code>来竞争同步状态, 也就是重新获得锁. 如果成功的话, 将从<code>awaitUninterruptibly()</code>中返回.</p>
<p>对于<code>signalAll()</code>, 它通过一个循环, 调用<code>signal()</code>来实现唤醒等待队列中的全部线程.</p>
<blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote>
<p>当一个线程调用等待方法时, 它首先会把自己添加进等待队列中, 接着释放同步状态, 然后被挂起. 直到其他线程调用唤醒的方法, 节点会被移动到同步队列中并且唤醒对应的线程去竞争同步状态, 如果成功的话, 将从等待的方法中返回, 下面是逻辑图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktlspogakj30f20n9q4q.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AbstractQueuedSynchronizer中的ConditionObject剖析&quot;&gt;&lt;a href=&quot;#AbstractQueuedSynchronizer中的ConditionObject剖析&quot; class=&quot;headerlink&quot; title=&quot;Ab
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#AQS" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-AQS/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer剖析</title>
    <link href="http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer%E5%89%96%E6%9E%90/"/>
    <id>http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer剖析/</id>
    <published>2017-10-31T15:33:14.724Z</published>
    <updated>2017-10-31T15:33:14.724Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktbn58ux2j30m80b47l5.jpg" alt=""></p>
<h1 id="AbstractQueuedSynchronizer剖析"><a href="#AbstractQueuedSynchronizer剖析" class="headerlink" title="AbstractQueuedSynchronizer剖析"></a>AbstractQueuedSynchronizer剖析</h1><p>在介绍AbstractQueuedSynchronizer(下面称AQS)前, 我们先来看看一个不安全的锁, 然后引出构建安全锁需要处理哪些情况.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">lock_t</span> &#123;</div><div class="line">    <span class="keyword">int</span> flag;</div><div class="line">&#125; <span class="keyword">lock_t</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    mutex-&gt;flag = <span class="number">0</span>; <span class="comment">//0表示锁空闲, 1表示锁被占有</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(mutex-&gt;flag == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//自旋等待</span></div><div class="line">    &#125;</div><div class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">//获得锁</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    mutex-&gt;flag = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>flag</code>字段是一个状态字段, 0表示锁空闲, 1表示锁被占有. 初始化时, <code>flag</code>被初始化为0, 表示锁是空闲的. 在<code>lock(lock_t*)</code>中, 会循环检查<code>flag</code>标记, 如果是为1的话, 表示锁已经被占有, 于是就一直自旋等待. 直到<code>flag</code>被设置为0, 也就是<code>unlock(lock_t*)</code>操作.</p>
<p>但是这个锁, 是不能保证正确性的. 因为 <code>mutex-&gt;flag == 1</code>和 <code>mutex-&gt;flag = 1</code>不是原子操作, 执行这两句的过程中, 有可能被中断.</p>
<p>而且, 这个锁的性能也不怎么好, 如果锁已经被占有的话, 它只会一直循环, 这样就白白浪费了CPU时间片.</p>
<p>如果能将<code>mutex-&gt;flag == 1;</code>和 <code>mutex-&gt;flag = 1</code>作为一个原子操作的话, 那么就能保证锁的正确性. 换句话说, 只要把检查和更新锁的状态字段的操作作为一个原子操作的话, 就不会出现问题. 所以现代处理器普遍都提供了<code>campare and swap</code>原句来解决这个问题.</p>
<p>至于性能的问题: 与其让它一直自旋等待, 不如让出时间片, 等锁空闲的时候再调度或者自旋等待一段时间, 超过这个时间后还没获得锁的话, 就放弃时间片.</p>
<p>现在总结一下解决这两个问题需要处理的情况:</p>
<ul>
<li><p>需要管理<code>flag</code>字段的同步状态, 利用一些同步原句来更新和管理同步状态.</p>
</li>
<li><p>为了提高锁的性能, 我们需要让获取锁失败的线程挂起或者等待一段时间后才挂起, 防止浪费时间片. 所以, 我们需要一个数据结构来管理记录这些获取锁失败的线程, 并且在当锁空闲的时候, 负责唤醒挂起的线程, 以便他们进行获取锁的操作.</p>
</li>
</ul>
<blockquote>
<h2 id="AQS的使命"><a href="#AQS的使命" class="headerlink" title="AQS的使命"></a>AQS的使命</h2></blockquote>
<p>经过上面的简单介绍, 我们知道构建一个安全并且性能高的锁需要处理下面的情况</p>
<ul>
<li><p>管理同步状态</p>
</li>
<li><p>管理获取锁失败的线程, 并且负责挂起和唤醒获取锁失败的线程.</p>
</li>
</ul>
<p><code>AQS</code>的使命就是来完成上面的任务, 以便让各种类型的锁只关注自己本身的特性. 换句话说: <code>AQS</code>是并发包中的基本骨架, 并发包中的各种锁都是基于<code>AQS</code>, <code>AQS</code>为其他锁将所有的脏活和累活(管理同步状态, 将获取锁失败的线程排队,挂起和唤醒.)都解决掉, 让其他的锁只关注自己的特性.</p>
<blockquote>
<h2 id="AQS设计"><a href="#AQS设计" class="headerlink" title="AQS设计"></a>AQS设计</h2></blockquote>
<p><code>AQS</code>是基于模板设计模式来实现的. 它将公用的特性自己实现, 对于具体的子类特性, <code>AQS</code>提供了一些方法作为模板, 子类只需要实现对应的模板方法来构建就行了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//独占式获取同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//独占式释放同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//共享式获取同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//共享式释放同步状态</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tryXXX</code>是<code>AQS</code>提供给子类实现的模板方法, 这些模板对应两种获取同步状态的模式: 独占式模式和共享式模式. 每种模式对应有获取和释放方法. 对于共享式, 同个时刻可以有多个线程获取同步状态, 至于获取的规则由子类去实现. 子类实现这种模式一般是共享锁. 至于独占式, 同个时刻只有一个线程可以获取, 获取的规则也是由子类去重写对应的模板方法实现. 子类实现这种模式一般是独占锁.</p>
<blockquote>
<h3 id="AQS中的同步队列"><a href="#AQS中的同步队列" class="headerlink" title="AQS中的同步队列"></a>AQS中的同步队列</h3></blockquote>
<p>对于获取锁失败的线程, <code>AQS</code>需要用一个数据结构来追踪记录他们. 这个数据结构是一个双向链表. 也可以看做是一个FIFO的<code>同步队列</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); <span class="comment">//标记当前模式为共享式</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; <span class="comment">//标记当前模式为独占式</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>; <span class="comment">//当前节点已经被取消</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>; <span class="comment">//标记后继节点需要被唤醒</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; <span class="comment">//标记当前节点处于等待队列中(注意不是同步队列)</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; <span class="comment">//用于共享模式中, 表示后继节点获取同步状态可以无条件传递下去.</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">//前继节点</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">//后继节点</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">//获取锁失败的线程</span></div><div class="line"></div><div class="line">    Node nextWaiter; <span class="comment">//等待队列中的当前节点的下个节点</span></div></pre></td></tr></table></figure>
<p>如果线程获取锁失败时, <code>AQS</code>会将其包装成一个<code>Node</code>节点并且入队在同步队列中. <code>Node</code>节点和<code>Thread</code>引用通过<code>volatile</code>来保证每次读取的值是最新的. 需要注意的是: <code>nextWaiter</code>是<code>等待队列</code>中的后继节点引用, 这里的<code>等待队列</code>和<code>同步队列</code>不是一样的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">//队列头结点</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">//队列尾节点</span></div></pre></td></tr></table></figure>
<p>每次出队时, 是从<code>head</code>节点出队, 入队时. 是从<code>tail</code>节点插入. 头尾节点也是被<code>volatile</code>修饰来保证他们在多线程环境下的可见性.</p>
<blockquote>
<h3 id="AQS中的状态管理"><a href="#AQS中的状态管理" class="headerlink" title="AQS中的状态管理"></a>AQS中的状态管理</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> state;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</div><div class="line">   state = newState;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">   <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">   <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于同步状态的管理, <code>AQS</code>采用一个<code>int</code>变量来表示, 并且该变量也是由<code>volatile</code>来修饰, 因此<code>getState</code>和<code>setState</code>这两个方法不用加锁. 这里需要注意的是: <code>volatile</code>能保证可见性, 但是不能保证原子性. 它只能保证单操作的原子性, 也就是更新时不依赖本身的状态或者是其他变量的值. 如果需要原子更新的话, 应该使用<code>compareAndSetState(int expect, int update)</code>, 该方法能够保证原子性和可见性.</p>
<blockquote>
<h3 id="AQS分类"><a href="#AQS分类" class="headerlink" title="AQS分类"></a>AQS分类</h3></blockquote>
<p>总得来说, <code>AQS</code>的操作分为两种模式:</p>
<ul>
<li><p>共享式: 共享式可以细分为: 1. <code>不响应中断的共享式获取同步状态</code>. 2. <code>响应中断的共享式获取同步状态</code>. 3. <code>同时响应中断和超时的共享式获取同步状态</code>.</p>
</li>
<li><p>独占式: 独占式跟共享式基本一样, 可以分为: 1. <code>不响应中断的独占式获取同步状态</code>. 2. <code>响应中断的独占式获取同步状态</code>. 3. <code>同时响应中断和超时的独占式获取同步状态</code>.</p>
</li>
</ul>
<p>下面我们通过官方的例子来解析AQS的原理. 如果理解了下面例子的话, 理解并发包中的其他锁自然也不在话下.</p>
<blockquote>
<h3 id="独占式锁"><a href="#独占式锁" class="headerlink" title="独占式锁"></a>独占式锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// Our internal helper class</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">     <span class="comment">// Reports whether in locked state</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Acquires the lock if state is zero</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">         setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Releases the lock by setting state to zero</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">       setState(<span class="number">0</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Provides a Condition</span></div><div class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Deserializes properly</span></div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></div><div class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</div><div class="line">       s.defaultReadObject();</div><div class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.acquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.release(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.newCondition();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> sync.isHeldExclusively();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Mutex</code>是一个简单的独占锁, 同一个时刻只允许有一个线程获取锁. <code>Sync</code>是<code>Mutex</code>的一个静态内部类, 该类继承了<code>AQS</code>, 并且重写了<code>AQS</code>提供的模板方法. <code>Sync</code>是<code>Mutex</code>一个代理类, <code>Mutex</code>的所有操作都是代理给<code>Sync</code>. <code>Sync</code>会调用<code>AQS</code>的方法, 而<code>AQS</code>又会回调<code>Sync</code>实现的模板方法.<br>这就是<code>AQS</code>的设计思路: 实现一个锁时, 往往是设置一个内部静态类, 该类继承<code>AQS</code>并且重写其中的模板方法, 最后锁内部的方法都代理给这个内部静态类. 并发包中的其他锁的实现思想也是这样的.</p>
<blockquote>
<h4 id="不响应中断的获取同步状态-acquire-int"><a href="#不响应中断的获取同步状态-acquire-int" class="headerlink" title="不响应中断的获取同步状态: acquire(int)"></a>不响应中断的获取同步状态: acquire(int)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">  sync.acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lock()</code>方法为不响应中断获取同步状态, 内部会调用<code>sync</code>的<code>acquire</code>, 而<code>acquire</code>方法是定义在<code>AQS</code>里面的. 那么先到<code>AQS</code>中看看.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会调用<code>tryAcquire(int)</code>来尝试获取同步状态, 如果获取成功的话, 直接返回. 获取失败的话, 需要入队. 获取的逻辑是在<code>Sync</code>重写的<code>tryAcquire(int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">    setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Mutex</code>实现得很简单, 通过<code>CAS</code>来更新状态. 如果获取成功的话, 返回<code>true</code>. 失败的话, 返回<code>false</code>.</p>
<p>如果获取同步状态失败的话, 也就是<code>tryAcquire</code>返回<code>false</code>的话, <code>AQS</code>会将对应的线程包装成一个<code>Node</code>节点, 然后加入同步队列中, 最后挂起线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//由于Head和Tail节点采用延迟加载的策略, 因此tail有可能为空</span></div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">//成功的话, 证明入队成功.</span></div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node); <span class="comment">//失败的话, 说明被其他线程给更新了尾节点, 因此进入enq方法入队.</span></div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 由于Head和Tail节点采用延迟加载的策略, 因此tail有可能为空</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addWaiter</code>内部首先尝试使用<code>CAS</code>来更新尾节点, 也就是插入新的节点. 如果<code>CAS</code>返回<code>true</code>的话, 证明插入成功, 如果失败的话, 进入<code>enq</code>方法.</p>
<p>在<code>enq</code>中, 通过一个死循环来保证入队的成功.</p>
<p>入队完成后, 进入<code>acquireQueued(final Node node, int arg)</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//拿到当前节点的前驱节点</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//如果当前节点的前驱节点为Head节点的话, 证明该节点处于队列的第二位置(第一是头节点. 仅仅做标记用), 因此它有权获取同步状态.</span></div><div class="line">                setHead(node); <span class="comment">//获取成功后, 更新头节点</span></div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果p != head或者获取同步状态失败的话, 需要将线程挂起</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>acquireQueued</code>的逻辑: 首先拿到当前节点的前驱节点, 如果前驱节点为<code>head</code>的话, 证明该节点处于队列的第二个位置, 由于<code>head</code>节点仅仅起标记的作用, 因此处于第二个位置的节点逻辑上是处于队头, 它能够竞争同步状态. 如果前驱节点不是<code>head</code>节点的话, 需要将线程挂起.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkr4pd1fycj30r607zt92.jpg" alt=""></p>
<p>现在我们来看看挂起线程的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">//首先判断是不是已经设置了SIGNAL状态, 是的话, 证明需要被挂起</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">//节点状态为CANCELLED, 跳过这些取消的节点</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        do &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">//设置节点为SIGNAL, 表明需要被挂起.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个线程被挂起前, 必须设置状态为<code>SIGNAL</code>, 设置为<code>SIGNAL</code>后, 表明前驱节点出队后, 必须唤醒这个节点. 如果节点的状态被设置为<code>CANCELLED</code>的话, 说明它不需要被挂起.</p>
<p>所以<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>, 如果线程需要被挂起的话, 它的状态为0(默认状态), 那么它通过<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</code>来将状态设置为<code>SIGNAL</code>, 表明它需要被挂起, 在下次再调用该方法时, 会执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回<code>true</code>来表示它需要被挂起.</p>
<p>如果线程的状态被设置为<code>CANCELLED</code>, 也就是<code>ws &gt; 0</code>, 那么会跳过这些取消的节点, 下次循环进入时, 执行上面的逻辑.</p>
<p>当<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>返回<code>true</code>时, 会调用<code>parkAndCheckInterrupt()</code>来挂起线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LockSupport.park(this)</code>是一个挂起线程的操作.</p>
<p>现在我们再经过一张图来理清<code>acquire(int)</code>的逻辑</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkrwnsxu5ej30oi0mq75m.jpg" alt=""></p>
<p>当线程尝试获取同步状态时, 如果成功的话, 直接退出. 如果失败的话, 将线程包装成一个<code>Node</code>节点并且加入到队列中. 入队后, 需要判断线程是否需要被挂起. 如果当前节点的前驱节点是<code>head</code>节点的话, 尝试获取同步状态, 如果成功的话, 将自己设置为头节点后退出. 如果当前节点的前驱节点不是<code>head</code>或者是<code>head</code>节点但是获取同步状态失败, 将线程挂起. 被挂起的线程会被前驱节点唤醒, 接着继续竞争同步状态.</p>
<blockquote>
<h4 id="响应中断的获取同步状态-acquireInterruptibly-int-arg"><a href="#响应中断的获取同步状态-acquireInterruptibly-int-arg" class="headerlink" title="响应中断的获取同步状态: acquireInterruptibly(int arg)"></a>响应中断的获取同步状态: acquireInterruptibly(int arg)</h4></blockquote>
<p><code>acquireInterruptibly(int arg)</code>可以响应线程的中断而退出.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">        doAcquireInterruptibly(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查线程的中断状态标记, 如果已经被设置了中断的话, 抛出中断异常来响应. 如果没有被中断的话, 先尝试快速的获取同步状态, 如果成功的话, 直接退出. 失败的话进入<code>doAcquireInterruptibly(arg);</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doAcquireInterruptibly(int arg)</code>方法的逻辑和<code>acquireQueued(final Node node, int arg)</code>大致一样. 下面只说说不一样的地方. 如果<code>parkAndCheckInterrupt()</code>返回<code>true</code>的话, 会抛出中断异常来响应中断.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程被唤醒后会检查中断标记位.</p>
<p>由于<code>acquireInterruptibly(int arg)</code>逻辑和<code>acquire</code>差不多, 所以这里不多讲.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkrxgdyggoj30p30mujss.jpg" alt=""></p>
<blockquote>
<h4 id="支持超时的获取同步状态-tryAcquireNanos-int-arg-long-nanosTimeout"><a href="#支持超时的获取同步状态-tryAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="支持超时的获取同步状态: tryAcquireNanos(int arg, long nanosTimeout)"></a>支持超时的获取同步状态: tryAcquireNanos(int arg, long nanosTimeout)</h4></blockquote>
<p><code>tryAcquireNanos(int arg, long nanosTimeout)</code>方法如果在给定的一个时间内不能够获取锁的话, 会直接返回. 该方法同时也支持中断. 换句话说<code>tryAcquireNanos(int arg, long nanosTimeout)</code>是在<code>acquireInterruptibly(int arg)</code>的基础上加入超时获取的逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</div><div class="line">        doAcquireNanos(arg, nanosTimeout);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查中断标志, 如果<code>true</code>的话, 抛出异常来响应. <code>false</code>的话, 首先尝试获取同步状态, 成功的话直接返回. 失败的话, 进入<code>doAcquireNanos(arg, nanosTimeout);</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">//记录超时的时间</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">//如果nanosTimeout &lt; 0=的话, 证明超时了</span></div><div class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// 剩余的超时时间如果小于这个spinForTimeoutThreshold的话, 线程不会被挂起, 而是会自旋</span></div><div class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doAcquireNanos(int, long)</code>的逻辑和<code>doAcquireInterruptibly(int arg)</code>大体相同, 不同的是: <code>doAcquireNanos(int, long)</code>支持超时获取锁. 超时获取的逻辑: 首先计算出超时的时间戳<code>final long deadline = System.nanoTime() + nanosTimeout;</code>, 在自旋的过程中, 如果<code>deadline - System.nanoTime() &lt;= 0</code>的话,证明已经超时, 所以返回<code>false</code>. 如果大于0的话, 说明还没超时. 如果线程挂起的另外一个条件是<code>nanosTimeout &gt; spinForTimeoutThreshold</code>. 这样做为因为<code>spinForTimeoutThreshold = 1000</code>纳秒, 已经很小了, 如果再进行超时等待的话, 反而会更加不准确. 因此, 如果<code>nanosTimeout</code>小于等于<code>spinForTimeoutThreshold(1000纳秒)</code>时,将不会使该线程进行超时等待,而是进入快速的自旋过程。</p>
<blockquote>
<h4 id="释放同步状态-release-int-arg"><a href="#释放同步状态-release-int-arg" class="headerlink" title="释放同步状态: release(int arg)"></a>释放同步状态: release(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head; <span class="comment">//获取头结点</span></div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>release(int)</code>为释放同步状态, 它会调用<code>tryRelease(int)</code>模板方法, 这个模板方法是由<code>Mutex</code>来重写的, 具体代码前面已经贴出来了.<br>接着它会进入<code>unparkSuccessor(h);</code>来唤醒同步队列中的线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了防止提前线程被提前唤醒, 首先利用<code>CAS</code>将状态更新为默认状态. 一般而言, 需要唤醒的节点为<code>head</code>节点的下个节点, 但是为了防止节点已经被取消或者为空, 需要判断一下, 如果是的话, 从队列找到下一个需要释放的节点. 最后才唤醒线程.</p>
<blockquote>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3></blockquote>
<p>共享锁是指允许同个时刻, 允许多个线程获得资源. 共享锁的实现需要<code>AQS</code>的四组方法支持</p>
<ul>
<li><p><code>acquireShared(int arg)</code>: 不支持中断获取同步状态</p>
</li>
<li><p><code>acquireSharedInterruptibly(int arg)</code>: 支持中断地获取同步状态</p>
</li>
<li><p><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>: 超时获取并且支持中断获取同步状态</p>
</li>
<li><p><code>releaseShared(int arg)</code>: 释放同步状态</p>
</li>
</ul>
<p>这四组方法的逻辑跟独占模式下的方法的逻辑差不多, 因此, 这里只分析<code>acquireShared(int arg)</code>和<code>releaseShared(int arg)</code>.</p>
<blockquote>
<h4 id="acquireShared-int-arg"><a href="#acquireShared-int-arg" class="headerlink" title="acquireShared(int arg)"></a>acquireShared(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireShared(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tryAcquireShared(arg)</code>为子类重写的模板方法. 如果方法返回值小于0的话, 说明获取同步状态失败. 因此进入<code>doAcquireShared(arg)</code>进行排队和挂起等操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">//添加进队列</span></div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获取前驱节点</span></div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">//获取同步状态</span></div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">//如果同步状态还有剩余的话</span></div><div class="line">                    setHeadAndPropagate(node, r); <span class="comment">//唤醒后续的线程</span></div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    <span class="keyword">if</span> (interrupted)</div><div class="line">                        selfInterrupt();</div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前驱节点为<code>head</code>节点的话, 此时会超时获取同步状态, 如果成功并且状态大于等于0的话, 证明同步资源还有剩余, 可以唤醒后面的线程. 因此会调用<code>setHeadAndPropagate(node, r)</code>, 设置头结点并且将唤醒后面的线程.</p>
<blockquote>
<h4 id="releaseShared-int-arg"><a href="#releaseShared-int-arg" class="headerlink" title="releaseShared(int arg)"></a>releaseShared(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>共享式的释放和独占式的释放的主要区别在于: 独占式释放的时候, 只有一个线程在执行, 因此不存在竞争条件, 直接唤醒后续线程即可. 但是在共享式中, 由于同个时刻有多个线程在执行, 因此存在条件竞争, <code>doReleaseShared()</code>内部通过循环和<code>CAS</code>来保证线程安全.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<p><code>AQS</code>利用模板设计模式来为其子类屏蔽了同步状态的管理, 同步队列的管理, 线程的挂起和唤醒等操作, 使得子类只需要关注本身获取同步状态的逻辑. <code>AQS</code>内部总体实现分为两种模式:</p>
<ul>
<li><p>共享式</p>
</li>
<li><p>独占式</p>
</li>
</ul>
<p>共享式和独占式都支持不可中断, 可中断, 可中断并且超时获取同步状态.</p>
<p>关于<code>AQS</code>, 其内部还有一个<code>ConditionObject</code>类, 该类是实现等待/通知模式. 由于篇幅的关系, 打算在下篇中分析.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fktbn58ux2j30m80b47l5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;AbstractQueuedSynchronizer剖析&quot;&gt;&lt;a href=&quot;#A
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#AQS" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-AQS/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-WeakHashMap,%20IdentityHashMap%20%E5%92%8C%20HashTable/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable/</id>
    <published>2017-10-31T13:58:15.503Z</published>
    <updated>2017-10-31T13:58:15.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2></blockquote>
<p><code>WeakHashMap</code>总体实现和<code>HashMap</code>差不多, 不同的时, <code>WeakHashMap</code>中的Key是弱引用类型, <code>WeakHashMap</code>内部的Key是会被自动回收的. 另外需要关注的是, <code>WeakHashMap</code>并没有向<code>HashMap</code>那样, 在1.8做了优化.</p>
<blockquote>
<h3 id="弱引用Key"><a href="#弱引用Key" class="headerlink" title="弱引用Key"></a>弱引用Key</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    V value;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates new entry.</div><div class="line">     */</div><div class="line">    Entry(Object key, V value,</div><div class="line">          ReferenceQueue&lt;Object&gt; queue,</div><div class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(key, queue);</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.hash  = hash;</div><div class="line">        <span class="keyword">this</span>.next  = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (K) WeakHashMap.unmaskNull(get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">        K k1 = getKey();</div><div class="line">        Object k2 = e.getKey();</div><div class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">            V v1 = getValue();</div><div class="line">            Object v2 = e.getValue();</div><div class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        K k = getKey();</div><div class="line">        V v = getValue();</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>内部的结点是继承弱引用类型, 并且指定了一个<code>ReferenceQueue&lt;Object&gt;</code>, 当Key被GC回收时, Key对应的对象会被添加到<code>ReferenceQueue&lt;Object&gt;</code>这个队列中. 这个队列是定义在<code>WeakHashMap</code>内部的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Reference queue for cleared WeakEntries</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>的实现原理跟<code>HashMap</code>是差不多的. 不过<code>HashMap</code>在1.8后, 做了很多优化, 但是<code>WeakHashMap</code>并没有跟随<code>HashMap</code>进行优化.</p>
<p>由于<code>WeakHashMap</code>和<code>HashMap</code>差不多, 我们只分析重要的实现方法.</p>
<p><code>WeakHashMap</code>的增删查改, 都会做一个同步操作, 什么是同步操作? 因为<code>WeakHashMap</code>的Key是弱引用类型, Key值会随时被GC回收. 虽然Key被回收了,但是对应的Value还是没有被回收的. 所以, 同步操作就是移除被回收Key对应的Value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunges stale entries from the table.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123; <span class="comment">//判断queue队列中是否有被回收的Key, 有的话, 需要移除对应Value</span></div><div class="line">        <span class="keyword">synchronized</span> (queue) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</div><div class="line"></div><div class="line">            Entry&lt;K,V&gt; prev = table[i];</div><div class="line">            Entry&lt;K,V&gt; p = prev;</div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                Entry&lt;K,V&gt; next = p.next;</div><div class="line">                <span class="keyword">if</span> (p == e) &#123;</div><div class="line">                    <span class="keyword">if</span> (prev == e)</div><div class="line">                        table[i] = next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        prev.next = next;</div><div class="line">                    <span class="comment">// Must not null out e.next;</span></div><div class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></div><div class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></div><div class="line">                    size--;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                prev = p;</div><div class="line">                p = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是同步操作的方法, <code>WeakHashMap</code>增删改查时, 都会调用的方法. 原理是这样的: 每当弱引用类型Key被GC回收时, 由于<code>WeakHashMap</code>内部指定了<code>ReferenceQueue&lt;Object&gt;</code>, 因此, 被移除的Key会被添加到该队列. 这个方法就是调用队列的<code>poll()</code>方法, 获得被移除的Key, 然后利用该Key, 移除在<code>WeakHashMap</code>内部对应的Value.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li><p><code>WeakHashMap</code>和<code>HashMap</code>一样, Key和Value都支持null.</p>
</li>
<li><p><code>WeakHashMap</code>内部的继承WeakReference, 将Key指定为弱引用类型, 这样Key会被自动回收. 虽然Key会被自动回收, 但是Value不会被自动回收. 因此, <code>WeakHashMap</code>内部每次增删改查时, 都会做同步操作.</p>
</li>
</ul>
<blockquote>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2></blockquote>
<p><code>IdentityHashMap</code>继承于<code>AbstractMap</code>,并实现了<code>Map</code>接口. 总体来说, <code>IdentityHashMap</code>跟<code>HashMap</code>差别还是很大的. 虽然继承结构相同, 但是实现的思想却是截然不同.</p>
<p><code>IdentityHashMap</code>内部并没有结点, 它的Key和Vaule都是储存在数组内的. 因此, <code>IdentityHashMap</code>解决的冲突是开放地址法.</p>
<p>上面说到<code>IdentityHashMap</code>的Key和Value都是存在数组内的. Key和Value总是连续的存放.</p>
<p>另外值得一提的是: <code>IdentityHashMap</code>是利用 <code>==</code>来比较Key的相等性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    init(DEFAULT_CAPACITY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2</span></div><div class="line">    <span class="comment">// assert initCapacity &gt;= MINIMUM_CAPACITY;</span></div><div class="line">    <span class="comment">// assert initCapacity &lt;= MAXIMUM_CAPACITY;</span></div><div class="line"></div><div class="line">    table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>默认的容量是64. 长度跟<code>HashMap</code>一样, 都是2的次幂.还是跟之前的套路一样, 只分析一些重要的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object k = maskNull(key);</div><div class="line"></div><div class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> Object[] tab = table;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</div><div class="line">        <span class="keyword">int</span> i = hash(k, len); <span class="comment">//获得数组的index</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>; <span class="comment">//有冲的话, 查找下一个index</span></div><div class="line">             i = nextKeyIndex(i, len)) &#123;</div><div class="line">            <span class="keyword">if</span> (item == k) &#123;</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</div><div class="line">                tab[i + <span class="number">1</span>] = value;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</div><div class="line">        <span class="comment">// Use optimized form of 3 * s.</span></div><div class="line">        <span class="comment">// Next capacity is len, 2 * current capacity.</span></div><div class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len)) <span class="comment">//当储存的元素大于 容量的3分之一的话, 扩容</span></div><div class="line">            <span class="keyword">continue</span> retryAfterResize;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        tab[i] = k;</div><div class="line">        tab[i + <span class="number">1</span>] = value; <span class="comment">//Value始终是保存在Key的下个index</span></div><div class="line">        size = s;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>hash</code>函数, 获得index, 如果index对应已经存有元素的话, 会调用<code>nextKeyIndex(int, int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>是使用开放地址法解决冲突. 当发生冲突时, 它会寻找下个位置, 而下个位置是 i + 2. 之所以是i + 2,而不是i + 1的原因是 Key和Value总是连续的储存的, 因此寻找下个位置时, 需要跳多一个位置.如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fip01fuwt1j30er06bmx6.jpg" alt=""></p>
<p>如果index没有储存元素的话, 会先检查内部储存元素数量是不是大于容量的1/3, 是的话会进行扩容操作.每次扩容都是扩为原来的2倍.</p>
<blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2></blockquote>
<p><code>HashTable</code>是一个遗留类, 已经被<code>HashMap</code>替代了. 从功能上来说, 跟HashMap差不多. 主要比较它跟<code>HashMap</code>的异同.</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><code>HashMap</code>是允许K或者V为null的, 但是<code>HashTable</code>不允许K或者V为null</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><code>HashMap</code>是线程不安全的, 而<code>HashTable</code>是线程安全的, 因为内部的方法都是加了锁. 但是在并发的环境, 不建议使用<code>HashTable</code>, 应该使用<code>ConcurrentHashMap&lt;K,V&gt;</code>. <code>ConcurrentHashMap&lt;K,V&gt;</code>是使用分段锁来控制同步, 显然性能上要比<code>HashTable</code>好.</p>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p><code>HashMap</code>的容量为2的n次幂, 而<code>HashTable</code>为素数.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;W
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-返回结果的状态码-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%9B%BE%E8%A7%A3HTTP-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-%E7%AC%94%E8%AE%B0/"/>
    <id>http://cristianoro7.github.io/2017/10/31/图解HTTP-返回结果的状态码-笔记/</id>
    <published>2017-10-31T13:57:58.722Z</published>
    <updated>2017-10-31T13:57:58.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="状态码类别："><a href="#状态码类别：" class="headerlink" title="状态码类别："></a>状态码类别：</h4><p>类别    原因短语<br>1XX    Informational(信息性状态码)    接收的请求正在处理<br>2XX    Success(成功状态码)    请求正常处理完毕<br>3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求<br>4XX    Client Error(客户端错误状态码)    服务器无法处理请求<br>5XX    Server Error(服务器错误状态码)    服务器处理请求出错</p>
<a id="more"></a>
<h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h5><ul>
<li>200 OK：表示客户端的请求被服务器成功处理</li>
<li><p>204 No Content：该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</p>
</li>
<li><p>206 Partial Content：该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h5><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<ul>
<li><p>301 Moved Permanently:永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</p>
</li>
<li><p>302 Found:临时性重定向：该状态码表示请求的资源已被分配了新的URI，希望用户本次请求能使用新的URI。302和301很相似，302表示的URI并不是永久性移动，换句话说就是URI还有可能发生变化。</p>
</li>
<li><p>303 See Other：该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。303和302有着相似的功能，他们之间的区别是303状态码表示明确客户端采用GET请求获取资源</p>
</li>
<li><p>304 Not Modified  </p>
</li>
</ul>
<h5 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h5><p>4XX响应结果表示错误发生在客户端</p>
<ul>
<li><p>400 Bad Request:该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。</p>
</li>
<li><p>403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。</p>
</li>
<li><p>404 Not Found：该状态码表明服务器上无法找到请求的资源。</p>
</li>
</ul>
<h5 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h5><p>5XX 的响应结果表明服务器本身发生错误。</p>
<ul>
<li><p>500 Internal Server Error:该状态码表明服务器端在执行请求时发生了错误。</p>
</li>
<li><p>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。</p>
</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;状态码类别：&quot;&gt;&lt;a href=&quot;#状态码类别：&quot; class=&quot;headerlink&quot; title=&quot;状态码类别：&quot;&gt;&lt;/a&gt;状态码类别：&lt;/h4&gt;&lt;p&gt;类别    原因短语&lt;br&gt;1XX    Informational(信息性状态码)    接收的请求正在处理&lt;br&gt;2XX    Success(成功状态码)    请求正常处理完毕&lt;br&gt;3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求&lt;br&gt;4XX    Client Error(客户端错误状态码)    服务器无法处理请求&lt;br&gt;5XX    Server Error(服务器错误状态码)    服务器处理请求出错&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#HTTP" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    
  </entry>
  
</feed>
