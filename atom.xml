<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Desperado</title>
  <subtitle>Do one thing every day that scares you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cristianoro7.github.io/"/>
  <updated>2017-12-01T10:59:55.283Z</updated>
  <id>http://cristianoro7.github.io/</id>
  
  <author>
    <name>Desperado</name>
    <email>424494431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java知识体系</title>
    <link href="http://cristianoro7.github.io/2017/12/01/Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    <id>http://cristianoro7.github.io/2017/12/01/Java知识体系/</id>
    <published>2017-12-01T10:59:55.283Z</published>
    <updated>2017-12-01T10:59:55.283Z</updated>
    
    <content type="html"><![CDATA[<p>总结自己的编程知识体系. 该体系动态更新.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm1geo0sukj30mw120go2.jpg" alt=""></p>
<blockquote>
<h3 id="抽象和接口"><a href="#抽象和接口" class="headerlink" title="抽象和接口"></a>抽象和接口</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3></blockquote>
<p>未启动</p>
<blockquote>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3></blockquote>
<p>注解主要分为两个部分:</p>
<ul>
<li><p>内置注解: <code>Java</code>提供给我们的三个内置注解</p>
</li>
<li><p>自定义注解: 这个包括元注解和注解元素支持的类型</p>
</li>
<li><p>注解处理器: 开发一个处理器分为两个步骤: 1. 继承<code>AbstractProcessor</code>并重写其中的4个方法. 2. 注册注解处理器.</p>
</li>
</ul>
<p>详情:</p>
<ul>
<li><p><a href="https://cristianoro7.github.io/2017/11/22/Java%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">java注解基础</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/11/30/Java%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/">Java注解处理器实战</a></p>
</li>
</ul>
<blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3></blockquote>
<p>反射也是分为两部分:</p>
<ul>
<li><p>基础: 主要描述如何在运行时, 检查一个类的元素. 这些元素可以是: <code>Class</code>对象, <code>Method</code>对象等.</p>
</li>
<li><p>应用: 反射的一个强大用法: 动态代理和运行时处理注解(这个在PC端用得比较多.). 反射的缺点: 破坏性强. 比如: 破坏单例或者是绕开编译时的泛型类型限定.</p>
</li>
</ul>
<p>详情:</p>
<ul>
<li><p><a href="https://cristianoro7.github.io/2017/11/24/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/">Java反射基础</a></p>
</li>
<li><p><a href="https://cristianoro7.github.io/2017/11/25/Java%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8/">Java反射的运用</a></p>
</li>
</ul>
<blockquote>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3></blockquote>
<p>编写中…</p>
<blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3></blockquote>
<p>未启动…</p>
<blockquote>
<h3 id="IO系统"><a href="#IO系统" class="headerlink" title="IO系统"></a>IO系统</h3></blockquote>
<p>未完成…</p>
<blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3></blockquote>
<p>差不多完成…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结自己的编程知识体系. 该体系动态更新.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fm1geo0sukj30mw120go2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=
    
    </summary>
    
      <category term="知识体系" scheme="http://cristianoro7.github.io/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    
      <category term="知识体系#Java" scheme="http://cristianoro7.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java注解处理器实战</title>
    <link href="http://cristianoro7.github.io/2017/11/30/Java%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cristianoro7.github.io/2017/11/30/Java注解处理器详解/</id>
    <published>2017-11-30T11:42:21.159Z</published>
    <updated>2017-11-30T11:42:21.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm0c4an974j30m80b4qhy.jpg" alt=""></p>
<blockquote>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3></blockquote>
<p>注解强大的地方在于: 我们可以在运行时或者编译时处理注解. 在编译时或者运行时处理注解的机制都可以称为一个注解处理器.</p>
<blockquote>
<h3 id="注解处理器的类型"><a href="#注解处理器的类型" class="headerlink" title="注解处理器的类型"></a>注解处理器的类型</h3></blockquote>
<p>注解处理器的类型分为两大类:</p>
<ul>
<li><p>运行时处理器: 这种机制是在程序运行时利用<code>反射</code>机制去处理注解.</p>
</li>
<li><p>编译时处理器: 这种机制是在程序编译时利用<code>javac</code>提供的一个<code>apt</code>工具来处理注解.</p>
</li>
</ul>
<p>运行时处理器的特点: 该机制基于反射机制, 因此灵活性很大, 但是却相对耗性能. 编译时处理器的特点:这种方法是在编译时处理注解, 因此不存在性能的问题, 但是灵活性也相对比较低.</p>
<p>在已有的开源库实现中, 普遍是结合<code>编译时处理器</code>和<code>反射机制</code>这两种方法. 举个例子: <code>ButterKnife</code>. 它是一个<code>View</code>注入的库. 内部实现的原理: 编译时利用<code>apt</code>生成<code>findViewById</code>等一些列模板代码, 然后在运行时利用反射去实例生成的模板代码类, 这样完成了一次注入. 从这里可以看出, <code>ButterKnife</code>并没有完全基于编译时注解处理器. 而是加了反射.</p>
<p>这样做的好处: 开发者不需要手动实例<code>apt</code>生成的类. 换句话说: 开发者不需要了解生成类的命令规则. 也许你可能会觉得利用反射会耗性能. 但是仔细想想, 如果没有利用反射的话, 开发者都需要手动编译, 然后再实例化生成的类. 这个过程也是挺繁琐的. 而且, 库内部是有做相应的缓存的, 所以耗的性能还是相对比较低的.</p>
<p>对于反射的利用, 应该适当使用, 而不是避而不用或者滥用.</p>
<p>接下来, 讲讲<code>APT</code>的一些知识, 最后再仿写一个简单的<code>ButterKnife</code>作为实战.</p>
<blockquote>
<h3 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h3></blockquote>
<p>开发注解处理器的第一个步骤就是继承<code>AbstractProcessor</code>. 然后重写其四个方法:</p>
<ul>
<li><p><code>public synchronized void init(ProcessingEnvironment processingEnvironment)</code>: 这个方法一般是做一些初始化的工作.</p>
</li>
<li><p><code>public SourceVersion getSupportedSourceVersion()</code>: 该处理器所支持的<code>JDK</code>版本, 一般是支持到最新: <code>SourceVersion.latestSupported()</code>.</p>
</li>
<li><p><code>public Set&lt;String&gt; getSupportedAnnotationTypes()</code>: 你所要处理的注解的类型.</p>
</li>
<li><p><code>public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</code>: 处理注解的方法. 这个是我们主要实现的方法. 返回值表示当前这个注解类型是否需要被随后的注解处理器处理. <code>true</code>表示不需要, <code>false</code>表示后面的注解处理器可能会对本次处理的注解.</p>
</li>
</ul>
<p>认识这4个方法后, 我们还需要熟悉一下编写处理器涉及到的一些概念和<code>API</code>.</p>
<h4 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h4><p><code>ProcessingEnvironment</code>是在<code>init</code>方法传入的. 它表示<code>APT</code>框架的一个处理时上下文. 这个类主要是提供一些工具类. 详细看下面代码注释:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessingEnvironment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//获取外部配置的参数</span></div><div class="line">    <span class="function">Map&lt;String,String&gt; <span class="title">getOptions</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Messager对象, 用于打印一些日志</span></div><div class="line">    <span class="function">Messager <span class="title">getMessager</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Filer对象, 该对象用于创建文件</span></div><div class="line">    <span class="function">Filer <span class="title">getFiler</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Elements, 它包含处理Element的一些工具方法</span></div><div class="line">    <span class="function">Elements <span class="title">getElementUtils</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取Types, 它包含处理TypeMirror的一些工具方法</span></div><div class="line">    <span class="function">Types <span class="title">getTypeUtils</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">SourceVersion <span class="title">getSourceVersion</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="RoundEnvironment"><a href="#RoundEnvironment" class="headerlink" title="RoundEnvironment"></a>RoundEnvironment</h4><p>当<code>APT</code>启动时, 它将会扫描源文件, 然后进入<code>process</code>方法处理, 如果这个过程生成了新的文件的话, 新文件会被<code>APT</code>再次作为输入, 接着<code>process</code>会被<code>apt</code>再次调用, 如此循环下去, 直到没有新的文件产生. <code>RoundEnvironment</code>为处理轮次的上下文环境. 下面是<code>RoundEnvironment</code>的方法简单介绍:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoundEnvironment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//用于判断是否处理完了, 只有当没有新文件生成时, 证明已经处理完了, 才会返回true</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">processingOver</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//上一次处理是否存在错误</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">errorRaised</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取前一次处理的根元素集合</span></div><div class="line">    Set&lt;? extends Element&gt; getRootElements();</div><div class="line"></div><div class="line">    <span class="comment">//获取被指定的类型元素标注的元素集</span></div><div class="line">    Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a);</div><div class="line"></div><div class="line">    <span class="comment">//获取被指定的注解标注的元素集</span></div><div class="line">    Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><p><code>Element</code>代表<code>Java</code>静态语言结构的元素. 这样听起来可能有点难以理解, 不过看下面的例子就会很好理解了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.desperado.processors; <span class="comment">//PackageElement</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; <span class="comment">//TypeElement: 代表类或接口元素</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> xixi; <span class="comment">//VariableElement:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; <span class="comment">//ExecutableElement</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">(String arg)</span> </span>&#123; <span class="comment">//haha方法为TExecutableElement</span></div><div class="line">        <span class="keyword">int</span> v; <span class="comment">//VariableElement</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>TypeElement</code>: 代表类或接口元素</p>
</li>
<li><p><code>VariableElement</code>: 代表字段, 枚举常量, 方法或构造函数的参数, 局部变量, 资源变量和异常参数.</p>
</li>
<li><p><code>PackageElement</code>: 代表包元素</p>
</li>
<li><p><code>ExecutableElement</code>: 代表的方法, 构造方法,和接口或者类的初始化块.</p>
</li>
</ul>
<h4 id="DeclaredType-TypeElement和TypeMirror"><a href="#DeclaredType-TypeElement和TypeMirror" class="headerlink" title="DeclaredType, TypeElement和TypeMirror"></a>DeclaredType, TypeElement和TypeMirror</h4><p><code>TypeElement</code>表示类或接口元素, 可以从中获取类名, 但是不能获得类本身的信息, 比如父类.</p>
<p><code>TypeMirror</code>: 表示<code>Java</code>语言中的类型, 其中包括: 基本类型, 声明类型(类类型和接口类型), 数组类型, 类型变量和空类型. 也代表通配类型参数，可执行文件的签名和返回类型.</p>
<p><code>DeclaredType</code>: 代表声明的类型, 类类型还是接口类型，当然也包括参数化类型，比如Set<string>，也包括原始类型.</string></p>
<blockquote>
<h3 id="开发一个注解处理器"><a href="#开发一个注解处理器" class="headerlink" title="开发一个注解处理器"></a>开发一个注解处理器</h3></blockquote>
<p>掌握了上面的概念后, 我们开始来开发一个仿<code>ButterKnife</code>的注解处理器.</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li><p>继承<code>AbstractProcessor</code>并重写其中的四个方法.</p>
</li>
<li><p>注册注解处理器.</p>
</li>
</ul>
<h5 id="继承AbstractProcessor"><a href="#继承AbstractProcessor" class="headerlink" title="继承AbstractProcessor"></a>继承<code>AbstractProcessor</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Types types;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Filer filer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messager messager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Elements elements;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(processingEnvironment);</div><div class="line">        types = processingEnvironment.getTypeUtils();</div><div class="line">        filer = processingEnvironment.getFiler();</div><div class="line">        messager = processingEnvironment.getMessager();</div><div class="line">        elements = processingEnvironment.getElementUtils();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line">        <span class="comment">//process</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">        annotations.add(BindView.class.getCanonicalName());</div><div class="line">        <span class="keyword">return</span> annotations;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>getSupportedAnnotationTypes()</code>中, 我们直接返回了需要处理的注解的全限定名称集合.</p>
<h5 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h5><p>写好的处理器还需要处理告诉<code>Javac</code>, 让它编译时运行我们的处理器. 注册的步骤为: 在项目新建一个<code>resources</code>目录, 然后在<code>resources</code>内新建这样的目录结构: <code>/META-INF/services/</code>. 最后在<code>services</code>中新建文件: <code>javax.annotation.processing.Processor</code>. 并且在文件上填写你的处理器的全路径名称. 例如: <code>com.desperado.processors.ViewBindingProcessor</code>.</p>
<p>其实还有一种更为简单的方法. 添加<code>com.google.auto.service:auto-service:1.0-rc2</code>这个库(Google开源的). 然后在你的处理器上添加注解: <code>@AutoService(Processor.class)</code>. 这样, 编译时就会自动帮我们生成注册文件.</p>
<blockquote>
<h4 id="如何组织处理器结构"><a href="#如何组织处理器结构" class="headerlink" title="如何组织处理器结构"></a>如何组织处理器结构</h4></blockquote>
<p>为了不将注解处理器的代码打包进<code>APK</code>. 我们需要将注解和注解处理器分开. 具体的组织如下:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fm07qpsw5qj30cw047aa1.jpg" alt=""></p>
<ul>
<li><p><code>annotations</code>: <code>annotations</code>是一个<code>java lib</code>. 是我们自定义的注解</p>
</li>
<li><p><code>processors</code>: <code>processors</code>也是一个<code>java lib</code>. 是我们的注解处理器</p>
</li>
<li><p><code>viewbinding</code>: 为提供为<code>app</code>的api.</p>
</li>
</ul>
<blockquote>
<h4 id="annotations"><a href="#annotations" class="headerlink" title="annotations"></a>annotations</h4></blockquote>
<p>首先我们在<code>annotation</code>模块定义一个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="processors"><a href="#processors" class="headerlink" title="processors"></a>processors</h4></blockquote>
<p>在讲处理器模块前, 我们先看看期望生成的代码模板:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>$<span class="title">ViewBinding</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> MainActivity$ViewBinding(MainActivity activity, View view) &#123;</div><div class="line">    <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    activity.mTvTextView = view.findViewById(<span class="number">2131165249</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的代码的类名为: XXXX$ViewBinding</p>
<p>然后在构造函数中对传入的<code>activity</code>中的<code>View</code>进行赋值.</p>
<h5 id="定义处理规则"><a href="#定义处理规则" class="headerlink" title="定义处理规则."></a>定义处理规则.</h5><ul>
<li><p><code>BindView</code>只能标注字段.</p>
</li>
<li><p><code>BindView</code>不能标注接口中的字段, 只能标注类中的字段.</p>
</li>
<li><p><code>BindView</code>不能标注抽象类中的字段.</p>
</li>
<li><p><code>BindView</code>不能标注被<code>private</code>, <code>static</code>或者<code>final</code>修饰的字段</p>
</li>
<li><p><code>BindView</code>标注字段所属的类必须是<code>Activity</code>的子类.</p>
</li>
<li><p><code>BindView</code>标注的字段必须是<code>View</code>的子类</p>
</li>
</ul>
<p>定义好这些规则后, 我们就可以来看处理器的代码了.</p>
<h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Types types;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Filer filer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messager messager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Elements elements;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, ViewClass&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_ACTIVITY = <span class="string">"android.app.Activity"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_VIEW = <span class="string">"android.view.View"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(processingEnvironment);</div><div class="line">        types = processingEnvironment.getTypeUtils();</div><div class="line">        filer = processingEnvironment.getFiler();</div><div class="line">        messager = processingEnvironment.getMessager();</div><div class="line">        elements = processingEnvironment.getElementUtils();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line">        map.clear(); <span class="comment">//该方法会被调用多次, 所以每次进入时, 首先清空之前的脏数据</span></div><div class="line">        logNote(<span class="string">"start process"</span>);</div><div class="line">        <span class="keyword">for</span> (Element e : roundEnvironment.getElementsAnnotatedWith(BindView.class)) &#123;</div><div class="line">            <span class="keyword">if</span> (!isValid(e)) &#123; <span class="comment">//首先判断被标注的元素是否符合我们上面定的规则</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//出现错误, 停止编译</span></div><div class="line">            &#125;</div><div class="line">            logNote(<span class="string">"start parse annotations"</span>);</div><div class="line">            performParseAnnotations(e); <span class="comment">//开始解析注解</span></div><div class="line">        &#125;</div><div class="line">        logNote(<span class="string">"start generate code"</span>);</div><div class="line">        generateCode(); <span class="comment">//生成代码</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Element element)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> VariableElement)) &#123;</div><div class="line">            logError(<span class="string">"BindView只能标注字段"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        VariableElement variableElement = (VariableElement) element;</div><div class="line">        TypeElement typeElement = (TypeElement) variableElement.getEnclosingElement();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (typeElement.getKind() != ElementKind.CLASS) &#123;</div><div class="line">            logError(<span class="string">"只能标注类中的字段"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (typeElement.getModifiers().contains(Modifier.ABSTRACT)) &#123;</div><div class="line">            logError(<span class="string">"不能标注抽象类中的字段"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Modifier modifier : element.getModifiers()) &#123;</div><div class="line">            <span class="keyword">if</span> (modifier == Modifier.PRIVATE || modifier == Modifier.STATIC ||</div><div class="line">                    modifier == Modifier.FINAL) &#123;</div><div class="line">                logError(<span class="string">"BindView不能标注被static,"</span> +</div><div class="line">                        <span class="string">"private或者final的字段"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isSubtype(typeElement.asType(), TYPE_ACTIVITY)) &#123; <span class="comment">//判断被标注的字段的类是不是Activity的子类</span></div><div class="line">            logError(typeElement.getSimpleName() + <span class="string">"必须是 Activity的子类"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!isSubtype(variableElement.asType(), TYPE_VIEW)) &#123; <span class="comment">//判断被标注的字段是不是View的子类</span></div><div class="line">            logError(<span class="string">"BindView只能标注View的子类"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtype</span><span class="params">(TypeMirror tm, String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isSubType = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span> (tm != <span class="keyword">null</span>) &#123; <span class="comment">//循环获取父类信息</span></div><div class="line">            <span class="keyword">if</span> (type.equals(tm.toString())) &#123; <span class="comment">//通过全路径是否相等</span></div><div class="line">                isSubType = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            TypeElement superTypeElem = (TypeElement) types.asElement(tm);</div><div class="line">            <span class="keyword">if</span> (superTypeElem != <span class="keyword">null</span>) &#123;</div><div class="line">                tm = superTypeElem.getSuperclass();</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果为空, 说明没了父类, 所以直接退出</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> isSubType;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performParseAnnotations</span><span class="params">(Element element)</span> </span>&#123;</div><div class="line"></div><div class="line">        VariableElement variableElement = (VariableElement) element;</div><div class="line">        TypeElement typeElement = (TypeElement) variableElement.getEnclosingElement();</div><div class="line"></div><div class="line">        String className = typeElement.getSimpleName().toString();</div><div class="line"></div><div class="line">        ViewClass viewClass = map.get(className);</div><div class="line">        ViewField field = <span class="keyword">new</span> ViewField(variableElement);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (viewClass == <span class="keyword">null</span>) &#123;</div><div class="line">            viewClass = <span class="keyword">new</span> ViewClass(elements.getPackageOf(variableElement).getQualifiedName().toString(),</div><div class="line">                    className, typeElement);</div><div class="line">            map.put(className, viewClass);</div><div class="line">        &#125;</div><div class="line">        viewClass.addField(field);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (ViewClass vc : map.values()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                vc.generateCode().writeTo(filer);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                logError(<span class="string">"error in parse"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">        annotations.add(BindView.class.getCanonicalName());</div><div class="line">        <span class="keyword">return</span> annotations;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        log(Diagnostic.Kind.ERROR, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logNote</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        log(Diagnostic.Kind.NOTE, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Diagnostic.Kind kind, String msg)</span> </span>&#123;</div><div class="line">        messager.printMessage(kind, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了使代码结构更为清晰, 这里将注解标注的字段的信息抽象为<code>ViewField</code>类, 字段所属的类的信息抽象为<code>ViewClass</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewField</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String fieldName;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewField</span><span class="params">(VariableElement variableElement)</span> </span>&#123;</div><div class="line">        id = variableElement.getAnnotation(BindView.class).value();</div><div class="line">        fieldName = variableElement.getSimpleName().toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFieldName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> fieldName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String packName;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String className;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;ViewField&gt; fields = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TypeElement typeElement;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewClass</span><span class="params">(String packName, String className, TypeElement typeElement)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.packName = packName;</div><div class="line">        <span class="keyword">this</span>.className = className;</div><div class="line">        <span class="keyword">this</span>.typeElement = typeElement;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addField</span><span class="params">(ViewField viewField)</span> </span>&#123;</div><div class="line">        fields.add(viewField);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> JavaFile <span class="title">generateCode</span><span class="params">()</span> </span>&#123; <span class="comment">//为了方便, 这里生成代码用了JavaPoet库来生成代码</span></div><div class="line">        MethodSpec.Builder con = MethodSpec.constructorBuilder()</div><div class="line">                .addModifiers(Modifier.PUBLIC)</div><div class="line">                .addParameter(TypeName.get(typeElement.asType()), <span class="string">"activity"</span>)</div><div class="line">                .addParameter(ClassName.get(<span class="string">"android.view"</span>, <span class="string">"View"</span>), <span class="string">"view"</span>)</div><div class="line">                .beginControlFlow(<span class="string">"if (activity == null)"</span>)</div><div class="line">                .addStatement(<span class="string">"return"</span>)</div><div class="line">                .endControlFlow();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (ViewField f : fields) &#123;</div><div class="line">            con.addStatement(<span class="string">"activity.$N = view.findViewById($L)"</span>, f.getFieldName(), f.getId());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        FieldSpec.Builder fid = FieldSpec.builder(TypeName.get(typeElement.asType()), <span class="string">"activity"</span>);</div><div class="line">        TypeSpec typeSpec = TypeSpec.classBuilder(className + <span class="string">"$ViewBinding"</span>)</div><div class="line">                .addModifiers(Modifier.PUBLIC)</div><div class="line">                .addField(fid.build())</div><div class="line">                .addMethod(con.build())</div><div class="line">                .build();</div><div class="line">        <span class="keyword">return</span> JavaFile.builder(packName, typeSpec).build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理过程其实并不复杂, 只是需要我们熟悉<code>API</code>而已, 因此, 接下来总结一下获取一些常用信息的方法:</p>
<h5 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Types types;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Filer filer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messager messager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Elements elements;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_ACTIVITY = <span class="string">"android.app.Activity"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_VIEW = <span class="string">"android.view.View"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(processingEnvironment);</div><div class="line">        types = processingEnvironment.getTypeUtils();</div><div class="line">        filer = processingEnvironment.getFiler();</div><div class="line">        messager = processingEnvironment.getMessager();</div><div class="line">        elements = processingEnvironment.getElementUtils();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Element e : roundEnvironment.getElementsAnnotatedWith(BindView.class)) &#123;</div><div class="line">            String packName = elements.getPackageOf(e).getQualifiedName().toString(); <span class="comment">//获取包名</span></div><div class="line"></div><div class="line">            <span class="comment">//2: 获取类名.</span></div><div class="line">            <span class="comment">//如果标注的是类的话</span></div><div class="line">            TypeElement t = (TypeElement)e;</div><div class="line">            String className = t.getSimpleName().toString();</div><div class="line"></div><div class="line">            <span class="comment">//如果被标注的是字段或者是方法</span></div><div class="line">            TypeElement t = (TypeElement)e.getEnclosingElement();</div><div class="line">            String className = t.getSimpleName().toString();</div><div class="line"></div><div class="line">            <span class="comment">//3. 获取方法名字, 或者字段名字</span></div><div class="line">            String name = e.getSimpleName().toString();</div><div class="line"></div><div class="line">            <span class="comment">//4: 获取标注的注解</span></div><div class="line">            BindView annotation = e.getAnnotation(BindView.class);</div><div class="line">            <span class="keyword">int</span> id = annotation.value();</div><div class="line"></div><div class="line">            <span class="comment">//5: 判断被标注的元素类型, 以字段类型为例子</span></div><div class="line">            ElementKind kind = e.getKind();</div><div class="line">            <span class="keyword">if</span> (kind == ElementKind.FIELD) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//6: 获取元素的修饰符. 我们以被修饰的字段为例子.</span></div><div class="line">            <span class="keyword">for</span> (Modifier modifier : e.getModifiers()) &#123;</div><div class="line">                <span class="keyword">if</span> (modifier == Modifier.PRIVATE || modifier == Modifier.STATIC ||</div><div class="line">                modifier == Modifier.FINAL) &#123;</div><div class="line">                  logError(<span class="string">"BindView不能标注被static,"</span> +</div><div class="line">                    <span class="string">"private或者final的字段"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//7: 判读被标注的元素的是不是某个类的子类, 以View类为例子, 判读被修饰的字段是否是View的子类</span></div><div class="line">            TypeMirror tm = e.asType();</div><div class="line">            <span class="keyword">boolean</span> isSubType = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">while</span> (tm != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="string">"android.view.View"</span>.equals(tm.toString())) &#123;</div><div class="line">                    isSubType = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                TypeElement t = (TypeElement)types.asElement(tm);</div><div class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">                    tm = t.getSuperclass(); <span class="comment">//获取父类信息</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果为空, 说明没了父类, 所以直接退出</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="viewbinding"><a href="#viewbinding" class="headerlink" title="viewbinding"></a>viewbinding</h4></blockquote>
<p>模板代码已经生成了, 但是我们还需要实例化这些类. 这个工作交由<code>viewbinding</code>. 它提供一些绑定的<code>API</code>给<code>app</code>. 这样我们就不需要手动调用了.</p>
<p>实现的思路: 运行时利用反射去实例化对应的模板类. 为了降低反射的消耗, 内部会做响应的缓存操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBinding</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String LATTER_NAME = <span class="string">"$ViewBinding"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Constructor&lt;?&gt;&gt; CACHE = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Activity&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(T target)</span> </span>&#123;</div><div class="line">        View sourceView = target.getWindow().getDecorView();</div><div class="line">        bind(target, sourceView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(T target, View sourceView)</span> </span>&#123;</div><div class="line">        Class&lt;? extends Activity&gt; cl = target.getClass();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; bindClass = findBindClass(cl);</div><div class="line">            Constructor&lt;?&gt; constructor = findBindConstructor(bindClass, cl);</div><div class="line">            constructor.newInstance(target, sourceView);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; findBindClass(Class&lt;?&gt; targetClass) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        <span class="keyword">return</span> targetClass.getClassLoader().loadClass(targetClass.getName() + LATTER_NAME);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;?&gt; findBindConstructor(Class&lt;?&gt; bindClass, Class&lt;? extends Activity&gt; targetClass) <span class="keyword">throws</span> NoSuchMethodException &#123;</div><div class="line">        Constructor&lt;?&gt; constructor = CACHE.get(bindClass);</div><div class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</div><div class="line">            constructor = bindClass.getConstructor(targetClass, View.class);</div><div class="line">            CACHE.put(bindClass, constructor);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> constructor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4></blockquote>
<p>注解处理器现在算是开发好了. 最后的步骤就是在<code>app</code>中添加依赖, 然后实现绑定.</p>
<p>在<code>app</code>的<code>build.gradle</code>添加下面的依赖:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">implementation <span class="title">project</span><span class="params">(<span class="string">':viewbinding'</span>)</span></span></div><div class="line">implementation <span class="title">project</span><span class="params">(<span class="string">':annotations'</span>)</span></div><div class="line">annotationProcessor <span class="title">project</span><span class="params">(<span class="string">':processors'</span>)</span></div></pre></td></tr></table></figure>
<p>然后在<code>MainActivity</code>中实现注入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.main_tv_hello)</div><div class="line">    TextView mTvTextView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        ViewBinding.bind(<span class="keyword">this</span>);</div><div class="line">        mTvTextView.setText(<span class="string">"xuixi"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完…</p>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></blockquote>
<p><a href="http://jinchim.com/2017/08/23/JBind/" target="_blank" rel="external">http://jinchim.com/2017/08/23/JBind/</a></p>
<p><a href="http://blog.csdn.net/dd864140130/article/details/53875814" target="_blank" rel="external">http://blog.csdn.net/dd864140130/article/details/53875814</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fm0c4an974j30m80b4qhy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;注解处理器&quot;&gt;&lt;a href=&quot;#注解处理器&quot; clas
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java反射的应用</title>
    <link href="http://cristianoro7.github.io/2017/11/25/Java%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8/"/>
    <id>http://cristianoro7.github.io/2017/11/25/Java反射应用/</id>
    <published>2017-11-25T09:49:50.475Z</published>
    <updated>2017-11-25T09:49:50.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fluguov7y5j30m80b4wux.jpg" alt=""></p>
<blockquote>
<h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3></blockquote>
<p>代理模式是在不改变被代理类的代码的情况下, 对被代理的方法进行扩展, 这些扩展可以是打印日志, 控制访问等.</p>
<p>代理模式又分为静态代理和动态代理. 静态代理是指代理类在编译时, 就能够生成字节码被<code>JVM</code>识别. 而动态代理则是在运行时, 运用反射生成代理类字节码,最后被<code>JVM</code>识别.</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理比较简单, 下面给出一个例子, 然后分析它的缺点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"I am XiaoMing, I`am going to school!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMingProxy</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Student student;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoMingProxy</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.student = student;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"goodbye mom!"</span>);</div><div class="line">        student.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        XiaoMingProxy proxy = <span class="keyword">new</span> XiaoMingProxy(<span class="keyword">new</span> XiaoMing());</div><div class="line">        proxy.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>XiaoMingProxy</code>代理对象<code>XiaoMing</code>, 在他去上学之前打印日志.</p>
<p>上面就是一个简单的静态代理. 静态代理, 有一个很明显的缺点: 必须我们自己手动写代理类, 并且<code>代理类的复用性不强</code>. <code>代理类复用性不强</code>指的是: 本来打印日志这个功能是通用的, 但是静态代理的代理类不能被其他类复用. 比如现在我们添加一个教师类, 我们也要给她添加一个打印日志的功能, 那么我们必须重新写代理类, 不能复用之前的代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Teacher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungTeacher</span> <span class="keyword">implements</span> <span class="title">Teacher</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"go to school!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherProxy</span> <span class="keyword">implements</span> <span class="title">Teacher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Teacher teacher;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TeacherProxy</span><span class="params">(Teacher teacher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.teacher = teacher;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"goodbye mon!"</span>);</div><div class="line">        teacher.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原本一样的逻辑, 我们却得再次写代理类.</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理可以解决静态代理的缺点.  它的原理是: 在运行时, 运用反射自动帮你生成实现了接口的代理类, 并且将扩展方法的逻辑都分发到了一个<code>InvocationHandler</code>中的<code>invoke</code>方法. 这样就能实例代理方法的复用. 下面我们运用动态代理来解决之前静态代理出现的问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(Object tar)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = tar;</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(tar.getClass().getClassLoader(),</div><div class="line">                tar.getClass().getInterfaces(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"goodbye mom!"</span>);</div><div class="line">        <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LoggerHandler handler = <span class="keyword">new</span> LoggerHandler();</div><div class="line"></div><div class="line">        Student student = handler.bind(<span class="keyword">new</span> XiaoMing());</div><div class="line">        student.goToSchool();</div><div class="line"></div><div class="line">        Teacher teacher = handler.bind(<span class="keyword">new</span> YoungTeacher());</div><div class="line">        teacher.goToSchool();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是一个动态代理的例子, 我们将打印日志的功能放在<code>LoggerHandler</code>中, 这样其他的代理类就可以通过复用这个<code>LoggerHandler</code>来复用打印日志的功能.</p>
<h4 id="动态代理原理解析"><a href="#动态代理原理解析" class="headerlink" title="动态代理原理解析"></a>动态代理原理解析</h4><p>动态代理之所以能克服静态代理的缺点, 主要是: 它是在运行时通过反射创建代理类(这个代理类实现了我们被代理类的接口), 然后返回这个代理类的引用, 每个代理类都会绑定一个<code>InvocationHandler</code>的实例. 接着每次对这个代理类的方法调用, 都会被分发到<code>InvocationHandler</code>中的<code>invoke</code>方法来统一处理. 因此<code>InvocationHandler</code>常常是我们写扩展逻辑的地方. 在<code>LoggerHandler</code>中, 它就是扩展了打印日志的功能. 这样不同被代理类如果需要扩展这个打印日志的功能的话, 就可以共享这个<code>LoggerHandler</code>来实现.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flubhp8380j30nx0bz3zp.jpg" alt=""></p>
<blockquote>
<h3 id="利用反射来获取注解"><a href="#利用反射来获取注解" class="headerlink" title="利用反射来获取注解"></a>利用反射来获取注解</h3></blockquote>
<p>反射另外一个应用是: 在运行时获取注解信息. 下面是利用反射实现的一个<code>View</code>的绑定.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.main_tv_hello_world)</div><div class="line">    <span class="keyword">private</span> TextView mTvextView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ViewInjection.inject(<span class="keyword">this</span>);</div><div class="line">        Log.d(TAG, <span class="string">"onCreate: "</span> + mTvextView.getText().toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewInjection</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> &lt;T extends Activity&gt;  <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(T activity)</span> </span>&#123;</div><div class="line">        Class activityClass = activity.getClass();</div><div class="line"></div><div class="line">        Field[] fields = activityClass.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">            BindView bindView = f.getAnnotation(BindView.class);</div><div class="line">            <span class="keyword">if</span> (bindView != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> id = bindView.value();</div><div class="line">                View view = activity.findViewById(id);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    f.setAccessible(<span class="keyword">true</span>);</div><div class="line">                    f.set(activity, view);</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3></blockquote>
<p>反射能够在运行时调用一个类的方法,或者访问其字段等, 包括被<code>private</code>修饰的字段或者方法, 这一定程度上说明了反射是具有一定的破坏性.</p>
<h4 id="利用反射绕开编译时的泛型限定"><a href="#利用反射绕开编译时的泛型限定" class="headerlink" title="利用反射绕开编译时的泛型限定"></a>利用反射绕开编译时的泛型限定</h4><p><code>Java</code>泛型是在编译期由编译器检查和实现的. 如果我们运用反射绕开编译期的泛型限定的话, 我们可以破坏泛型机制.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</div><div class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        strings.add(<span class="string">"xixi"</span>);</div><div class="line">        Method method = strings.getClass().getDeclaredMethod(<span class="string">"add"</span>, Object.class);</div><div class="line">        method.invoke(strings, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (String s : strings) &#123;</div><div class="line">            System.out.println(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>main</code>方法中, 我们在运行时, 利用反射给<code>strings</code>添加了一个<code>int</code>类型, 这样就绕开了泛型的限定. 所以当遍历<code>strings</code>时,会报异常.</p>
<h4 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="反射破坏单例"></a>反射破坏单例</h4><p>既然反射能够访问<code>private</code>字段和<code>private</code>方法, 那么我们就可以利用反射来破坏单例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</div><div class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        Singleton singleton = Singleton.getInstance();</div><div class="line">        System.out.println(singleton.hashCode());</div><div class="line"></div><div class="line">        Class c = Singleton.class;</div><div class="line">        Constructor constructor = c.getDeclaredConstructor(<span class="keyword">null</span>); <span class="comment">//获取Singleton的私有构造方法</span></div><div class="line">        constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Singleton newInstance = (Singleton) constructor.newInstance(<span class="keyword">null</span>); <span class="comment">//然后再实例化另一个</span></div><div class="line">        System.out.println(newInstance.hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行上面的代码, 最后打印出来的<code>HashCode</code>不一样, 说明单例被破坏了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fluguov7y5j30m80b4wux.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;什么是代理模式&quot;&gt;&lt;a href=&quot;#什么是代理模式&quot; 
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java反射基础</title>
    <link href="http://cristianoro7.github.io/2017/11/24/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://cristianoro7.github.io/2017/11/24/Java反射基础/</id>
    <published>2017-11-24T15:54:14.613Z</published>
    <updated>2017-11-24T15:54:14.613Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fltld849k4j30m80b47gy.jpg" alt=""></p>
<blockquote>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3></blockquote>
<p>在<code>Java</code>中, 每一个对象都对应有一个<code>Class</code>对象, 这个<code>Class</code>对象记录着对象的类型信息, 也就是类的内部结构.</p>
<p>我们知道, 我们编写的<code>.java</code>文件, 是需要被编译成<code>.class</code>文件, 然后才能被虚拟机加载执行. 正常情况下, <code>.class</code>是在编译期生成并且被<code>JVM</code>识别. 而反射机制则将<code>.class</code>文件的打开和检查推迟到运行时.</p>
<p>简单的说, 反射机制能让你在运行时操作一个类, 这些操作可以是: 实例化该类的对象, 调用对象方法和修改对象的属性值. 至于操作的类的<code>.class</code>文件可以是编译期未知.</p>
<blockquote>
<h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3></blockquote>
<p>一个类的元素可以被拆分为下面几个元素:</p>
<ul>
<li><p><code>Class</code>: 一个类对象</p>
</li>
<li><p><code>Constructor</code>: 构造器对象, 可以通过<code>Class</code>对象获得</p>
</li>
<li><p><code>Method</code>: 方法对象, 可以通过<code>Class</code>对象获得</p>
</li>
<li><p><code>Fields</code>: 字段对象, 可以通过<code>Class</code>对象获得</p>
</li>
<li><p><code>Annotation</code>: 注解对象, 可以通过<code>Class</code>对象获得</p>
</li>
</ul>
<p>从上面的元素可以看出, 我们如果要进行反射的话, 首先得获得类的<code>Class</code>对象, 进而才可以操作类的字段, 方法和构造器等.</p>
<blockquote>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3></blockquote>
<p>要进行反射, 我们首先要获得需要反射的类的<code>Class</code>对象. 而获取的方法有下面三种:</p>
<ul>
<li><p><code>Class class2 = Class.forName(&quot;com.desperado.reflaction.Bean&quot;)</code>: 调用<code>Class</code>类的<code>forName(String)</code>方法, 参数为类的全限定符号. 如果运行时找不到该类的话, 会报<code>ClassNotFoundException</code>异常. 这种方法一般用于编译期不能获得<code>.class</code>文件的情形.</p>
</li>
<li><p><code>Class class1 = Bean.class</code>: 通过类字面量来获取<code>Class</code>对象.</p>
</li>
<li><p><code>Bean bean = new Bean(); Class class3 = bean.getClass();</code>: 通过对象来获取<code>Class</code>对象.</p>
</li>
</ul>
<blockquote>
<h3 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h3></blockquote>
<p>得到<code>Class</code>对象后, 我们可以利用这个<code>Class</code>对象来获取类的构造函数, 以此来创建实例.</p>
<p>获取构造方法的方法有:</p>
<ul>
<li><p><code>getConstructors()</code>: 获取所有被<code>public</code>修饰的构造方法.</p>
</li>
<li><p><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code>: 返回指定参数类型的构造方法, 并且构造方法是被<code>public</code>修饰的.</p>
</li>
<li><p><code>getDeclaredConstructors()</code>: 获取所有的构造方法, 与权限修饰符无关.</p>
</li>
<li><p><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>: 获取指定类型的构造方法, 与权限修饰符无关.</p>
</li>
</ul>
<blockquote>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class beanClass = Bean.class;</div><div class="line">Bean  b = (Bean) beanClass.newInstance();</div></pre></td></tr></table></figure>
<p><code>newInstance()</code>这个方法会调用类无参的构造函数, 如果类没有无参构造函数的话, 会报异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Human</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class&lt;?&gt; c = Human.class;</div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line">Human human = (Human) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">Constructor priCon = c.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</div><div class="line">priCon.setAccessible(<span class="keyword">true</span>);</div><div class="line">Human h = (Human) priCon.newInstance(<span class="string">"xiaohong"</span>, <span class="number">18</span>);</div></pre></td></tr></table></figure>
<p>利用<code>getConstructor</code>方法, 调用了<code>Human</code>中带有<code>String</code>参数的构造方法.<code>getDeclaredConstructor</code>可以获取私有构造方法.</p>
<blockquote>
<h3 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h3></blockquote>
<p>利用<code>Class</code>对象, 我们可以获得<code>Method</code>来调用Class的方法. 获得<code>Method</code>的方法有:</p>
<ul>
<li><p><code>getMethods()</code>: 获取所有被<code>public</code>修饰的方法, 包含父类和接口中的方法</p>
</li>
<li><p><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 获取指定<code>name</code>的<code>public</code>方法. 包含父类的方法.</p>
</li>
<li><p><code>getDeclaredMethods()</code>:  获取所有的方法, 包括<code>private</code>. 但是不包括父类的方法</p>
</li>
<li><p><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 获取指定的方法, 包括<code>private</code>. 但是不包括父类的方法.</p>
</li>
</ul>
<blockquote>
<h4 id="getMethods和getMethod"><a href="#getMethods和getMethod" class="headerlink" title="getMethods和getMethod"></a>getMethods和getMethod</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Human</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">humanPubMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"humanPubMethod"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">humanPriMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"humanPriMethod"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoHong</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"xiaohong"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoHong</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"priMethod"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException,</span></div><div class="line">              InstantiationException, NoSuchMethodException,InvocationTargetException &#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Method method = c.getMethod(<span class="string">"humanPubMethod"</span>, <span class="keyword">null</span>);</div><div class="line">    method.invoke(xiaoHong, <span class="keyword">null</span>); <span class="comment">//调用方法</span></div><div class="line"></div><div class="line">    Method[] methods = c.getMethods();</div><div class="line">    <span class="keyword">for</span> (Method m : methods) &#123; <span class="comment">//遍历方法</span></div><div class="line">        System.out.println(m.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="getDeclaredMethod和getDeclaredMethods"><a href="#getDeclaredMethod和getDeclaredMethods" class="headerlink" title="getDeclaredMethod和getDeclaredMethods"></a>getDeclaredMethod和getDeclaredMethods</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Method method = c.getDeclaredMethod(<span class="string">"priMethod"</span>, <span class="keyword">null</span>);</div><div class="line">    method.setAccessible(<span class="keyword">true</span>);</div><div class="line">    method.invoke(xiaoHong, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    Method[] methods = c.getDeclaredMethods();</div><div class="line">    <span class="keyword">for</span> (Method m : methods)&#123;</div><div class="line">        System.out.println(m.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="获取Fields"><a href="#获取Fields" class="headerlink" title="获取Fields"></a>获取Fields</h3></blockquote>
<p>利用<code>Class</code>对象, 我们同样可以获得类的字段, 并且可以<code>set</code>和<code>get</code>字段的值. 我们可以通过下面的方法获取<code>Field</code>对象</p>
<ul>
<li><p><code>getFields()</code>: 获取类的所有被<code>public</code>修饰的字段, 包括父类中的.</p>
</li>
<li><p><code>getField(String name)</code>: 获取类的指定被<code>public</code>修饰的字段, 包括父类中的.</p>
</li>
<li><p><code>getDeclaredFields()</code>: 获取类的所有字段, 包括被<code>private</code>修饰的字段. 但是不包括父类中的.</p>
</li>
<li><p><code>getDeclaredField(String name)</code>: 获取类的指定字段, 包括被<code>private</code>修饰的字段. 但是不包括父类中的.</p>
</li>
</ul>
<blockquote>
<h4 id="getFields和getField"><a href="#getFields和getField" class="headerlink" title="getFields和getField"></a>getFields和getField</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Field field = c.getField(<span class="string">"pubName"</span>);</div><div class="line">    String pubName = (String) field.get(xiaoHong);</div><div class="line">    System.out.println(pubName);</div><div class="line"></div><div class="line">    Field[] fields = c.getFields();</div><div class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">      System.out.println(f.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="getDeclaredFields和getDeclaredField"><a href="#getDeclaredFields和getDeclaredField" class="headerlink" title="getDeclaredFields和getDeclaredField"></a>getDeclaredFields和getDeclaredField</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    Field field = c.getDeclaredField(<span class="string">"name"</span>);</div><div class="line">    field.setAccessible(<span class="keyword">true</span>);</div><div class="line">    System.out.println(field.get(xiaoHong));</div><div class="line"></div><div class="line">    Field[] fields = c.getDeclaredFields();</div><div class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">      System.out.println(f.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="获得Annotation"><a href="#获得Annotation" class="headerlink" title="获得Annotation"></a>获得Annotation</h3></blockquote>
<p>由于注解可以用来标注类, 方法, 字段, 参数, 所以, <code>Annotation</code>可以通过这些来获取.下面以<code>Class</code>对象为例子. 可以通过下面两个方法获取:</p>
<ul>
<li><p><code>getAnnotation(Class&lt;A&gt; annotationClass)</code>: 获取类指定的注解</p>
</li>
<li><p><code>getAnnotations()</code>: 获取类标注的所有注解</p>
</li>
</ul>
<blockquote>
<h4 id="getAnnotations和getAnnotation-Class-annotationClass"><a href="#getAnnotations和getAnnotation-Class-annotationClass" class="headerlink" title="getAnnotations和getAnnotation(Class annotationClass)"></a>getAnnotations和getAnnotation(Class<a> annotationClass)</a></h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; c = XiaoHong.class;</div><div class="line">    Constructor constructor = c.getConstructor(String.class);</div><div class="line">    XiaoHong xiaoHong = (XiaoHong) constructor.newInstance(<span class="string">"xiaohong"</span>);</div><div class="line"></div><div class="line">    BindView bindView = c.getAnnotation(BindView.class);</div><div class="line">    <span class="keyword">if</span> (bindView != <span class="keyword">null</span>) &#123;</div><div class="line">        System.out.println(bindView.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Annotation[] annotations = c.getAnnotations();</div><div class="line">    <span class="keyword">for</span> (Annotation a : annotations) &#123;</div><div class="line">        <span class="keyword">if</span> (a.annotationType().equals(BindView.class)) &#123;</div><div class="line">            System.out.println(<span class="string">"equal"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="利用反射处理数组"><a href="#利用反射处理数组" class="headerlink" title="利用反射处理数组"></a>利用反射处理数组</h3></blockquote>
<p><code>Java</code>反射机制通过<code>java.lang.reflect.Array</code>这个类来处理数组。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] ints = (<span class="keyword">int</span>[]) Array.newInstance(<span class="keyword">int</span>.class, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>上面是一个创建数组的例子, <code>newInstance</code>方法的第一个参数为: 数组存放的类型, 第二个为数组的长度.</p>
<h4 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = Array.getInt(ints, <span class="number">0</span>);</div><div class="line">Array.setInt(ints,<span class="number">1</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>对于基本类型, <code>Array</code>中提供了<code>setXX</code>和<code>getXX</code>方法来访问数组, 对于普通对象, 可以调用<code>get</code>和<code>set</code>方法.</p>
<h4 id="数组Class对象"><a href="#数组Class对象" class="headerlink" title="数组Class对象"></a>数组Class对象</h4><p>对于获取数组的<code>Class</code>对象, 可以先实例化对于的数组, 再得到它的<code>Class</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class aClass = Class.forName(<span class="string">"com.desperado.reflaction.XiaoHong"</span>); <span class="comment">//先获得class对象</span></div><div class="line">Class classArray = Array.newInstance(aClass, <span class="number">0</span>).getClass(); <span class="comment">//再创建class对象数组, 最后获取数组class对象</span></div></pre></td></tr></table></figure>
<blockquote>
<h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3></blockquote>
<p>由于泛型会在编译期被擦除, 所以我们是不能在运行时获得泛型类的参数类型的. 但是我们却可以通过使用了参数类型的字段或者返回了带有类型参数的方法来获得一个泛型类的类型信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stringList = list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取方法返回值的参数类型"><a href="#获取方法返回值的参数类型" class="headerlink" title="获取方法返回值的参数类型"></a>获取方法返回值的参数类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Method method = TClass.class.getMethod(<span class="string">"getList"</span>, <span class="keyword">null</span>);</div><div class="line">Type type = method.getGenericReturnType();</div><div class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</div><div class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</div><div class="line">    Type[] ts = parameterizedType.getActualTypeArguments();</div><div class="line">    <span class="keyword">for</span> (Type t : ts) &#123;</div><div class="line">        Class c = (Class) t;</div><div class="line">        System.out.println(c.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取方法参数的参数类型"><a href="#获取方法参数的参数类型" class="headerlink" title="获取方法参数的参数类型"></a>获取方法参数的参数类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Field field = TClass.class.getDeclaredField(<span class="string">"stringList"</span>);</div><div class="line">Type t = field.getGenericType();</div><div class="line"><span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</div><div class="line">    ParameterizedType pt = (ParameterizedType) t;</div><div class="line">    Type[] types = pt.getActualTypeArguments();</div><div class="line">    <span class="keyword">for</span> (Type ty : types) &#123;</div><div class="line">        Class c = (Class) ty;</div><div class="line">        System.out.println(c.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取字段的参数类型"><a href="#获取字段的参数类型" class="headerlink" title="获取字段的参数类型"></a>获取字段的参数类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Method method = TClass.class.getMethod(<span class="string">"setList"</span>, List.class);</div><div class="line">Type[] type = method.getGenericParameterTypes();</div><div class="line"><span class="keyword">for</span> (Type parT : type) &#123;</div><div class="line">    <span class="keyword">if</span> (parT <span class="keyword">instanceof</span> ParameterizedType) &#123;</div><div class="line">        ParameterizedType parameterizedType = (ParameterizedType) parT;</div><div class="line">        Type[] types = parameterizedType.getActualTypeArguments();</div><div class="line">        <span class="keyword">for</span> (Type ty: types) &#123;</div><div class="line">            Class c = (Class) ty;</div><div class="line">            System.out.println(c.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3></blockquote>
<h3 id="Java核心编程思想"><a href="#Java核心编程思想" class="headerlink" title="Java核心编程思想"></a>Java核心编程思想</h3><h3 id="http-ifeve-com-java-reflection-9-generics"><a href="#http-ifeve-com-java-reflection-9-generics" class="headerlink" title="http://ifeve.com/java-reflection-9-generics/"></a><a href="http://ifeve.com/java-reflection-9-generics/" target="_blank" rel="external">http://ifeve.com/java-reflection-9-generics/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fltld849k4j30m80b47gy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;什么是反射&quot;&gt;&lt;a href=&quot;#什么是反射&quot; clas
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java注解基础</title>
    <link href="http://cristianoro7.github.io/2017/11/22/Java%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/"/>
    <id>http://cristianoro7.github.io/2017/11/22/Java注解基础/</id>
    <published>2017-11-22T12:34:53.714Z</published>
    <updated>2017-11-22T12:34:53.714Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flr4xe3496j30m80b47mn.jpg" alt=""></p>
<blockquote>
<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3></blockquote>
<p>注解是一种元数据, 它能够让我们在代码中添加信息, 使得我们可以在稍后的某个时刻非常方便地使用这些数据.</p>
<blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3></blockquote>
<ul>
<li><p>编译时生成一些配置文件或者部署文件</p>
</li>
<li><p>可以根据注解中的数据来生成模板代码, 从而减轻编写模板代码的负担</p>
</li>
</ul>
<blockquote>
<h3 id="Java内置的3个注解"><a href="#Java内置的3个注解" class="headerlink" title="Java内置的3个注解"></a>Java内置的3个注解</h3></blockquote>
<p><code>Java</code>内置了3个注解, 他们是:</p>
<ul>
<li><p><code>Override</code>: 表示当前方法定义将覆盖父类的方法. 如果你不小心拼写错误的话, 编译器会报警提示.</p>
</li>
<li><p><code>Deprecated</code>: 如果使用了被该注解标注的元素的话, 编译器会发出警告.</p>
</li>
<li><p><code>SuppressWarning</code>: 关闭编译器的报警提示.</p>
</li>
</ul>
<p>上面的3个注解是<code>Java</code>内置的注解, 主要是帮助编译器来检查和规范代码.</p>
<blockquote>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3></blockquote>
<p><code>Java</code>内置的注解一般是不满足我们平常开发的需求的, 因此我们需要自己自定义注解. 下面说说用于描述注解的<code>元注解</code>, 接着再谈谈注解元素支持的类型.</p>
<blockquote>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4></blockquote>
<p><code>元注解</code>是描述注解的注解, 他们负责定义创建的注解的一些信息:</p>
<ul>
<li><p><code>@Target</code>: 表示该注解是用于什么地方的, 可选的字段有:</p>
<ol>
<li><code>CONSTRUCTOR</code>: 用于注解构造器</li>
<li><code>FIELD</code>: 用于注解实例域</li>
<li><code>METHOD</code>: 用于注解方法</li>
<li><code>PACKAGE</code>: 用于注解包</li>
<li><code>PARAMETER</code>: 用于注解参数</li>
<li><code>TYPE</code>: 用于注解类, 接口(包括注解类型)或者枚举.</li>
</ol>
</li>
<li><p><code>@Retention</code>: 用于描述注解的声明周期, 或者说是需要在什么时候保留注解信息, 什么时候丢弃注解信息. 可选的字段有:</p>
<ol>
<li><code>SOURCE</code>: 注解在源文件内有效, 但是会被编译器丢弃.</li>
<li><code>CLASS</code>: 注解在<code>.class</code>文件内有效, 但是会被<code>VM</code>丢弃.</li>
<li><code>RUNTIME</code>: 注解在运行时有效, 因此可以在运行时通过反射来获取注解的信息.</li>
</ol>
</li>
<li><p><code>@Document</code>: 将此注解包含在<code>Javadoc</code>中.</p>
</li>
<li><p><code>@Inherit</code>: 允许子类继承父类拥有的注解, 注意: 这里并不是说注解支持继承.</p>
</li>
</ul>
<blockquote>
<h4 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h4></blockquote>
<p>注解内的元素可用的类型如下:</p>
<ul>
<li><p>所有基本类型.</p>
</li>
<li><p><code>String</code></p>
</li>
<li><p><code>Class</code></p>
</li>
<li><p><code>enum</code></p>
</li>
<li><p><code>Annotation</code></p>
</li>
<li><p>以上类型的所有数组形式.</p>
</li>
</ul>
<blockquote>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</div><div class="line">    <span class="function">String <span class="title">date</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">    <span class="function">String <span class="title">describe</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Author</span>(</div><div class="line">        name = &#123;<span class="string">"xiaoming, xiaohong"</span>&#125;,</div><div class="line">        describe = <span class="string">"注册器"</span>,</div><div class="line">        date = <span class="string">"2017/11/22"</span></div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterController</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Author</code>是一个自定义的注解. 定义注解的语法跟定义接口很像, 只不过多了在<code>interface</code>之前加<code>@</code>符号的这个步骤. 在<code>Author</code>中, <code>@Target</code>的元素值为:<code>ElementType.TYPE</code>和<code>ElementType.METHOD</code>, 表示该注解用于标注类或者方法. <code>@Retention</code>的元素值为: <code>RetentionPolicy.CLASS</code>表示在<code>.class</code>文件中仍然保持注解, 但是在运行时, 注解会被丢弃.</p>
<p><code>Author</code>中的元素值都有被<code>default</code>标注, 这个关键字可以为元素值设置一个默认值. 需要注意的是, 注解是不支持不确定的值的, 所以在使用注解时, 要么给出注解的确定值, 要么在定义注解给定默认值. 注解不支持<code>null</code>. 在定义注解时, 最好都给每个元素标注要默认值, 用于表示特殊的状态. 例如, <code>int</code>类型可以用<code>-1</code>来表示默认值; <code>String</code>类型可以用<code>&quot;&quot;</code>空字符串来表示默认值.</p>
<blockquote>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3></blockquote>
<p>定了注解后, 我们会运用反射或者注解处理器去获取注解元素的值, 然后生成一些配置文件或者模板代码.</p>
<p>反射是在运行时获取注解的元素值, 会比较耗性能. 所以在移动端会比较少用反射. 后端用得比较多.</p>
<p>注解处理器则是在编译时, 通过扫描源文件来获取注解元素的值, 不存在性能的问题, 最多是增加编译的时长. 因此, 注解处理器在移动端会用得比较多.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1flr4xe3496j30m80b47mn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; clas
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java#基础" scheme="http://cristianoro7.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android动画框架总结</title>
    <link href="http://cristianoro7.github.io/2017/11/21/Android%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://cristianoro7.github.io/2017/11/21/Android动画框架总结/</id>
    <published>2017-11-21T09:32:34.677Z</published>
    <updated>2017-11-21T09:32:34.677Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flpsxet776j30m80b4tf9.jpg" alt=""></p>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>在<code>Android</code>中, 动画分为两种: <code>Animation</code>和<code>Transition</code>. 其中<code>Animation</code>分为<code>View Animation</code>和<code>Property Animation</code>.</p>
<p><code>Transition</code>是用于<code>Activity</code>和<code>Fragment</code>的转场动画.</p>
<p><code>View Animation</code>的作用对象是整个<code>View</code>对象, 它只支持4种动画效果: 平移, 缩放, 旋转和透明度动画. 另外, <code>View Animation</code>的一种特殊表现为: 逐帧动画. 它是通过缓慢的播放一组图像来到达一种动画效果. 需要注意的是: 由于逐帧动画是播放一组图像, 如果图片太大的话, 容易导致<code>OOM</code>.</p>
<p><code>Property Animation</code>中文意思为: 属性动画. 它是<code>Android 3.0</code>推出的全新动画. 它主要是为了弥补<code>View Animation</code>的缺陷. <code>View Animation</code>只能支持<code>View</code>的四中动画. 除了这四种外的动画, <code>View Animation</code>都无能为力. 例如: 颜色的渐变动画.</p>
<p>下面主要总结一下<code>Android</code>中的属性动画.</p>
<blockquote>
<h3 id="动画的简单原理"><a href="#动画的简单原理" class="headerlink" title="动画的简单原理"></a>动画的简单原理</h3></blockquote>
<p>假设现在有一个<code>View</code>, 它的<code>X</code>坐标为0. 如果我们想让它移动到<code>X</code>坐标为100的地方. 我们可以调用<code>view.setTranslationX()</code>. 但是出来的效果是: <code>View</code>在一瞬间跳跃到了100那里, 给人一种非常突然的感觉. 基于这种情况, 我们要让<code>View</code>移动到100的地方这个过程更符合人类的感官. 所以我们可以在一定的时间内, 每一帧改变<code>View</code>的位置, 当最后一帧的时候, 让<code>View</code>处于最终位置. 这样会比较符合人类的感官.</p>
<p>简单的来讲, 动画的整个过程可以这么概括: 给定一个动画完成的时间<code>S</code>, 动画每一帧的时间<code>Sa</code>, 根据经过的帧数来计算出动画完成的时间度(n*Sa / S). 接着根据这个时间完成度, 计算出动画完成度<code>D</code>. 最后根据<code>D</code>来计算出此时对应的属性为多少, 然后根据这个值来重新绘制.</p>
<p>时间完成度通过一个<code>TimeInterpolator</code>来计算出来动画的完成度. 而动画完成度通过<code>TypeEvaluator</code>计算出此刻的属性.</p>
<blockquote>
<h3 id="属性动画API"><a href="#属性动画API" class="headerlink" title="属性动画API"></a>属性动画API</h3></blockquote>
<p>在使用属性动画时, 我们可以用这三个类:</p>
<ul>
<li><p><code>ValueAnimator</code>: 最基础的动画类, 它只负责根据时间完成度来计算出动画完成度. API最难使用, 但是最为灵活.</p>
</li>
<li><p><code>ObjectAnimator</code>: <code>ValueAnimator</code>的子类, 对<code>ValueAnimator</code>进一步的封装. 内部会根据传入的属性值来调用其对应的<code>set</code>和<code>get</code>方法来更新界面. API比较简单, 但是灵活性不如<code>ValueAnimator</code>.</p>
</li>
<li><p><code>ViewPropertyAnimator</code>: 针对<code>Android View</code>控件的动画的封装. 该类的使用场景: 多个动画需要同时进行. 该类内部会只调用一个重绘操作. 这也是该类的一个主要优化. 它的API调用最为简单. 但是只支持<code>View</code>的四种动画, 灵活性不大.</p>
</li>
</ul>
<blockquote>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3></blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>ViewPropertyAnimator</code>的使用最为简单:</p>
<ul>
<li>执行单个动画:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.animate().translationX(<span class="number">50</span>);  <span class="comment">//向右平移50</span></div></pre></td></tr></table></figure>
<ul>
<li>多个动画同时执行:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">view.animate()</div><div class="line">    .setDuration(<span class="number">400</span>)</div><div class="line">    .setInterpolator(<span class="keyword">new</span> LinearInterpolator())</div><div class="line">    .translationX(<span class="number">50</span>)</div><div class="line">    .scaleX(<span class="number">0.5f</span>);</div></pre></td></tr></table></figure>
<p>由于<code>ViewPropertyAnimator</code>在播放多个动画时, 只支持同时播放, 所以播放同时播放多个动画时, 各个动画是共享<code>Interpolator</code>和播放时间的.</p>
<h4 id="设置监听器"><a href="#设置监听器" class="headerlink" title="设置监听器"></a>设置监听器</h4><p><code>ViewPropertyAnimator</code>支持设置三种类型的监听器:</p>
<ul>
<li><p><code>ViewPropertyAnimator.setListener()</code></p>
</li>
<li><p><code>ViewPropertyAnimator.setUpdateListener()</code></p>
</li>
<li><p><code>ViewPropertyAnimator.withStartAction/EndAction()</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">propertyAnimator.setListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画开始时被回调</span></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画完成的时候被回调, 注意: 当动画被取消后, 该方法也会回调.</span></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画被取消的时候被会回调</span></div><div class="line">                            &#125;   </div><div class="line"></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画重复执行的时候被回调</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line"></div><div class="line">propertyAnimator.setListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</div><div class="line">                          <span class="comment">//如果不想重写那么多方法的话, 可以利用这个适配器</span></div><div class="line">                          <span class="comment">//根据需要重写对应的方法</span></div><div class="line">                        &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">propertyAnimator.setUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">                          <span class="meta">@Override</span></div><div class="line">                          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                          <span class="comment">//动画更新时被调用, 默认更新的时间为10ms</span></div><div class="line">                          &#125;&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">propertyAnimator.withEndAction(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="comment">//动画结束的时候被调用(被取消的时候不会被调用), 该监听器是一次性的, 只要被调用过一次的话, 后面就不会再被调用了</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line"></div><div class="line">                        propertyAnimator.withEndAction(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                              <span class="comment">//动画开始的时候被调用, 该监听器是一次性的, 只要被调用过一次的话, 后面就不会再被调用了</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div></pre></td></tr></table></figure>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p><code>ViewPropertyAnimator</code>的动画只支持<code>View</code>的四种动画. 还有只支持多个动画同时播放. 所以它的适用场景:</p>
<ul>
<li><p>需要的动画类型为: <code>View</code>的四种动画.(因此API调用简单)</p>
</li>
<li><p>需要的是<code>View</code>动画类型, 并且多个动画同时播放. (因此内部会只进行一次重绘的优化)</p>
</li>
</ul>
<blockquote>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3></blockquote>
<p>如果你有一个自定义<code>View</code>, 它是一个自定义的圆形进度条. 你想对它的进度进行动画, 但是进度的类型为<code>float</code>, 因此, <code>ViewPropertyAnimator</code>不能胜任. 此时就要用<code>ObjectAnimator</code>了.</p>
<p><code>ObjectAnimator</code>支持对任何类型值进行动画. 但是有一个前提: 在自定义<code>View</code>的内部添加<code>setter</code>和<code>getter</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"progress"</span>, <span class="number">0</span>, <span class="number">75</span>);</div><div class="line">animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</div><div class="line">animator.start();</div></pre></td></tr></table></figure>
<h4 id="Interpolator"><a href="#Interpolator" class="headerlink" title="Interpolator"></a>Interpolator</h4><p>前面说过, <code>Interpolator</code>是计算动画完成度的依据. 它本质上是一个算法, 动画的完成度由时间完成度根据这个算法算出来的.</p>
<p>系统自带了它的很多子类. 这里不多说, 可以参考这<a href="http://hencoder.com/ui-1-6/" target="_blank" rel="external">篇文章</a></p>
<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p><code>ObjectAnimator</code>支持三种监听器</p>
<ul>
<li><p><code>ObjectAnimator.addListener()</code></p>
</li>
<li><p><code>ObjectAnimator.addUpdateListener()</code></p>
</li>
<li><p><code>ObjectAnimator.addPauseListener()</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">animator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画开始时被回调</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画完成的时候被回调, 注意: 当动画被取消后, 该方法也会回调.</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画被取消的时候被会回调</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画重复执行的时候被回调</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line"></div><div class="line">animator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</div><div class="line">                  <span class="comment">//如果不想重写那么多方法的话, 可以利用这个适配器</span></div><div class="line">                  <span class="comment">//根据需要重写对应的方法</span></div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                      <span class="comment">//动画更新时被调用, 默认更新的时间为10ms</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">animator.addPauseListener(<span class="keyword">new</span> Animator.AnimatorPauseListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationPause</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                        <span class="comment">//动画被暂停的时候回调</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationResume</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                        <span class="comment">//动画被恢复的时候调用</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>当动画类型不是<code>View</code>的四种动画类型, 并且你有权利给你的<code>View</code>添加<code>setter</code>和<code>getter</code></li>
</ul>
<p>但是如果你没有权利给<code>View</code>添加<code>setter</code>和<code>getter</code>方法呢? 比如你正在用一个第三方的<code>View</code>. 这时候有两种选择:</p>
<ul>
<li><p>用一个类来包装你的<code>View</code>, 为包装<code>View</code>添加<code>setter</code>和<code>getter</code>方法.</p>
</li>
<li><p>使用<code>ValuesAnimator</code>来自己手动更新.</p>
</li>
</ul>
<blockquote>
<h3 id="ValuesAnimator"><a href="#ValuesAnimator" class="headerlink" title="ValuesAnimator"></a>ValuesAnimator</h3></blockquote>
<p><code>ValuesAnimator</code>是<code>ViewPropertyAnimator</code>和<code>ObjectAnimator</code>的父类, 这两个类都是对<code>ValuesAnimator</code>的进一步封装, 以此来提供更为便利的<code>API</code>调用. 因此这两个类的灵活性也下降了. 当上面的两个类都不能满足你的需求时, 你可以使用<code>ValuesAnimator</code>, 让它帮你计算每一帧后的属性值, 然后你监听这个属性的变化, 最后设置对应的属性, 并且重绘<code>View</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">100</span>);</div><div class="line">valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                        <span class="keyword">int</span> value = (<span class="keyword">int</span>) animation.getAnimatedValue();</div><div class="line">                        <span class="comment">//设置 value属性, 并且重绘View</span></div><div class="line">              &#125;</div><div class="line">&#125;);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure>
<p>从上面的代码, 我们发现, <code>ValueAnimator</code>的<code>API</code>调用相比前两个类, 要复杂一点, 但是它最为灵活. 前两个类只不过是对<code>ValueAnimator</code>的封装, 以便提供更为方便的<code>API</code>.</p>
<blockquote>
<h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a>TypeEvaluator</h3></blockquote>
<p><code>TypeEvaluator</code>为估值器, 前面说到, 算出动画的完成度后, 我们可以根据这个动画完成度来计算出当前属性的值. 那怎么算呢? <code>TypeEvaluator</code>就是来完成这个计算工作的.</p>
<p>在<code>ObjectAnimator</code>中, 我们常用的是<code>ofInt</code>和<code>ofFloat</code>方法, 但是如果你的属性是一个对象呢? 比如<code>PointF</code>对象, 这时, 应该使用<code>ofObject</code>方法.</p>
<p>下面以官方提供的一个<code>PontFEvaluator</code>为例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofObject(view, <span class="string">"point"</span>, <span class="keyword">new</span> PointFEvaluator(), <span class="keyword">new</span> PointF(<span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                       <span class="keyword">new</span> PointF(<span class="number">100</span>, <span class="number">100</span>));</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointFEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">PointF</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> PointF mPoint;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PointFEvaluator</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PointFEvaluator</span><span class="params">(PointF reuse)</span> </span>&#123;</div><div class="line">      mPoint = reuse;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> PointF <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, PointF startValue, PointF endValue)</span> </span>&#123;</div><div class="line">      <span class="keyword">float</span> x = startValue.x + (fraction * (endValue.x - startValue.x)); <span class="comment">//根据动画完成度算出X坐标</span></div><div class="line">      <span class="keyword">float</span> y = startValue.y + (fraction * (endValue.y - startValue.y)); <span class="comment">//根据动画完成度算出Y坐标</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (mPoint != <span class="keyword">null</span>) &#123;</div><div class="line">          mPoint.set(x, y);</div><div class="line">          <span class="keyword">return</span> mPoint; <span class="comment">//返回对应的新对象</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> PointF(x, y);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="多个属性的动画同时执行"><a href="#多个属性的动画同时执行" class="headerlink" title="多个属性的动画同时执行"></a>多个属性的动画同时执行</h3></blockquote>
<p><code>ViewPropertyAnimator</code>调用多个属性进行动画时, 是同时进行的. 那么对于<code>ObjectAnimator</code>呢? 它如何让多个属性进行配合? 答案是使用<code>PropertyValuesHolder</code>. 用法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(<span class="string">"scaleX"</span>, <span class="number">1.5f</span>);</div><div class="line">PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(<span class="string">"scaleY"</span>, <span class="number">1.5f</span>);</div><div class="line">PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(<span class="string">"alpha"</span>, <span class="number">0.4f</span>);</div><div class="line"></div><div class="line">ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3);</div><div class="line">objectAnimator.start();</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="多个动画配合执行"><a href="#多个动画配合执行" class="headerlink" title="多个动画配合执行"></a>多个动画配合执行</h3></blockquote>
<p>有时候, 我们需要的效果可能是多个动画配合执行, 这时候, 我们可以用<code>AnimatorSet</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator1 = ObjectAnimator.ofInt(...);</div><div class="line">ObjectAnimator animator2 = ObjectAnimator.ofInt(...);</div><div class="line">ObjectAnimator animator3 = ObjectAnimator.ofInt(...);</div><div class="line"></div><div class="line">AnimatorSet set = <span class="keyword">new</span> AnimatorSet();</div><div class="line"></div><div class="line">set.playSequentially(animator1, animator2, animator3); <span class="comment">//按顺序播放</span></div><div class="line">set.start();</div><div class="line"></div><div class="line">set.playTogether(animator1, animator2); <span class="comment">//同时播放</span></div><div class="line">set.start();</div><div class="line"></div><div class="line">set.play(animator1).with(animator2);</div><div class="line">set.play(animator2).after(animator3); <span class="comment">//进行精准控制播放</span></div><div class="line">set.start();</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li><p>当你的动画类型是<code>View</code>四种动画的其中一种或者两种以上的话, 优先使用<code>ViewPropertyAnimator</code> 因为<code>API</code>调用很简单.</p>
</li>
<li><p>当<code>ViewPropertyAnimator</code>不能满足你的需求时, 使用<code>ObjectAnimator</code>.</p>
</li>
<li><p>如果使用的<code>View</code>的属性没有对应的<code>setter</code>和<code>getter</code>方法的话, 可以使用<code>ValueAnimator</code>.</p>
</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></blockquote>
<p><a href="http://hencoder.com/ui-1-6/" target="_blank" rel="external">HenCoder</a></p>
<p>Android开发艺术探索</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1flpsxet776j30m80b4tf9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;hea
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="Android#自定义View" scheme="http://cristianoro7.github.io/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发机制总结</title>
    <link href="http://cristianoro7.github.io/2017/11/21/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://cristianoro7.github.io/2017/11/21/Android事件分发机制总结/</id>
    <published>2017-11-21T09:32:31.885Z</published>
    <updated>2017-11-21T09:32:31.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fll5g8ssmmj30m80b4aiv.jpg" alt=""></p>
<p>关于<code>Andorid</code>事件分发机制的解析, 网上一堆文章, 并且写得很详细, 因此这里只写写一些总结, 不涉及原理的解析.</p>
<blockquote>
<h2 id="分发对象"><a href="#分发对象" class="headerlink" title="分发对象"></a>分发对象</h2></blockquote>
<p>在<code>Android</code>中, 点击手势被封装成<code>MotionEvent</code>对象. 因此对于点击事件的分发, 实质上是对<code>MotionEvent</code>对象的分发.</p>
<p>对于单点触控, 有下面两种情况的手势对应<code>MotionEvent</code>的状态:</p>
<ul>
<li><p>点击 -&gt; 松开 : <code>ACTION_DOWN</code> -&gt; <code>ACTION_UP</code></p>
</li>
<li><p>点击 -&gt; 移动 -&gt; 移动 -&gt; …-&gt; 松开 :　<code>ACTION_DOWN</code> -&gt; <code>ACTION_MOVE</code> -&gt; <code>ACTION_MOVE</code> -&gt; … -&gt; <code>ACTION_UP</code></p>
</li>
</ul>
<blockquote>
<h2 id="事件的传递顺序"><a href="#事件的传递顺序" class="headerlink" title="事件的传递顺序"></a>事件的传递顺序</h2></blockquote>
<p>点击事件发生后, 事件的传递顺序为: <code>Activity</code> -&gt; <code>PhoneWindow</code> -&gt; <code>DecorView</code> -&gt; <code>ViewGroup</code> …. -&gt; <code>View</code></p>
<blockquote>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2></blockquote>
<p><code>Android</code>事件分发机制的设计思想是基于责任链模式. 事件在传递的过程中, 先从上层传递到下层, 在这个过程中, 如果该事件你需要处理的话, 可以拦截下来处理, 如果不需要的话, 交给下层处理. 当事件传递到底层且底层不处理事件的话, 事件会从底层往上层传递. 如果上传的过程中, 事件没有被消费的话, 最终由<code>Activity</code>消费.</p>
<blockquote>
<h2 id="分发过程中涉及的方法"><a href="#分发过程中涉及的方法" class="headerlink" title="分发过程中涉及的方法"></a>分发过程中涉及的方法</h2></blockquote>
<p>事件分发的过程中, 事件需要被传递, 被分发, 分消费, 这些操作涉及到下面的方法:</p>
<p><code>public boolean dispatchTouchEvent(MotionEvent ev)</code> : 用来分发事件</p>
<p><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code> : 用来判断是否拦截事件, 如果当前<code>View</code>拦截了某个事件, 那么同一个事件序列当中, 此方法不会被调用. 换句话说, 该方法不是每次都会被调用.</p>
<p><code>public boolean onTouchEvent(MotionEvent ev)</code> : 用来处理点击事件.</p>
<p>上面的三个方法的关系可以用下面的伪代码来表示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> isConsume = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123; <span class="comment">//判断是否要拦截</span></div><div class="line">      isConsume = onTouchEvent(ev); <span class="comment">//是的话, 自己处理点击事件</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      isConsume = child.dispatchTouchEvent(ev); <span class="comment">//不是的话, 传递给下一层处理</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isConsume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: 事件的消费与否是通过<code>boolean</code>来标识的, <code>true</code>表示消费事件, <code>false</code>表示不消费事件. 事件的消费与否与是否使用了<code>MotionEvent</code>对象无关.</p>
</blockquote>
<p>前面说过, 事件的传递顺序为 : <code>Activity</code> -&gt; <code>PhoneWindow</code> -&gt; <code>DecorView</code> -&gt; <code>ViewGroup</code> …. -&gt; <code>View</code>. 下面我们来看看<code>Activity</code>, <code>ViewGroup</code>和<code>View</code>中是否有上面的三个方法:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>方法</th>
<th>Activity</th>
<th>ViewGroup</th>
<th>View</th>
</tr>
</thead>
<tbody>
<tr>
<td>事件分发</td>
<td>dispatchTouchEvent</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>事件拦截</td>
<td>onInterceptTouchEvent</td>
<td>不存在</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>事件消费</td>
<td>onTouchEvent</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody>
</table>
<blockquote>
<p>从上表可以看出: <code>Activity</code>和<code>View</code>是不存在事件拦截的.</p>
<h2 id="事件分发的总体流程"><a href="#事件分发的总体流程" class="headerlink" title="事件分发的总体流程"></a>事件分发的总体流程</h2></blockquote>
<p>一个点击时事件总是先到达<code>Activity</code>, 然后传给<code>Window</code>, 接着<code>Window</code>传给顶级<code>View</code>, 最后按照事件分发机制去分发. 分发的流程图如下:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fll2pjny8dj30jb0u3jtj.jpg" alt=""></p>
<blockquote>
<h2 id="监听器的优先级"><a href="#监听器的优先级" class="headerlink" title="监听器的优先级"></a>监听器的优先级</h2></blockquote>
<p>当一个<code>View</code>设置了<code>OnTouchListener</code>, 那么<code>OnTouchListener</code>的<code>onTouch</code>会先被调用. 如果<code>OnTouch</code>返回<code>true</code>的话, 事件被消费. 如果返回<code>false</code>的话, 当前<code>View</code>的<code>onTouEvent</code>会被调用. 而在<code>onTouchEvent</code>中, 会根据事件类型来调用<code>OnLongClickListener</code>或者<code>OnClickListener</code>监听器的监听方法.</p>
<p>换句话说, 监听器的优先级为: <code>OnTouchListener</code> -&gt; <code>OnLongClickListener</code> -&gt; <code>OnClickListener</code>.</p>
<blockquote>
<h2 id="View默认的消费事件行为"><a href="#View默认的消费事件行为" class="headerlink" title="View默认的消费事件行为"></a>View默认的消费事件行为</h2></blockquote>
<p>如果<code>View</code>的<code>clickable</code>属性为<code>true</code>的话, 该<code>View</code>会默认消费事件.</p>
<p>如果给<code>View</code>设置了<code>onClickListener</code>、<code>onLongClickListener</code>、<code>OnContextClickListener</code>其中一个监听器, 或者<code>android:clickable=&quot;true&quot;</code>的话, 该<code>View</code>是可点击的, 也就是<code>clickable</code>为<code>true</code>.</p>
<p>有些控件默认是可点击的, 比如:<code>Button</code>. 不可点击的控件: <code>TextView</code>.</p>
<blockquote>
<p>注意: <code>View</code>的<code>enable</code>属性并不会影响事件的分发.</p>
</blockquote>
<h2 id="事件分发小总结"><a href="#事件分发小总结" class="headerlink" title="事件分发小总结"></a>事件分发小总结</h2><ul>
<li><p>正常情况下, 一个事件序列, 只能被一个<code>View</code>拦截并且消费. 因为如果一个<code>View</code>拦截了一个事件, 那么后续的事件将交给它处理.</p>
</li>
<li><p>如果一个<code>View</code>不消费<code>ACTION_DOWN</code>事件的话, 后续的事件就不会传递给它. 事件将交给父元素处理, 即使父元素的<code>OnTouchEvent</code>会被调用.</p>
</li>
<li><p><code>ViewGroup</code>默认不拦截任何事件.</p>
</li>
<li><p>事件总是先传给父元素, 再传给子元素. 子元素可以通过<code>requestDisallowInterceptTouchEvent</code>来干预父元素的拦截, 但是对于<code>ACTION_DOWN</code>事件, 子元素不能干预父元素的拦截.</p>
</li>
</ul>
<blockquote>
<h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2></blockquote>
<p>常见的滑动冲突有三种:</p>
<ol>
<li><p>外部和内部的滑动方向不一样</p>
</li>
<li><p>外部和内部的滑动方向一样.</p>
</li>
<li><p>上面两种情况的嵌套.</p>
</li>
</ol>
<blockquote>
<h3 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h3></blockquote>
<p>场景1: 当用户左右滑动时, 让外部的<code>View</code>拦截点击事件; 当用户上下滑动时, 让内部的<code>View</code>拦截点击事件. 可以根据<code>View</code>滑动的水平距离和垂直距离差或角度差来判断用户是左右还是水平滑动.</p>
<p>场景2: 这种情况只能根据业务逻辑来拦截事件.</p>
<p>场景3: 跟场景2一样.</p>
<blockquote>
<h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3></blockquote>
<p>处理冲突的方法可以分为两种:</p>
<ul>
<li><p>外部拦截法: 事件总是先经过父元素, 如果父元素需要的话, 就拦截下来.</p>
</li>
<li><p>内部拦截法: 父容器默认不拦截事件, 所有事件先交给子元素处理, 如果子元素需要的话, 就消费掉, 不需要的话, 交给父元素处理.</p>
</li>
</ul>
<p>下面是这两种方法的模板代码:</p>
<blockquote>
<p>外部拦截法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">            <span class="keyword">if</span> (父容器需要当前点击事件) &#123;</div><div class="line">                intercepted = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        mLastXIntercepted = x;</div><div class="line">        mLastYIntercepted = y;</div><div class="line">        <span class="keyword">return</span> intercepted;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>内部拦截法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//子元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">            <span class="keyword">if</span> (父容器需要此点击事件) &#123;</div><div class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    mLastX = x;</div><div class="line">    mLastY = y;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//父元素:</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> action = ev.getAction();</div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Android开发艺术探索</p>
<p><a href="http://www.gcssloop.com/customview/dispatch-touchevent-source" target="_blank" rel="external">http://www.gcssloop.com/customview/dispatch-touchevent-source</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fll5g8ssmmj30m80b4aiv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Andorid&lt;/code&gt;事件分发机制的解析, 网上一堆文章, 并且写得很
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="Android#自定义View" scheme="http://cristianoro7.github.io/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>SP解析</title>
    <link href="http://cristianoro7.github.io/2017/11/14/SP%E8%A7%A3%E8%AF%BB/"/>
    <id>http://cristianoro7.github.io/2017/11/14/SP解读/</id>
    <published>2017-11-14T08:00:59.799Z</published>
    <updated>2017-11-14T08:00:59.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhnrmq40dj30m80b4q9b.jpg" alt=""></p>
<blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></blockquote>
<p><code>SharedPreferences</code>是<code>Android</code>中的数据持久化技术中的一种. 它将<code>Key-Value</code>键值对储存在一个<code>XMl</code>文件中. 它比较适用储存小量的数据. 比如一些应用的配置信息.</p>
<blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></blockquote>
<p><code>SharedPreferences</code>的被设计成<code>读写分离</code>的模式,  <code>SharedPreferences</code>用来读取数据, <code>SharedPreferences.Editor</code>则是用来写数据.</p>
<blockquote>
<h3 id="获取SharedPreferences"><a href="#获取SharedPreferences" class="headerlink" title="获取SharedPreferences"></a>获取SharedPreferences</h3></blockquote>
<p>关于如何获取<code>SharedPreferences</code>, 可以通过下面这三种方法来获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPreferences = Activity.getPreferences(MODE_PRIVATE); <span class="comment">//在Activity中调用</span></div><div class="line">SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);</div><div class="line">SharedPreferences sharedPreferences = context.getSharedPreferences(<span class="string">"cr7"</span>, MODE_APPEND);</div></pre></td></tr></table></figure>
<p>前面两种都是第三种的封装. 第三种的函数原型为: <code>Context.getSharedPreferences(String name, int mode)</code>. 其中<code>name</code>为文件的名字, <code>mode</code>为操作模式. 操作模式可选有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_PRIVATE = <span class="number">0x0000</span>; <span class="comment">//默认的模式, 每次写都会覆盖之前的数据. 并且只允许本应用内或者拥有用一个userId的应用进行读写文件</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_WORLD_READABLE = <span class="number">0x0001</span>; <span class="comment">//允许多个应用进行读, 由于安全性问题, 已被弃用.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_WORLD_WRITEABLE = <span class="number">0x0002</span>; <span class="comment">//允许多个应用进行写, 由于安全性问题, 已被弃用.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_APPEND = <span class="number">0x8000</span>; <span class="comment">//如果文件已经存在的话, 写不会覆盖之前的数据, 会直接写到文件的末尾.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MULTI_PROCESS = <span class="number">0x0004</span>; <span class="comment">//多进程模式, 该模式不安全, 不建议使用.</span></div></pre></td></tr></table></figure>
<p>上面有些是由于安全性的问题被弃用的. 而<code>MODE_MULTI_PROCESS</code>用于多进程读写的模式, 但是不能保证可靠性, 有可能会出现脏读现象, 已被官方弃用.</p>
<p><code>SharedPreferences</code>的文件储存在<code>/data/data/shared_prefs/</code>. <code>Activity.getPreferences(MODE_PRIVATE)</code>默认的文件名: 调用的<code>Activity</code>的名字, 比如在<code>SpActivity</code>中调用, 得到的文件名字为: <code>SpActivity.xml</code>. 至于调用<code>PreferenceManager.getDefaultSharedPreferences(context)</code>得到的文件名字为: <code>包名+ _preferences.xml</code>.</p>
<p>获取完<code>SharedPreferences</code>后, 我们就可以调用其中的<code>getXX</code>来获取数据.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sharedPreferences.getString(<span class="string">"cr7"</span>, <span class="string">""</span>); <span class="comment">//如果不存在cr7这个key的话, 返回默认值""</span></div></pre></td></tr></table></figure>
<blockquote>
<h3 id="获取SharedPreferences-Editor"><a href="#获取SharedPreferences-Editor" class="headerlink" title="获取SharedPreferences.Editor"></a>获取SharedPreferences.Editor</h3></blockquote>
<p>获得<code>SharedPreferences</code>实例后, 我们可以调用它的<code>editor()</code>方法拿到<code>Editor</code>对象, 注意, 每次调用<code>editor()</code>方法都是新建一个<code>Editor</code>对象. 拿到对象后, 就可以进行写数据了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">editor.putString(<span class="string">"cr7"</span>, <span class="string">"good and best"</span>);</div><div class="line">editor.apply();</div></pre></td></tr></table></figure>
<p>要将数据写入文件中的话, 最后还得调用<code>apply()</code>或者<code>commit()</code>方法.</p>
<blockquote>
<h3 id="监听Key的对应的Value值的变化"><a href="#监听Key的对应的Value值的变化" class="headerlink" title="监听Key的对应的Value值的变化"></a>监听Key的对应的Value值的变化</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sharedPreferences.registerOnSharedPreferenceChangeListener(<span class="keyword">new</span> SharedPreferences.OnSharedPreferenceChangeListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSharedPreferenceChanged</span><span class="params">(SharedPreferences sharedPreferences, String key)</span> </span>&#123;</div><div class="line">        Log.d(TAG, <span class="string">"onSharedPreferenceChanged: "</span> + key);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">sharedPreferences.unregisterOnSharedPreferenceChangeListener(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>如果我们需要监听<code>Key</code>对应的<code>Value</code>的变化的话, 可以调用<code>sharedPreferences</code>中的注册方法. 每当<code>Key</code>值对应的<code>Value</code>发生变化时, 都会回调这个接口. 但是不用的时候, 记得调用注销接口.</p>
<blockquote>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhc48le84j312h0hodhv.jpg" alt=""></p>
<p>上图为<code>sharedPreferences</code>的UML设计图, <code>sharedPreferences</code>和<code>sharedPreferences.Editor</code>只是一个接口, 对应的实现由<code>SharedPreferencesImpl</code>和<code>SharedPreferencesImpl.EditorImpl</code>来负责.</p>
<p><code>SharedPreferencesImpl</code>被设计成单例的形式, 是由<code>ContextImpl</code>负责创建和维护. 在<code>ContextImpl</code>中有字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</div></pre></td></tr></table></figure>
<p>这个字段是负责维护<code>SharedPreferences</code>的. 并且为静态字段,证明同一进程中只有一个实例.</p>
<blockquote>
<h3 id="创建SharedPreferences"><a href="#创建SharedPreferences" class="headerlink" title="创建SharedPreferences"></a>创建SharedPreferences</h3></blockquote>
<p><code>SharedPreferences</code>的创建是由<code>ContextImpl</code>负责的, 对应实现方法为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="comment">// At least one application in the world actually passes in a null</span></div><div class="line">    <span class="comment">// name.  This happened to work because when we generated the file name</span></div><div class="line">    <span class="comment">// we would stringify it to "null.xml".  Nice.</span></div><div class="line">    <span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">            Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">            name = <span class="string">"null"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    File file;</div><div class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</div><div class="line">        <span class="keyword">if</span> (mSharedPrefsPaths == <span class="keyword">null</span>) &#123;</div><div class="line">            mSharedPrefsPaths = <span class="keyword">new</span> ArrayMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        file = mSharedPrefsPaths.get(name); <span class="comment">//根据路径得到文件</span></div><div class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123; <span class="comment">//如果没有缓存的话, 创建对应的文件</span></div><div class="line">            file = getSharedPreferencesPath(name); <span class="comment">//创建文件</span></div><div class="line">            mSharedPrefsPaths.put(name, file); <span class="comment">//添加入缓存</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getSharedPreferences(file, mode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合注释: 首先根据传入的文件名, 先从缓存中拿, 如果不存在的话, 说明该文件还没有被创建, 因此会创建文件后添加进缓存中. 接着调用<code>getSharedPreferences(file, mode)</code>获取<code>SharedPreferences</code>实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    checkMode(mode); <span class="comment">//检查模式</span></div><div class="line">    <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</div><div class="line">        <span class="keyword">if</span> (isCredentialProtectedStorage()</div><div class="line">                &amp;&amp; !getSystemService(StorageManager.class).isUserKeyUnlocked(</div><div class="line">                        UserHandle.myUserId())</div><div class="line">                &amp;&amp; !isBuggy()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"SharedPreferences in credential encrypted "</span></div><div class="line">                    + <span class="string">"storage are not available until after user is unlocked"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    SharedPreferencesImpl sp;</div><div class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</div><div class="line">        <span class="keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</div><div class="line">        sp = cache.get(file); <span class="comment">//从缓存中获取SP</span></div><div class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123; <span class="comment">//不存在的话, 创建实例并添加进缓存.</span></div><div class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</div><div class="line">            cache.put(file, sp);</div><div class="line">            <span class="keyword">return</span> sp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置了MODE_MULTI_PROCESS模式后, 会重新加载文件. 但是这不能解决多进程的脏读现象</span></div><div class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</div><div class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></div><div class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></div><div class="line">        <span class="comment">// historical (if undocumented) behavior.</span></div><div class="line">        sp.startReloadIfChangedUnexpectedly();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>getSharedPreferences(File file, int mode)</code>中的逻辑, 会先调用<code>checkMode(int)</code>来检查模式.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkMode</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.N) &#123;</div><div class="line">        <span class="keyword">if</span> ((mode &amp; MODE_WORLD_READABLE) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"MODE_WORLD_READABLE no longer supported"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ((mode &amp; MODE_WORLD_WRITEABLE) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"MODE_WORLD_WRITEABLE no longer supported"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Android N</code>后, 出于安全性的考虑, 开始不支持<code>MODE_WORLD_READABLE</code>和<code>MODE_WORLD_WRITEABLE</code>.</p>
<p>检查完模式后, 接着从缓存中获取该文件对应的<code>SharedPreferences</code>, 如果存在的话, 返回. 不存在的话, 创建实例并添加进缓存.</p>
<p>经过上面的步骤就创建并缓存了<code>SharedPreferences</code>. 那么我们下面来看看<code>SharedPreferences</code>创建的时候内部都做了什么.</p>
<blockquote>
<h3 id="SharedPreferencesImpl"><a href="#SharedPreferencesImpl" class="headerlink" title="SharedPreferencesImpl"></a>SharedPreferencesImpl</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SharedPreferencesImpl(File file, <span class="keyword">int</span> mode) &#123;</div><div class="line">    mFile = file;</div><div class="line">    mBackupFile = makeBackupFile(file); <span class="comment">//备份文件, 用于文件读写失败时恢复</span></div><div class="line">    mMode = mode;</div><div class="line">    mLoaded = <span class="keyword">false</span>;</div><div class="line">    mMap = <span class="keyword">null</span>;</div><div class="line">    startLoadFromDisk(); <span class="comment">//开始从硬盘中加载文件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>SharedPreferencesImpl</code>的构造方法中, 首先备份文件, 用于文件读写失败时的恢复. 最后调用<code>startLoadFromDisk</code>从硬盘中加载文件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        mLoaded = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            loadFromDisk();</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先将加载标记<code>mLoad</code>设置为<code>false</code>表示文件还没有加载完. 然后开一条线程去加载文件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        <span class="keyword">if</span> (mLoaded) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</div><div class="line">            mFile.delete();</div><div class="line">            mBackupFile.renameTo(mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Debugging</span></div><div class="line">    <span class="keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"Attempt to read preferences file "</span> + mFile + <span class="string">" without permission"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Map map = <span class="keyword">null</span>;</div><div class="line">    StructStat stat = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        stat = Os.stat(mFile.getPath());</div><div class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</div><div class="line">            BufferedInputStream str = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                str = <span class="keyword">new</span> BufferedInputStream(</div><div class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span>*<span class="number">1024</span>);</div><div class="line">                map = XmlUtils.readMapXml(str); <span class="comment">//将文件内容读进Map中</span></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                Log.w(TAG, <span class="string">"Cannot read "</span> + mFile.getAbsolutePath(), e);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                IoUtils.closeQuietly(str);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</div><div class="line">        <span class="comment">/* ignore */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        mLoaded = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            mMap = map;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        mLock.notifyAll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法主要做了两件事, 1: 从<code>XML</code>文件中读出数据, 并存放在<code>Map</code>中. 2: 将加载标记设置为<code>true</code>表示已经加载完成. 然后调用<code>notifyAll()</code>通知正在等待读写的线程.</p>
<blockquote>
<h3 id="利用SharedPreferences读数据"><a href="#利用SharedPreferences读数据" class="headerlink" title="利用SharedPreferences读数据"></a>利用SharedPreferences读数据</h3></blockquote>
<p>创建完<code>SharedPreferences</code>后, 我们就可以拿到它的实例来进行读数据, 下面通过其中的<code>getString(String key, String defValue)</code>来分析.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">        String v = (String)mMap.get(key);</div><div class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</div><div class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></div><div class="line">        <span class="comment">// thread, since the real read will be in a different</span></div><div class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></div><div class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mLock.wait();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次读数据时, 都会判断文件是否加载完, 没有的话, 会调用<code>wait()</code>挂起线程, 直到文件加载完才被唤醒.</p>
<p>前面说过文件的内容都是加载进了<code>mMap</code>中, 所以<code>getXXX</code>方法获取的数据都是从<code>mMap</code>中获取.</p>
<blockquote>
<h3 id="Editor写数据"><a href="#Editor写数据" class="headerlink" title="Editor写数据"></a>Editor写数据</h3></blockquote>
<p>前面分析过, <code>SharedPreferences</code>的读写是分离的. 要进行写数据的话, 我们需要拿到<code>Editor</code>对象, 这个对象可以通过<code>SharedPreferences</code>中的<code>editor()</code>方法拿到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove the need to call awaitLoadedLocked() when</span></div><div class="line">    <span class="comment">// requesting an editor.  will require some work on the</span></div><div class="line">    <span class="comment">// Editor, but then we should be able to do:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// ... all without blocking.</span></div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意: 每次调用这个方法的方法都是新建一个实例, 所以在使用的时候,最好缓存起来, 避免多次调用生成多个对象.</p>
<p>下面也是通过<code>Editor</code>中的<code>putString(String key, String value)</code>为例子来分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">putString</span><span class="params">(String key, @Nullable String value)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        mModified.put(key, value);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写数据时, 并没有直接操作<code>SharedPreferences</code>中的<code>mMap</code>, 而是自己新建一个<code>mModified</code>的<code>Map</code>对象来记录修改的数据.</p>
<p>从上面可以看出, 调用<code>putXXX</code>方法, 数据只是存在内存中, 此时还没有写进磁盘. 需要调用<code>commit()</code>或者<code>apply()</code>方法.</p>
<blockquote>
<h3 id="提交数据commit"><a href="#提交数据commit" class="headerlink" title="提交数据commit()"></a>提交数据commit()</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        startTime = System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MemoryCommitResult mcr = commitToMemory(); <span class="comment">//将修改的数据写进mMap中</span></div><div class="line"></div><div class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(</div><div class="line">        mcr, <span class="keyword">null</span> <span class="comment">/* sync write on this thread okay */</span>); <span class="comment">//写进磁盘</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mcr.writtenToDiskLatch.await();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</div><div class="line">                    + <span class="string">" committed after "</span> + (System.currentTimeMillis() - startTime)</div><div class="line">                    + <span class="string">" ms"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    notifyListeners(mcr);</div><div class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>commit()</code>方法总体逻辑: 1: 将写的数据同步到<code>SharedPreferences</code>中的<code>mMap</code>中; 2: 将<code>mMap</code>写进磁盘. 3: 回到<code>Key</code>监听器.</p>
<blockquote>
<h4 id="commitToMemory"><a href="#commitToMemory" class="headerlink" title="commitToMemory"></a>commitToMemory</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> MemoryCommitResult <span class="title">commitToMemory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> memoryStateGeneration;</div><div class="line">    List&lt;String&gt; keysModified = <span class="keyword">null</span>;</div><div class="line">    Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="keyword">null</span>;</div><div class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>.mLock) &#123;</div><div class="line">        <span class="comment">// We optimistically don't make a deep copy until</span></div><div class="line">        <span class="comment">// a memory commit comes in when we're already</span></div><div class="line">        <span class="comment">// writing to disk.</span></div><div class="line">        <span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// We can't modify our mMap as a currently</span></div><div class="line">            <span class="comment">// in-flight write owns it.  Clone it before</span></div><div class="line">            <span class="comment">// modifying it.</span></div><div class="line">            <span class="comment">// noinspection unchecked</span></div><div class="line">            mMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(mMap);</div><div class="line">        &#125;</div><div class="line">        mapToWriteToDisk = mMap;</div><div class="line">        mDiskWritesInFlight++;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> hasListeners = mListeners.size() &gt; <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (hasListeners) &#123;</div><div class="line">            keysModified = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">            listeners = <span class="keyword">new</span> HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            <span class="keyword">boolean</span> changesMade = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mClear) &#123; <span class="comment">//如果在调用了Editor的clear()方法的话, 会将mMap中的数据先清除</span></div><div class="line">                <span class="keyword">if</span> (!mMap.isEmpty()) &#123;</div><div class="line">                    changesMade = <span class="keyword">true</span>;</div><div class="line">                    mMap.clear();</div><div class="line">                &#125;</div><div class="line">                mClear = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123; <span class="comment">//将mModified的数据添加到mMap中</span></div><div class="line">                String k = e.getKey();</div><div class="line">                Object v = e.getValue();</div><div class="line">                <span class="comment">// "this" is the magic value for a removal mutation. In addition,</span></div><div class="line">                <span class="comment">// setting a value to "null" for a given key is specified to be</span></div><div class="line">                <span class="comment">// equivalent to calling remove on that key.</span></div><div class="line">                <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!mMap.containsKey(k)) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    mMap.remove(k);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (mMap.containsKey(k)) &#123;</div><div class="line">                        Object existingValue = mMap.get(k);</div><div class="line">                        <span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    mMap.put(k, v);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                changesMade = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span> (hasListeners) &#123;</div><div class="line">                    keysModified.add(k);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mModified.clear();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (changesMade) &#123;</div><div class="line">                mCurrentMemoryStateGeneration++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            memoryStateGeneration = mCurrentMemoryStateGeneration;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</div><div class="line">            mapToWriteToDisk);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先判断<code>mClear</code>字段是否被设置, 是的话, 清除<code>mMap</code>中的数据. 接着将<code>mModified</code>的数据添加到<code>mMap</code>中.</p>
<blockquote>
<h4 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></div><div class="line">                              <span class="keyword">final</span> Runnable postWriteRunnable) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>); <span class="comment">//由于传入的postWriteRunnable为null, 所以该字段为true</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr, isFromSyncCommit); <span class="comment">//写入文件</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></div><div class="line">    <span class="comment">// the current thread.</span></div><div class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于传入的<code>postWriteRunnable</code>为<code>null</code>, <code>isFromSyncCommit</code>为<code>true</code>. 然后调用<code>writeToFile(mcr, isFromSyncCommit)</code>将数据写进磁盘.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> existsTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> backupExistsTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> outputStreamCreateTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> writeTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> fsyncTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> setPermTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> fstatTime = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> deleteTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        startTime = System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> fileExists = mFile.exists();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        existsTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="comment">// Might not be set, hence init them to a default value</span></div><div class="line">        backupExistsTime = existsTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Rename the current file so it may be used as a backup during the next read</span></div><div class="line">    <span class="keyword">if</span> (fileExists) &#123;</div><div class="line">        <span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Only need to write if the disk state is older than this commit</span></div><div class="line">        <span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</div><div class="line">            <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">                needsWrite = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                    <span class="comment">// No need to persist intermediate states. Just wait for the latest state to</span></div><div class="line">                    <span class="comment">// be persisted.</span></div><div class="line">                    <span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</div><div class="line">                        needsWrite = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!needsWrite) &#123;</div><div class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            backupExistsTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!backupFileExists) &#123;</div><div class="line">            <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                Log.e(TAG, <span class="string">"Couldn't rename file "</span> + mFile</div><div class="line">                      + <span class="string">" to backup file "</span> + mBackupFile);</div><div class="line">                mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mFile.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attempt to write the file, delete the backup and return true as atomically as</span></div><div class="line">    <span class="comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span></div><div class="line">    <span class="comment">// from the backup.</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            outputStreamCreateTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</div><div class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str); <span class="comment">//将数据写入文件</span></div><div class="line"></div><div class="line">        writeTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        FileUtils.sync(str);</div><div class="line"></div><div class="line">        fsyncTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            setPermTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</div><div class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                mStatTimestamp = stat.st_mtime;</div><div class="line">                mStatSize = stat.st_size;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</div><div class="line">            <span class="comment">// Do nothing</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            fstatTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Writing was successful, delete the backup file if there is one.</span></div><div class="line">        mBackupFile.delete(); <span class="comment">//删除备份文件</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            deleteTime = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mDiskStateGeneration = mcr.memoryStateGeneration; <span class="comment">//更新磁盘状态代数</span></div><div class="line"></div><div class="line">        mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>); <span class="comment">//设置结果</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">            Log.d(TAG, <span class="string">"write: "</span> + (existsTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (backupExistsTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (outputStreamCreateTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (writeTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (fsyncTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (setPermTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (fstatTime - startTime) + <span class="string">"/"</span></div><div class="line">                    + (deleteTime - startTime));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</div><div class="line">        mSyncTimes.add(Long.valueOf(fsyncDuration).intValue());</div><div class="line">        mNumSync++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG || mNumSync % <span class="number">1024</span> == <span class="number">0</span> || fsyncDuration &gt; MAX_FSYNC_DURATION_MILLIS) &#123;</div><div class="line">            mSyncTimes.log(TAG, <span class="string">"Time required to fsync "</span> + mFile + <span class="string">": "</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Clean up an unsuccessfully written file</span></div><div class="line">    <span class="keyword">if</span> (mFile.exists()) &#123;</div><div class="line">        <span class="keyword">if</span> (!mFile.delete()) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"Couldn't clean up partially-written file "</span> + mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>writeToFile</code>方法是<code>commit()</code>和<code>apply()</code>公用的. 接下来说说<code>commit()</code>会走的流程: 首先将当前文件备份, 接着写入磁盘, 最后删除备份文件.</p>
<p>经过前面的分析, 我们可以看出, <code>commit()</code>方法是以同步的方式将数据写入磁盘.</p>
<blockquote>
<h3 id="提交数据apply"><a href="#提交数据apply" class="headerlink" title="提交数据apply"></a>提交数据apply</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory(); <span class="comment">//将数据提交到内存</span></div><div class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    mcr.writtenToDiskLatch.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;</div><div class="line">                    Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</div><div class="line">                            + <span class="string">" applied after "</span> + (System.currentTimeMillis() - startTime)</div><div class="line">                            + <span class="string">" ms"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    QueuedWork.addFinisher(awaitCommit);</div><div class="line"></div><div class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                awaitCommit.run();</div><div class="line">                QueuedWork.removeFinisher(awaitCommit);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable); <span class="comment">//写入磁盘</span></div><div class="line"></div><div class="line">    <span class="comment">// Okay to notify the listeners before it's hit disk</span></div><div class="line">    <span class="comment">// because the listeners should always get the same</span></div><div class="line">    <span class="comment">// SharedPreferences instance back, which has the</span></div><div class="line">    <span class="comment">// changes reflected in memory.</span></div><div class="line">    notifyListeners(mcr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>apply()</code>的逻辑跟<code>commit()</code>一样, 只不过, 写入磁盘的方式不一样, 下面我们只分析写入磁盘的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></div><div class="line">                              <span class="keyword">final</span> Runnable postWriteRunnable) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr, isFromSyncCommit);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></div><div class="line">    <span class="comment">// the current thread.</span></div><div class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于传入的<code>Runnable</code>不为<code>null</code>, 所以<code>isFromSyncCommit</code>为<code>false</code>. 最后会调用<code>QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(Runnable work, <span class="keyword">boolean</span> shouldDelay)</span> </span>&#123;</div><div class="line">    Handler handler = getHandler();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (sLock) &#123;</div><div class="line">        sWork.add(work);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (shouldDelay &amp;&amp; sCanDelay) &#123;</div><div class="line">            handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>QueueWork</code>封装了<code>HandlerThread</code>和<code>Handler</code>. 用来处理<code>apply()</code>的异步写入的请求.</p>
<p>在<code>queue</code>方法中, 发送了一条延迟消息. 延迟时间为100毫秒.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWorkHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_RUN = <span class="number">1</span>;</div><div class="line"></div><div class="line">    QueuedWorkHandler(Looper looper) &#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.what == MSG_RUN) &#123;</div><div class="line">            processPendingWork();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>QueuedWorkHandler</code>接受到消息时, 调用<code>processPendingWork()</code>处理异步写入请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPendingWork</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        startTime = System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (sProcessingWork) &#123;</div><div class="line">        LinkedList&lt;Runnable&gt; work;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</div><div class="line">            work = (LinkedList&lt;Runnable&gt;) sWork.clone();</div><div class="line">            sWork.clear();</div><div class="line"></div><div class="line">            <span class="comment">// Remove all msg-s as all work will be processed now</span></div><div class="line">            getHandler().removeMessages(QueuedWorkHandler.MSG_RUN);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (work.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (Runnable w : work) &#123;</div><div class="line">                w.run(); <span class="comment">//调用Runnable的run方法</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                Log.d(LOG_TAG, <span class="string">"processing "</span> + work.size() + <span class="string">" items took "</span> +</div><div class="line">                        +(System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>processPendingWork()</code>中会循环调用<code>Runnable</code>中的<code>run</code>方法. 现在我们回到之前的<code>Runnable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</div><div class="line">                writeToFile(mcr, isFromSyncCommit); <span class="comment">//写入文件</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                mDiskWritesInFlight--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                postWriteRunnable.run();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;</div><div class="line">     <span class="keyword">long</span> startTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> existsTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> backupExistsTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> outputStreamCreateTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> writeTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> fsyncTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> setPermTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> fstatTime = <span class="number">0</span>;</div><div class="line">     <span class="keyword">long</span> deleteTime = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">         startTime = System.currentTimeMillis();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">boolean</span> fileExists = mFile.exists();</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">         existsTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">         <span class="comment">// Might not be set, hence init them to a default value</span></div><div class="line">         backupExistsTime = existsTime;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Rename the current file so it may be used as a backup during the next read</span></div><div class="line">     <span class="keyword">if</span> (fileExists) &#123;</div><div class="line">         <span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">         <span class="comment">// Only need to write if the disk state is older than this commit</span></div><div class="line">         <span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</div><div class="line">             <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">                 needsWrite = <span class="keyword">true</span>;</div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                     <span class="comment">// No need to persist intermediate states. Just wait for the latest state to</span></div><div class="line">                     <span class="comment">// be persisted.</span></div><div class="line">                     <span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123; <span class="comment">//如果有多次提交的话, 只处理最后一次提交的数据</span></div><div class="line">                         needsWrite = <span class="keyword">true</span>;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (!needsWrite) &#123;</div><div class="line">             mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             backupExistsTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (!backupFileExists) &#123;</div><div class="line">             <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                 Log.e(TAG, <span class="string">"Couldn't rename file "</span> + mFile</div><div class="line">                       + <span class="string">" to backup file "</span> + mBackupFile);</div><div class="line">                 mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             mFile.delete();</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Attempt to write the file, delete the backup and return true as atomically as</span></div><div class="line">     <span class="comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span></div><div class="line">     <span class="comment">// from the backup.</span></div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         FileOutputStream str = createFileOutputStream(mFile);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             outputStreamCreateTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</div><div class="line">             mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line"></div><div class="line">         writeTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">         FileUtils.sync(str);</div><div class="line"></div><div class="line">         fsyncTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">         str.close();</div><div class="line">         ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             setPermTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</div><div class="line">             <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                 mStatTimestamp = stat.st_mtime;</div><div class="line">                 mStatSize = stat.st_size;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</div><div class="line">             <span class="comment">// Do nothing</span></div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             fstatTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// Writing was successful, delete the backup file if there is one.</span></div><div class="line">         mBackupFile.delete();</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             deleteTime = System.currentTimeMillis();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         mDiskStateGeneration = mcr.memoryStateGeneration;</div><div class="line"></div><div class="line">         mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">             Log.d(TAG, <span class="string">"write: "</span> + (existsTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (backupExistsTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (outputStreamCreateTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (writeTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (fsyncTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (setPermTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (fstatTime - startTime) + <span class="string">"/"</span></div><div class="line">                     + (deleteTime - startTime));</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</div><div class="line">         mSyncTimes.add(Long.valueOf(fsyncDuration).intValue());</div><div class="line">         mNumSync++;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (DEBUG || mNumSync % <span class="number">1024</span> == <span class="number">0</span> || fsyncDuration &gt; MAX_FSYNC_DURATION_MILLIS) &#123;</div><div class="line">             mSyncTimes.log(TAG, <span class="string">"Time required to fsync "</span> + mFile + <span class="string">": "</span>);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</div><div class="line">         Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">         Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Clean up an unsuccessfully written file</span></div><div class="line">     <span class="keyword">if</span> (mFile.exists()) &#123;</div><div class="line">         <span class="keyword">if</span> (!mFile.delete()) &#123;</div><div class="line">             Log.e(TAG, <span class="string">"Couldn't clean up partially-written file "</span> + mFile);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>apply()</code>中将数据写入磁盘跟<code>commit()</code>是有区别的. 前者的写入方式是异步写入, 也就是在<code>QueueWork</code>所在的线程. 所以当进行多次提交时, 只会将最后一次提交的数据写入磁盘.</p>
<blockquote>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhmk9nwkfj30dc09nt95.jpg" alt=""></p>
<p><code>SharedPreferences</code>内部对数据的储存是经过内存-硬盘这样的两级缓存. 每次<code>commit</code>或者<code>apply</code>的时候, 都会先写入内存, 接着再将内存写入硬盘.</p>
<p><code>commit()</code>方法是以同步的方式提交到内存. 具体如下图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhmznz2a7j30el0ahwf0.jpg" alt=""></p>
<p>两次<code>commit</code>的提交是串行化的, <code>commit#2</code>必须要等待<code>commit#1</code>写入磁盘后才能写.</p>
<p>与<code>commit()</code>方法不同. <code>apply()</code>是以异步的形式将数据写入磁盘, 也就是说: 写进内存是同步的, 但是内存写进磁盘是异步的, 当进行多次提交时, 后提交的会覆盖前面提交到内存的数据, 最后只有最后一次的提交才会被写进磁盘. 具体如下图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1flhnaf4orxj30ga0anaak.jpg" alt=""></p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><p><code>SharedPreferences</code>适合储存一些小数据的情景. 如果储存的数据太大的话, 第一次加载时, 有可能会阻塞到主线程.</p>
</li>
<li><p><code>editor()</code>每次调用都会生成一个<code>Editor</code>实例, 所以在封装的时候要注意, 最好缓存起来, 不然频繁调用的话, 有可能会出现内存抖动.</p>
</li>
<li><p><code>commit</code>是在当前线程以同步的方法写入磁盘, 如果在主线程连续多次提交的话, 有可能阻塞主线程.</p>
</li>
<li><p><code>apply</code>是先将数据同步写到内存, 然后将内存的数据异步写入磁盘, 并且只会写入最后一次提交的数据, 这样磁盘的读写次数就减少了, 所以<code>apply</code>会比<code>commit</code>高效.</p>
</li>
<li><p><code>SharedPreferences</code>是不支持多进程的, 如果在多进程下读写的话, 可能出现脏读现象. 如果需要在多进程下读写数据的话, 可以借用<code>ContentProvider</code>来实现, 数据源设置为<code>SharedPreferences</code>即可.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1flhnrmq40dj30m80b4q9b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;hea
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="Android#数据持久化#SP" scheme="http://cristianoro7.github.io/tags/Android-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-SP/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C中的并发工具类</title>
    <link href="http://cristianoro7.github.io/2017/10/31/J.U.C%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://cristianoro7.github.io/2017/10/31/J.U.C中的并发工具类/</id>
    <published>2017-10-31T15:33:44.648Z</published>
    <updated>2017-10-31T15:33:44.648Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fl1ikq8wyhj30m80b4qi7.jpg" alt=""></p>
<p>在<code>Java</code>的<code>J.U.C</code>包中提供了几个并发编程中非常有用工具类, 例如: <code>Semaphore</code>, <code>CountDownLatch</code>和<code>CyclicBarrier</code>. 这次准备来介绍这三个工具类.</p>
<blockquote>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2></blockquote>
<p><code>Semaphore</code>中文意思为: 信号量. 它主要用来维护一组有限的资源. 比如数据库连接, <code>Socket</code>连接. 信号量的使用方式很简单, 在构造函数中, 传入你需要维护的有限资源的数量, 每次需要申请资源时, 调用<code>acquire()</code>, 接着做一些业务逻辑, 完成后, 再调用<code>release()</code>归还有限资源. 如果有限资源被申请完了后, 还调用<code>acquire()</code>的话, 调用的线程会被阻塞, 直到其他线程归还资源后, 才从阻塞中返回.</p>
<blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>Semaphore</code>的原理很简单. 基于<code>AQS</code>构建的. 它内部维护一个状态计数器, 每次调用申请资源时, 都会递减状态计数器值, 归还资源时, 会增加状态计数器的值. 当状态计数器为负数时, 说明有限资源已经被申请完了, 这时<code>AQS</code>会将申请不到资源的线程添加进同步队列中, 并挂起线程, 直到其他线程唤醒.</p>
<p>由于<code>Semaphore</code>也是基于<code>AQS</code>实现的, 所以它支持不响应中断, 响应中断和响应中断且超时获取资源这三种类型. 同时获取资源的方式支持公平性和非公平性的获取. 默认的实现是非公平的获取方式.</p>
<blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面给出一个简单的例子: 数据库连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DBPool pool = <span class="keyword">new</span> DBPool(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        doSomeWork();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</div><div class="line">        Connection connection = pool.get();</div><div class="line">        <span class="comment">//访问数据库</span></div><div class="line">        pool.release(connection);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBPool</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Semaphore semaphore;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Connection[] pool;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] connectionFlags;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(size, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">boolean</span> isFair)</span> </span>&#123;</div><div class="line">        semaphore = <span class="keyword">new</span> Semaphore(size, isFair);</div><div class="line">        initPool(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        pool = <span class="keyword">new</span> Connection[size];</div><div class="line">        connectionFlags = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            pool[i] = DBDriver.create();</div><div class="line">            connectionFlags[i] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        semaphore.acquireUninterruptibly();</div><div class="line">        <span class="keyword">return</span> fetchConnection();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">fetchConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pool.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!connectionFlags[i]) &#123;</div><div class="line">                connectionFlags[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span> pool[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection connection)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectionFlags.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (pool[i] == connection &amp;&amp; connectionFlags[i]) &#123;</div><div class="line">                connectionFlags[i] = <span class="keyword">false</span>;</div><div class="line">                semaphore.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DBDriver</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">static</span> Connection <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//fake connection</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2></blockquote>
<p>当一个或者多个线程的执行需要等待其他线程执行完后才能执行的话, <code>CountDownLatch</code>能够很好的完成任务.</p>
<p><code>CountDownLatch</code>的使用方式很简单, 只要在构造函数中传入需要等待执行完的线程数, 在需要等待其他线程执行完才执行的线程调用<code>await()</code>, 如果此时其他线程还没执行完的话, 该操作会阻塞, 直到每个线程中调用<code>countDown()</code>方法来表示自己已经完成了, 最后被阻塞的线程才会从<code>await()</code>中返回.</p>
<blockquote>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面是<code>CountDownLatch</code>的一个例子: 工头要带搬砖工去搬砖, 所以工头必须得等他们都上车了才可以开车.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); <span class="comment">//需要等待10个搬砖工上车</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(countDownLatch)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            countDownLatch.await(); <span class="comment">//等待搬砖工上车完才开车.</span></div><div class="line">            System.out.println(<span class="string">"OK, 搬砖工已经上车了, 开车去搬砖"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            getOnBus();</div><div class="line">            countDownLatch.countDown(); <span class="comment">//执行完了.</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getOnBus</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"搬砖工上车了!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>CountDownLatch</code>内部实现的原理很简单. 它基于<code>AQS</code>, 通过构造函数传入的<code>int</code>数值, 来维护一个计数器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sync(<span class="keyword">int</span> count) &#123;</div><div class="line">    setState(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入<code>count</code>被设置为<code>AQS</code>内部的状态值.</p>
<p>接下来看看<code>await()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>await()</code>中最终会回调<code>tryAcquireShared(int acquires)</code>. 该方法实现的逻辑: 如果状态不为0的话, 说明还有其他线程还没执行完, 所以返回-1告诉<code>AQS</code>阻塞当前线程. 如果状态为0, 说明全部线程已经执行完, 此时返回1, 告诉<code>AQS</code>不用阻塞线程.</p>
<p>当线程被阻塞后, 需要它等待的线程执行完才会被唤醒. 被等待的线程调用<code>countDown()</code>表示自己已经完成.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>countDown()</code>通过循环和<code>CAS</code>来更新同步状态, 当最后一个线程也调用了该方法的话, 同步状态为0. 此时被阻塞的线程会得以唤醒.</p>
<blockquote>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2></blockquote>
<p><code>CyclicBarrier</code>允许一组线程互相等待其到达一个同步点的时候才继续执行. 同时<code>CyclicBarrier</code>具有重用性, 当等待的一组线程被释放后(成功或者失败), 它能够被继续使用. 这点和<code>CountDownLatch</code>不一样, <code>CountDownLatch</code>只能够使用一次.</p>
<p><code>CyclicBarrier</code>遵循<code>all-or-none</code>的损坏模式, 相互等待的一组线程如果其中一个线程被中断的或者等待超时的话, 其他线程也将失败. 简单来讲, 要么全部成功, 要么全部失败.</p>
<p><code>CyclicBarrier</code>还支持一组等待的线程被释放后, 执行传入的<code>Runnable</code>.</p>
<blockquote>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3></blockquote>
<p>下面给出一个例子. 游戏玩家都必须等待各自准备好才能开始.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(<span class="string">"玩家-"</span> + i, cyclicBarrier)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, CyclicBarrier cyclicBarrier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name + <span class="string">"已经准备好"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cyclicBarrier.await(); <span class="comment">//等待其他玩家</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还可以在<code>CyclicBarrier</code>的构造函数中传入一个<code>Runnable</code>, 当所有线程都到达同步点后, 该任务会被执行, 默认是最后一个到达的线程执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> ReadyFinish());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(<span class="string">"玩家-"</span> + i, cyclicBarrier)).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, CyclicBarrier cyclicBarrier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name + <span class="string">"已经准备好"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cyclicBarrier.await(); <span class="comment">//等待其他玩家</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadyFinish</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"所以玩家已经准备完了, 开始游戏"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p><code>CyclicBarrier</code>内部基于<code>ReentrantLock</code>和<code>Condition</code>实现的. 到达同步点的线程会被暂时挂在条件队列中等待.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//支持重用性, 表示第几代</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> broken = <span class="keyword">false</span>; <span class="comment">//是否成功等待所有线程到达同步点</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//确保线程安全</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition(); <span class="comment">//到达安全点的线程会被挂在等待队列中</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties; <span class="comment">//互相等待的一组线程</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand; <span class="comment">//全部线程到达后, 执行的一个任务</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//记录还有多少个线程没到达同步点</span></div></pre></td></tr></table></figure>
<p>上面是<code>CyclicBarrier</code>中的实例域, 具体讲解看注释.</p>
<p>下面我们来看看线程到达同步点时的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</div><div class="line">           TimeoutException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">//失败</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//线程被中断了, 失败</span></div><div class="line">            breakBarrier();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> index = --count; <span class="comment">//获得还没到达的线程数</span></div><div class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                    command.run();</div><div class="line">                ranAction = <span class="keyword">true</span>;</div><div class="line">                nextGeneration();</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!ranAction)</div><div class="line">                    breakBarrier();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!timed)</div><div class="line">                    trip.await(); <span class="comment">//挂起线程</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</div><div class="line">                    nanos = trip.awaitNanos(nanos); <span class="comment">//挂起线程</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; <span class="comment">//中断失败</span></div><div class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> ie;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                    <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">//有一个线程失败了, 所有线程也跟着失败</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">//如果当前代对象不相等的话, 证明已经更新代数了.</span></div><div class="line">                <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得还没到达的线程数, 如果不为0的话, 说明还有线程没到达, 这时, 应该阻塞线程. 当最后一个线程到达时, <code>index</code>为0, 此时说明全部线程已经到达, 所以进入唤醒等待线程的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">    <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">            command.run();</div><div class="line">        ranAction = <span class="keyword">true</span>;</div><div class="line">        nextGeneration();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!ranAction)</div><div class="line">            breakBarrier();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</div><div class="line">    trip.signalAll(); <span class="comment">//唤醒在条件队列中等待的线程</span></div><div class="line">    <span class="comment">//重置CyclicBarrier, 使得它可以被复用</span></div><div class="line">    count = parties;</div><div class="line">    generation = <span class="keyword">new</span> Generation();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果构造函数中有传入<code>Runnable</code>对象的话, 最后一个线程会执行该<code>Runnable</code>对象, 然后进入<code>nextGeneration()</code>中唤醒在同步点等待的线程, 最后更新当前年代.</p>
<p>如果等待线程在等待的过程中有被中断或者等待超时的话, 会执行<code>breakBarrier()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</div><div class="line">    generation.broken = <span class="keyword">true</span>;</div><div class="line">    count = parties;</div><div class="line">    trip.signalAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先设置当代已经被破坏了, 这样可以让其他线程都失败.然后唤醒在等待队列上等待的线程. 被唤醒的线程会检查<code>broken</code>字段, 最后抛出异常.</p>
<p>如果等待的过程中没有超时或者被中断的话, 其他线程从阻塞的方法中返回后, 当前的<code>generation</code>是否相等, 不是的话, 说明已经进入下一代了,所以返回一个<code>index</code>, 该<code>index</code>表示这线程是第几个到达同步点的.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<p><code>Semaphore</code>用来维护一组有限的资源, 每次申请资源时, 都会递减资源数, 如果资源没了的话, 会阻塞当前线程, 直到有可用的资源为止. 有限的资源可以是: 数据库连接, <code>Socket</code>连接.</p>
<p><code>CountDownLatch</code>适用于 : 当一个或者多个线程的执行需要等待其他线程执行完后才可以执行的场景.</p>
<p>多个线程需要等待彼此到达一个同步点时, 才继续执行, 这种情况下, 可以用<code>CyclicBarrier</code>. 而且它具有重用行, 可被多次使用, 这点和<code>CountDownLatch</code>不一样, 后者只能被使用一次.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fl1ikq8wyhj30m80b4qi7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;J.U.C&lt;/code&gt;包中提供了几个并发
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#工具类" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock和ReentrantReadWriteLock详解</title>
    <link href="http://cristianoro7.github.io/2017/10/31/ReentrantLock%E5%92%8CReentrantReadWriteLock%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cristianoro7.github.io/2017/10/31/ReentrantLock和ReentrantReadWriteLock详解/</id>
    <published>2017-10-31T15:33:33.368Z</published>
    <updated>2017-10-31T15:33:33.368Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkz6p5rdydj30m80b47at.jpg" alt=""></p>
<p><code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>是<code>Java</code>并发包中提供的锁, 他们都属于可重入锁.但是<code>ReentrantLock</code>是一种悲观锁, 它总是假设竞争条件总是会发生, 所以它同一时刻只能有一个线程获得锁, 而<code>ReentrantReadWriteLock</code>是属于乐观锁, 它假设竞争条件并不会经常发生, 所以同一时刻能让多个线程执行.</p>
<p>他们的一个共同点是: 都支持公平和非公平性的获取锁.</p>
<blockquote>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h2></blockquote>
<p>前面分析过<code>AQS</code>, 它是并发包中的锁的基本骨架. 所以<code>ReentrantLock</code>内部也是基于<code>AQS</code>实现的. <code>ReentrantLock</code>内部将获取锁和释放锁的方法都代理给其内部类: <code>Sync</code>, 而<code>Sync</code>是继承<code>AQS</code>的, 为了支持公平性和非公平性的锁, <code>Sync</code>有两个子类, 分别为<code>NonfairSync</code>和<code>FairSync</code>, 他们都重写了<code>tryAcquire(int)</code>方法来实现自己公平和非公平获取锁的逻辑, 由于释放锁的逻辑都一样, 因此<code>tryRelease(int)</code>由<code>Sync</code>重写.</p>
<p>既然<code>ReentrantLock</code>基于<code>AQS</code>实现的, 所以它支持三种方式获取锁:</p>
<ul>
<li><p><code>lock()</code>: 不支持中断的获取锁</p>
</li>
<li><p><code>lockInterruptibly()</code>: 响应中断地获取锁</p>
</li>
<li><p><code>tryLock(long timeout, TimeUnit unit)</code>: 响应中断并且支持超时获取锁.</p>
</li>
</ul>
<p>由于三种方式在<code>AQS</code>中已经分析过, 所以这里只分析<code>lock()</code>. 主要分析公平性和非公平性地获取锁的逻辑</p>
<blockquote>
<h3 id="NonfairSync-非公平锁"><a href="#NonfairSync-非公平锁" class="headerlink" title="NonfairSync: 非公平锁"></a>NonfairSync: 非公平锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是非公平性获取锁的逻辑: 如果同步状态为0的话, 证明锁还没被获取, 所以利用<code>CAS</code>来获取同步状态, 成功的话, 设置当前线程持有锁. 如果同步状态不为0的话, 判断获取锁的线程是否为当前线程, 如果是的话, 更新同步状态, 从这里也可以看出来<code>ReentrantLock</code>是可重入锁.</p>
<blockquote>
<h3 id="FairSync-公平锁"><a href="#FairSync-公平锁" class="headerlink" title="FairSync: 公平锁"></a>FairSync: 公平锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平和非公平的区别是: 公平性意味着哪个线程等待的时间更长, 就应该首先让它获取锁, 也就是获取锁的顺序必须是<code>FIFO</code>. 所以每次获取同步状态时, 都会调用<code>hasQueuedPredecessors()</code>判断当前节点是不是有前驱节点, 如果有的话, 证明已经有线程在等待, 因此不获取同步状态, 这样就实现了公平性地获取锁.<br>至于其他逻辑和前面的大致一样.</p>
<blockquote>
<h3 id="tryRelease-int-releases"><a href="#tryRelease-int-releases" class="headerlink" title="tryRelease(int releases)"></a>tryRelease(int releases)</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平锁和非公平锁的释放锁的逻辑都是一样的, 由于<code>ReentrantLock</code>是可重入的, 因此只有当同步状态为0的时候才需要将当前持有锁的线程设置为<code>null</code>, 也就是释放锁.</p>
<blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></blockquote>
<p><code>ReentrantLock</code>内部默认是非公平锁, 因为非公平锁的吞吐量会比公平锁高, 这是由于非公平锁每次获取锁的时候, 不需要理会当前节点是否有前驱节点, 也就是前面有线程在等待, 只要被唤醒了, 并且能够获取同步状态的话, 就可以获取. 而公平锁每次获取锁时, 当前节点必须是头节点, 也就是它的前面没有线程在等待. 在这种情况下, 如果非头结点的线程被唤醒的话或者是刚刚释放锁的线程又立刻获取锁, 是不能获取锁的, 只能再进行多一次调度. 因此, 非公平锁的吞吐量会比公平锁的高.</p>
<blockquote>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2></blockquote>
<p>与<code>ReentrantLock</code>不同,  <code>ReentrantReadWriteLock</code>的伸缩性要强一些, 因为它将读写锁分离. 在进行读操作的时候, 多个线程是可以同时获取锁的, 这样能更大地提高并发度. 下面是<code>ReentrantReadWriteLock</code>的特性</p>
<ul>
<li><p>公平性: 与<code>ReentrantLock</code>一样, <code>ReentrantReadWriteLock</code>内部也是支持公平性和非公平性锁, 默认是非公平性的锁.</p>
</li>
<li><p>可重入: <code>ReentrantReadWriteLock</code>支持一个线程多次获取锁.</p>
</li>
<li><p>读写分离: <code>ReentrantReadWriteLock</code>内部维护两个锁, 一个是读锁, 另外一个是写锁. 在读多写少的情况下, <code>ReentrantReadWriteLock</code>能发挥更大的并发度.  因为<code>ReentrantReadWriteLock</code>支持多个读线程同时获取锁. <code>ReentrantReadWriteLock</code>的读写规则: 当一个写线程获得锁后, 其他线程不能获取锁. 当读线程获得锁后, 其他的读线程可以获得锁, 但是写线程不能.</p>
</li>
<li><p>锁降级: 当一个线程持有写锁后, 再获取读锁, 然后释放写锁, 这个过程称为一个锁的降级. <code>ReentrantReadWriteLock</code>不支持锁的升级, 因为锁的升级有可能带来竞争条件的问题.</p>
</li>
</ul>
<blockquote>
<h3 id="读写同步状态设计"><a href="#读写同步状态设计" class="headerlink" title="读写同步状态设计"></a>读写同步状态设计</h3></blockquote>
<p><code>ReentrantReadWriteLock</code>内部也是基于<code>AQS</code>实现的, 但是<code>AQS</code>内只有一个<code>int</code>类型的变量, 那么<code>ReentrantReadWriteLock</code>怎么表示两个同步状态呢? 答案是通过位运算来处理.</p>
<p><code>int</code>类型有32位, <code>ReentrantReadWriteLock</code>将高16位作为读状态, 低16位作为写状态. 这样每次通过一定的位运算来获取高16位或者低16位.</p>
<blockquote>
<h3 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h3></blockquote>
<p>写锁是一种互斥锁, 同一个时刻锁只能被一个线程获取.</p>
<blockquote>
<h4 id="非公平性写锁"><a href="#非公平性写锁" class="headerlink" title="非公平性写锁"></a>非公平性写锁</h4></blockquote>
<p>跟<code>ReentrantLock</code>一样, <code>ReentrantReadWriteLock</code>内部支持三种类型的获取, 因此下面只分析一种.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>lock()</code>方法中, 会调用<code>AQS</code>的<code>acquire(int)</code>, 在<code>acquire(int)</code>中又会回调子类重写的模板方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Walkthrough:</div><div class="line">     * 1. If read count nonzero or write count nonzero</div><div class="line">     *    and owner is a different thread, fail.</div><div class="line">     * 2. If count would saturate, fail. (This can only</div><div class="line">     *    happen if count is already nonzero.)</div><div class="line">     * 3. Otherwise, this thread is eligible for lock if</div><div class="line">     *    it is either a reentrant acquire or</div><div class="line">     *    queue policy allows it. If so, update state</div><div class="line">     *    and set owner.</div><div class="line">     */</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">//获取写的同步状态</span></div><div class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></div><div class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        <span class="comment">// Reentrant acquire</span></div><div class="line">        setState(c + acquires);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>c != 0</code>且 <code>w(写状态)</code>为0的话, 证明读状态不为0, 说明此时获得锁的是读线程, 所以会直接返回<code>false</code>来表示获取失败. 如果<code>w != 0</code>的话, 说明此时写线程拥有锁, 此时如果拥有锁是当前线程的话, 会更新同步状态来支持可重入的特性, 可重入的次数为65535.</p>
<p>如果<code>c == 0</code>的话, 说明同步状态还没被获取, 此时应该会先调用<code>writerShouldBlock()</code>, 在非公平的写锁的实现为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非公平性的写锁默认是返回<code>false</code>, 接着利用<code>CAS</code>更新同步状态, 如果成功的话, 设置当前线程为执行线程, 否则的话返回<code>false</code>, 进入<code>AQS</code>中排队.</p>
<blockquote>
<h4 id="非公平性写锁-1"><a href="#非公平性写锁-1" class="headerlink" title="非公平性写锁"></a>非公平性写锁</h4></blockquote>
<p>公平锁和非公平锁获取锁的基本一样, 不一样的话<code>writerShouldBlock()</code>的实现不一样.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></div><div class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></div><div class="line">    <span class="comment">// thread is first in queue.</span></div><div class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></div><div class="line">    Node h = head;</div><div class="line">    Node s;</div><div class="line">    <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>公平锁每次获取锁时, 为了保证公平性, 都需要看看同步队列中是否有比当前线程等待时间更长的线程, 如果有的话, 就不能获取.</p>
<blockquote>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4></blockquote>
<p><code>ReentrantReadWriteLock</code>释放锁的逻辑跟<code>ReentrantLock</code>一样.</p>
<blockquote>
<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3></blockquote>
<p>读锁是一种共享锁, 多个读线程可以同时获取锁. 但是当读线程持有锁时, 写线程是不能持有锁的.</p>
<blockquote>
<p>非公平读锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Walkthrough:</div><div class="line">     * 1. If write lock held by another thread, fail.</div><div class="line">     * 2. Otherwise, this thread is eligible for</div><div class="line">     *    lock wrt state, so ask if it should block</div><div class="line">     *    because of queue policy. If not, try</div><div class="line">     *    to grant by CASing state and updating count.</div><div class="line">     *    Note that step does not check for reentrant</div><div class="line">     *    acquires, which is postponed to full version</div><div class="line">     *    to avoid having to check hold count in</div><div class="line">     *    the more typical non-reentrant case.</div><div class="line">     * 3. If step 2 fails either because thread</div><div class="line">     *    apparently not eligible or CAS fails or count</div><div class="line">     *    saturated, chain to version with full retry loop.</div><div class="line">     */</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</div><div class="line">        getExclusiveOwnerThread() != current)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> r = sharedCount(c);</div><div class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</div><div class="line">        r &lt; MAX_COUNT &amp;&amp;</div><div class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">            firstReader = current;</div><div class="line">            firstReaderHoldCount = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</div><div class="line">            firstReaderHoldCount++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            HoldCounter rh = cachedHoldCounter;</div><div class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</div><div class="line">                cachedHoldCounter = rh = readHolds.get();</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</div><div class="line">                readHolds.set(rh);</div><div class="line">            rh.count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取写状态, 如果写状态为不0且持有写锁的线程是当前执行的线程, 说明这是一个锁降级的操作, 因此允许继续获取同步状态.</p>
<p>如果写状态为0且<code>getExclusiveOwnerThread() != current</code>为<code>true</code>的话, 表示持有写锁的不是当前执行的线程, 所以返回-1表示失败.</p>
<p>在尝试获取同步状态前, 会先调用<code>readerShouldBlock()</code>判断是否应该阻塞读线程, 这个方法在公平和非公平锁的实现不一样.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></div><div class="line">      * block if the thread that momentarily appears to be head</div><div class="line">      * of queue, if one exists, is a waiting writer.  This is</div><div class="line">      * only a probabilistic effect since a new reader will not</div><div class="line">      * block if there is a waiting writer behind other enabled</div><div class="line">      * readers that have not yet drained from the queue.</div><div class="line">      */</div><div class="line">     <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</div><div class="line">     Node h, s;</div><div class="line">     <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">         (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</div><div class="line">         !s.isShared()         &amp;&amp;</div><div class="line">         s.thread != <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在非公平锁的实现中, 只要同步状态队列中有写线程正在等待的话, 就应该阻塞读线程, 不让其获取同步状态. 这样做是为了防止写线程出现饥饿现象.</p>
<blockquote>
<p>公平读锁</p>
</blockquote>
<p>公平读锁和非公平读锁的实现也是基本一样, 不一样的就是<code>readerShouldBlock()</code>实现不同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></div><div class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></div><div class="line">    <span class="comment">// thread is first in queue.</span></div><div class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></div><div class="line">    Node h = head;</div><div class="line">    Node s;</div><div class="line">    <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了保持公平性, 每次都是让同步队列中的队头线程获取锁, 因为队头线程等待的时间最长.</p>
<blockquote>
<p>释放读锁</p>
</blockquote>
<p>忽略一些其他的操作的话, 读锁的释放逻辑跟写锁的差不多, 都是<code>CAS</code>来更新同步状态, 不同的是, 读锁是共享锁, 必须通过循环<code>CAS</code>来保证线程安全.</p>
<blockquote>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3></blockquote>
<p><code>ReentrantReadWriteLock</code>内部维护两个锁, 一个是写锁, 另外一个是读锁. 通过将读写锁分离, 在读多写少的情况下, 更够提高程序的并发程度, 因此, <code>ReentrantReadWriteLock</code>的伸缩性要好于<code>ReentrantLock</code>. 在读多写少的情况下, 应该使用<code>ReentrantReadWriteLock</code>更为合适.</p>
<p><code>ReentrantReadWriteLock</code>只支持锁降级, 不支持锁升级. 因为锁升级有可能会出现条件竞争. 由于读锁是可以被多个线程持有的, 如果进行锁升级的话, 当写线程改变共享变量的状态时, 其他读线程有可能感知不到.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fkz6p5rdydj30m80b47at.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;和&lt;code&gt;ReentrantRead
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#Lock" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-Lock/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer中的ConditionObject剖析</title>
    <link href="http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer%E4%B8%AD%E7%9A%84ConditionObject%E5%89%96%E6%9E%90/"/>
    <id>http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer中的ConditionObject剖析/</id>
    <published>2017-10-31T15:33:18.156Z</published>
    <updated>2017-10-31T15:33:18.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer中的ConditionObject剖析"><a href="#AbstractQueuedSynchronizer中的ConditionObject剖析" class="headerlink" title="AbstractQueuedSynchronizer中的ConditionObject剖析"></a>AbstractQueuedSynchronizer中的ConditionObject剖析</h1><p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktlv07v17j30jg0dwngp.jpg" alt=""></p>
<p>在多线程环境中, 有时候, 一个线程的执行是需要等待一个条件发生后才能执行的. 在经典的生产者和消费者模式中, 如果缓冲区满后, 生产者是不能向缓冲区投放<code>item</code>的, 它需要等待一个条件: <code>缓冲区不为满的状态</code>. 同理, 如果缓冲区为空时, 消费者是不能消费<code>item</code>的, 它需要等待一个条件: <code>缓冲区不为空</code>. 一个线程需要等待一定的条件发生, 这个条件往往是别的线程触发的, 这就是经典的<code>等待/唤醒</code>模式.</p>
<p>在<code>JDK1.5</code>之前要实现这种模式的话, 只能够借助<code>synchronized</code>关键字和<code>Object</code>的对象锁来实现. 在<code>1.5</code>之后, 可以利用基于<code>AQS</code>实现的锁和<code>AQS</code>内部的<code>ConditionObject</code>来实现. 下面以<code>ReentrantLock</code>为例实现一个等待/唤醒模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObjectTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Condition isEmpty = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Condition isFull = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        ReentrantLock reentrantLock = lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">if</span> (count &gt;= MAX_LENGTH) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                isEmpty.await(); <span class="comment">//等待一个缓冲区不为满的条件</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        queue.add(i);</div><div class="line">        count++;</div><div class="line">        isFull.signal(); <span class="comment">//通知缓冲区已经不为空</span></div><div class="line">        reentrantLock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</div><div class="line">        ReentrantLock reentrantLock = lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                isFull.await(); <span class="comment">//等待缓冲区不为空的条件</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = queue.peek(); <span class="comment">//消费</span></div><div class="line">        count--;</div><div class="line">        isEmpty.signal(); <span class="comment">//通知缓冲区不为满</span></div><div class="line">        reentrantLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中定义了两个条件, 一个是缓冲区为空的条件, 另外一个是缓冲区为满的条件. 当队列达到最大长度时, 也就是缓冲区满了, 此时生产者调用了<code>isEmpty.await()</code>来等待一个缓冲区不为满的条件, 因此线程会暂时被挂起. 这个条件是由消费者消费了一个<code>item</code>后调用<code>isEmpty.signal()</code>是触发的. 触发了这个条件后, 会唤醒处于等待的生产者线程, 使它从<code>isEmpty.await()</code>中返回. 至于当缓冲区为满时的情况原理是一样的, 这里不多分析. 下面主要分析<code>AQS</code>内部怎么实现等待通知模式的.</p>
<blockquote>
<h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2></blockquote>
<p>一般而言, 线程是否需要等待一个条件的判断, 这个判断往往是访问一个共享变量, 在前面的例子中, 这个共享变量是<code>缓冲区</code>. 因此, 每次等待一个条件或者触发一个条件时, 都必须先获得锁. 这也解释为什么<code>ConditionObject</code>会作为<code>AQS</code>的内部类.</p>
<blockquote>
<h2 id="ConditionObject的等待-通知方法"><a href="#ConditionObject的等待-通知方法" class="headerlink" title="ConditionObject的等待/通知方法"></a>ConditionObject的等待/通知方法</h2></blockquote>
<p><code>ConditionObject</code>中的等待方法支持的类型跟<code>AQS</code>中一样, 都支持不可中断, 可中断, 超时三种类型.</p>
<blockquote>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4></blockquote>
<ul>
<li><p><code>awaitUninterruptibly()</code>: 不可中断的等待一个条件</p>
</li>
<li><p><code>await()</code>: 响应中断的等待一个条件</p>
</li>
<li><p><code>awaitNanos(long nanosTimeout)</code>: 超时等待一个条件, 如果超过指定的等待时间的话, 会直接返回. 超时等待还有两个重载方法, 这里只列出一个.</p>
</li>
</ul>
<blockquote>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4></blockquote>
<ul>
<li><p><code>signal()</code>: 从等待队列中唤醒一个正在等待的线程</p>
</li>
<li><p><code>signalAll()</code>: 唤醒等待队列中的全部线程.</p>
</li>
</ul>
<blockquote>
<h4 id="awaitUninterruptibly-解读"><a href="#awaitUninterruptibly-解读" class="headerlink" title="awaitUninterruptibly()解读"></a><code>awaitUninterruptibly()</code>解读</h4></blockquote>
<p>三种类型的等待方法的实现逻辑跟<code>AQS</code>中的获取同步状态的三种类型差不多, 这里只分析<code>awaitUninterruptibly()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node node = addConditionWaiter(); <span class="comment">//添加进等待队列, 等待队列不是AQS中的同步队列</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放同步状态, 相当于释放锁</span></div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//判断节点是不是在同步队列中, 也就是等待获取同步状态的队列</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">//不在同步队列的话, 证明已经在等待队列了, 需要等待一个条件, 因此挂起线程, 等待其他线程唤醒</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">//被唤醒后, 重新竞争同步状态, 也就是竞争锁</span></div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于每次调用这个方法时, 必定时已经获取了锁的, 所以不用控制同步, 实现起来比较简单. 首先将当前节点添加进等待队列, 接着释放同步状态, 也就是释放锁, 它准备要被挂起了, 挂起前必须释放同步状态, 不然有可能引起死锁. 然后, 判断节点是否存在同步队列中, 如果不存在的话,证明已经被添加进等待队列中, 此时进入<code>While</code>循环挂起线程. 接下来执行到这里就停了. 需要等待其他线程触发它等待的条件.</p>
<blockquote>
<h4 id="signal-解读"><a href="#signal-解读" class="headerlink" title="signal()解读"></a><code>signal()</code>解读</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    Node first = firstWaiter;</div><div class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">        doSignal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次都是释放等待队列中的第一个节点, 说明等待队列是一个<code>FIFO</code>队列. 释放的主要逻辑都在<code>doSignal(first)</code>中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">    do &#123;</div><div class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</div><div class="line">            lastWaiter = <span class="keyword">null</span>;</div><div class="line">        first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</div><div class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>doSignal()</code>中会调用<code>transferForSignal(first)</code>将等待队列中的节点移动到同步队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If cannot change waitStatus, the node has been cancelled.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Splice onto queue and try to set waitStatus of predecessor to</div><div class="line">     * indicate that thread is (probably) waiting. If cancelled or</div><div class="line">     * attempt to set waitStatus fails, wake up to resync (in which</div><div class="line">     * case the waitStatus can be transiently and harmlessly wrong).</div><div class="line">     */</div><div class="line">    Node p = enq(node);</div><div class="line">    <span class="keyword">int</span> ws = p.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">        LockSupport.unpark(node.thread);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过<code>CAS</code>设置节点的状态, 如果设置失败的话, 说明节点已经被取消. 接着调用<code>enq(node)</code>方法, 将节点移动到同步队列中, 然后设置节点的状态为<code>SIGNAL</code>.最后唤醒线程. 唤醒后, 在之前的等待方法中, 会被执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node node = addConditionWaiter(); <span class="comment">//添加进等待队列, 等待队列不是AQS中的同步队列</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放同步状态, 相当于释放锁</span></div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//判断节点是不是在同步队列中, 也就是等待获取同步状态的队列</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">//不在同步队列的话, 证明已经在等待队列了, 需要等待一个条件, 因此挂起线程, 等待其他线程唤醒</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">//被唤醒后, 重新竞争同步状态, 也就是竞争锁</span></div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于节点已经被移动到同步队列中, 所以<code>isOnSyncQueue(node)</code>会返回<code>true</code>跳出循环, 接着调用<code>acquireQueued(node, savedState)</code>来竞争同步状态, 也就是重新获得锁. 如果成功的话, 将从<code>awaitUninterruptibly()</code>中返回.</p>
<p>对于<code>signalAll()</code>, 它通过一个循环, 调用<code>signal()</code>来实现唤醒等待队列中的全部线程.</p>
<blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote>
<p>当一个线程调用等待方法时, 它首先会把自己添加进等待队列中, 接着释放同步状态, 然后被挂起. 直到其他线程调用唤醒的方法, 节点会被移动到同步队列中并且唤醒对应的线程去竞争同步状态, 如果成功的话, 将从等待的方法中返回, 下面是逻辑图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktlspogakj30f20n9q4q.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AbstractQueuedSynchronizer中的ConditionObject剖析&quot;&gt;&lt;a href=&quot;#AbstractQueuedSynchronizer中的ConditionObject剖析&quot; class=&quot;headerlink&quot; title=&quot;Ab
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#AQS" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-AQS/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer剖析</title>
    <link href="http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer%E5%89%96%E6%9E%90/"/>
    <id>http://cristianoro7.github.io/2017/10/31/AbstractQueuedSynchronizer剖析/</id>
    <published>2017-10-31T15:33:14.724Z</published>
    <updated>2017-10-31T15:33:14.724Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fktbn58ux2j30m80b47l5.jpg" alt=""></p>
<h1 id="AbstractQueuedSynchronizer剖析"><a href="#AbstractQueuedSynchronizer剖析" class="headerlink" title="AbstractQueuedSynchronizer剖析"></a>AbstractQueuedSynchronizer剖析</h1><p>在介绍AbstractQueuedSynchronizer(下面称AQS)前, 我们先来看看一个不安全的锁, 然后引出构建安全锁需要处理哪些情况.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">lock_t</span> &#123;</div><div class="line">    <span class="keyword">int</span> flag;</div><div class="line">&#125; <span class="keyword">lock_t</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    mutex-&gt;flag = <span class="number">0</span>; <span class="comment">//0表示锁空闲, 1表示锁被占有</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(mutex-&gt;flag == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//自旋等待</span></div><div class="line">    &#125;</div><div class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">//获得锁</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</div><div class="line">    mutex-&gt;flag = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>flag</code>字段是一个状态字段, 0表示锁空闲, 1表示锁被占有. 初始化时, <code>flag</code>被初始化为0, 表示锁是空闲的. 在<code>lock(lock_t*)</code>中, 会循环检查<code>flag</code>标记, 如果是为1的话, 表示锁已经被占有, 于是就一直自旋等待. 直到<code>flag</code>被设置为0, 也就是<code>unlock(lock_t*)</code>操作.</p>
<p>但是这个锁, 是不能保证正确性的. 因为 <code>mutex-&gt;flag == 1</code>和 <code>mutex-&gt;flag = 1</code>不是原子操作, 执行这两句的过程中, 有可能被中断.</p>
<p>而且, 这个锁的性能也不怎么好, 如果锁已经被占有的话, 它只会一直循环, 这样就白白浪费了CPU时间片.</p>
<p>如果能将<code>mutex-&gt;flag == 1;</code>和 <code>mutex-&gt;flag = 1</code>作为一个原子操作的话, 那么就能保证锁的正确性. 换句话说, 只要把检查和更新锁的状态字段的操作作为一个原子操作的话, 就不会出现问题. 所以现代处理器普遍都提供了<code>campare and swap</code>原句来解决这个问题.</p>
<p>至于性能的问题: 与其让它一直自旋等待, 不如让出时间片, 等锁空闲的时候再调度或者自旋等待一段时间, 超过这个时间后还没获得锁的话, 就放弃时间片.</p>
<p>现在总结一下解决这两个问题需要处理的情况:</p>
<ul>
<li><p>需要管理<code>flag</code>字段的同步状态, 利用一些同步原句来更新和管理同步状态.</p>
</li>
<li><p>为了提高锁的性能, 我们需要让获取锁失败的线程挂起或者等待一段时间后才挂起, 防止浪费时间片. 所以, 我们需要一个数据结构来管理记录这些获取锁失败的线程, 并且在当锁空闲的时候, 负责唤醒挂起的线程, 以便他们进行获取锁的操作.</p>
</li>
</ul>
<blockquote>
<h2 id="AQS的使命"><a href="#AQS的使命" class="headerlink" title="AQS的使命"></a>AQS的使命</h2></blockquote>
<p>经过上面的简单介绍, 我们知道构建一个安全并且性能高的锁需要处理下面的情况</p>
<ul>
<li><p>管理同步状态</p>
</li>
<li><p>管理获取锁失败的线程, 并且负责挂起和唤醒获取锁失败的线程.</p>
</li>
</ul>
<p><code>AQS</code>的使命就是来完成上面的任务, 以便让各种类型的锁只关注自己本身的特性. 换句话说: <code>AQS</code>是并发包中的基本骨架, 并发包中的各种锁都是基于<code>AQS</code>, <code>AQS</code>为其他锁将所有的脏活和累活(管理同步状态, 将获取锁失败的线程排队,挂起和唤醒.)都解决掉, 让其他的锁只关注自己的特性.</p>
<blockquote>
<h2 id="AQS设计"><a href="#AQS设计" class="headerlink" title="AQS设计"></a>AQS设计</h2></blockquote>
<p><code>AQS</code>是基于模板设计模式来实现的. 它将公用的特性自己实现, 对于具体的子类特性, <code>AQS</code>提供了一些方法作为模板, 子类只需要实现对应的模板方法来构建就行了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//独占式获取同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//独占式释放同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//共享式获取同步状态</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//共享式释放同步状态</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tryXXX</code>是<code>AQS</code>提供给子类实现的模板方法, 这些模板对应两种获取同步状态的模式: 独占式模式和共享式模式. 每种模式对应有获取和释放方法. 对于共享式, 同个时刻可以有多个线程获取同步状态, 至于获取的规则由子类去实现. 子类实现这种模式一般是共享锁. 至于独占式, 同个时刻只有一个线程可以获取, 获取的规则也是由子类去重写对应的模板方法实现. 子类实现这种模式一般是独占锁.</p>
<blockquote>
<h3 id="AQS中的同步队列"><a href="#AQS中的同步队列" class="headerlink" title="AQS中的同步队列"></a>AQS中的同步队列</h3></blockquote>
<p>对于获取锁失败的线程, <code>AQS</code>需要用一个数据结构来追踪记录他们. 这个数据结构是一个双向链表. 也可以看做是一个FIFO的<code>同步队列</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); <span class="comment">//标记当前模式为共享式</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; <span class="comment">//标记当前模式为独占式</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>; <span class="comment">//当前节点已经被取消</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>; <span class="comment">//标记后继节点需要被唤醒</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; <span class="comment">//标记当前节点处于等待队列中(注意不是同步队列)</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; <span class="comment">//用于共享模式中, 表示后继节点获取同步状态可以无条件传递下去.</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">//前继节点</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">//后继节点</span></div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">//获取锁失败的线程</span></div><div class="line"></div><div class="line">    Node nextWaiter; <span class="comment">//等待队列中的当前节点的下个节点</span></div></pre></td></tr></table></figure>
<p>如果线程获取锁失败时, <code>AQS</code>会将其包装成一个<code>Node</code>节点并且入队在同步队列中. <code>Node</code>节点和<code>Thread</code>引用通过<code>volatile</code>来保证每次读取的值是最新的. 需要注意的是: <code>nextWaiter</code>是<code>等待队列</code>中的后继节点引用, 这里的<code>等待队列</code>和<code>同步队列</code>不是一样的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">//队列头结点</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">//队列尾节点</span></div></pre></td></tr></table></figure>
<p>每次出队时, 是从<code>head</code>节点出队, 入队时. 是从<code>tail</code>节点插入. 头尾节点也是被<code>volatile</code>修饰来保证他们在多线程环境下的可见性.</p>
<blockquote>
<h3 id="AQS中的状态管理"><a href="#AQS中的状态管理" class="headerlink" title="AQS中的状态管理"></a>AQS中的状态管理</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> state;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</div><div class="line">   state = newState;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">   <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">   <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于同步状态的管理, <code>AQS</code>采用一个<code>int</code>变量来表示, 并且该变量也是由<code>volatile</code>来修饰, 因此<code>getState</code>和<code>setState</code>这两个方法不用加锁. 这里需要注意的是: <code>volatile</code>能保证可见性, 但是不能保证原子性. 它只能保证单操作的原子性, 也就是更新时不依赖本身的状态或者是其他变量的值. 如果需要原子更新的话, 应该使用<code>compareAndSetState(int expect, int update)</code>, 该方法能够保证原子性和可见性.</p>
<blockquote>
<h3 id="AQS分类"><a href="#AQS分类" class="headerlink" title="AQS分类"></a>AQS分类</h3></blockquote>
<p>总得来说, <code>AQS</code>的操作分为两种模式:</p>
<ul>
<li><p>共享式: 共享式可以细分为: 1. <code>不响应中断的共享式获取同步状态</code>. 2. <code>响应中断的共享式获取同步状态</code>. 3. <code>同时响应中断和超时的共享式获取同步状态</code>.</p>
</li>
<li><p>独占式: 独占式跟共享式基本一样, 可以分为: 1. <code>不响应中断的独占式获取同步状态</code>. 2. <code>响应中断的独占式获取同步状态</code>. 3. <code>同时响应中断和超时的独占式获取同步状态</code>.</p>
</li>
</ul>
<p>下面我们通过官方的例子来解析AQS的原理. 如果理解了下面例子的话, 理解并发包中的其他锁自然也不在话下.</p>
<blockquote>
<h3 id="独占式锁"><a href="#独占式锁" class="headerlink" title="独占式锁"></a>独占式锁</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// Our internal helper class</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">     <span class="comment">// Reports whether in locked state</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Acquires the lock if state is zero</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">         setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Releases the lock by setting state to zero</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">       setState(<span class="number">0</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Provides a Condition</span></div><div class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Deserializes properly</span></div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></div><div class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</div><div class="line">       s.defaultReadObject();</div><div class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.acquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.release(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">     sync.newCondition();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> sync.isHeldExclusively();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Mutex</code>是一个简单的独占锁, 同一个时刻只允许有一个线程获取锁. <code>Sync</code>是<code>Mutex</code>的一个静态内部类, 该类继承了<code>AQS</code>, 并且重写了<code>AQS</code>提供的模板方法. <code>Sync</code>是<code>Mutex</code>一个代理类, <code>Mutex</code>的所有操作都是代理给<code>Sync</code>. <code>Sync</code>会调用<code>AQS</code>的方法, 而<code>AQS</code>又会回调<code>Sync</code>实现的模板方法.<br>这就是<code>AQS</code>的设计思路: 实现一个锁时, 往往是设置一个内部静态类, 该类继承<code>AQS</code>并且重写其中的模板方法, 最后锁内部的方法都代理给这个内部静态类. 并发包中的其他锁的实现思想也是这样的.</p>
<blockquote>
<h4 id="不响应中断的获取同步状态-acquire-int"><a href="#不响应中断的获取同步状态-acquire-int" class="headerlink" title="不响应中断的获取同步状态: acquire(int)"></a>不响应中断的获取同步状态: acquire(int)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">  sync.acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lock()</code>方法为不响应中断获取同步状态, 内部会调用<code>sync</code>的<code>acquire</code>, 而<code>acquire</code>方法是定义在<code>AQS</code>里面的. 那么先到<code>AQS</code>中看看.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会调用<code>tryAcquire(int)</code>来尝试获取同步状态, 如果获取成功的话, 直接返回. 获取失败的话, 需要入队. 获取的逻辑是在<code>Sync</code>重写的<code>tryAcquire(int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">    setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Mutex</code>实现得很简单, 通过<code>CAS</code>来更新状态. 如果获取成功的话, 返回<code>true</code>. 失败的话, 返回<code>false</code>.</p>
<p>如果获取同步状态失败的话, 也就是<code>tryAcquire</code>返回<code>false</code>的话, <code>AQS</code>会将对应的线程包装成一个<code>Node</code>节点, 然后加入同步队列中, 最后挂起线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//由于Head和Tail节点采用延迟加载的策略, 因此tail有可能为空</span></div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">//成功的话, 证明入队成功.</span></div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node); <span class="comment">//失败的话, 说明被其他线程给更新了尾节点, 因此进入enq方法入队.</span></div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 由于Head和Tail节点采用延迟加载的策略, 因此tail有可能为空</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addWaiter</code>内部首先尝试使用<code>CAS</code>来更新尾节点, 也就是插入新的节点. 如果<code>CAS</code>返回<code>true</code>的话, 证明插入成功, 如果失败的话, 进入<code>enq</code>方法.</p>
<p>在<code>enq</code>中, 通过一个死循环来保证入队的成功.</p>
<p>入队完成后, 进入<code>acquireQueued(final Node node, int arg)</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//拿到当前节点的前驱节点</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//如果当前节点的前驱节点为Head节点的话, 证明该节点处于队列的第二位置(第一是头节点. 仅仅做标记用), 因此它有权获取同步状态.</span></div><div class="line">                setHead(node); <span class="comment">//获取成功后, 更新头节点</span></div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果p != head或者获取同步状态失败的话, 需要将线程挂起</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>acquireQueued</code>的逻辑: 首先拿到当前节点的前驱节点, 如果前驱节点为<code>head</code>的话, 证明该节点处于队列的第二个位置, 由于<code>head</code>节点仅仅起标记的作用, 因此处于第二个位置的节点逻辑上是处于队头, 它能够竞争同步状态. 如果前驱节点不是<code>head</code>节点的话, 需要将线程挂起.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkr4pd1fycj30r607zt92.jpg" alt=""></p>
<p>现在我们来看看挂起线程的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">//首先判断是不是已经设置了SIGNAL状态, 是的话, 证明需要被挂起</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">//节点状态为CANCELLED, 跳过这些取消的节点</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        do &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">//设置节点为SIGNAL, 表明需要被挂起.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个线程被挂起前, 必须设置状态为<code>SIGNAL</code>, 设置为<code>SIGNAL</code>后, 表明前驱节点出队后, 必须唤醒这个节点. 如果节点的状态被设置为<code>CANCELLED</code>的话, 说明它不需要被挂起.</p>
<p>所以<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>, 如果线程需要被挂起的话, 它的状态为0(默认状态), 那么它通过<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</code>来将状态设置为<code>SIGNAL</code>, 表明它需要被挂起, 在下次再调用该方法时, 会执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回<code>true</code>来表示它需要被挂起.</p>
<p>如果线程的状态被设置为<code>CANCELLED</code>, 也就是<code>ws &gt; 0</code>, 那么会跳过这些取消的节点, 下次循环进入时, 执行上面的逻辑.</p>
<p>当<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>返回<code>true</code>时, 会调用<code>parkAndCheckInterrupt()</code>来挂起线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LockSupport.park(this)</code>是一个挂起线程的操作.</p>
<p>现在我们再经过一张图来理清<code>acquire(int)</code>的逻辑</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkrwnsxu5ej30oi0mq75m.jpg" alt=""></p>
<p>当线程尝试获取同步状态时, 如果成功的话, 直接退出. 如果失败的话, 将线程包装成一个<code>Node</code>节点并且加入到队列中. 入队后, 需要判断线程是否需要被挂起. 如果当前节点的前驱节点是<code>head</code>节点的话, 尝试获取同步状态, 如果成功的话, 将自己设置为头节点后退出. 如果当前节点的前驱节点不是<code>head</code>或者是<code>head</code>节点但是获取同步状态失败, 将线程挂起. 被挂起的线程会被前驱节点唤醒, 接着继续竞争同步状态.</p>
<blockquote>
<h4 id="响应中断的获取同步状态-acquireInterruptibly-int-arg"><a href="#响应中断的获取同步状态-acquireInterruptibly-int-arg" class="headerlink" title="响应中断的获取同步状态: acquireInterruptibly(int arg)"></a>响应中断的获取同步状态: acquireInterruptibly(int arg)</h4></blockquote>
<p><code>acquireInterruptibly(int arg)</code>可以响应线程的中断而退出.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">        doAcquireInterruptibly(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查线程的中断状态标记, 如果已经被设置了中断的话, 抛出中断异常来响应. 如果没有被中断的话, 先尝试快速的获取同步状态, 如果成功的话, 直接退出. 失败的话进入<code>doAcquireInterruptibly(arg);</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doAcquireInterruptibly(int arg)</code>方法的逻辑和<code>acquireQueued(final Node node, int arg)</code>大致一样. 下面只说说不一样的地方. 如果<code>parkAndCheckInterrupt()</code>返回<code>true</code>的话, 会抛出中断异常来响应中断.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程被唤醒后会检查中断标记位.</p>
<p>由于<code>acquireInterruptibly(int arg)</code>逻辑和<code>acquire</code>差不多, 所以这里不多讲.</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fkrxgdyggoj30p30mujss.jpg" alt=""></p>
<blockquote>
<h4 id="支持超时的获取同步状态-tryAcquireNanos-int-arg-long-nanosTimeout"><a href="#支持超时的获取同步状态-tryAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="支持超时的获取同步状态: tryAcquireNanos(int arg, long nanosTimeout)"></a>支持超时的获取同步状态: tryAcquireNanos(int arg, long nanosTimeout)</h4></blockquote>
<p><code>tryAcquireNanos(int arg, long nanosTimeout)</code>方法如果在给定的一个时间内不能够获取锁的话, 会直接返回. 该方法同时也支持中断. 换句话说<code>tryAcquireNanos(int arg, long nanosTimeout)</code>是在<code>acquireInterruptibly(int arg)</code>的基础上加入超时获取的逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</div><div class="line">        doAcquireNanos(arg, nanosTimeout);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查中断标志, 如果<code>true</code>的话, 抛出异常来响应. <code>false</code>的话, 首先尝试获取同步状态, 成功的话直接返回. 失败的话, 进入<code>doAcquireNanos(arg, nanosTimeout);</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">//记录超时的时间</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">//如果nanosTimeout &lt; 0=的话, 证明超时了</span></div><div class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// 剩余的超时时间如果小于这个spinForTimeoutThreshold的话, 线程不会被挂起, 而是会自旋</span></div><div class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doAcquireNanos(int, long)</code>的逻辑和<code>doAcquireInterruptibly(int arg)</code>大体相同, 不同的是: <code>doAcquireNanos(int, long)</code>支持超时获取锁. 超时获取的逻辑: 首先计算出超时的时间戳<code>final long deadline = System.nanoTime() + nanosTimeout;</code>, 在自旋的过程中, 如果<code>deadline - System.nanoTime() &lt;= 0</code>的话,证明已经超时, 所以返回<code>false</code>. 如果大于0的话, 说明还没超时. 如果线程挂起的另外一个条件是<code>nanosTimeout &gt; spinForTimeoutThreshold</code>. 这样做为因为<code>spinForTimeoutThreshold = 1000</code>纳秒, 已经很小了, 如果再进行超时等待的话, 反而会更加不准确. 因此, 如果<code>nanosTimeout</code>小于等于<code>spinForTimeoutThreshold(1000纳秒)</code>时,将不会使该线程进行超时等待,而是进入快速的自旋过程。</p>
<blockquote>
<h4 id="释放同步状态-release-int-arg"><a href="#释放同步状态-release-int-arg" class="headerlink" title="释放同步状态: release(int arg)"></a>释放同步状态: release(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head; <span class="comment">//获取头结点</span></div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>release(int)</code>为释放同步状态, 它会调用<code>tryRelease(int)</code>模板方法, 这个模板方法是由<code>Mutex</code>来重写的, 具体代码前面已经贴出来了.<br>接着它会进入<code>unparkSuccessor(h);</code>来唤醒同步队列中的线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了防止提前线程被提前唤醒, 首先利用<code>CAS</code>将状态更新为默认状态. 一般而言, 需要唤醒的节点为<code>head</code>节点的下个节点, 但是为了防止节点已经被取消或者为空, 需要判断一下, 如果是的话, 从队列找到下一个需要释放的节点. 最后才唤醒线程.</p>
<blockquote>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3></blockquote>
<p>共享锁是指允许同个时刻, 允许多个线程获得资源. 共享锁的实现需要<code>AQS</code>的四组方法支持</p>
<ul>
<li><p><code>acquireShared(int arg)</code>: 不支持中断获取同步状态</p>
</li>
<li><p><code>acquireSharedInterruptibly(int arg)</code>: 支持中断地获取同步状态</p>
</li>
<li><p><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>: 超时获取并且支持中断获取同步状态</p>
</li>
<li><p><code>releaseShared(int arg)</code>: 释放同步状态</p>
</li>
</ul>
<p>这四组方法的逻辑跟独占模式下的方法的逻辑差不多, 因此, 这里只分析<code>acquireShared(int arg)</code>和<code>releaseShared(int arg)</code>.</p>
<blockquote>
<h4 id="acquireShared-int-arg"><a href="#acquireShared-int-arg" class="headerlink" title="acquireShared(int arg)"></a>acquireShared(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireShared(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tryAcquireShared(arg)</code>为子类重写的模板方法. 如果方法返回值小于0的话, 说明获取同步状态失败. 因此进入<code>doAcquireShared(arg)</code>进行排队和挂起等操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">//添加进队列</span></div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获取前驱节点</span></div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">//获取同步状态</span></div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">//如果同步状态还有剩余的话</span></div><div class="line">                    setHeadAndPropagate(node, r); <span class="comment">//唤醒后续的线程</span></div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    <span class="keyword">if</span> (interrupted)</div><div class="line">                        selfInterrupt();</div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前驱节点为<code>head</code>节点的话, 此时会超时获取同步状态, 如果成功并且状态大于等于0的话, 证明同步资源还有剩余, 可以唤醒后面的线程. 因此会调用<code>setHeadAndPropagate(node, r)</code>, 设置头结点并且将唤醒后面的线程.</p>
<blockquote>
<h4 id="releaseShared-int-arg"><a href="#releaseShared-int-arg" class="headerlink" title="releaseShared(int arg)"></a>releaseShared(int arg)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>共享式的释放和独占式的释放的主要区别在于: 独占式释放的时候, 只有一个线程在执行, 因此不存在竞争条件, 直接唤醒后续线程即可. 但是在共享式中, 由于同个时刻有多个线程在执行, 因此存在条件竞争, <code>doReleaseShared()</code>内部通过循环和<code>CAS</code>来保证线程安全.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<p><code>AQS</code>利用模板设计模式来为其子类屏蔽了同步状态的管理, 同步队列的管理, 线程的挂起和唤醒等操作, 使得子类只需要关注本身获取同步状态的逻辑. <code>AQS</code>内部总体实现分为两种模式:</p>
<ul>
<li><p>共享式</p>
</li>
<li><p>独占式</p>
</li>
</ul>
<p>共享式和独占式都支持不可中断, 可中断, 可中断并且超时获取同步状态.</p>
<p>关于<code>AQS</code>, 其内部还有一个<code>ConditionObject</code>类, 该类是实现等待/通知模式. 由于篇幅的关系, 打算在下篇中分析.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006VdOYcgy1fktbn58ux2j30m80b47l5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;AbstractQueuedSynchronizer剖析&quot;&gt;&lt;a href=&quot;#A
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java并发包#AQS" scheme="http://cristianoro7.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8C%85-AQS/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-WeakHashMap,%20IdentityHashMap%20%E5%92%8C%20HashTable/"/>
    <id>http://cristianoro7.github.io/2017/10/31/深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable/</id>
    <published>2017-10-31T13:58:15.503Z</published>
    <updated>2017-10-31T13:58:15.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2></blockquote>
<p><code>WeakHashMap</code>总体实现和<code>HashMap</code>差不多, 不同的时, <code>WeakHashMap</code>中的Key是弱引用类型, <code>WeakHashMap</code>内部的Key是会被自动回收的. 另外需要关注的是, <code>WeakHashMap</code>并没有向<code>HashMap</code>那样, 在1.8做了优化.</p>
<blockquote>
<h3 id="弱引用Key"><a href="#弱引用Key" class="headerlink" title="弱引用Key"></a>弱引用Key</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    V value;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates new entry.</div><div class="line">     */</div><div class="line">    Entry(Object key, V value,</div><div class="line">          ReferenceQueue&lt;Object&gt; queue,</div><div class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(key, queue);</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.hash  = hash;</div><div class="line">        <span class="keyword">this</span>.next  = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (K) WeakHashMap.unmaskNull(get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">        K k1 = getKey();</div><div class="line">        Object k2 = e.getKey();</div><div class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">            V v1 = getValue();</div><div class="line">            Object v2 = e.getValue();</div><div class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        K k = getKey();</div><div class="line">        V v = getValue();</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>内部的结点是继承弱引用类型, 并且指定了一个<code>ReferenceQueue&lt;Object&gt;</code>, 当Key被GC回收时, Key对应的对象会被添加到<code>ReferenceQueue&lt;Object&gt;</code>这个队列中. 这个队列是定义在<code>WeakHashMap</code>内部的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Reference queue for cleared WeakEntries</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>的实现原理跟<code>HashMap</code>是差不多的. 不过<code>HashMap</code>在1.8后, 做了很多优化, 但是<code>WeakHashMap</code>并没有跟随<code>HashMap</code>进行优化.</p>
<p>由于<code>WeakHashMap</code>和<code>HashMap</code>差不多, 我们只分析重要的实现方法.</p>
<p><code>WeakHashMap</code>的增删查改, 都会做一个同步操作, 什么是同步操作? 因为<code>WeakHashMap</code>的Key是弱引用类型, Key值会随时被GC回收. 虽然Key被回收了,但是对应的Value还是没有被回收的. 所以, 同步操作就是移除被回收Key对应的Value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunges stale entries from the table.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123; <span class="comment">//判断queue队列中是否有被回收的Key, 有的话, 需要移除对应Value</span></div><div class="line">        <span class="keyword">synchronized</span> (queue) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</div><div class="line"></div><div class="line">            Entry&lt;K,V&gt; prev = table[i];</div><div class="line">            Entry&lt;K,V&gt; p = prev;</div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                Entry&lt;K,V&gt; next = p.next;</div><div class="line">                <span class="keyword">if</span> (p == e) &#123;</div><div class="line">                    <span class="keyword">if</span> (prev == e)</div><div class="line">                        table[i] = next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        prev.next = next;</div><div class="line">                    <span class="comment">// Must not null out e.next;</span></div><div class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></div><div class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></div><div class="line">                    size--;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                prev = p;</div><div class="line">                p = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是同步操作的方法, <code>WeakHashMap</code>增删改查时, 都会调用的方法. 原理是这样的: 每当弱引用类型Key被GC回收时, 由于<code>WeakHashMap</code>内部指定了<code>ReferenceQueue&lt;Object&gt;</code>, 因此, 被移除的Key会被添加到该队列. 这个方法就是调用队列的<code>poll()</code>方法, 获得被移除的Key, 然后利用该Key, 移除在<code>WeakHashMap</code>内部对应的Value.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li><p><code>WeakHashMap</code>和<code>HashMap</code>一样, Key和Value都支持null.</p>
</li>
<li><p><code>WeakHashMap</code>内部的继承WeakReference, 将Key指定为弱引用类型, 这样Key会被自动回收. 虽然Key会被自动回收, 但是Value不会被自动回收. 因此, <code>WeakHashMap</code>内部每次增删改查时, 都会做同步操作.</p>
</li>
</ul>
<blockquote>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2></blockquote>
<p><code>IdentityHashMap</code>继承于<code>AbstractMap</code>,并实现了<code>Map</code>接口. 总体来说, <code>IdentityHashMap</code>跟<code>HashMap</code>差别还是很大的. 虽然继承结构相同, 但是实现的思想却是截然不同.</p>
<p><code>IdentityHashMap</code>内部并没有结点, 它的Key和Vaule都是储存在数组内的. 因此, <code>IdentityHashMap</code>解决的冲突是开放地址法.</p>
<p>上面说到<code>IdentityHashMap</code>的Key和Value都是存在数组内的. Key和Value总是连续的存放.</p>
<p>另外值得一提的是: <code>IdentityHashMap</code>是利用 <code>==</code>来比较Key的相等性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    init(DEFAULT_CAPACITY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2</span></div><div class="line">    <span class="comment">// assert initCapacity &gt;= MINIMUM_CAPACITY;</span></div><div class="line">    <span class="comment">// assert initCapacity &lt;= MAXIMUM_CAPACITY;</span></div><div class="line"></div><div class="line">    table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>默认的容量是64. 长度跟<code>HashMap</code>一样, 都是2的次幂.还是跟之前的套路一样, 只分析一些重要的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object k = maskNull(key);</div><div class="line"></div><div class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> Object[] tab = table;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</div><div class="line">        <span class="keyword">int</span> i = hash(k, len); <span class="comment">//获得数组的index</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>; <span class="comment">//有冲的话, 查找下一个index</span></div><div class="line">             i = nextKeyIndex(i, len)) &#123;</div><div class="line">            <span class="keyword">if</span> (item == k) &#123;</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</div><div class="line">                tab[i + <span class="number">1</span>] = value;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</div><div class="line">        <span class="comment">// Use optimized form of 3 * s.</span></div><div class="line">        <span class="comment">// Next capacity is len, 2 * current capacity.</span></div><div class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len)) <span class="comment">//当储存的元素大于 容量的3分之一的话, 扩容</span></div><div class="line">            <span class="keyword">continue</span> retryAfterResize;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        tab[i] = k;</div><div class="line">        tab[i + <span class="number">1</span>] = value; <span class="comment">//Value始终是保存在Key的下个index</span></div><div class="line">        size = s;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>hash</code>函数, 获得index, 如果index对应已经存有元素的话, 会调用<code>nextKeyIndex(int, int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>是使用开放地址法解决冲突. 当发生冲突时, 它会寻找下个位置, 而下个位置是 i + 2. 之所以是i + 2,而不是i + 1的原因是 Key和Value总是连续的储存的, 因此寻找下个位置时, 需要跳多一个位置.如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fip01fuwt1j30er06bmx6.jpg" alt=""></p>
<p>如果index没有储存元素的话, 会先检查内部储存元素数量是不是大于容量的1/3, 是的话会进行扩容操作.每次扩容都是扩为原来的2倍.</p>
<blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2></blockquote>
<p><code>HashTable</code>是一个遗留类, 已经被<code>HashMap</code>替代了. 从功能上来说, 跟HashMap差不多. 主要比较它跟<code>HashMap</code>的异同.</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><code>HashMap</code>是允许K或者V为null的, 但是<code>HashTable</code>不允许K或者V为null</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><code>HashMap</code>是线程不安全的, 而<code>HashTable</code>是线程安全的, 因为内部的方法都是加了锁. 但是在并发的环境, 不建议使用<code>HashTable</code>, 应该使用<code>ConcurrentHashMap&lt;K,V&gt;</code>. <code>ConcurrentHashMap&lt;K,V&gt;</code>是使用分段锁来控制同步, 显然性能上要比<code>HashTable</code>好.</p>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p><code>HashMap</code>的容量为2的n次幂, 而<code>HashTable</code>为素数.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;W
    
    </summary>
    
      <category term="Java" scheme="http://cristianoro7.github.io/categories/Java/"/>
    
    
      <category term="Java集合框架" scheme="http://cristianoro7.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-返回结果的状态码-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%9B%BE%E8%A7%A3HTTP-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-%E7%AC%94%E8%AE%B0/"/>
    <id>http://cristianoro7.github.io/2017/10/31/图解HTTP-返回结果的状态码-笔记/</id>
    <published>2017-10-31T13:57:58.722Z</published>
    <updated>2017-10-31T13:57:58.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="状态码类别："><a href="#状态码类别：" class="headerlink" title="状态码类别："></a>状态码类别：</h4><p>类别    原因短语<br>1XX    Informational(信息性状态码)    接收的请求正在处理<br>2XX    Success(成功状态码)    请求正常处理完毕<br>3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求<br>4XX    Client Error(客户端错误状态码)    服务器无法处理请求<br>5XX    Server Error(服务器错误状态码)    服务器处理请求出错</p>
<a id="more"></a>
<h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h5><ul>
<li>200 OK：表示客户端的请求被服务器成功处理</li>
<li><p>204 No Content：该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</p>
</li>
<li><p>206 Partial Content：该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h5><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<ul>
<li><p>301 Moved Permanently:永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</p>
</li>
<li><p>302 Found:临时性重定向：该状态码表示请求的资源已被分配了新的URI，希望用户本次请求能使用新的URI。302和301很相似，302表示的URI并不是永久性移动，换句话说就是URI还有可能发生变化。</p>
</li>
<li><p>303 See Other：该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。303和302有着相似的功能，他们之间的区别是303状态码表示明确客户端采用GET请求获取资源</p>
</li>
<li><p>304 Not Modified  </p>
</li>
</ul>
<h5 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h5><p>4XX响应结果表示错误发生在客户端</p>
<ul>
<li><p>400 Bad Request:该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。</p>
</li>
<li><p>403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。</p>
</li>
<li><p>404 Not Found：该状态码表明服务器上无法找到请求的资源。</p>
</li>
</ul>
<h5 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h5><p>5XX 的响应结果表明服务器本身发生错误。</p>
<ul>
<li><p>500 Internal Server Error:该状态码表明服务器端在执行请求时发生了错误。</p>
</li>
<li><p>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。</p>
</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;状态码类别：&quot;&gt;&lt;a href=&quot;#状态码类别：&quot; class=&quot;headerlink&quot; title=&quot;状态码类别：&quot;&gt;&lt;/a&gt;状态码类别：&lt;/h4&gt;&lt;p&gt;类别    原因短语&lt;br&gt;1XX    Informational(信息性状态码)    接收的请求正在处理&lt;br&gt;2XX    Success(成功状态码)    请求正常处理完毕&lt;br&gt;3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求&lt;br&gt;4XX    Client Error(客户端错误状态码)    服务器无法处理请求&lt;br&gt;5XX    Server Error(服务器错误状态码)    服务器处理请求出错&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#HTTP" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-网络基础-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%9B%BE%E8%A7%A3HTTP-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://cristianoro7.github.io/2017/10/31/图解HTTP-网络基础/</id>
    <published>2017-10-31T13:57:52.659Z</published>
    <updated>2017-10-31T13:57:52.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h4><h5 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h5><ul>
<li>我们通常使用到的网络是在<strong>TCP/IP</strong>协议族的基础上运作的。而HTTP属于它内部的一个子集。</li>
<li>TCP/IP是互联网各类协议族的总称, 如图:<br><img src="/uploads/图解HTTP/网络基础01.jpg" alt=""><a id="more"></a></li>
<li>协议中存在各式各样的内容,从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序,以及 Web 页面显示需要处理的步骤,等等。像这样把互联网通信的相关协议集合起来的协议族就叫做TCP/IP协议</li>
</ul>
<h5 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h5><ul>
<li>TCP/IP中一个重要的点就是分层设计。</li>
<li>层次: 应用层,传输层,网路层,链路层</li>
<li>分层设计的好处:<ul>
<li>利于修改:这样不会因某些地方要修改而导致整个协议都得修改,只需要各层把借口规范好,需要改动的时候就在相应的层次改动</li>
<li>各层只需完成自己的任务,无需关注其他层次。比如:应用层不需知道怎么传输和接收方在哪里</li>
</ul>
</li>
<li><strong>TCP/IP协议族各层的作用</strong><ul>
<li>应用层: 该层决定了想用户提供服务时的通信活动。TCP/IP协议族中预存了各类通用的应用服务,比如, FTP(File Transfer Protocol, 文件传输协议) 和 DNS (Domain Name System, 域名解析系统), HTTP协议处于应用层。</li>
<li>传输层: 该层对上层应用层, 提供处于网络连接中的两台计算机之间的数据传输。传输层中有两个性质不同的协议:<strong>TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User Data Protocol, 用户数据报协议)</strong></li>
<li>网络层(网路互连层): 该层用来处理在网络上流动的数据包, 数据包是在网络传输时的最小数据单位, 网络层规定了通过怎么样的路径到达对方的计算机,并把数据包发给对方</li>
<li>链路层(有名:数据链路层, 网络接口层):用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card,网络适配器,即网卡),及光纤等物理可见部分(还包括连接器等一切传输媒介)。硬件上的范畴均在<br>链路层的作用范围之内。</li>
</ul>
</li>
</ul>
<h5 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h5><p><img src="/uploads/图解HTTP/网络基础02.jpg" alt=""></p>
<ul>
<li>从上图,我们可以清楚:使用TCP/IP协议进行网络通信时,发送端是从应用层往下走,接收端是往应用层上走</li>
<li>我们用 HTTP 举例来说明,首先作为发送端的客户端在应用层(HTTP 协议)发出一个想看某个 Web 页面的 HTTP 请求。接着,为了传输方便,在传输层(TCP 协议)把从应用层处收到的数据(HTTP 请求报文)进行分割,并在各个报文上打上标记序号及端口号后转发给网络层。在网络层(IP 协议),增加作为通信目的地的 MAC地址后转发给链路层。这样一来,发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据,按序往上层发送,一直到应用层。当传输到应用层,才能算真正接收到由客户端发送过来的 HTTP请求。</li>
</ul>
<p><img src="/uploads/图解HTTP/网络基础03.jpg" alt=""></p>
<ul>
<li>发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息。反之,接收端在层与层传输数据时,经过一层时会把对应的首部消去。</li>
</ul>
<h5 id="与HTTP关系密切的协议-TCP-IP-DNS"><a href="#与HTTP关系密切的协议-TCP-IP-DNS" class="headerlink" title="与HTTP关系密切的协议: TCP IP DNS"></a>与HTTP关系密切的协议: TCP IP DNS</h5><ul>
<li>负责传输的IP协议:<br>1.按层次分,IP(Internet Protocol)网际协议位于网络层。<br>2.IP协议的作用是把各种数据包发送给对方,其中发送成功的;两个重要条件时:IP地址和MAC地址(Media Access Control Address)<br>3.MAC地址所指的是网卡地址,不可以改变,而IP地址则可以变换<br>4.在网络条通信中,双方同时位于同一个局域网内的情况是很少的,通常是是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时,会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时,会采用 ARP 协议(AddressResolution Protocol)。ARP 是一种用以解析地址的协议,根据通信方的 IP 地址就可以反查出对应的 MAC 地址。<br>5.无论哪台计算机、哪台网络设备,它们都无法全面掌握互联网中的细节。</li>
</ul>
<p><img src="/uploads/图解HTTP/网络基础04.jpg" alt=""></p>
<ul>
<li>确保可靠性的TCP协议</li>
</ul>
<ol>
<li>按层次分,TCP 位于传输层,提供可靠的字节流服务。所谓的字节流服务(Byte Stream Service)是指,为了方便传输,将大<br>块数据分割成以报文段(segment)为单位的数据包进行管理。而可靠的传输服务是指,能够把数据准确可靠地传给对方。一言以蔽之,TCP 协议为了更容易传送大数据才把数据分割,而且 TCP 协议能够确认数据最终是否送达到对方。</li>
<li>TCP协议采用三次握手(three-way-handshaking)策略来保证数据能准确无误的送达</li>
<li>握手过程中使用了 TCP 的标志(flag) —— SYN(synchronize) 和ACK(acknowledgement)。</li>
<li>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后,回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后,发送端再回传一个带ACK标志的数据包,代表“握手”结束。若在握手过程中某个阶段莫名中断,TCP协议会再次以相同的顺序发送相同的数据包。</li>
<li>除了上面的三次握手,TCP协议还有其他的协议来保证通信的可靠。</li>
</ol>
<p><img src="/uploads/图解HTTP/网络基础05.jpg" alt=""></p>
<ul>
<li>DNS:</li>
</ul>
<ol>
<li>DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址,或逆向从 IP 地址反查域名的服务。</li>
</ol>
<p><img src="/uploads/图解HTTP/网络基础06.jpg" alt=""></p>
<h5 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h5><p><img src="/uploads/图解HTTP/网络基础07.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络基础-TCP-IP&quot;&gt;&lt;a href=&quot;#网络基础-TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;网络基础 TCP/IP&quot;&gt;&lt;/a&gt;网络基础 TCP/IP&lt;/h4&gt;&lt;h5 id=&quot;TCP-IP协议族&quot;&gt;&lt;a href=&quot;#TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议族&quot;&gt;&lt;/a&gt;TCP/IP协议族&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;我们通常使用到的网络是在&lt;strong&gt;TCP/IP&lt;/strong&gt;协议族的基础上运作的。而HTTP属于它内部的一个子集。&lt;/li&gt;
&lt;li&gt;TCP/IP是互联网各类协议族的总称, 如图:&lt;br&gt;&lt;img src=&quot;/uploads/图解HTTP/网络基础01.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://cristianoro7.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络#HTTP" scheme="http://cristianoro7.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask源码浅析</title>
    <link href="http://cristianoro7.github.io/2017/10/31/AsyncTask%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://cristianoro7.github.io/2017/10/31/AsyncTask源码浅析/</id>
    <published>2017-10-31T13:57:36.959Z</published>
    <updated>2017-10-31T13:57:36.959Z</updated>
    
    <content type="html"><![CDATA[<h5 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h5><ul>
<li>概述<br>AsyncTask是一个执行异步任务的小型框架，里面封装了Handler，使得使用者不必关心线程之间的切换，虽然现在执行异步任务都不会用AsyncTask，用得更多的是Bolt Tasks 和RxJava，但是AsyncTask中的设计思想还是很多值得学习的，比如：内部中，串行运行任务时的队列控制，handler的将结果回调回主线程，以及如何取消正在执行的任务等。。<a id="more"></a></li>
<li>我们知道，使用AsyncTask的要先实例化该类再调用其中的execute（）方法，那么自然先要来看其中的构造方法都初始化了哪些操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               Result result = doInBackground(mParams);</div><div class="line">               Binder.flushPendingCommands();</div><div class="line">               <span class="keyword">return</span> postResult(result);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面的代码中，分别实例化了WorkRunnable对象和FutureTask对象，其中，WorkRunnable是一个内部类，我们来看看该内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</div><div class="line">       Params[] mParams;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该类实现了Callable接口，其中保存了Params参数，也就是AsyncTask传入的参数</p>
</li>
<li><p>我们接下去看看execute（Params)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法返回AsyncTask本身，调用者可以根据需要保持对其的引用</p>
</li>
<li><p>execute（Params… params）executeOnExecutor(sDefaultExecutor, params)；我们点进该方法中看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">            Params... params) &#123;</div><div class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">            <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">                <span class="keyword">case</span> RUNNING:</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                            + <span class="string">" the task is already running."</span>);</div><div class="line">                <span class="keyword">case</span> FINISHED:</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                            + <span class="string">" the task has already been executed "</span></div><div class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">        onPreExecute();</div><div class="line"></div><div class="line">        mWorker.mParams = params;</div><div class="line">        exec.execute(mFuture);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Status是类中的枚举，作用是记录Task的运行状态。onPreExecute()，我们可以在该方法中做一些UI线程的初始化操作</p>
</li>
<li>接着将传进的参数赋值给mWork.parmas,也就是在构造函数初始化的WorkRunnable对象，保存了传入的参数</li>
<li>最后调用了传入的线程池的execute（Runnable）并且返回本身</li>
<li>传入的线程池是里面默认的线程池，该线程池是一个串行执行的</li>
<li><p>我们来看看该默认的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">        Runnable mActive;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        r.run();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        scheduleNext();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">                scheduleNext();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内部类中，将传入的Runnable对象添加到mTask队列中，并且在scheduleNext()方法中从mTask队列中拿出头元素，将该元素在后台线程池中执行</p>
</li>
<li>讲到这里，我们可以看出AsyncTask中的串行执行是通过在默认的线程池中进行队列控制，真正执行的是在后台线程池中执行，并且在执行完再安排下一个任务到后台线程池，这样就巧妙的完成了串行运行</li>
<li>我们回来execute（Runnable），传入的参数是mFutureTask，该对象是在之前构造函数实例化的，让我们回到构造函数：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               Result result = doInBackground(mParams);</div><div class="line">               Binder.flushPendingCommands();</div><div class="line">               <span class="keyword">return</span> postResult(result);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在FutureTask中，将callable对象出传入，现在看看mWorker其中的操作</p>
<ul>
<li>首先设置一个任务被调用的标记</li>
<li>接着调用doInBackground(mParams);该方法是我们重写的方法</li>
<li>最后将结果传入postResult(Result)中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">               <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">       message.sendToTarget();</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法中的逻主要是通过handler发送一条消息，该消息是包含结果对象的消息</li>
<li><p>我们先来看看内部类AsyncTaskResult<result>：</result></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">        <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">            mTask = task;</div><div class="line">            mData = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类中主要是保存了传入的结果以及AsyncTask自身</p>
</li>
<li>接着来看看InternalHandler()：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">           <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">               <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                   <span class="comment">// There is only one result</span></div><div class="line">                   result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                   result.mTask.onProgressUpdate(result.mData);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该内部类重写的Handler是运行在线程的handler，在handleMessage中接收处理消息</p>
</li>
<li><p>分析完了这两个内部类，我们回到postResult中发送消息，消息到达的是InternalHandler的 handleMessage，</p>
</li>
<li>result.mTask.finish(result.mData[0])，该语句调用了finish。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">           onCancelled(result);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           onPostExecute(result);</div><div class="line">       &#125;</div><div class="line">       mStatus = Status.FINISHED;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法中会先判断任务是不是被取消，如果没有的话，就地调用onPostExecute(result);也就是我们重写的结果方法</p>
</li>
<li><p>以上就是AsyncTask的执行流程。publishProgress方法的执行跟postResult差不多，这里不分析</p>
</li>
<li><p>关于AsyncTask现在支持并行运行，如果想要并且并行运行的话，可以调用executeOnExecutor(THREAD_POOL_EXECUTOR,<br>Params… params)。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;源码浅析&quot;&gt;&lt;a href=&quot;#源码浅析&quot; class=&quot;headerlink&quot; title=&quot;源码浅析&quot;&gt;&lt;/a&gt;源码浅析&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;概述&lt;br&gt;AsyncTask是一个执行异步任务的小型框架，里面封装了Handler，使得使用者不必关心线程之间的切换，虽然现在执行异步任务都不会用AsyncTask，用得更多的是Bolt Tasks 和RxJava，但是AsyncTask中的设计思想还是很多值得学习的，比如：内部中，串行运行任务时的队列控制，handler的将结果回调回主线程，以及如何取消正在执行的任务等。。
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="异步框架#AsyncTask" scheme="http://cristianoro7.github.io/tags/%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6-AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发艺术探索-View的事件体系-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://cristianoro7.github.io/2017/10/31/安卓开发艺术探索-第三章笔记/</id>
    <published>2017-10-31T13:56:12.992Z</published>
    <updated>2017-10-31T13:56:12.992Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第三章：View的事件体系"><a href="#第三章：View的事件体系" class="headerlink" title="第三章：View的事件体系"></a>第三章：View的事件体系</h4><h5 id="View的位置参数："><a href="#View的位置参数：" class="headerlink" title="View的位置参数："></a>View的位置参数：</h5><a id="more"></a>
<ul>
<li>View的位置参数left， top， right， bottom是相对于VIew的父容器来说的，因此是一种相对坐标</li>
<li>宽高和坐标的关系：<ul>
<li>width = right - left</li>
<li>height = bottom - top</li>
</ul>
</li>
<li>这四个参数对应于源码的mLeft， mRight， mTop， mBottom这四个成员变量，获取方式：<ul>
<li>left = getLeft（）</li>
<li>right = getRight（）</li>
<li>Top = getTop（）</li>
<li>Bottom = 个体Bottom（）</li>
</ul>
</li>
</ul>
<h5 id="MotionEvent和TouchSlop"><a href="#MotionEvent和TouchSlop" class="headerlink" title="MotionEvent和TouchSlop"></a>MotionEvent和TouchSlop</h5><ul>
<li>通过MotionEvent我们可以得到点击事件发生的坐标。</li>
<li>getX和getY得到的是相对于当前View的坐标</li>
<li>getRawX和getRawY是相对于屏幕的坐标</li>
<li>TouchSlop是系统所能识别出的被认为是滑动的最小距离，下面是获取的方式：<ul>
<li>ViewConfiguration.get(getContext()).getScaledTouchSlop();</li>
</ul>
</li>
</ul>
<h5 id="VeloccityTracker和GuestureDetector和Scroller"><a href="#VeloccityTracker和GuestureDetector和Scroller" class="headerlink" title="VeloccityTracker和GuestureDetector和Scroller"></a>VeloccityTracker和GuestureDetector和Scroller</h5><ul>
<li>VelocityTracker：速度追踪，用于追踪手指在滑动中的速度</li>
<li>使用：首先在View的onTouchEvent方法中追踪当前事件的速度：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</div><div class="line">        velocityTracker.addMovement(event);</div><div class="line">        velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">int</span> xv = (<span class="keyword">int</span>) velocityTracker.getXVelocity();</div><div class="line">        <span class="keyword">int</span> yv = (<span class="keyword">int</span>) velocityTracker.getYVelocity();</div></pre></td></tr></table></figure>
<ul>
<li>注意：获取速度之前必须计算速度；第二点：这里的速度指的是一段时间内手指所划过的像素数</li>
<li>最后不用的时候，应当调用clear和recycle来回收</li>
</ul>
<h5 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h5><ul>
<li>使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GestureDetector detector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//解决长按屏幕后无法拖动的现象</span></div><div class="line">        detector.setIsLongpressEnabled(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">boolean</span> resume = detector.onTouchEvent(event);</div><div class="line">        <span class="keyword">return</span> resume;</div></pre></td></tr></table></figure>
<ul>
<li>首先创建一个对象，并实现其监听接口，接着在接管View的onTouchEvent方法中，接管该事件</li>
</ul>
<h5 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h5><ul>
<li>实现View的滑动有三种方式：<ul>
<li>View自身提供的scrollerTo/scrollerBy</li>
<li>通过动画平移</li>
<li>改变View的layoutParams</li>
</ul>
</li>
<li>scrollerTo/scrollerBy</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Set the scrolled position of your view. This will cause a call to</div><div class="line">   * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line">   * invalidated.</div><div class="line">   * <span class="doctag">@param</span> x the x position to scroll to</div><div class="line">   * <span class="doctag">@param</span> y the y position to scroll to</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line">          <span class="keyword">int</span> oldX = mScrollX;</div><div class="line">          <span class="keyword">int</span> oldY = mScrollY;</div><div class="line">          mScrollX = x;</div><div class="line">          mScrollY = y;</div><div class="line">          invalidateParentCaches();</div><div class="line">          onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class="line">          <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">              postInvalidateOnAnimation();</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Move the scrolled position of your view. This will cause a call to</div><div class="line">   * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line">   * invalidated.</div><div class="line">   * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</div><div class="line">   * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      scrollTo(mScrollX + x, mScrollY + y);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>scrollTo是绝对滑动</li>
<li>scrollBy是相对于自身位置滑动</li>
<li>在滑动过程中，mScrollX的值等于View左边缘和View内容左边缘的水平距离，而mscrollY的值总是等于View上边缘和内容边缘在竖直方向上的距离</li>
<li>使用这两种方法不能使得View本身滑动，只能是内容滑动</li>
<li>使用动画：</li>
<li>改变布局参数：通过改变Margin来滑动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) mFriends.getLayoutParams();</div><div class="line">   params.width += <span class="number">10</span>;</div><div class="line"></div><div class="line">   params.leftMargin += <span class="number">10</span>;</div><div class="line"></div><div class="line">   mFriends.requestLayout();</div></pre></td></tr></table></figure>
<ul>
<li><p>总结：</p>
<ul>
<li>scrollTo/scrollBy：操作简单，适合对View内容的滑动</li>
<li>动画：操作简单。主要适合用于没有交互的View和实现复杂的动画效果</li>
<li>改变布局参数：操作稍微复杂，用于有交互的View</li>
</ul>
</li>
</ul>
<h5 id="实现弹性滑动"><a href="#实现弹性滑动" class="headerlink" title="实现弹性滑动"></a>实现弹性滑动</h5><ul>
<li>使用Scroller</li>
<li>用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(<span class="keyword">this</span>);</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> desX, <span class="keyword">int</span> desY)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">        <span class="keyword">int</span> deltaX = desX - scrollX;</div><div class="line">        mScroller.startScroll(scrollX, <span class="number">0</span>, deltaX, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">        mFriends.invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(mScroller.computeScrollOffset()) &#123;</div><div class="line">            mFriends.scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">            mFriends.postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先构造一个Scroller对象，接着调用它的startScroll，但是该方法内部知识保存了几个传递的参数</li>
<li>让View是实现弹性滑动的是invalidate（），该方法或导致View的重绘，在View的draw中又会去调用computeScroll，而computeScroll是我们自己实现的一个方法，在computeScroll中又会去获得当前的scrollX， scrollY，然后通过scrollTo实现滑动，接着又调用postInvalidate再进行重绘，如此反复，直到滑动完成</li>
<li>computeScrollOffset：该方法通过计算时间的流逝来计算出当前scrollX和scrollY的值，类似插值器的工作原理</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>Scroller本身并不能够实现View的滑动，它需要配合View的computerScroll来实现弹性滑动，它不断地让View重绘，而每次重绘距滑动起始时间会有一个间隔，通过这个时间间隔Scroller就可以得出View当前的滑动位置，知道了滑动位置就可以通过scrollTo来实现滑动。就这样，每次View的重绘都会导致View进行小幅度的滑动，而多次的小滑动就组成了View的弹性滑动</li>
<li>使用动画：</li>
<li>使用延时策略：通过使用Handler来实现</li>
</ul>
<h5 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h5><ul>
<li>相关的三个重要的方法：<ul>
<li>public boolean dispatchTouchEvent(MotionEvent event)：用于进行事件的分发。如果时间能够传递给当前的View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent（）方法的影响，表示是否消费当前事件</li>
<li>public boolean onInterceptHoverEvent(MotionEvent event)：在上述方法内部调用，用于判断是不是要拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被调用，返回结果表示是否拦截当前事件。</li>
<li>public boolean onTouchEvent(MotionEvent event)：在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否拦截当前事件，如果不消耗，那么在同一个事件序列当中，当前View将无法接受到事件</li>
</ul>
</li>
<li>概述：对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent会被调用，如果这个ViewGroup的onInterceptHoverEvent返回true表示它要拦截当前事件，接着该事件就会交给这个ViewGroup处理，即它的onTouchEvent会被调用；如果返回false表示不拦截此事件，这时该事件会传给它的子View，接着子View的dispatchTouchEvent会被调用，如此直到该事件被最终处理</li>
</ul>
<h5 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h5><p>1.Activity对点击事件的分发过程</p>
<ul>
<li>当一个点击事件发生时，事件最先传递给当前的Activity，由该Activity的dispatchTouchEvent来进行事件派发，具体的是又Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（framelayout），通过Activity.getWindow().getDecorView()可以获得。 下面是Activity的dispatchTouchEvent的源码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            onUserInteraction();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先事件开始交给Activity所依附的Window进行分发，如果返回true的话，整个事件循环就结束了，返回false的话意味着事件没有人处理，所有的View都返回onTouchEvent都返回false，那么Activity的onTouchEvent就会被调用。</li>
<li>接下来看Window是怎么样传给ViewGroup对象的，首先Window是一个抽象类，superDispatchTouchEvent方法也是抽象方法，其具体实现类是PhoneWindow，那么我们来看看其superDispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>PhoneWindow将事件直接传递给DecorView，我们来看看DecorView是什么？</li>
<li>我们知道，通过getWindow（）.getDecorView().findViewById(android.R.id.content).getChildAt(0)这种方式就可以获取Activity所设置的View，这个mDecorView显然就是getWindow().getDecorView()返回的View，而我们通过setContentView（）就是它的一个子View</li>
<li>在这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般说的是ViewGroup</li>
</ul>
<h5 id="顶级View对点击事件的分发过程"><a href="#顶级View对点击事件的分发过程" class="headerlink" title="顶级View对点击事件的分发过程"></a>顶级View对点击事件的分发过程</h5><ul>
<li>首先看看其dispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check for interception.</span></div><div class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">                   intercepted = onInterceptTouchEvent(ev);</div><div class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   intercepted = <span class="keyword">false</span>;</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">               <span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">               intercepted = <span class="keyword">true</span>;</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<ul>
<li>从上面的代码可以看出，在两种情况下ViewGroup会拦截此事件：事件类型为：ACTION_DOWN或者mFirstTouchTarget ！= null。当是事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向该子元素。</li>
<li>也就是说，当ViewGroup不拦截事件并将事件交给子元素处理时，mFirstTouchTarget ！= null。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget ！= null就不成立。</li>
<li>那么当MOVE和UP事件传递过来的时候，由于（actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null）为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其他事件都会默认交给它处理</li>
<li>还有一种特殊情况，那就是 FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceptTouchEvent来设置的，一旦被设置后，ViewGroup将无法拦截除了DOWN事件以外的点击事件。这时因此ViewGroup在分发事件时，如果是DOWN事件的话就会重置这个标记位，将导致子View中设置的标记无效，面对DOWN事件，ViewGroup总会询问自己是不是要拦截：</li>
<li>小结：当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理，并且不再调用onInterceptTouchEvent。FLAG_DISALLOW_INTERCEPT这个标记的作用是让ViewGroup不再拦截事件，</li>
<li>接着看ViewGroup不拦截事件的时候，事件会向下分发交给它的子View进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> View[] children = mChildren;</div><div class="line">                      <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                          <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">                                  ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">                          <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                                  ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line"></div><div class="line">                          <span class="comment">// If there is a view that has accessibility focus we want it</span></div><div class="line">                          <span class="comment">// to get the event first and if not handled we will perform a</span></div><div class="line">                          <span class="comment">// normal dispatch. We may do a double iteration but this is</span></div><div class="line">                          <span class="comment">// safer given the timeframe.</span></div><div class="line">                          <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">                              <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                  <span class="keyword">continue</span>;</div><div class="line">                              &#125;</div><div class="line">                              childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">                              i = childrenCount - <span class="number">1</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">                                  || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">                              ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                              <span class="keyword">continue</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          newTouchTarget = getTouchTarget(child);</div><div class="line">                          <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                              <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">                              <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">                              newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                              <span class="keyword">break</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          resetCancelNextUpFlag(child);</div><div class="line">                          <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                              <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">                              mLastTouchDownTime = ev.getDownTime();</div><div class="line">                              <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                                  <span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">                                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                                      <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                          mLastTouchDownIndex = j;</div><div class="line">                                          <span class="keyword">break</span>;</div><div class="line">                                      &#125;</div><div class="line">                                  &#125;</div><div class="line">                              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                  mLastTouchDownIndex = childIndex;</div><div class="line">                              &#125;</div><div class="line">                              mLastTouchDownX = ev.getX();</div><div class="line">                              mLastTouchDownY = ev.getY();</div><div class="line">                              newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                              alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                              <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>首先遍历ViewGroup所有子View，然后判断子View是不是能够接收点击事件。是否能够接收点击事件主要由两点来衡量：子元素是否在播放动画和点击事件的坐标是不是落在子元素的区域。如果子View满足两个条件的话，那么事件将交给它处理，</li>
<li>实际调用子元素的dispatchTouchEvent是在dispatchTransformedTouchEvent中，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">           View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line"></div><div class="line">       <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></div><div class="line">       <span class="comment">// or filtering.  The important part is the action, not the contents.</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">       <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">           event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">           <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">               handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               handled = child.dispatchTouchEvent(event);</div><div class="line">           &#125;</div><div class="line">           event.setAction(oldAction);</div><div class="line">           <span class="keyword">return</span> handled;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果传递的字View不为null的话，就会调用子View的dispatchTouchEvent，这样事件就交给子View处理了</li>
<li>如果子View的dispatchTouchEvent返回true的话，那么mFirstTouchTarget就会被赋值并跳出循环：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                                <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码完成了对mFirstTouchTarget赋值并终止了对子View的遍历。</li>
<li>如果子View返回false的话，ViewGroup会将事件分给下一个子View（还有下一个子 View的话）</li>
<li>如果遍历所有子View后事件都没有被合适处理，这包含两种情况：<ul>
<li>ViewGroup没有子View</li>
<li>子元素处理了点击事件，但是在dispatchTouchEvent中返回false。</li>
</ul>
</li>
<li>上面这两种情况下ViewGroup会自己处理点击事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dispatch to touch targets.</span></div><div class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                       TouchTarget.ALL_POINTER_IDS);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码中第三个参数为null，显然调用super.dispatchTouchEvent</li>
</ul>
<h5 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a>View对点击事件的处理过程</h5><ul>
<li>先看看其dispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">    ListenerInfo li = mListenerInfo;</div><div class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">    mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></div><div class="line"><span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></div><div class="line"><span class="comment">// of the gesture.</span></div><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</div><div class="line">        actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class="line">        (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class="line">    stopNestedScroll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<ul>
<li>可以看到，首先会判断有没有设置OnTouchEventListener，如果OnTouchEventListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，这样做的好处是方便外界处理点击事件</li>
<li>接下来分析onTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">        setPressed(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">    <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">    <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面是View在不可用的状态下点击事件的处理过程，显然不可用的View照样会消费事件，只是没有为点击做出回应</li>
<li>下面看看onTouchEvent对点击事件的具体处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">               (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">               (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">           <span class="keyword">switch</span> (action) &#123;</div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                   <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                   <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</div><div class="line">                       <span class="comment">// take focus if we don't have it already and we should in</span></div><div class="line">                       <span class="comment">// touch mode.</span></div><div class="line">                       <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                           focusTaken = requestFocus();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                           <span class="comment">// The button is being released before we actually</span></div><div class="line">                           <span class="comment">// showed it as pressed.  Make it show the pressed</span></div><div class="line">                           <span class="comment">// state now (before scheduling the click) to ensure</span></div><div class="line">                           <span class="comment">// the user sees it.</span></div><div class="line">                           setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                           <span class="comment">// This is a tap, so remove the longpress check</span></div><div class="line">                           removeLongPressCallback();</div><div class="line"></div><div class="line">                           <span class="comment">// Only perform take click actions if we were in the pressed state</span></div><div class="line">                           <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                               <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                               <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                               <span class="comment">// of the view update before click actions start.</span></div><div class="line">                               <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                   mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                               &#125;</div><div class="line">                               <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                   performClick();</div><div class="line">                               &#125;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                           mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                           postDelayed(mUnsetPressedState,</div><div class="line">                                   ViewConfiguration.getPressedStateDuration());</div><div class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                           <span class="comment">// If the post failed, unpress right now</span></div><div class="line">                           mUnsetPressedState.run();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       removeTapCallback();</div><div class="line">                   &#125;</div><div class="line">                   mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                   mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class="line">                   <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                   <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class="line">                   <span class="comment">// a short period in case this is a scroll.</span></div><div class="line">                   <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                       mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                       <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                           mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                       &#125;</div><div class="line">                       mPendingCheckForTap.x = event.getX();</div><div class="line">                       mPendingCheckForTap.y = event.getY();</div><div class="line">                       postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></div><div class="line">                       setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                       checkForLongClick(<span class="number">0</span>);</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                   setPressed(<span class="keyword">false</span>);</div><div class="line">                   removeTapCallback();</div><div class="line">                   removeLongPressCallback();</div><div class="line">                   mInContextButtonPress = <span class="keyword">false</span>;</div><div class="line">                   mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                   mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                   drawableHotspotChanged(x, y);</div><div class="line"></div><div class="line">                   <span class="comment">// Be lenient about moving outside of buttons</span></div><div class="line">                   <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                       <span class="comment">// Outside button</span></div><div class="line">                       removeTapCallback();</div><div class="line">                       <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                           <span class="comment">// Remove any future long press/tap checks</span></div><div class="line">                           removeLongPressCallback();</div><div class="line"></div><div class="line">                           setPressed(<span class="keyword">false</span>);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>只要View的CLICKABLE和LONG——CLICKABLE有一个为true的话，那么它就会消费这个事件，即onTouchEvent返回true，不管状态是不是DISABLE状态。然后就是当ACTION_UP事件发生时，就会出发performClick，如果View设置了OnClickListener的话，performClick内部就会调用onClick</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">*/</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">     <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">     <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">         playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">         li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">         result = <span class="keyword">true</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         result = <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>View的LONG_CLICKABLE默认设置为false，而CLICKABLE则要看具体的View，可点击的View的CLICKABLE为true，不可点击的为false。</li>
<li><p>setOnClickListener会自动将View的CLICKABLE设置为true，setOnLongClickListener也会将View的LONG_CLICKABLE设置为true，在源码可以找到，这里就不贴代码了。</p>
</li>
<li><p>结论：</p>
<ul>
<li>正常情况下，一个事件序列只能被一个View拦截且消费，因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一事件序列中的事件不能分别由两个View同时处理，但是通过特殊的手段可以实现，比如一个View将本该自己处理的事件通过onTouchEvent返回false，强行传给其他View</li>
<li>某个View一旦决定拦截，那么一个事件序列都只能有它处理，并且onInterceptTouchEvent不会被调用。</li>
<li>某个View一旦开始处理事件，如果不消耗ACTION_DOWN事件，那么同一事件序列中的其他事件都不会交给它处理，并且事件将重新交给父元素去处理。</li>
<li>如果View不消耗ACTION_DOWN以外的事件，那么这个点击事件会消失，此时父元素的onTouchEvent不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件由Activity来处理。</li>
<li>ViewGroup内部默认不拦截事件</li>
<li>View中不能拦截事件，一旦有事件交给它，它的onTouchEvent就会被调用</li>
<li>View的onTouchEvent都默认消费事件，除非它是不可点击的。</li>
<li>View的enable不影响onTouchEvent的默认返回值。</li>
<li>onClick的发生前提时当前View可点击，并且它收到了down和up事件</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，容纳后再由父元素进行分发，通过requestDisalowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发，但是ACTION_DOWN除外</li>
</ul>
</li>
</ul>
<h5 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h5><ul>
<li>在界面中，只要内外两层同时可以滑动，这个时候就会产生滑动冲突</li>
</ul>
<h5 id="常见的滑动冲突场景："><a href="#常见的滑动冲突场景：" class="headerlink" title="常见的滑动冲突场景："></a>常见的滑动冲突场景：</h5><ul>
<li>外部滑动和内部滑动方向不一致；</li>
<li>外部滑动方向和内部滑动方向一致；</li>
<li>上面两种情况的嵌套。</li>
</ul>
<h5 id="滑动冲突的处理规则"><a href="#滑动冲突的处理规则" class="headerlink" title="滑动冲突的处理规则"></a>滑动冲突的处理规则</h5><ul>
<li>对于场景一，处理的规则是：当用户左右（上下）滑动时，需要让外部的View拦截点击事件，当用户上下（左右）滑动的时候，需要让内部的View拦截点击事件。根据滑动的方向判断谁来拦截事件。</li>
<li>对于场景二，由于滑动方向一致，这时候只能在业务上找到突破点，根据业务需求，规定什么时候让外部View拦截事件，什么时候由内部View拦截事件。</li>
<li>场景三的情况相对比较复杂，同样根据需求在业务上找到突破点。</li>
</ul>
<h5 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h5><ul>
<li>外部拦截法：所谓的外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。下面是伪代码：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">     <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line">     <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line"></div><div class="line">     <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">       <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">           <span class="keyword">if</span> (父容器需要当前事件）&#123;</div><div class="line">               intercepted = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               intercepted = flase;</div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">       &#125;    </div><div class="line"></div><div class="line">      <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">          intercepted = <span class="keyword">false</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLastXIntercept=x;</div><div class="line">    mLastYIntercept=y;</div><div class="line">    <span class="keyword">return</span> intercepted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>内部拦截法：内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗，否则就交由父容器进行处理。这种方法与Android事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。下面是伪代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent even)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) even.getX();</div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) even.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (even.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                parent.requestDisallowIntercepttouchEvent(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</div><div class="line">                <span class="keyword">int</span> deltaY = x - mLastY;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(父容器需要此类点击事件) &#123;</div><div class="line">                    parent.requestDisallowIntercepttouchEvent(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            mLastX = x;</div><div class="line">            mLastY = y;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(even);</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>除了子元素需要做处理外，父元素也要默认拦截ACTION_DOWN以外的事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需要的事件，因此，父元素需要修改：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent even)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> action = even.getAction();</div><div class="line">	<span class="keyword">if</span>(about == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;第三章：View的事件体系&quot;&gt;&lt;a href=&quot;#第三章：View的事件体系&quot; class=&quot;headerlink&quot; title=&quot;第三章：View的事件体系&quot;&gt;&lt;/a&gt;第三章：View的事件体系&lt;/h4&gt;&lt;h5 id=&quot;View的位置参数：&quot;&gt;&lt;a href=&quot;#View的位置参数：&quot; class=&quot;headerlink&quot; title=&quot;View的位置参数：&quot;&gt;&lt;/a&gt;View的位置参数：&lt;/h5&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="安卓开发艺术探索笔记" scheme="http://cristianoro7.github.io/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发艺术探索-自定义View的思想-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://cristianoro7.github.io/2017/10/31/安卓开发艺术探索-第四章笔记(二)/</id>
    <published>2017-10-31T13:56:09.408Z</published>
    <updated>2017-10-31T13:56:09.408Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h4><h5 id="概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理"><a href="#概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理" class="headerlink" title="概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理"></a>概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理</h5><a id="more"></a>
<h5 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h5><ul>
<li>继承View重写onDraw方法：采用这种方式需要自己支持wrap_content和padding</li>
<li>继承ViewGroup派生出特殊的layout：需要根据需求来处理ViewGroup的测量和布局这两个过程，并且同时处理子元素的测量和布局的过程</li>
<li>继承特定的View（比如TextView）：扩展某种View的功能</li>
<li>继承特定的ViewGroup（比如LinearLayout）</li>
</ul>
<h5 id="自定义View须知："><a href="#自定义View须知：" class="headerlink" title="自定义View须知："></a>自定义View须知：</h5><ul>
<li>让View支持wrap_content</li>
<li>如果有必要，让你的View支持padding</li>
<li>尽量要在View中使用Handler，没必要</li>
<li>View中如果有线程或者动画，需要及时停止</li>
<li>View带有滑动嵌套情形时，需要处理好滑动冲突</li>
</ul>
<h5 id="自定义View的实例，具体在书中P202-P216"><a href="#自定义View的实例，具体在书中P202-P216" class="headerlink" title="自定义View的实例，具体在书中P202~P216"></a>自定义View的实例，具体在书中P202~P216</h5><blockquote>
<p>以上笔记来源于安卓开发艺术探索一书中</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;自定义View&quot;&gt;&lt;a href=&quot;#自定义View&quot; class=&quot;headerlink&quot; title=&quot;自定义View&quot;&gt;&lt;/a&gt;自定义View&lt;/h4&gt;&lt;h5 id=&quot;概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理&quot;&gt;&lt;a href=&quot;#概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理&quot; class=&quot;headerlink&quot; title=&quot;概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理&quot;&gt;&lt;/a&gt;概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理&lt;/h5&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="安卓开发艺术探索笔记" scheme="http://cristianoro7.github.io/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发艺术探索-View的工作原理（一）-笔记</title>
    <link href="http://cristianoro7.github.io/2017/10/31/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://cristianoro7.github.io/2017/10/31/安卓开发艺术探索-第四章笔记(一)/</id>
    <published>2017-10-31T13:56:07.576Z</published>
    <updated>2017-10-31T13:56:07.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h4><h5 id="初始ViewRoot和DecorView"><a href="#初始ViewRoot和DecorView" class="headerlink" title="初始ViewRoot和DecorView"></a>初始ViewRoot和DecorView</h5><a id="more"></a>
<ul>
<li><p>ViewRoot对应的实体类是ViewRootImpl类，它时连接WindowManager和DecorView的纽带</p>
</li>
<li><p>View的三大流程都是通过ViewRoot完成的</p>
</li>
<li><p>在ActivityThread中，当Activity对象被创建后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewImpl对象和DecorView建立关联：</p>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext, display);</div><div class="line">root.setView(view, wparams, panelParentView);</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>View的绘制流程是从ViewRoot的performTraversals中开始的，它经过measure，layout，draw三个过程。</p>
</li>
<li><p>performTraversals大致流程：</p>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>childLayoutParams\parentSpecMode</th>
<th>ECACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp/px</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><p>DecorView作为顶级View，本质是一个LinearLayout，该layout中一般情况下包含标题栏和内容栏。</p>
</li>
<li><p>在Activity中，我们setContentView所设置的布局，其实就是被加到内容栏中的</p>
</li>
</ul>
<hr>
<h5 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h5><p>MeasureSpec很大程度上决定了一个View的尺寸规格，之所以说很大程度，其实时因为在这个过程中还受父容器的影响，父容器回影响View的MeasureSpec的创建。</p>
<ul>
<li><p>MeasureSpec代表一个32位的int值，高2位代表SpecMode：测量模式，低30位表示SpecSize：在某种模式下的测量规格。</p>
</li>
<li><p>在下面的源码中，MeasureSpec将SpecMode和SpecSize打包成一个int值来避免过多对象内存的分配。为了方便操作提供了打包和解包的方法</p>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has not imposed any constraint</div><div class="line">         * on the child. It can be whatever size it wants.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has determined an exact size</div><div class="line">         * for the child. The child is going to be given those bounds regardless</div><div class="line">         * of how big it wants to be.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The child can be as large as it wants up</div><div class="line">         * to the specified size.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Like &#123;<span class="doctag">@link</span> #makeMeasureSpec(int, int)&#125;, but any spec with a mode of UNSPECIFIED</div><div class="line">         * will automatically get a size of 0. Older apps expect this.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@hide</span> internal use only for compatibility with system widgets and older apps</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the mode from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the mode from</div><div class="line">         * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#UNSPECIFIED&#125;,</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#AT_MOST&#125; or</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#EXACTLY&#125;</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the size from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the size from</div><div class="line">         * <span class="doctag">@return</span> the size in pixels defined in the supplied measure specification</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</div><div class="line">            <span class="keyword">int</span> size = getSize(measureSpec);</div><div class="line">            <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="comment">// No need to adjust size for UNSPECIFIED mode.</span></div><div class="line">                <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            size += delta;</div><div class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">                Log.e(VIEW_LOG_TAG, <span class="string">"MeasureSpec.adjust: new size would be negative! ("</span> + size +</div><div class="line">                        <span class="string">") spec: "</span> + toString(measureSpec) + <span class="string">" delta: "</span> + delta);</div><div class="line">                size = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>SpecMode有三类：</p>
<ul>
<li><p>UNSPECIFIED：父容器不对View有限制，这种情况一般用于系统内部，表示一种测量的状态</p>
</li>
<li><p>EXACTLY：父容器已经检验出View所需要的大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式</p>
</li>
<li><p>AT_MOST:父容器指定了一个可用的大小，即SpecSize，View的大小不能大于这个值。它对应于LayoutParams中的wrap_content</p>
</li>
</ul>
</li>
<li><p>MeasureSpec和LayoutParams的对应关系</p>
<ul>
<li><p>正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParams。在View测量的时候，系统会将LayoutParams在父容器的约束下转为对应的MeasureSpec，然后再根据这个MeasureSpec来确定View的宽高</p>
</li>
<li><p>LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽高</p>
</li>
<li><p>对于顶级View（DecorView）和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定</p>
</li>
<li><p>DecorView的MeasureSpec创建过程是在ViewRootImpl中的measureHierarchy方法创建的：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
<ul>
<li>接着看看getRootMeasureSpec：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;pre style="background-color:#21282d;color:#e0e2e4;font-family:'Courier New';font-size:15.0pt;"&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class="line"> int measureSpec;</div><div class="line"> switch (rootDimension) &#123;</div><div class="line"></div><div class="line"> case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line"> // Window can't resize. Force root view to be windowSize.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line"> case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line"> // Window can resize. Set max size for root view.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line"> break;</div><div class="line"> default:</div><div class="line"> // Window wants to be an exact size. Force root view to be that size.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line">&#125;  return measureSpec;&lt;/pre&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>LayoutParams.MATCH_PARENT:精确模式，大小就是窗口的大小；</p>
</li>
<li><p>LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小</p>
</li>
<li><p>固定大小：精确模式，大小为LayoutParams中指定的大小。</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>对于普通View来说（指的时我们布局中的View），它的measure过程是由ViewGroup传递过来的，下面看看ViewGroup中的measureChildWithMargins：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">           <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">       <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                       + widthUsed, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                       + heightUsed, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>从上面代码来看，子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，此外还有与View的margin和padding有关，下面再看看ViewGroup的getChildMeasureSpec：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">      <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">      <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">      <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">              <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">              <span class="comment">// be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">              <span class="comment">// big it should be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>从上面的方法来看，它的主要作用时结合父容器发MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，参数中的padding指的是父容器中已被占用的空间大小。</p>
</li>
<li><p>下面的表是对getChildMeasureSpec的工作原理的梳理，其中parentSize指的是父容器中目前可以使用的大小。</p>
</li>
</ul>
<hr>
<p><img src="index_files/f78c4596-e57c-41be-a3ca-a75bdcd06778.jpg" alt=""></p>
<h4 id="View的工作过程"><a href="#View的工作过程" class="headerlink" title="View的工作过程"></a>View的工作过程</h4><h5 id="View的measure过程："><a href="#View的measure过程：" class="headerlink" title="View的measure过程："></a>View的measure过程：</h5><ul>
<li>measure方法时一个final方法，则意味着不能重写该方法，在该方法中会调用View的onMeasure方法（真正测量的方法）， 下面我们看看onMeasure的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">  getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setMeasureDimension方法中会设置View的宽高的测量值，因此，我们来看看getDefaultSize方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = size;</div><div class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">  result = size;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">  <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">  result = specSize;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"> &#125;  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于我我们来说，我们只看AT_MOST和EXACTLY这两种情况。简单的理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，这个specSize就是测量后View的大小，这里说时是测量后，是因为View的最终大小是在layout阶段确定的，除了特殊情况外，View的测量大小和最终大小是相等的。</p>
<ul>
<li>对于UNSPECIFIED来说，一般用于系统内部测量，在这种情况下，View的大小为getDefaultSize第一个参数size，即分别为getSuggestedMinimumWidth/Height：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果View没有设置背景，那么View的高度为mMinHeight，而该属性对应于aandroid：minWidth，如果这个属性不指定的话，默认为0。如果设置了背景则返回minHeight和背景的最小高度中的最大值</p>
<ul>
<li><p>从getDefaultSize的实现来看，我们可以得到以下小结：</p>
<ul>
<li><p>直接继承View的自定义控件需要重写onMeasure方法设置wrap_content时的自身大小，否则在布局中使用就相当于match_parent</p>
</li>
<li><p>通过之前分析，如果View在布局中被设为wrap_content的话，它的specMode时AT_MOST模式，此时它的宽高等于specSize，而View的specSize是parentSize，parentSize是父容器目前所剩余的空间大小。这样这种效果就相当于match_parent</p>
</li>
<li><p>解决方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"> <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"> <span class="keyword">int</span> widthSpecMode = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> widthSpecSize = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecMode = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecSize = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, mHeight);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, heightSpecSize);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(heightSpecMode == View.MeasureSpec.AT_MOST)&#123;</div><div class="line"> setMeasureDimension(widthSpecSize, mHeight);</div><div class="line"></div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于wrap_content的情形，我们直接设置我们默认的大小就可以</p>
<hr>
<h5 id="ViewGroup的measure过程："><a href="#ViewGroup的measure过程：" class="headerlink" title="ViewGroup的measure过程："></a>ViewGroup的measure过程：</h5><ul>
<li><p>ViewGroup除了测量自身的大小外，还会遍历所有的子元素的measure方法，各个子元素再递归去执行这个过程</p>
</li>
<li><p>ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但是提供了一个measureChildren的方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码来看，ViewGroup在meaure的时候，会对每个子元素进行measure，下面来看看measureChild：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>meaureChild中，就是取出子元素的LayoutParams，然后通过getChildMeasureSpec来创建子元素的MeasureSpec。将MeaureSpec直接传递给View的meaure进行测量。</p>
<ul>
<li><p>我们知道ViewGroup是一个抽象类，并没有实现具体的测量过程，所以，我们来看看它子类中的实现，下面用LinearLayout来当例子</p>
</li>
<li><p>首先先来看看其onMeasure方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面代码中，根据不同的布局方向来测量，我们选择来看竖直方向的测量过程中的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// See how tall everyone is. Also remember max width.</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">          <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">              mTotalLength += measureNullChild(i);</div><div class="line">              <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">             i += getChildrenSkipCount(child, i);</div><div class="line">             <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">              mTotalLength += mDividerHeight;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">          totalWeight += lp.weight;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Optimization: don't bother measuring children who are going to use</span></div><div class="line">              <span class="comment">// leftover space. These views will get measured again down below if</span></div><div class="line">              <span class="comment">// there is any leftover space.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class="line">              skippedMeasure = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></div><div class="line">                  <span class="comment">// child wanted to stretch to fill available space.</span></div><div class="line">                  <span class="comment">// Translate that to WRAP_CONTENT so that it does not end up</span></div><div class="line">                  <span class="comment">// with a height of 0</span></div><div class="line">                  oldHeight = <span class="number">0</span>;</div><div class="line">                  lp.height = LayoutParams.WRAP_CONTENT;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// Determine how big this child would like to be. If this or</span></div><div class="line">              <span class="comment">// previous children have given a weight, then we allow it to</span></div><div class="line">              <span class="comment">// use all available space (and we will shrink things later</span></div><div class="line">              <span class="comment">// if needed).</span></div><div class="line">              measureChildBeforeLayout(</div><div class="line">                     child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</div><div class="line">                     totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">                 lp.height = oldHeight;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                     lp.bottomMargin + getNextLocationOffset(child));</div></pre></td></tr></table></figure>
<p>系统会遍历每个子元素，并且对每个子元素进行measureChildBeforeLayout，这个方法会调用子元素的measure，这样就开始了measure过程，并且系统会通过mToatalLength这个变量来保存LinearLayout在竖直方向上的初步高度，当测量完子元素时，LinearLauout会测量自己的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add in our padding</span></div><div class="line">       mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> heightSize = mTotalLength;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum height</span></div><div class="line">       heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line"></div><div class="line">       <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></div><div class="line">       <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">       heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line"></div><div class="line">       <span class="comment">// Either expand children with weight to take up available space or</span></div><div class="line">       <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></div><div class="line">       <span class="comment">// measurement on any children, we need to measure them now.</span></div><div class="line">       <span class="keyword">int</span> delta = heightSize - mTotalLength;</div><div class="line">       <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">           <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line"></div><div class="line">           mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">               <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">               <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">               <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                   <span class="comment">// Child said it could absorb extra space -- give him his share</span></div><div class="line">                   <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">                   weightSum -= childExtra;</div><div class="line">                   delta -= share;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                           mPaddingLeft + mPaddingRight +</div><div class="line">                                   lp.leftMargin + lp.rightMargin, lp.width);</div><div class="line"></div><div class="line">                   <span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">                   <span class="comment">// child has been previously measured</span></div><div class="line">                   <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != MeasureSpec.EXACTLY)) &#123;</div><div class="line">                       <span class="comment">// child was measured once already above...</span></div><div class="line">                       <span class="comment">// base new measurement on stored values</span></div><div class="line">                       <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</div><div class="line">                       <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</div><div class="line">                           childHeight = <span class="number">0</span>;</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// child was skipped in the loop above.</span></div><div class="line">                       <span class="comment">// Measure for this first time here      </span></div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// Child may now not fit in vertical dimension.</span></div><div class="line">                   childState = combineMeasuredStates(childState, child.getMeasuredState()</div><div class="line">                           &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</div><div class="line">               maxWidth = Math.max(maxWidth, measuredWidth);</div><div class="line"></div><div class="line">               <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</div><div class="line">                       lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                       matchWidthLocally ? margin : measuredWidth);</div><div class="line"></div><div class="line">               allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">               mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</div><div class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Add in our padding</span></div><div class="line">           mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">           <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                                          weightedMaxWidth);</div><div class="line"></div><div class="line"></div><div class="line">           <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></div><div class="line">           <span class="comment">// Children will have already been measured once.</span></div><div class="line">           <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                   <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">                       <span class="keyword">continue</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                           (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                   <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">                   <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                       child.measure(</div><div class="line">                               MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</div><div class="line">                                       MeasureSpec.EXACTLY),</div><div class="line">                               MeasureSpec.makeMeasureSpec(largestChildHeight,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">           maxWidth = alternativeMaxWidth;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       maxWidth += mPaddingLeft + mPaddingRight;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum width</span></div><div class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line"></div><div class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">               heightSizeAndState);</div></pre></td></tr></table></figure>
<ul>
<li><p>分析到这里算是把measure分析完了，下面我们来看看需要注意的一些地方：</p>
<ul>
<li>如果要获取View的测量宽高或者最终宽高的话，比较好的做法是在onLayout中获取，因为在某些极端的情况下，measure可能会被多次调用，这样在onMeasure获取的宽高就不准确</li>
</ul>
</li>
<li><p>四种方法中的三种解决Activity启动时获取View的宽高</p>
<ul>
<li><p>在onWindowFocusChanged中获取： 该方法会在窗口的得到和失去焦点的时候被调用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</div><div class="line">    <span class="keyword">if</span>(hasFocus) &#123;</div><div class="line">        <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">        <span class="keyword">int</span> heigh = view.getMeasureHeight();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>view.post(runnable):将一个runnable投递到消息队列尾部，等待Looper调用此runnable的时候，View已经初始化完成了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        view.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ViewTreeObserver：使用其中的OnGlobalLayoutListener这个接口，当View状态或者View树内部的View可见性发现改变时，onGlobalLayout会被回调。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line"></div><div class="line">        ViewTreeObserver observer = view.getViewTreeObserver();</div><div class="line">        observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">                view.getViewTreeObserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h5><ul>
<li>先看看View的layout方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在layout中首先会通过setFrame方法来设定View的四个顶点位置，即初始化mLeft， mRight， mTop， mBottom，view的顶点确定后，那么View在ViewGroup中的位置也相应的确定；接着调用onLayout的方法，该方法的具体实现是在ViewGroup的子类中，我们来看看LinearLayout中是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           layoutVertical(l, t, r, b);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           layoutHorizontal(l, t, r, b);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们只拿竖直方向上的来分析：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> childTop;</div><div class="line">        <span class="keyword">int</span> childLeft;</div><div class="line"></div><div class="line">        <span class="comment">// Where right end of child should go</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</div><div class="line">        <span class="keyword">int</span> childRight = width - mPaddingRight;</div><div class="line"></div><div class="line">        <span class="comment">// Space available for child</span></div><div class="line">        <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (majorGravity) &#123;</div><div class="line">           <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">           <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">           <span class="keyword">case</span> Gravity.TOP:</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                childTop += measureNullChild(i);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line"></div><div class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                <span class="keyword">int</span> gravity = lp.gravity;</div><div class="line">                <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</div><div class="line">                    gravity = minorGravity;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</div><div class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</div><div class="line">                                + lp.leftMargin - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</div><div class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.LEFT:</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        childLeft = paddingLeft + lp.leftMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                    childTop += mDividerHeight;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                childTop += lp.topMargin;</div><div class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                        childWidth, childHeight);</div><div class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line"></div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此方法会遍历所有子元素并调用setChildFrame来为子元素指定相应的位置，该方法中调用了子元素的layout方法，这样就实现了View的一层层测量。</p>
<ul>
<li><p>分析完了layout，我们来看看哪些需要注意的地方：</p>
<ul>
<li>View的getMeasureWidth和getWidth有什么区别：我们首先来看看getWidth的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> mRight - mLeft;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在View的默认实现过程中，View的测量宽高和最终宽高时相等的，只不过两者的赋值时机不同而已，测量宽高是在measure，而最终宽高是在layout。</p>
</li>
</ul>
<hr>
<h5 id="draw过程："><a href="#draw过程：" class="headerlink" title="draw过程："></a>draw过程：</h5><ul>
<li><p>View的绘制过程遵循下面这几步：</p>
<ul>
<li>绘制自己的背景（bakcground.draw(canvas)）</li>
<li>绘制自己（onDraw）</li>
<li>绘制children（dispatchDraw）</li>
<li>绘制装饰（onDrawScrollBars）</li>
</ul>
</li>
<li><p>上面的这个步骤可以在draw源码中看出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">               (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">       <span class="comment">/*</span></div><div class="line">        * Draw traversal performs several drawing steps which must be executed</div><div class="line">        * in the appropriate order:</div><div class="line">        *</div><div class="line">        *      1. Draw the background</div><div class="line">        *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">        *      3. Draw view's content</div><div class="line">        *      4. Draw children</div><div class="line">        *      5. If necessary, draw the fading edges and restore layers</div><div class="line">        *      6. Draw decorations (scrollbars for instance)</div><div class="line">        */</div><div class="line"></div><div class="line">       <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">       <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">           drawBackground(canvas);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">       <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">           <span class="comment">// Step 3, draw the content</span></div><div class="line">           <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Step 4, draw the children</span></div><div class="line">           dispatchDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">           <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">               mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">           onDrawForeground(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// we're done...</span></div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>View的绘制过程的传递时通过dispatchDraw来实现的，该方法回遍历所有子元素的draw（具体的实现实在ViewGroup的子类中），这样draw就可以一层层传递下去。View中的一个特殊方法：setWillNotDraw:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</div><div class="line">       setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>如果一个View不需要绘制任何内容的话，我们就可以把这个标记设为true。默认情况下View没有启动这个标志，但是ViewGroup会默认启动。如果我们自定义控件的时候需要继承ViewGroup时，我们就可以开启这个标记来便于系统的后续优化。</p>
<blockquote>
<p>以上的笔记来源于安卓开发艺术探索</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;View的工作原理&quot;&gt;&lt;a href=&quot;#View的工作原理&quot; class=&quot;headerlink&quot; title=&quot;View的工作原理&quot;&gt;&lt;/a&gt;View的工作原理&lt;/h4&gt;&lt;h5 id=&quot;初始ViewRoot和DecorView&quot;&gt;&lt;a href=&quot;#初始ViewRoot和DecorView&quot; class=&quot;headerlink&quot; title=&quot;初始ViewRoot和DecorView&quot;&gt;&lt;/a&gt;初始ViewRoot和DecorView&lt;/h5&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="安卓开发艺术探索笔记" scheme="http://cristianoro7.github.io/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>universal-image-loader缓存策略</title>
    <link href="http://cristianoro7.github.io/2017/10/31/universal-image-loader%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://cristianoro7.github.io/2017/10/31/universal-image-loader内存缓存策略/</id>
    <published>2017-10-31T13:54:57.407Z</published>
    <updated>2017-10-31T13:54:57.407Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>有看过UIL源码的人都应该知道，库中缓存使用了策略模式来对bitmap进行缓存。这次来单独来分析其中的内存缓存策略<br><a id="more"></a></p>
<h5 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h5><p>接口：</p>
<ul>
<li>MemoryCacheAware：底层接口，里面定义了基本的缓存操作方法</li>
<li>MemoryCache：单纯继承了MemoryCacheAware接口</li>
</ul>
<p>抽象类：</p>
<ul>
<li>BaseMemoryCache：实现了MemoryCahce，运用弱引用包装Bitmap后缓存存在HashMap中。同时也实现了MemoryCacheAware中的接口的方法</li>
<li>LimitedMemoryCache：这个类继承BaseMemoryCahce，并在类中扩展了一级强引用缓存，也就是说LimitedMemoryCache是拥有双级缓存的（强引用缓存，弱引用缓存）。<ul>
<li>LimitedMemoryCache会限制内存的缓存大小，当达到缓存达到最大的内存缓存时，会移除缓存，至于移除的策略，库中有提供几个实现策略。</li>
</ul>
</li>
</ul>
<p>具体实现类：</p>
<ul>
<li>WeakMeoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakMemoryCache</span> <span class="keyword">extends</span> <span class="title">BaseMemoryCache</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WeakMemoryCache是继承自BaseMemoryCache，并且只是重写了createReference，所有WeakMemoryCache只有弱引用的缓存。</p>
<ul>
<li>LruMemoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Bitmap&gt; map;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</div><div class="line">    <span class="comment">/** Size of this cache in bytes */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@param</span> maxSize Maximum sum of the sizes of the Bitmaps in this cache */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruMemoryCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;String, Bitmap&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the Bitmap for &#123;<span class="doctag">@code</span> key&#125; if it exists in the cache. If a Bitmap was returned, it is moved to the head</div><div class="line">     * of the queue. This returns null if a Bitmap is not cached.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">return</span> map.get(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Caches &#123;<span class="doctag">@code</span> Bitmap&#125; for &#123;<span class="doctag">@code</span> key&#125;. The Bitmap is moved to the head of the queue. */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            size += sizeOf(key, value);</div><div class="line">            Bitmap previous = map.put(key, value);</div><div class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                size -= sizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        trimToSize(maxSize);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove the eldest entries until the total of remaining entries is at or below the requested size.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1 to evict even 0-sized elements.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            String key;</div><div class="line">            Bitmap value;</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName() + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Map.Entry&lt;String, Bitmap&gt; toEvict = map.entrySet().iterator().next();</div><div class="line">                <span class="keyword">if</span> (toEvict == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                key = toEvict.getKey();</div><div class="line">                value = toEvict.getValue();</div><div class="line">                map.remove(key);</div><div class="line">                size -= sizeOf(key, value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists. */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Bitmap previous = map.remove(key);</div><div class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                size -= sizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> previous;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;String&gt;(map.keySet());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        trimToSize(-<span class="number">1</span>); <span class="comment">// -1 will evict 0-sized elements</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the size &#123;<span class="doctag">@code</span> Bitmap&#125; in bytes.</div><div class="line">     * &lt;p/&gt;</div><div class="line">     * An entry's size must not change while it is in the cache.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(<span class="string">"LruCache[maxSize=%d]"</span>, maxSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LruMemoryCache继承自MemoryCache，因此只有强引用的缓存，LruMemoryCache移除缓存的策略是使用最近最少使用算法，即每次通过get得到的Bitmap都会放在队列头，移除的时候就会先从队列尾移除，这样就保证了最少使用的最先被移除</p>
<ul>
<li>LimitedAgeMemoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedAgeMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxAge;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Long&gt; loadingDates = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Long&gt;());</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> cache  Wrapped memory cache</div><div class="line">     * <span class="doctag">@param</span> maxAge Max object age &lt;b&gt;(in seconds)&lt;/b&gt;. If object age will exceed this value then it'll be removed from</div><div class="line">     *               cache on next treatment (and therefore be reloaded).</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitedAgeMemoryCache</span><span class="params">(MemoryCache cache, <span class="keyword">long</span> maxAge)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.cache = cache;</div><div class="line">        <span class="keyword">this</span>.maxAge = maxAge * <span class="number">1000</span>; <span class="comment">// to milliseconds</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> putSuccesfully = cache.put(key, value);</div><div class="line">        <span class="keyword">if</span> (putSuccesfully) &#123;</div><div class="line">            loadingDates.put(key, System.currentTimeMillis());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> putSuccesfully;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Long loadingDate = loadingDates.get(key);</div><div class="line">        <span class="keyword">if</span> (loadingDate != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() - loadingDate &gt; maxAge) &#123;</div><div class="line">            cache.remove(key);</div><div class="line">            loadingDates.remove(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        loadingDates.remove(key);</div><div class="line">        <span class="keyword">return</span> cache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.keys();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        cache.clear();</div><div class="line">        loadingDates.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>LimitedAgeMemoryCache是MemoryCache的装饰类，也就是说LimitedAgeMemoryCache可以装饰实现了MemoryCache接口的类，比如LruMemoryCache。那么装饰的新功能是什么？</li>
<li><p>通过上面源码，可以清楚的得出，LimitedAgeMemoryCache是通过判断Bitmap的缓存时间是否超过在初始化传入时的缓存最大时间。超过的话就从内存中移除。</p>
</li>
<li><p>FuzzyKeyMemoryCache：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuzzyKeyMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;String&gt; keyComparator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FuzzyKeyMemoryCache</span><span class="params">(MemoryCache cache, Comparator&lt;String&gt; keyComparator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.cache = cache;</div><div class="line">        <span class="keyword">this</span>.keyComparator = keyComparator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Search equal key and remove this entry</span></div><div class="line">        <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line">            String keyToRemove = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (String cacheKey : cache.keys()) &#123;</div><div class="line">                <span class="keyword">if</span> (keyComparator.compare(key, cacheKey) == <span class="number">0</span>) &#123;</div><div class="line">                    keyToRemove = cacheKey;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (keyToRemove != <span class="keyword">null</span>) &#123;</div><div class="line">                cache.remove(keyToRemove);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cache.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        cache.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.keys();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FuzzyKeyMemoryCache也是继承自MemoryCache，同时也是MemoryCache的装饰类，装饰的新功能是：</li>
<li><p>当添加Bitmap进缓存时，如果添加进去的key跟之前添加过的key值相同的话，从内存移除之前key值对应的Bitmap，添加新传进来的Bitmap到内存。至于key相同的标准是什么,这个得根据自身的需求在重写Comparator对象并在初始化的时候传入。</p>
</li>
<li><p><strong>UsingFreqLimitedMemoryCache</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingFreqLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Contains strong references to stored objects (keys) and last object usage date (in milliseconds). If hard cache</div><div class="line">     * size will exceed limit then object with the least frequently usage is deleted (but it continue exist at</div><div class="line">     * &#123;<span class="doctag">@link</span> #softMap&#125; and can be collected by GC at any time)</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, Integer&gt; usingCounts = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Bitmap, Integer&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsingFreqLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            usingCounts.put(value, <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="comment">// Increment usage count for value if value is contained in hardCahe</span></div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            Integer usageCount = usingCounts.get(value);</div><div class="line">            <span class="keyword">if</span> (usageCount != <span class="keyword">null</span>) &#123;</div><div class="line">                usingCounts.put(value, usageCount + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            usingCounts.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        usingCounts.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer minUsageCount = <span class="keyword">null</span>;</div><div class="line">        Bitmap leastUsedValue = <span class="keyword">null</span>;</div><div class="line">        Set&lt;Entry&lt;Bitmap, Integer&gt;&gt; entries = usingCounts.entrySet();</div><div class="line">        <span class="keyword">synchronized</span> (usingCounts) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;Bitmap, Integer&gt; entry : entries) &#123;</div><div class="line">                <span class="keyword">if</span> (leastUsedValue == <span class="keyword">null</span>) &#123;</div><div class="line">                    leastUsedValue = entry.getKey();</div><div class="line">                    minUsageCount = entry.getValue();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Integer lastValueUsage = entry.getValue();</div><div class="line">                    <span class="keyword">if</span> (lastValueUsage &lt; minUsageCount) &#123;</div><div class="line">                        minUsageCount = lastValueUsage;</div><div class="line">                        leastUsedValue = entry.getKey();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        usingCounts.remove(leastUsedValue);</div><div class="line">        <span class="keyword">return</span> leastUsedValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>UsingFreqLimitedMemoryCache继承自LimitedMemoryCache，所以他拥有双级缓存用能（强弱引用缓存）。</li>
<li><p>UsingFreqLimitedMemoryCache的移除缓存的策略：每次使用get获得Bitmap时都会记录Bitmap使用的次数。要移除时，移除使用最少的次数的Bitmap，移除的只是强引用的缓存，弱引用中的缓存并不一定有被移除</p>
</li>
<li><p><strong>LRULimit</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">1.1f</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** Cache providing Least-Recently-Used logic */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Bitmap&gt; lruCache = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap&lt;String, Bitmap&gt;(INITIAL_CAPACITY, LOAD_FACTOR, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@param</span> maxSize Maximum sum of the sizes of the Bitmaps in this cache */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(maxSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            lruCache.put(key, value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        lruCache.get(key); <span class="comment">// call "get" for LRU logic</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        lruCache.remove(key);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        lruCache.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Bitmap mostLongUsedValue = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (lruCache) &#123;</div><div class="line">            Iterator&lt;Entry&lt;String, Bitmap&gt;&gt; it = lruCache.entrySet().iterator();</div><div class="line">            <span class="keyword">if</span> (it.hasNext()) &#123;</div><div class="line">                Entry&lt;String, Bitmap&gt; entry = it.next();</div><div class="line">                mostLongUsedValue = entry.getValue();</div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mostLongUsedValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>LRULimitedMemoryCache继承自LimitedMemoryCache，同样也是具有两级缓存。而移除的策略是lru算法，这里不多分析。</p>
</li>
<li><p><strong>LargestLimitedMemoryCache</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Contains strong references to stored objects (keys) and sizes of the objects. If hard cache</div><div class="line">     * size will exceed limit then object with the largest size is deleted (but it continue exist at</div><div class="line">     * &#123;<span class="doctag">@link</span> #softMap&#125; and can be collected by GC at any time)</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, Integer&gt; valueSizes = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Bitmap, Integer&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LargestLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            valueSizes.put(value, getSize(value));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            valueSizes.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        valueSizes.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer maxSize = <span class="keyword">null</span>;</div><div class="line">        Bitmap largestValue = <span class="keyword">null</span>;</div><div class="line">        Set&lt;Entry&lt;Bitmap, Integer&gt;&gt; entries = valueSizes.entrySet();</div><div class="line">        <span class="keyword">synchronized</span> (valueSizes) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;Bitmap, Integer&gt; entry : entries) &#123;</div><div class="line">                <span class="keyword">if</span> (largestValue == <span class="keyword">null</span>) &#123;</div><div class="line">                    largestValue = entry.getKey();</div><div class="line">                    maxSize = entry.getValue();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Integer size = entry.getValue();</div><div class="line">                    <span class="keyword">if</span> (size &gt; maxSize) &#123;</div><div class="line">                        maxSize = size;</div><div class="line">                        largestValue = entry.getKey();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        valueSizes.remove(largestValue);</div><div class="line">        <span class="keyword">return</span> largestValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LargestLimitedMemoryCache继承自LimitedMemoryCache，拥有双级缓存。移除缓存的策略是移除占内存最大的Bitmap</p>
<ul>
<li><strong>FIFOLimitedMemoryCache</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FIFOLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Bitmap&gt; queue = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;Bitmap&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            queue.add(value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            queue.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.remove(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理也是具有双级缓存功能，移除缓存的策略是移除头部的Bitmap</p>
<h5 id="内存缓存策略总结："><a href="#内存缓存策略总结：" class="headerlink" title="内存缓存策略总结："></a>内存缓存策略总结：</h5><ul>
<li><p>类库中提供的三个接口：</p>
<ul>
<li>MemoryCache：实现该接口的类只有强引用的缓存功能</li>
<li>BaseMemoryCache：实现该接口的类只有弱引用的缓存功能</li>
<li>LimitedMemoryCache：实现该类的拥有两级缓存功能（强弱引用功能）</li>
</ul>
</li>
<li><p>库中针对这三个接口，都给出了具体的实现类，我们可以根据自己的需求来设置缓存策略，默认的是LruMemoryCache</p>
</li>
<li>关于双级缓存：实现了LimitMemoryCache的类都具有双级缓存，但是为什么要使用双级缓存？<ul>
<li>理解：缓存内存的最大值是固定的，超过这个值后，我们就得从内存中移除Bitmap，但是我们有时不是想要移除，只是内存不足了，我们被迫移除了Bitmap，所以增加了一级强引用的缓存，当内存不足 时，首先移除强引用的Bitmap，弱引用并没有被移除。这样下次如果请求相同的Bitmap时，就可以从弱引用的缓存中取出。但是这样做也有缺点，牺牲了内存。</li>
<li>总体说就是双级缓存就是通过牺牲内存来提高响应速度。</li>
</ul>
</li>
<li>如果觉得库中提供给我们的策略不符合自己的业务需求的话，可以根据自己的业务需求来定制缓存策略。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;有看过UIL源码的人都应该知道，库中缓存使用了策略模式来对bitmap进行缓存。这次来单独来分析其中的内存缓存策略&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cristianoro7.github.io/categories/Android/"/>
    
    
      <category term="图片加载框架#universal-image-loader" scheme="http://cristianoro7.github.io/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6-universal-image-loader/"/>
    
  </entry>
  
</feed>
