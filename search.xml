<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[CustomView总结]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/CustomView%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<h2 id="LayoutParams认知"><a href="#LayoutParams认知" class="headerlink" title="LayoutParams认知"></a>LayoutParams认知</h2></blockquote>
<h3 id="Q-什么是LayoutParams-它跟view的关系是什么"><a href="#Q-什么是LayoutParams-它跟view的关系是什么" class="headerlink" title="Q: 什么是LayoutParams? 它跟view的关系是什么?"></a>Q: 什么是LayoutParams? 它跟view的关系是什么?</h3><blockquote>
<h4 id="什么是LayoutParams"><a href="#什么是LayoutParams" class="headerlink" title="什么是LayoutParams?"></a>什么是LayoutParams?</h4></blockquote>
<p>我们在XML布局中定义的layout_xx属性,最终都会以Java代码的形式展现出来, 而LayoutParams就是这些layout_xx属性在Java层的映射, 也就是说LayoutParams是view在xml布局中layout_xx的属性容器.</p>
<p>可见, LayoutParams是子View跟父View进行协商的桥梁. 协商的内容可有: 子View宽高, 子View在父View中摆放的位置等.</p>
<blockquote>
<h4 id="LayoutParams的继承关系"><a href="#LayoutParams的继承关系" class="headerlink" title="LayoutParams的继承关系"></a>LayoutParams的继承关系</h4></blockquote>
<p>LayoutParams是作为内部类定义在ViewGroup中,下面是LayoutParams的继承关系:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik760lyaqj30s20l8dgp.jpg" alt=""></p>
<p>LayoutParams是定义在ViewGroup, LayoutParams只支持 height, width. ViewGroupn内部的一个默认实现是MarginLayoutParams, 该类继承LayoutParams, 扩展了margin属性.接下来, 各个VieGroup的子类内部都有LayoutParams的子类,扩展对应ViewGroup的属性.比如 LinearLayout.LayoutParams, 增加了weight属性.</p>
<blockquote>
<h4 id="在Java代码中获取view的LayoutParams"><a href="#在Java代码中获取view的LayoutParams" class="headerlink" title="在Java代码中获取view的LayoutParams"></a>在Java代码中获取view的LayoutParams</h4></blockquote>
<p>既然LayoutParms是View对自己在父布局中的属性设置, 那么父View在测量或者布局的时候, 肯定是需要拿到这个LayoutParams对象的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(deepExport = <span class="keyword">true</span>, prefix = <span class="string">"layout_"</span>)</div><div class="line">    <span class="keyword">public</span> ViewGroup.<span class="function">LayoutParams <span class="title">getLayoutParams</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mLayoutParams;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set the layout parameters associated with this view. These supply</div><div class="line">     * parameters to the &lt;i&gt;parent&lt;/i&gt; of this view specifying how it should be</div><div class="line">     * arranged. There are many subclasses of ViewGroup.LayoutParams, and these</div><div class="line">     * correspond to the different subclasses of ViewGroup that are responsible</div><div class="line">     * for arranging their children.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> params The layout parameters for this view, cannot be null</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(ViewGroup.LayoutParams params)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Layout parameters cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line">        mLayoutParams = params;</div><div class="line">        resolveLayoutParams();</div><div class="line">        <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">            ((ViewGroup) mParent).onSetLayoutParams(<span class="keyword">this</span>, params);</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是View提供的接口, 用于设置和获取View中的LayoutParams.父View在测量和布局时, 就是通过<code>view.getLayoutParams()</code>来获得子<code>View</code>设置的<code>LayoutParams</code>.</p>
<blockquote>
<h2 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h2></blockquote>
<h3 id="Q-什么是MeasureSpec-它的工作原理是什么"><a href="#Q-什么是MeasureSpec-它的工作原理是什么" class="headerlink" title="Q: 什么是MeasureSpec? 它的工作原理是什么?"></a>Q: 什么是MeasureSpec? 它的工作原理是什么?</h3><blockquote>
<h4 id="什么是MeasureSpec"><a href="#什么是MeasureSpec" class="headerlink" title="什么是MeasureSpec?"></a>什么是MeasureSpec?</h4></blockquote>
<p>我们都知道, Android体系中, View有三种测量模式,每种测量模式都有对应View的宽高.</p>
<p>一个View可能会被多次测量, 在运行时也可能被动态改变而导致重新测量,布局. Android团队为了减少多次测量带来的对象分配消耗, 将View的测量模式和View的大小打包成一个int类型的值,从而减少了对象分配带来的消耗.</p>
<p>MeasureSpec这个类就是提供了打包和解包方法, 将测量模式和大小打包或者解包成int值.</p>
<blockquote>
<h4 id="MeasureSpec的工作原理"><a href="#MeasureSpec的工作原理" class="headerlink" title="MeasureSpec的工作原理"></a>MeasureSpec的工作原理</h4></blockquote>
<p>在Java中, int类型固定占4字节, 也就是32位.</p>
<p>由于三种测量模式用2位就能够表示, 可分别表示为:<code>00(UNSPECIFIED)</code>, <code>01(EXACTLY)</code>, <code>10(AT_MOST)</code>.</p>
<p>既然三种测量模式用2位表示就够, 那么剩下的低30位用来表示大小.</p>
<p>问题来了? 如何将2位的测量模式和30位的大小打包成一个int后, 能够无差错的解包成测量模式和View的大小?</p>
<p>答案: 使用掩码和逻辑或,与运算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has not imposed any constraint</div><div class="line"> * on the child. It can be whatever size it wants.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The parent has determined an exact size</div><div class="line"> * for the child. The child is going to be given those bounds regardless</div><div class="line"> * of how big it wants to be.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Measure specification mode: The child can be as large as it wants up</div><div class="line"> * to the specified size.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div></pre></td></tr></table></figure>
<p>MODE_SHIFT为移多少位, MODE_MASK为掩码. 现在我们来算算掩码:3表示为二进制为:11, 所以0x3 &lt;&lt; 30 表示为: 1100000000(30个0). 这个掩码的作用就是配合逻辑与,或操作来进行打包和解包的操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>上面是打包操作, 在<code>size &amp; ~MODE_MASK</code>中, ~MODE_MASK为: 0011111(30个1),由于低30为全为1, 那么与size进行&amp;操作时, 低30位就由szie的低三十为决定, 而高2位则为00, <code>size &amp; ~MODE_MASK</code>这个操作就是将size的高2为设置为00, 同理:<code>(mode &amp; MODE_MASK)</code>这个操作是将mode低30位设置为0. 最后再进行 | 操作, 这样就得到了高2位为测量模式, 低30位为大小的int.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>getMode方法将一个打包的measureSpec解包为mode, 原理是通过&amp;获取measureSpec的高2位. 同理getSize(int measureSpec)也是同种道理.</p>
<blockquote>
<h2 id="LayoutParams和MeasureSpec的关系"><a href="#LayoutParams和MeasureSpec的关系" class="headerlink" title="LayoutParams和MeasureSpec的关系"></a>LayoutParams和MeasureSpec的关系</h2></blockquote>
<ul>
<li><p>MeasureSpec是由父容器中LayoutParams和本身的LayoutParams这两个因素决定的.</p>
</li>
<li><p>但是对于顶级View(DecorView),他的MeasureSpec是由屏幕的大小和自身的LayoutParams所决定的.</p>
</li>
<li><p>以上两点在阅读源码就可以看出来.</p>
</li>
</ul>
<h2 id="从源码角度来理解测量和布局"><a href="#从源码角度来理解测量和布局" class="headerlink" title="从源码角度来理解测量和布局"></a>从源码角度来理解测量和布局</h2><blockquote>
<h3 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h3></blockquote>
<p>为了更好的理解测量过程, 我们需要理解清楚MeasureSpec和LayoutParams的关系, 看MeasureSpec是怎么在LayoutParams的约束下生成的.</p>
<p>测量过程的工作是确定View的宽高.我们先从ViewRootImpl这个类来分析顶级View类是如何开始测量的.</p>
<p>测量,布局,绘制,这三个步骤将View显示到屏幕上,而触发这三个流程的地方是在<code>performTraversals()</code>方法中.</p>
<p>在<code>performTraversals()</code>方法中,除了测量,布局,绘制这三个阶段外, 其实在存在另外的两个阶段:预测量和窗口布局.</p>
<blockquote>
<h4 id="预测量"><a href="#预测量" class="headerlink" title="预测量"></a>预测量</h4></blockquote>
<p>ViewRootImpl在进行测量时,会预先进行一次测量,而这次预测量是在<code>measureHierarchy</code>方法中进行的. 预测量的目的就是为了在大屏幕的设备上将View更优雅的显示出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></div><div class="line">            <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight) &#123;</div><div class="line">        <span class="keyword">int</span> childWidthMeasureSpec;</div><div class="line">        <span class="keyword">int</span> childHeightMeasureSpec;</div><div class="line">        <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(TAG,</div><div class="line">                <span class="string">"Measuring "</span> + host + <span class="string">" in display "</span> + desiredWindowWidth</div><div class="line">                + <span class="string">"x"</span> + desiredWindowHeight + <span class="string">"..."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; <span class="comment">//为了让dialog显示得更好, 先根据预先定义好的dialog尺寸, 以此测量出一个包裹dialog的宽度.</span></div><div class="line">            <span class="comment">// On large screens, we don't want to allow dialogs to just</span></div><div class="line">            <span class="comment">// stretch to fill the entire width of the screen to display</span></div><div class="line">            <span class="comment">// one line of text.  First try doing the layout at a smaller</span></div><div class="line">            <span class="comment">// size to see if it will fit.</span></div><div class="line">            <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</div><div class="line">            res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">int</span> baseSize = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</div><div class="line">                baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": baseSize="</span> + baseSize);</div><div class="line">            <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</div><div class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//打包成MeasureSpec</span></div><div class="line">                childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//开始第一次测量</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                        + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123; <span class="comment">//如果测量出来的大小太小的话, 会再进行测量</span></div><div class="line">                    goodMeasure = <span class="keyword">true</span>; <span class="comment">//对测量结果满意</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Didn't fit in that size... try expanding a bit.</span></div><div class="line">                    baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": next baseSize="</span></div><div class="line">                            + baseSize); <span class="comment">//需要的话, 扩大宽度,进行二次测量</span></div><div class="line">                    childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); <span class="comment">//再次打包成MeasureSpec</span></div><div class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">//第二次测量</span></div><div class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></div><div class="line">                            + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</div><div class="line">                    <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Good!"</span>);</div><div class="line">                        goodMeasure = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!goodMeasure) &#123; <span class="comment">//最后还是太小的话, 只能妥协,返回窗口的可能改变的标记</span></div><div class="line">            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">            <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</div><div class="line">                windowSizeMayChange = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DBG) &#123;</div><div class="line">            System.out.println(<span class="string">"======================================"</span>);</div><div class="line">            System.out.println(<span class="string">"performTraversals -- after measure"</span>);</div><div class="line">            host.debug();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> windowSizeMayChange;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>为了让View更优雅的显示出来, 比如dialog在大屏幕的情况下, 如果其内容太大并且测量模式为WRAP_CONTENT的话,有可能会出现这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7l94nxgj30hi0br3yi.jpg" alt=""></p>
<ul>
<li>考虑到上面dialog的宽度有可能太小,会出现下面这种情况:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik7n6wvkcj30c809ka9y.jpg" alt=""></p>
<ul>
<li><p>所以在预测量阶段,每次测量后都会根据一个标记<code>(MEASURED_STATE_TOO_SMALL)</code>来判断是否要进行二次测量来扩大宽度.</p>
</li>
<li><p>如果进行了二次测量的话, 宽度还是大小,就只能妥协,放弃预测量.</p>
</li>
<li><p>预测量是针对悬浮窗口而言, 也就是对于非悬浮窗口而言, 是没有预测量阶段的.</p>
</li>
</ul>
<blockquote>
<h4 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h4></blockquote>
<p>一般测量阶段都会伴随一个布局阶段, 预测量也是如此, 窗口布局就是根据预测量阶段得出的结果来进行布局.</p>
<blockquote>
<h4 id="开始测量"><a href="#开始测量" class="headerlink" title="开始测量"></a>开始测量</h4></blockquote>
<p>分析完预测量和预布局, 我们来分析<code>&quot;真正&quot;</code>的测量阶段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG, <span class="string">"Ooops, something changed!  mWidth="</span></div><div class="line">                            + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</div><div class="line">                            + <span class="string">" mHeight="</span> + mHeight</div><div class="line">                            + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</div><div class="line">                            + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</div><div class="line"></div><div class="line"><span class="comment">// Ask host how big it wants to be</span></div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
<ul>
<li>在View的测量机制中, 是通过给子View传递MeasureSpec来进行的, 因此, 测量阶段会首先进行获取测量规格, 并传递给子View, 我们先来看看顶级View如何进行获取MeasureSpec.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码通过调用<code>getRootMeasureSpec(mWidth, lp.width)</code>来获取宽度的MeasureSpec, 传递给方法的参数分别为屏幕的窗口大小和顶级View的LayoutParams封装的宽度信息.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> measureSpec;</div><div class="line">        <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>如果宽度为<code>ViewGroup.LayoutParams.MATCH_PARENT</code>, 直接把将窗口的大小和<code>MeasureSpec.EXACTLY</code>打包成一个MeasureSpec; 当宽度为<code>ViewGroup.LayoutParams.WRAP_CONTENT</code>情况也是如此.</p>
</li>
<li><p>至于<code>getRootMeasureSpec(mHeight, lp.height)</code>跟上面的基本一致,这里不多说.</p>
</li>
<li><p>分析到这里, 也验证了,<code>顶级View的MeasureSpec是由窗口的大小和自身的LayoutParams所决定的</code></p>
</li>
</ul>
<p>我们接着继续分析<code>performMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个方法中只是简单的调用了View的measure(int, int)方法, 也就是从RootViewImppl调到了View中. 方法中的参数刚刚生成的两个测量规格.可见,测量规格是在父View中生成并传递给子View的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            <span class="keyword">int</span> oWidth  = insets.left + insets.right;</div><div class="line">            <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</div><div class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></div><div class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</div><div class="line">        <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// first clears the measured dimension flag</span></div><div class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">            resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</div><div class="line">                    mMeasureCache.indexOfKey(key);</div><div class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</div><div class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></div><div class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">                <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></div><div class="line">                setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</div><div class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></div><div class="line">            <span class="comment">// an exception to warn the developer</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></div><div class="line">                        + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></div><div class="line">                        + <span class="string">" measured dimension by calling"</span></div><div class="line">                        + <span class="string">" setMeasuredDimension()"</span>);</div><div class="line">            &#125;</div><div class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">        mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</div><div class="line">                (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法略长, 但是核心思路只有两个, 第一: 判断传入的大小和前一次测量的大小是否一样, 如果一样的话, 不进行测量, 如果不一样的话, 就开始测量. 第二:如果传入的大小和前一次测量的大小不一样的话, 会调用onMeasure(int, int),开始测量.</p>
</li>
<li><p>对于<code>onMeasure(int, int)</code>而言, View和ViewGroup的测量职责是不一样的. <code>对于View, 它只需测量自身的大小, 而对于ViewGroup, 它需要测量自己和测量自己的孩子, 一般都是先测量孩子,然后根据孩子的大小来设置自己的大小.</code></p>
</li>
<li><p>由于<code>measure()</code>方法是被final修饰的, 所以<code>measure(int, int)</code>是不允许被重写的, 需要我们重写的是onMeasure(int, int). 这样做的优点是:开发者无需关心View测量的其他细节, 只需关心测量View的大小就行, 减轻了开发者的开发难度.</p>
</li>
<li><p>既然View和ViewGroup的测量职责不一样, 那么View和ViewGroup中的onMeasure(int, int)的实现肯定不一样, 所以我们开始分情况来讨论</p>
</li>
</ul>
<blockquote>
<h5 id="View-onMeasure-int-int"><a href="#View-onMeasure-int-int" class="headerlink" title="View#onMeasure(int, int)"></a>View#onMeasure(int, int)</h5></blockquote>
<p>我们先从简单的View入手, 进入View的onMeasure(int, int):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>View的onMeasure(int, int)只是简单调用了setMeasureDimension(int size, int measureSpec),这个是保存测量得到的宽高.</p>
</li>
<li><p>setMeasureDimension(int, int), 其中的宽高是通过<code>getDefaultSize(int size, int measureSpec)</code>来获取的.我们进入该方法看看:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = size;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先根据传入的measureSpec来获得测量模式和测量大小, 如果测量模式是<code>AT_MOST</code>或者<code>EXACTLY</code>的话, 直接返回测量得到的大小.</p>
</li>
<li><p>从这个方法我们知道, View的onMeasure(int, int)的默认实现是根据传入的MeasureSpec来获取测量结果.那么这个MeasureSpec是怎么产生的? 前面我们说过, ViewGroup的onMeasure(int, int)中, 是需要测量孩子的, 这个MeasureSpec就是ViewGroup在测量子View时传递给子View的, 换句话说, 这个MeasureSpec是从ViewGroup传递下来的, 通过解包操作, 可以得到MeasureSpec中的大小, 这个大小究竟是ViewGroup的总体大小还是剩余大小? 这个得看具体的ViewGroup的具体实现.</p>
</li>
<li><p>上面的分析可能有点难以理解, 不过接下来分析完ViewGroup后, 自然会解开你的迷惑.</p>
</li>
</ul>
<blockquote>
<h5 id="ViewGroup-onMeasure-int-int"><a href="#ViewGroup-onMeasure-int-int" class="headerlink" title="ViewGroup#onMeasure(int, int)"></a>ViewGroup#onMeasure(int, int)</h5></blockquote>
<p>由于ViewGroup的子类对测量都有不同的策略, 因此, ViewGroup并没有重写onMeasure(int, int), 而是让其子类去重写.我们拿比较简单的FrameLayout来分析吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</div><div class="line">                MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</div><div class="line">                MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</div><div class="line">        mMatchParentChildren.clear();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> childState = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">            <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</div><div class="line">                measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">                maxWidth = Math.max(maxWidth,</div><div class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</div><div class="line">                maxHeight = Math.max(maxHeight,</div><div class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</div><div class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class="line">                <span class="keyword">if</span> (measureMatchParentChildren) &#123;</div><div class="line">                    <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</div><div class="line">                            lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                        mMatchParentChildren.add(child);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Account for padding too</span></div><div class="line">        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</div><div class="line">        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</div><div class="line"></div><div class="line">        <span class="comment">// Check against our minimum height and width</span></div><div class="line">        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</div><div class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line"></div><div class="line">        <span class="comment">// Check against our foreground's minimum height and width</span></div><div class="line">        <span class="keyword">final</span> Drawable drawable = getForeground();</div><div class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</div><div class="line">            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</div><div class="line">            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</div><div class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</div></pre></td></tr></table></figure>
<ul>
<li>我抽取了FrameLayout中onMeasure(int, int)的核心代码, 主要思路: 遍历子View,让子View测量自己,也就是触发子View的测量. 接着再根据子View的大小来计算自己的大小.我们先来看看measureChildrenWithMargins(View, int, int).</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该方法是ViewGroup提供的工具类, 关于View和ViewGroup提供的测量工具类, 后面的专门分析.</p>
</li>
<li><p>首先拿到View的LayoutParams, 然后调用getChildMeasureSpec来得到子View的MeasureSpec, 我们看看它是怎么得到的.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">                <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">                <span class="comment">// be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">                <span class="comment">// big it should be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先进行解包操作, 拿到父View传递下来的测量模式和测量大小, 在xml布局中的顶级View的MeasureSpec是由RootViewImpl传递下来的, 而对于顶级View(DecorView)来说, 其MeasureSpec是由窗口大小和自身的LayoutParams决定的.</p>
</li>
<li><p>接着进入switch语句:</p>
<ul>
<li><p>当父View的mode为<code>MeasureSpec.EXACTLY</code>时, 再根据子View的LayoutParams(也就是子View在xml文件中声明的layout_xx属性的容器), 又分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽(用宽来举例子)为确定的值, 那么resultSize为子View在xml文件中声明的宽度(也就是xxdp),resultMode为<code>MeasureSpec.EXACTLY</code>,然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占满父View的宽度, 因此, resultSize设置为父View的大小size, reslutMode为<code>MeasureSpec.EXACTLY</code></li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.WRAP_CONTENT)</code>时, 表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为<code>MeasureSpec.AT_MOST</code></li>
</ol>
</li>
<li><p>当父View的mode为<code>MeasureSpec.AT_MOST</code>时, 根据子View的LayoutParams, 分为三种情况:</p>
<ol>
<li>当子View在xml文件中声明的宽为确定的值时, resultSize为子View在xml文件中声明的宽度(也就是xxdp), resultMode为<code>MeasureSpec.EXACTLY</code>, 然后再打包为一个MeasureSpec.</li>
<li>当子View在xml文件中声明的宽为<code>LayoutParams.MATCH_PARENT</code>时, 表明子View想要占有父View的宽度, 但是由于父View的测量模式为<figure class="highlight plain"><figcaption><span>所以resultMode只能为```MeasureSpec.AT_MOST``(因为父View自身也不知道自己多大), resultSize设置为父Viw的大小.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">   3. 当子View在xml文件中声明的宽为``LayoutParams.AT_MOST``时表明子View想要根据自己的内容来决定大小, 所以resultSize设置为父View的size,用来表示不能操过这个值, resultMode设置为``MeasureSpec.AT_MOST``.</div><div class="line"></div><div class="line">* 分析到这里, 我们可以总结出View的MeasureSpec是由哪些因素决定的</div><div class="line"> * 对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以会看之前分析的代码)</div><div class="line"> * 对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</div><div class="line"></div><div class="line">* 上面我们针对宽度来进行了分析, 对于高度而言, 过程跟宽度一样</div><div class="line"></div><div class="line">* 最后调用子View的``measure(int, int)``, 将在``getChildMeasureSpec``中得到的宽和高对应的MeasureSpec(也就是我们上面以宽度为例子来分析的情况),传递给子View,接下去的过程跟我们前面在分析子View的情况一样.</div><div class="line"></div><div class="line">* 现在我们可以更加确定了这样一个事实: View的onMeasure(int, int)中的widthMeasureSpec和heightMeasureSpec是由父View根据自身的MeasureSpec和子View的LayoutParams产生并传递给子View的.</div><div class="line"></div><div class="line">* 如果你仔细总结的话,会发现:只要子View的的宽或高设置为``LayoutParams``设置为WRAP_CONTENT时, 生成MeasureSpec中的size都是父View的size(一般是父View剩下的size),而mode为AT_MOST.</div><div class="line"></div><div class="line">* 我们现在继续调到子View的measure方法中的onMeasure(), 我们再来看看getDefaultSize()这个方法:</div><div class="line"></div><div class="line">```java</div><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">        int result = size;</div><div class="line">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>首先解包出由父View传递下来的MeasureSpec, 通过上面的分析, 当子View在xml文件中将layout_width设置为WRAP_CONTENT时, 对应的SpecMode为AT_MOST, 此时进入switch语句, 得到的大小其实是父View的大小, 这也解释了,在自定义View(继承View)时,如果没有重写onMeasure(int, int)时,当这个自定义View的宽度或者高度设置为<code>WRAP_CONTENT</code>时,会变成占有父View的全部高度和宽度.</p>
</li>
<li><p>分析到这里, 已经基本分析完了测量过程,我们还是总结一下,再进入下一个流程.</p>
</li>
</ul>
<blockquote>
<h4 id="测量过程总结"><a href="#测量过程总结" class="headerlink" title="测量过程总结"></a>测量过程总结</h4></blockquote>
<ul>
<li><p>onMeasure(int widthSpec, int heightSpec)中的这两个MeasureSpec是由父View传递下来的.MeasureSpec一旦确定了, 在这个方法中就可以确定View的测量宽高了.</p>
</li>
<li><p>如何确定MeasureSpec?</p>
<ul>
<li>对于顶级View的MeasureSpec, 是由窗口的大小和自身的LayoutParams来决定的(可以回看之前分析的代码)</li>
<li>对于非顶级View的MeasureSpec, 是由父View的MeasureSpec(其中的mode)和子View自身的LayoutParams(也就是在xml文件声明的layout_xx的属性)</li>
</ul>
</li>
<li><p>父View的MeasureSpec和子View的LayoutParams如何确定MeasureSpec?</p>
<ul>
<li>在View测量的时候, 系统会将View的LayoutParams在父View的SpecMode的约束下再次打包为一个传递给子View的MeasureSpec.</li>
</ul>
</li>
<li><p>EXACTLY,AT_MOST和LayoutParams的关系</p>
<ul>
<li>EXACTLY: 父View已经检测出子View所需要的大小(通常是子View在xml文件中声明为精确的值,比如20dp),它对应于LayoutParams中的match_parent和具体的数值</li>
<li>AT_MOST: 子View不能超过父View给定的大小, 它对应与LayoutParams中的wrap_content.</li>
</ul>
</li>
<li><p>最后来看看流程图加深印象:</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8aodsxyj30nq0i2ta8.jpg" alt=""></p>
<blockquote>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3></blockquote>
<p>经过测量阶段后, View已经知道自己的宽和高, 接着就需要在布局阶段确定应该显示在哪个区域,也就是屏幕上的四个点.那我们回到VewiRootImpl中的performLayout()方法, 该方法是触发布局的起点, 在里面调用了View的layout方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</div></pre></td></tr></table></figure>
<ul>
<li><p>layout方法中的四个参数分别为屏幕上的四个点, 也就是整个屏幕的区域</p>
</li>
<li><p>我们进入View的layout方法:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们主要分析上面的两个核心操作:<ul>
<li>setFrame(left, top, right, bottom)这个方法主要是保存四个点的位置, 并且判断传入的位置跟之前的是不是一样, 不一样的话,会回调onSizeChange接口</li>
<li>调用onLayout(left, top, right, bottom), 但是这个方法View是一个空方法, 对于ViewGroup来说,具体的子类有其具体的实现方法.因此, <code>layout方法主要是view用于确定自己的位置的, 而onLayout是用于ViewGroup循环调用子类的layout方法来对子类进行布局的.</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>理解了上面的这两点, 其实布局过程就基本没什么了.</p>
</li>
<li><p>最后还是看看流程图, 加深理解.</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fik8dhsrxmj30kh0flwfa.jpg" alt=""></p>
<ul>
<li>分析到这里, 测量,布局都分析完了, 绘制流程就不讲了,</li>
</ul>
<h1 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h1><blockquote>
<h2 id="继承View重写onDraw方法和onMeasure方法"><a href="#继承View重写onDraw方法和onMeasure方法" class="headerlink" title="继承View重写onDraw方法和onMeasure方法"></a>继承View重写onDraw方法和onMeasure方法</h2></blockquote>
<p>这种方法一般用于实现基础控件和组合控件难以达到的效果. 所以需要重写onDraw方法来画出自己的图形, 重写onMeasure方法来支持wrap_content属性,和padding属性.</p>
<blockquote>
<h2 id="继承ViewGrroup派生特殊的Layout"><a href="#继承ViewGrroup派生特殊的Layout" class="headerlink" title="继承ViewGrroup派生特殊的Layout"></a>继承ViewGrroup派生特殊的Layout</h2></blockquote>
<p>当系统的基础布局容器不能满足我们的需求时, 我们可以继承ViewGroup来自定义一个布局容器. 这种方法需要合适处理ViewGroup的<code>测量(测量孩子和测量自己)</code>,布局这两个过程.</p>
<blockquote>
<h2 id="继承基础控件-如TextView"><a href="#继承基础控件-如TextView" class="headerlink" title="继承基础控件(如TextView)"></a>继承基础控件(如TextView)</h2></blockquote>
<p>这种方法一般用于扩展基础控件的功能,相对比较简单. 这种方法不需要自己处理wrap_content和padding.</p>
<blockquote>
<h2 id="继承基础容器-如LinearLayout"><a href="#继承基础容器-如LinearLayout" class="headerlink" title="继承基础容器(如LinearLayout)"></a>继承基础容器(如LinearLayout)</h2></blockquote>
<p>这种方法一般用于组合一些基础控件或者自定义View.</p>
<h1 id="自定义View的方法论"><a href="#自定义View的方法论" class="headerlink" title="自定义View的方法论"></a>自定义View的方法论</h1><blockquote>
<h2 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h2></blockquote>
<p>这种自定义方法,我们处理的主要有两个方法:</p>
<ul>
<li><p>在onMeasure(int, int)中处理wrap_content和padding</p>
</li>
<li><p>在onDraw(Canvas)中绘制你想要的UI和处理padding</p>
</li>
</ul>
<blockquote>
<h3 id="onMeasure-int-int-处理"><a href="#onMeasure-int-int-处理" class="headerlink" title="onMeasure(int, int)处理"></a>onMeasure(int, int)处理</h3></blockquote>
<p>在onMeasure(int, int)中需要处理的有两个: wrap_content和padding这两个属性.</p>
<blockquote>
<h4 id="支持wrap-content"><a href="#支持wrap-content" class="headerlink" title="支持wrap_content"></a>支持wrap_content</h4></blockquote>
<p>经过前面的分析, 我们知道对于一个继承View的控件, 如果没有重写onMeasure(int, int), 在xml布局中设置layout_width=”wrap_content”的时候, 会占满父View的宽度, 其中的原因前面已经分析了, 这里主要将如何支持wrap_content. 接下来我会讲解决这个问题的基本方法和另外一种快捷方法</p>
<ul>
<li>基本方法:</li>
</ul>
<p>当layout_width或者layout_height为wrap_content, 我们不用默认的高宽, 而是自己根据自己View的内容来决定View的高宽</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"><span class="comment">//1.首先拿到宽高的大小和测量模式</span></div><div class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"><span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">//2.接着判断宽高和mode是否为wrap_content, 如果是的话, 我们不用widthSize或者heightSize, 我们自己指定View的大小</span></div><div class="line">        <span class="comment">//wrap_content对应MeasureSpec.AT_MOST属性</span></div><div class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">  setMeasuredDimension(<span class="number">300</span>, <span class="number">300</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(<span class="number">300</span>, heightSize); <span class="comment">//只有width为wrap_content, 所以高直接用heightSize就行</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    setMeasuredDimension(widthSize, <span class="number">300</span>); <span class="comment">//只有height为wrap_content, 所以宽直接用widthSize就行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提供了解决wrap_content的基本思路.下面我们介绍另外一种快捷而且屏幕适配更好的方法.在介绍之前,我们先来看看View中的几个有用的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法返回一个建议的最小高度.如果View没有设置背景,那么返回值为mMinHeight(也就是在xml布局中声明的属性), 如果有的话, 会返回背景的Drawable对象的高度和mMinHeight中的最大值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法和前面的一样,这里不多说.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">                <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">                    result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    result = size;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">                result = specSize;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                result = size;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code>这个方法是View本身提供的一个支持wrap_content的一个方法(getDefaultSize()方法不支持wrap_content),这个方法除了支持wrap_content外, 还通过掩码操作添加了一些信息, 如果当size的大小大于父View的高度时, 会通过掩码操作将 MEASURED_STATE_TOO_SMALL和size打包成一个int值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resolveSizeAndState(size, measureSpec, <span class="number">0</span>) &amp; MEASURED_SIZE_MASK;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个是上个方法的重载版本, childMeasuredState属性传入0,表示不对标志做处理, 最后用MEASURED_SIZE_MASK这个掩码提取出想要是size值.</p>
<p>介绍完了上面的几个方法, 我们开始介绍另外一种快捷的适配wrap_content的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumWidth(), mTextSize); <span class="comment">//将默认的最小宽度和自己定义的字体大小比较, 取最大值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">super</span>.getSuggestedMinimumHeight(), mTextSize); <span class="comment">//将默认的高度和自己定义的字体大小比较, 取最大值.</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们知道,支持wrap_content的实质就是根据内容来决定View的大小.那么我们可以利用<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>这个两个方法来获取最小的高度和宽度.当mode为wrap_content时, 怎么计算出最小的高度和宽度, 这个看你的自定View情况, 自己灵活选择.</p>
<blockquote>
<h4 id="支持padding"><a href="#支持padding" class="headerlink" title="支持padding"></a>支持padding</h4></blockquote>
<p>支持padding是需要在onDraw和onMeasure中实现, 思路都很简单, 在onMeasure中的宽高将padding考虑进去, 在onDraw中绘制图形时,除去padding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxWidth = getSuggestedMinimumWidth();</div><div class="line">        <span class="keyword">int</span> maxHeight = getSuggestedMinimumHeight();</div><div class="line">        maxWidth = maxWidth + getPaddingLeft() + getPaddingRight(); <span class="comment">//加上paddingLeft和paddingRight得到宽度</span></div><div class="line">        maxHeight = maxHeight + getPaddingBottom() + getPaddingTop(); <span class="comment">//加上paddingBottom和paddingTop得到高度</span></div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> width = resolveSize(maxWidth, widthMeasureSpec);</div><div class="line">        <span class="comment">//调用resolveSize(int size, int measureSpec), size指的是, 当mode为wrap_content时, 这个方法会为我们返回size值.也就是支持wrap_content</span></div><div class="line">        <span class="keyword">int</span> height = resolveSize(maxHeight, heightMeasureSpec);</div><div class="line">        setMeasuredDimension(width, height); <span class="comment">//最后设置大小</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面是onMeasure中支持padding, 下面看看onDraw中支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> wdith = getWidth() - getPaddingLeft() - getPaddingRight();</div><div class="line">        <span class="keyword">int</span> height = getHeight() - getPaddingTop() - getPaddingBottom();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在onDraw中, 用到宽高时, 先减去对应的padding就能支持padding了.</p>
<blockquote>
<h2 id="继承ViewGroup"><a href="#继承ViewGroup" class="headerlink" title="继承ViewGroup"></a>继承ViewGroup</h2></blockquote>
<p>继承ViewGroup的View, 相当于自定义一个布局容器, 需要我们处理的有两个:</p>
<ul>
<li><p>onMeaure(int, int)</p>
</li>
<li><p>onLayout(int, int, int, int)</p>
</li>
</ul>
<blockquote>
<h3 id="处理onMeasure-int-int"><a href="#处理onMeasure-int-int" class="headerlink" title="处理onMeasure(int, int)"></a>处理onMeasure(int, int)</h3></blockquote>
<p>自定义ViewGroup不同于自定义View, 自定义ViewGroup在onMeasure(int, int)中, 除了测量自己,还需要测量孩子, 通常是遍历孩子并触发孩子的测量方法, 然后根据孩子的宽高来决定自己的宽高. 我们下面来看看ViewGroup给我们提供的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过传入子View,父View的宽高测量规格, 该方法内部会帮我们调用view的measure方法去测量View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法内部遍历所有子View, 然后调用上一个方法测量View, 也就是帮我们测量了所有子View, 不用我们手动for循环去测量View. 你们可以根据自己的需要去调用其中的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法也是测量子View的方法, 不过这个方法把子View的margin考虑进去了.</p>
<p>下面说说ViewGroup测量的套路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxHeight = getPaddingTop() + getPaddingBottom(); <span class="comment">//支持padding</span></div><div class="line">    <span class="keyword">int</span> maxWidth = getPaddingLeft() + getPaddingRight(); <span class="comment">//支持padding</span></div><div class="line">    <span class="comment">//循环测量孩子</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View child = getChildAt(i);</div><div class="line">        measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>); <span class="comment">//考虑margin测量孩子</span></div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        maxHeight = maxHeight + child.getMeasuredHeight() + params.topMargin + params.bottomMargin; <span class="comment">//将支持margin</span></div><div class="line">        maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + params.leftMargin + params.rightMargin); <span class="comment">//将支持margin</span></div><div class="line">    &#125;</div><div class="line">    setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), resolveSize(maxHeight, heightMeasureSpec)); <span class="comment">//测量自己</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我模拟了LinearLayout中的vertical布局属性.注意记得考虑padding和margin.</p>
<p>首先考虑padding, 然后循环遍历子View并测量, 最后根据孩子测量得到的宽高和孩子的margin属性和自己的布局属性来进行测量自己的大小.</p>
<blockquote>
<h3 id="onLayout-int-int-int-int"><a href="#onLayout-int-int-int-int" class="headerlink" title="onLayout(int, int, int, int)"></a>onLayout(int, int, int, int)</h3></blockquote>
<p>onLayout的职责就是将根据子View测量得到的宽高将其摆放在合适的位置. 注意: 在onLayout阶段, 没有特殊情况的话, 子View的布局要根据其测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> i, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = getPaddingLeft(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> top = getPaddingTop(); <span class="comment">//考虑padding</span></div><div class="line">    <span class="keyword">int</span> bottom;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; getChildCount(); j++) &#123;</div><div class="line">        View child = getChildAt(j);</div><div class="line">        MarginLayoutParams params = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">        left = left + params.leftMargin;</div><div class="line">        top = top + params.topMargin;</div><div class="line">        bottom = params.bottomMargin;</div><div class="line">        <span class="keyword">int</span> width = child.getMeasuredWidth();</div><div class="line">        <span class="keyword">int</span> height = child.getMeasuredHeight();</div><div class="line">        child.layout(left, top, left + width, top + height + bottom);</div><div class="line">        top = top + height + bottom;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是简单的模仿LinearLayout的vertical布局属性, 思路: 遍历所有的子View, 然后确定四个点的位置, 一般都是确定left, top这两个点, 然后对应加上View的宽高再得到另外的right, bottom.注意:这里right和bottom这两个点的确定,如果没有特殊情况, 应该根据view的测量得到的宽高来确定, 不能随便指定特定的值, 这样会导致getMeasureXX和getXX不相等, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child.layout(left, top, left + width + <span class="number">100</span>, top + height + bottom + <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>如果你按照上面的操作, getWidth会比getMeasureWidth大100, getHeight会比getMeasureHeight大100. 原因就是你布局的时候没有根据测量阶段View的宽高来布局(也就是私自加多了100, 导致两个点相减时会多出100). 因此,如果没有特殊情况, 布局阶段请按照子View测量得到的宽高来布局, 这样才是符合View的设计规范.</p>
<blockquote>
<h3 id="定义你自己的LayoutParams"><a href="#定义你自己的LayoutParams" class="headerlink" title="定义你自己的LayoutParams"></a>定义你自己的LayoutParams</h3></blockquote>
<p>最后补充一个. 如果你的自定义ViewGroup需要自定义LayoutParams的话, 需要进行下面两个步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayoutParams</span> <span class="keyword">extends</span> <span class="title">MarginLayoutParams</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> attr;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(c, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(width, height);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(LayoutParams source)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在你的类中定义上面的内部类, 属性自己定义.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(LayoutParams p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(p);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后重载上面的方法.</p>
<p>如果理解了上面的方法轮, 那么自定义View也就没多大问题了, 最后剩下的就是绘制了.</p>
<p>剩下的两种情况都不怎么难, 这里多说了.</p>
<blockquote>
<h2 id="自定义View的步骤"><a href="#自定义View的步骤" class="headerlink" title="自定义View的步骤"></a>自定义View的步骤</h2></blockquote>
<p>1: 首先分析这个View是怎么绘制的? 哪些是需要抽象成参数</p>
<p>2: 将抽象出来的参数定义在attr资源文件</p>
<p>3: 重写onMeasure方法,并让你的View支持wrap_content,或者padding(如果有必要的话)</p>
<p>4: 重写onDraw方法, 主要在onDraw也是要处理padding(如果有必要的话)</p>
<p>5: 暴露接口给外部(例如监听接口, 动态改变属性的接口)</p>
<p>6: 如果存在滑动冲突的话, 需要解决滑动冲突</p>
<p>7: 根据实际情况优化你的View</p>
<blockquote>
<h2 id="自己的自定义View的习惯"><a href="#自己的自定义View的习惯" class="headerlink" title="自己的自定义View的习惯:"></a>自己的自定义View的习惯:</h2></blockquote>
<p>上面是标准的自定义View的步骤, 实际情况中, 不需要按照严格的顺序进行.下面说说我写的时候的套路:</p>
<p>1: 先分析这个自定义View是怎么话的?</p>
<p>2: 抽象出一些参数,定义在View中</p>
<p>3: 先在onDraw中把图形先画出来,</p>
<p>4: 图形出来后, 再重写onMeasure来支持wrap_content.padding等属性</p>
<p>5: 将抽象出来的参数定义在attr资源文件</p>
<p>6: 暴露接口给外部</p>
<p>7: 优化View</p>
<h2 id="自定义View的使用场景"><a href="#自定义View的使用场景" class="headerlink" title="自定义View的使用场景"></a>自定义View的使用场景</h2><blockquote>
<h3 id="优先考虑继承现有的空间来实现额外的功能"><a href="#优先考虑继承现有的空间来实现额外的功能" class="headerlink" title="优先考虑继承现有的空间来实现额外的功能"></a>优先考虑继承现有的空间来实现额外的功能</h3></blockquote>
<p>如果一些效果是继承现有控件能够实现的话, 那么优先继承现有的控件, 因为现有的控件都是经过官方多次的优化,性能肯定比我们自己写出来的好.</p>
<blockquote>
<h3 id="当一个View嵌套很多布局时-考虑自定义View的实现"><a href="#当一个View嵌套很多布局时-考虑自定义View的实现" class="headerlink" title="当一个View嵌套很多布局时, 考虑自定义View的实现."></a>当一个View嵌套很多布局时, 考虑自定义View的实现.</h3></blockquote>
<p>如果View嵌套太深, requesLayout触发时, 会导致整个布局都被测量和布局, 这样的消耗太大了, 更好的做法是,自定义一个View, 减少测量和布局阶段的消耗.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络-运输层]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      <content type="html"><![CDATA[<h1 id="计算机网络-运输层"><a href="#计算机网络-运输层" class="headerlink" title="计算机网络-运输层"></a>计算机网络-运输层</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分用和复用</li>
<li>UDP协议</li>
<li>运输层梳理</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>当网络的边缘部分中的两个主机使用网络的核心部分功能进行通信时,只有主机的协议栈才有运输层,而网络的核心部分中的路由器在转发分组时都只用到下三层的功能.</p>
<p>网络层是为主机之间提供逻辑通信,而运输层为应用进程之间提供端到端的逻辑通信.</p>
<p>在网络层中, IP数据报首部的检验和字段只检验首部是否出现差错而不检查数据部分.而在运输层中, 应当进行首部和数据的差错检验.</p>
<blockquote>
<h3 id="分用和复用"><a href="#分用和复用" class="headerlink" title="分用和复用"></a>分用和复用</h3></blockquote>
<p>复用是指发送方不同的应用程序都可以使用同一个运输层协议传送数据.</p>
<p>分用是指接收方的运输层去掉报文的首部后能够把数据正确交付到目的进程中.</p>
<blockquote>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3></blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>UDP协议只在IP数据报服务上增加了很少的功能,这些功能是分用和复用还有差错检验.</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>UDP是无连接的,因此减少了开销和发送数据之前的时延</li>
<li>UDP使用尽最大努力交付,即不保证可靠交付.</li>
<li>UDP是面向报文的.应用层交给UDP多长的报文,UDP就照样发送,一次发一个报文.</li>
<li>UDP没有拥塞控制.</li>
<li>UDP支持1对1,1对多,多对1,多对多的交互通信.</li>
<li>UDP的首部开销小,只有8字节.</li>
</ol>
<blockquote>
<h3 id="运输层梳理"><a href="#运输层梳理" class="headerlink" title="运输层梳理"></a>运输层梳理</h3></blockquote>
<p>运输层主要有两个协议:</p>
<ol>
<li>UDP</li>
<li>TCP</li>
</ol>
<p>UDP是面向无连接的协议,只是在IP数据报上添加复用,分用和差错检验的功能,UDP协议本身比较简单.</p>
<p>TCP协议是面向连接的一种协议,在进程之间的通信中提供一种可靠交付的服务.相比于UDP协议, TCP协议比较复杂.</p>
<p>下面给出运输层的知识梳理图:</p>
<p><img src="/uploads/计网/运输层/运输层梳理.png" alt=""></p>
<p>其中TCP协议涉及的内容比较多,归纳起来可以分为:</p>
<p><a href="https://cristianoro7.github.io/2017/05/22/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">可靠传输的工作原理</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/22/TCP%E9%A6%96%E9%83%A8/">TCP首部</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/23/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">TCP滑动窗口</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/23/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">TCP流量控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/24/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制</a></p>
<p><a href="https://cristianoro7.github.io/2017/05/24/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/">TCP连接管理</a></p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP连接管理]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>TCP连接</li>
<li>TCP连接释放</li>
</ul>
<blockquote>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3></blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdilnjr84mj30zk0lk788.jpg" alt=""></p>
<p>上图为TCP连接建立的过程</p>
<p>B的TCP服务器进程首先创建传输控制块,准备接收客户端进程的连接请求.</p>
<p>A的TCP客户端进程首先创建传输控制块, 然后向B发送连接请求的报文段,此时首部SYN = 1,同时选择一个seq = x. TCP规定,SYN报文段不能携带数据,但要也要消耗一个序号.这次TCP客户端进程进入SYN-SEND状态.</p>
<p>B收到连接请求后, 如同意连接, 则向A发送确认. 在确认的报文段中应把SYN和ACK都置为1,确认号ack = x + 1, 同时也为自己选定一个序号seq = y.注意:这个报文段也不能携带数据,但是要消耗一个序号.此时TCP服务器进入SYN-RCVD状态.</p>
<p>TCP客户端收到B的确认后, 还要向B确认.确认的报文段的ACK置1,确认号ack = y+1,而自己的序号seq = x + 1.注意:ACK报文可以携带数据.如果不携带数据就不用消耗序号.此时TCP连接已经建立.A进入ESTALISHED状态.</p>
<p>当B收到A的确认后, 也进入ESTABLISHED状态.</p>
<p>上面的连接建立过程叫做三次握手.</p>
<p>三次握手的原因是为了防止已失效的连接请求报文段突然又传送到B,因此产生错误.</p>
<p>现在假定A发送出去的第一个连接请求报文段在某些网络结点长时间滞留了,以致延误到连接释放后的某个时间才到达B.本来这个是一个已经失效的报文段.但是B收到此有效的报文段后, 就误认为A又发出了<br>一次连接请求.于是向A发送确认报文段,同意建立连接.如果假设不采用三次握手, 那么B发出确认,新的连接就建立了.由于A并没有发出建立连接的请求, 因此不理睬B的确认,也不会向B发送数据.但B却以为新的连接已经建立,一直等待A发送数据.这样B的许多资源就白白浪费了.</p>
<p>如果采用三次握手的话, A不会向B发出确认.B由于收不到确认,就不知道A并没有要求建立连接.</p>
<blockquote>
<h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3></blockquote>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdilpjw72ej31180ou43x.jpg" alt=""></p>
<p>上图为TCP连接释放过程</p>
<p>A的应用首先让其TCP发出连接释放的报文段, 并停止发送数据,主动关闭连接.A把连接释放报文段首部FIN置为1,其序号seq = u.这时A进入FIN-WAIT-1状态,等待B的确认.注意:FIN报文段即使不携带数据也要消耗一个序号.</p>
<p>B收到连接释放的请求后即发出确认,确认号为ack = u + 1,而这个报文段的序号为v.然后B进入CLOSE-WAIT状态.TCP服务器此时通知应用进程, 因此A到B的连接已经释放掉了.这时TCP连接处于半释放状态.即A已经没有要传送数据了.但A仍然接收数据,因为B到A的连接还没有释放.</p>
<p>A收到B的确认后.进入FIN-WAIT-2状态,等待B发送连接释放报文段.</p>
<p>若B已经没有数据要发送了, 其应用进程会通知TCP释放连接.这时B发出的来连接释放报文段必须时FIN = 1.这时B就进入了LAST-ACK状态,等待A的确认.</p>
<p>A收到B的连接释放报文后,必须对此报文发出确认.然后进入TIME-WAIT状态.现在TCP连接还没有释放.必须经过时间等待计时器设置的时间2MSL后, A才进入CLOSED状态.</p>
<p>TIME-WAIT必须等待两个MSL的原因:</p>
<ul>
<li>保证A的最后一个确认报文段能够到达B</li>
<li>防止已失效的连接请求报文段出现在本地连接中.</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
<p><a href="http://blog.csdn.net/lihao21/article/details/52095980" target="_blank" rel="external">http://blog.csdn.net/lihao21/article/details/52095980</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP拥塞控制]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>慢开始和拥塞避免</li>
<li>快重传和快恢复</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>在计算机网络中, 链路的容量,交换节点中的缓存和处理机等都是网络的资源.在某段时间内,若对网络中的某一资源的需求超过本身能提供的资源,这时网络性能就会变差.这种情况成为网络拥塞.</p>
<p>所谓拥塞控制就是要防止过多的数据注入到网络中,这样可以使网络的路由器或者链路不致于过载.拥塞控制是一个全局性的过程,涉及到所有主机,所有的链路,以及与降低网络传输性能有关的所有因素.</p>
<blockquote>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3></blockquote>
<p>发送方维护一个拥塞窗口的状态变量.拥塞窗口的大小取决于网络的拥塞程度,并且动态改变.发送方让自己的发送窗口等于拥塞窗口.</p>
<h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>主机在发送数据的时候,不是直接把大量的数据字节注入网络, 而是先探测一下网络,即由小到大逐渐增大发送窗口,也就是由小到大逐渐增大拥塞窗口.增大的原则是每经过一个传输轮次,拥塞窗口就加倍.而一个传输轮次指的是发送方连续发送报文段后到收到这些连续报文段的确认所经历的时间.</p>
<p>为了防止拥塞窗口增大过大引起网络拥塞,还需要设置一个慢开始门限状态变量.慢开始门限用法:</p>
<ul>
<li>当拥塞窗口 &lt; 慢开始门限时,使用慢开始算法.</li>
<li>当拥塞窗口 &gt; 慢开始门限时,停止使用慢开始算法,改用拥塞避免算法.</li>
<li>当拥塞窗口 = 慢开始门限时,可以使用慢开始算法或者拥塞避免算法.</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞避免算法让拥塞窗口缓慢增大,即每经过一个往返时间RTT就把发送窗口+1,而不是加倍.这样,拥塞窗口按线性规律缓慢增长.</p>
<h4 id="乘法减小"><a href="#乘法减小" class="headerlink" title="乘法减小"></a>乘法减小</h4><p>不论在慢开始阶段还是拥塞避免阶段,只要出现拥塞情况,就把慢开始门限设置为当前拥塞窗口的一半.</p>
<p>当网络频繁出现拥塞时, 慢开始门限的值就下降得很快, 这样可以大大减少注入到网络的分组数.</p>
<h4 id="加法增大"><a href="#加法增大" class="headerlink" title="加法增大"></a>加法增大</h4><p>是指拥塞避免算法后, 使拥塞窗口缓慢增大,防止网络过早出现拥塞.</p>
<blockquote>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3></blockquote>
<h4 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h4><p>快重传算法规定: 发送方连续收到三个重复确认就立即重传该确认对应的分组,不必等待重传计时器到期.</p>
<h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><p>由于发送方连续收到三个重复的确认,此时很可能不是因为网络拥塞,否则也不会连续收到三个重复的确认,因此,不执行慢开始算法,而是执行快恢复算法,即:把拥塞窗口设置为慢开始门限减半后的数值,然后执行拥塞避免算法.</p>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>计算机网路</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP滑动窗口]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>以字节流为单位的滑动窗口</li>
<li>TCP数据流的类别</li>
<li>接收窗口的确认机制</li>
<li>窗口缩放</li>
<li>缓冲区</li>
<li>超时重传时间的选择</li>
<li>选择确认SACK</li>
</ul>
<blockquote>
<h3 id="以字节流为单位的滑动窗口"><a href="#以字节流为单位的滑动窗口" class="headerlink" title="以字节流为单位的滑动窗口"></a>以字节流为单位的滑动窗口</h3></blockquote>
<p>现假定A收到B发来的确认报文,其中窗口是20,而确认号为31.根据这两个数据,A就构造出了自己的发送窗口:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/滑动窗口.png" alt=""></p>
<ul>
<li>在没有收到B的确认的情况下,A可以连续把窗口内的数据都发送出去.凡是已经发送过去的数据,在未收到确认之前都必须暂时保留,以便在超时重传时使用.</li>
<li>窗口后沿的后面部分表示已经确认接收.这些数据不需要再保留了.</li>
<li>窗口的前沿部分表示不允许发送,因为接收方都没有为这部分数据保留缓存空间.</li>
</ul>
<blockquote>
<h3 id="TCP数据流的类别"><a href="#TCP数据流的类别" class="headerlink" title="TCP数据流的类别"></a>TCP数据流的类别</h3></blockquote>
<p>现在假定A发送序号为31到41的数据.此时, 发送窗口位置并未改变,如图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/数据流分类.png" alt=""></p>
<p>从上图,可以得来的信息:</p>
<p>小于P1的是已经发送并已经收到确认的部分.而大于P3的是不允许发送的部分.<br>P3-P1 = A 的发送窗口.</p>
<p>P2-P1 = 已发送但尚未确认的字节数</p>
<p>P3-P2 = 允许发送但尚未发送的字节数.又称为可用窗口.</p>
<blockquote>
<h3 id="接收窗口的确认机制"><a href="#接收窗口的确认机制" class="headerlink" title="接收窗口的确认机制"></a>接收窗口的确认机制</h3></blockquote>
<p>B的接收窗口大小是20. 在接收窗口外面,到30号为止的数据是已经发送过确认.接收窗口内的序号31~50是允许接收的. 下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/接收窗口确认机制.png" alt=""></p>
<p>B收到了序号为32和33的数据.这些数据没有按序到达,因为序号31还没有到达.此时,B只能对按序到达的数据中的最高序号给出确认,因此B发送的确认报文段中的确认号仍然为31.</p>
<blockquote>
<h3 id="窗口缩放"><a href="#窗口缩放" class="headerlink" title="窗口缩放"></a>窗口缩放</h3></blockquote>
<p>现在假定B收到了序号为31的数据,并把序号为31~33的数据交付主机,然后B删除这些数据.接着把接收窗口向前移动3个序号,如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/B的接收窗口.png" alt=""></p>
<p>同时给A发送确认,其中窗口值为20,但确认号为34.我们注意到, B收到了序号为37,38,40的数据,但这些数据没有按序到达,只能暂时存放在接收窗口中.</p>
<p>A收到B的确认后,就可以把发送窗口向前移动3个序号,但指针P2不动.可以看出,现在A的可用窗口增大了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/A的可用窗口增大.png" alt=""></p>
<p>A在继续发送完序号42~53的数据后,指针P2和P3重合.发送窗口内的序号已经用完,但还没有收到确认.这时A必须停止发送.如果一段时间后,A还没有收到B发来的确认,那么A必须重传这部分数据.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/发送窗口满.png" alt=""></p>
<blockquote>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3></blockquote>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/sliding_window-900x358.jpg" alt=""></p>
<p>上图中，我们可以看到：</p>
<ul>
<li><p>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</p>
</li>
<li><p>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</p>
</li>
</ul>
<blockquote>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3></blockquote>
<p>由于TCP的下层是互联网环境, 发送的报文段可能经过一个高速率的局域网, 也可能经过多个低速率的网络.如果把超时重传时间设置得太短, 就会引起很多报文的不必要重传. 如果把超时重传的时间设置得过长, 则会使得网络的空闲时间太长,从而降低了传输效率.</p>
<p>TCP采用了一种自适应的算法, 它记录一个报文段的发出时间, 以及收到相应的确认时间.这两个时间之差就是报文段的往返时间 RTT. TCP保留了RTT的一个加权平均往返时间RTTs.每当第一次测量到样本RTT样本时,RTTs的值就取为所测量到的RTT样本值.但以后每测量到一个新的RTT样本时,就按照下面的公式计算RTTs:</p>
<p>新的RTTs = (1 - a) <em> (旧的RTTs) + a </em> (新的RTT样本)</p>
<p>RFC推荐a的值为1/8.用这种方法测出的加权平均往返时间RTTs会比测量的RTT值更加平滑.</p>
<p>显然超时重传时间应略大于RTTs. RCF推荐使用下面公式计算:</p>
<p>RTO = RTTs+= + 4 * RTTD</p>
<p>RTTD是RTT的偏差加权平均值,它与RTTs和新的RTT样本的差有关.当第一次测量时, RTTD取为测量到的RTT样本值的一半.在以后的测量中,可以使用下面的公式计算出RTTD</p>
<p>新的RTTD = (1 - B) <em> (旧的RTTD) + B </em> |RTTs - 新的RTT样本 |</p>
<blockquote>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3></blockquote>
<p>现在假设接收方收到的报文段无差错, 只是未按序号,中间还缺少一些序号的数据,通过选择确认SACK可以实现只传送缺少的数据而不重传已经正确到达接收方的数据.下面使用一个例子来理解SACK的工作原理.</p>
<p>TCP接收方在接收对方发送过来的数据字节流的序号不连续,结果就形成了不连续的字节块:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/SACK.png" alt=""></p>
<p>从上图可以看出, 序号1~1000收到了,但序号1001~1500没有收到,接下来的字节又收到了,但是缺少3001~3500.后面序号4501起也没有收到.换句话说,接收方收到了和前面的字节流不连续的两个字节块.如果这些字节块都在接收窗口的范围内,那么接收方就先收下这些数据,但要把这些信息发给发送方,防止发送方重传接收方已经接收到的数据.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">http://coolshell.cn/articles/11609.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP流量控制]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>利用滑动窗口实现流量控制</li>
<li>零窗口</li>
<li>传输效率</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>一般来说,我们总希望数据传输得快一点, 但是如果发送方把数据发送得太快, 接收方就可能来不及接收,这就会造成数据的丢失.流量控制其实就是让发送方的发送速率不要太快, 要让接收方来得及接收.</p>
<blockquote>
<h3 id="利用TCP滑动窗口实现流量控制"><a href="#利用TCP滑动窗口实现流量控制" class="headerlink" title="利用TCP滑动窗口实现流量控制"></a>利用TCP滑动窗口实现流量控制</h3></blockquote>
<p>其实TCP流量控制本质上是利用滑动窗口机制来实现的.接下来,结合例子来解释TCP的流量控制.</p>
<p>如图:</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口/流量控制.png" alt=""></p>
<p>现在假设A向B发送数据. 在连接建立时, B告诉A:我的接收窗口为400.因此A的发送窗口不能超过B的发送窗口不能超过接收方窗口的数值.现在假设每个报文段的字节为100, 而报文段的初始值为1.</p>
<p>仔细观察上图, 接收方B进行了3次的流量控制. 第一次吧窗口值缩小到了300.第二次又减到100.最后减到0.即不允许对方再发送数据了.</p>
<blockquote>
<h3 id="零窗口"><a href="#零窗口" class="headerlink" title="零窗口"></a>零窗口</h3></blockquote>
<p>现在考虑一种情况. B向A发送了0窗口报文段不久后, B的接收缓存又有了一些空间.于是B向A发送了rwnd = 400的报文段. 然而这个报文在传送的过程中丢失了. 于是A只能一直等待B发送非零窗口的通知,而B一直等待A发送数据.此时如果没有其他措施,这种相互等待的局面会一直持续下去.</p>
<p>为了解决这个问题, TCP为每个连接设有一个持续计时器.只要TCP连接接收到零窗口,就启动持续计时器.若持续计时器时间一到,就发送一个零窗口探测报文段.而对方就在确认这个探测报文段时给出现在的窗口值.如果窗口值不是零的话,那么死索界面将会被打破,否则就重新启动持续计时器.</p>
<blockquote>
<h3 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h3></blockquote>
<h4 id="发送效率"><a href="#发送效率" class="headerlink" title="发送效率"></a>发送效率</h4><p>应用程序把数据传送给TCP的发送缓存后, 剩下的任务就由TCP来控制了.此时,TCP可以采用不同的机制来控制发送的时机.例如:</p>
<ul>
<li>TCP维护一个变量,它等于最大报文长度MSS.只要缓存中存放的数据达到MSS字节时,就组装成一个报文发送出去.</li>
<li>由发送方的应用程序指明要求发送报文段,也就是TCP的PSH操作.</li>
<li><p>第三种机制是发送方的计时器期限到了,就把当前已缓存的数据组装成报文发送出去.</p>
<p>在TCP的实现中, 广泛是使用Nagle算法.该算法如下:若发送应用程序把要发送的数据逐个字节都送到TCP缓存中, 则发送方会把第一个字节先发送出去,把后面到达的字节缓存起来.当发送方收到对第一个数据的确认时,再把缓存的字节组装成报文段发送出去,同时继续对后来到达的数据进行缓存.这样做,可以有效的提高网络的吞吐量.</p>
</li>
</ul>
<h4 id="接收效率"><a href="#接收效率" class="headerlink" title="接收效率"></a>接收效率</h4><p>现在假设TCP接收方的缓存已经满了,而应用进程一次只从接收缓存中读取1个字节,然后向发送方发送确认, 并把窗口值设置为1.如此循环下去, 会使网络的效率很低.</p>
<p>要解决上面的问题,可以有下面两种方法:</p>
<ol>
<li>让接收方等待一段时间,使得接收缓存有足够空间容纳一个MSS再发送确认.</li>
<li>让接收方等待一段时间,使得接收缓存已有一半的空闲的空间.</li>
</ol>
<p>上面的两种方法可以交替使用.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP首部]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/TCP%E9%A6%96%E9%83%A8/</url>
      <content type="html"><![CDATA[<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2></blockquote>
<p>TCP的全部功能都体现在其首部中的各个字段的作用.因此, 只有弄清TCP首部各个字段的作用才能理解TCP的工作原理.</p>
<p>TCP首部的前20个字节是固定的,后面有4n字节是根据需要而增加的选项.因此,TCP首部的最小长度为20字节.</p>
<h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占2个字节, 分别写入源端口号和目的端口号. TCP的分用和复用功能是通过端口实现的.</p>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占4个字节.TCP是面向字节流的,在一个TCP连接中传送的字节流中的每一个字节都按顺序编号.序号字段值是用来指定本报文段所发送的数据的第一个字节的序号.</p>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占4字节.是接收方期望收到发送方下一个报文段的第一个数据字节序号.例如:B正确接收了A发送过来的一个报文段,其序号字段为501,数据长度为200字节,表明B正确接收了501~700的序号的数据.因此,B期望收到A的下一个数据序号是701, 于是B在发送给A的确认报文中把确认号置为701.</p>
<h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占4位, 它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远.这个字段实际上是指出TCP首部的长度.</p>
<h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占6位, 保留为今后使用, 但目前应置为0</p>
<h3 id="紧急URG"><a href="#紧急URG" class="headerlink" title="紧急URG"></a>紧急URG</h3><p>当URG = 1时, 表明紧急指针字段有效.它告诉系统,当前报文段有紧急数据,应当尽快传送.</p>
<h3 id="确认ACK"><a href="#确认ACK" class="headerlink" title="确认ACK"></a>确认ACK</h3><p>仅当ACK = 1时确认号字段才有效.当ACK = 0时,确认号无效. TCP规定,在连接建立后所有传送的报文段都必须把ACK置为1.</p>
<h3 id="推送PSH"><a href="#推送PSH" class="headerlink" title="推送PSH"></a>推送PSH</h3><p>当发送方将PSH置为1,并立即创建一个报文段发送出去.接收方TCP收到PSH = 1的报文段时,就尽快地交付接收应用程序,而不再等到整个缓存填满了再向上交付.</p>
<h3 id="复位-RST"><a href="#复位-RST" class="headerlink" title="复位(RST)"></a>复位(RST)</h3><p>当RST = 1 时, 表明TCP连接出现严重错误,必须释放连接,然后再重新建立连接.</p>
<h3 id="同步SYN"><a href="#同步SYN" class="headerlink" title="同步SYN"></a>同步SYN</h3><p>在连接建立时用来同步序号. 当SYN = 1 时而ACK = 0 时表示这是一个连接请求报文段.若对方同意连接后, 则应在响应报文中使SYN = 1和ACK = 1.实际上SYN = 1 时表示这是一个连接请求或接受报文.</p>
<h3 id="终止FIN"><a href="#终止FIN" class="headerlink" title="终止FIN"></a>终止FIN</h3><p>用来释放一个连接. 当FIN = 1 时, 表明此报文段的发送数据已发送完毕,并要求释放连接.</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占2字节.窗口指的是发送报文段一方的接收窗口.窗口值告诉对方:接收方目前允许对方发送的数据量.</p>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>检验和字段检验的范围包括首部和数据这两部分.</p>
<h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占2字节. 当URG = 1 时才有意义, 它指出本报文段中的紧急数据字节数.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[可靠传输的工作原理]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>可靠运输的实现</li>
<li>停止等待协议</li>
<li>连续ARQ协议</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>TCP发送的报文段是交给IP层传送的, 但是IP层只能提供尽最大努力交付的服务,也就是说网络层提供的是不可靠的传输.因此,TCP必须采用适当的措施才能使得两个运输层之间的传输信道变得可靠.</p>
<blockquote>
<h3 id="可靠运输的实现"><a href="#可靠运输的实现" class="headerlink" title="可靠运输的实现"></a>可靠运输的实现</h3></blockquote>
<p>怎么样的运输才算是可靠运输? 要回答这个问题,可以从三方面入手:</p>
<ol>
<li>保证传输的分组无出错,也就是二进制比特流没有出现差错.</li>
<li>保证分组在传输的过程中没有丢失.</li>
<li>分组能够按序达到.</li>
</ol>
<p>既然知道了怎么样才能实现可靠运输,那么下面,我们来一步一步实现可靠运输原理.</p>
<h4 id="可靠运输1-0"><a href="#可靠运输1-0" class="headerlink" title="可靠运输1.0"></a>可靠运输1.0</h4><p>现在我们假设分组的传输是在一个可靠的信道上面传输的,也就是二进制比特流在这条通道上传输是不会出现比特流差错的.如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>但是,实际环境中,由于信道会受到声噪等因素影响,会使得传输的信道变得不可靠, 那么这时也就不能保证比特流的无差错.有没有什么办法能够解决这个问题?</p>
<h4 id="可靠运输2-0"><a href="#可靠运输2-0" class="headerlink" title="可靠运输2.0"></a>可靠运输2.0</h4><p>如何保证接收方接收到的比特流的无出错的? 关于这个问题,我们在可靠运输2.0版本中,通过使用一个比特流的检验和方法来检验接收方接收到的比特是否产生了差错.</p>
<p>我们引入了比特的差错检验来查看接收方收到的比特流的情况. 如果检验得比特流无差错,那么接收方可以直接接收.但是检验的结果是出现错误的话,那么这时接收方应该怎么做?</p>
<p>分析到这里, 我们需要引入另外的一种机制来解决这个问题. 这里我们引入确认机制,即接收方应该在接收到比特流后,应该向发送方确认,确认收到的比特流是否出现错误,可以使用ACK代表无差错,NACK代表有差错.</p>
<p>如果发送方接收到接收方发送的NACK,代表比特流出现了错误,那么发送方该怎么做?</p>
<p>这个时候,我们得引入重传机制, 也就是当发送方接收到NACK时,发送方应该重传分组.</p>
<p>整个过程如下图:</p>
<p><img src="/uploads/计网/运输层/TCP/可靠运输2.0.png" alt=""></p>
<p>为了在不可靠的信道上实现比特无差错,我们引入了检验和,确认(ACK/NACK)和重传机制来保证.但是我们如何解决ACK或NACK出现错误?</p>
<h4 id="可靠运输2-1"><a href="#可靠运输2-1" class="headerlink" title="可靠运输2.1"></a>可靠运输2.1</h4><p>为了应对ACK/NACK被破坏的情况,我们可以在ACK/NACK增加检验和机制来保证ACK/NACK不出现差错.</p>
<p>我们在2.0中引入了重传机制.因此,有可能出现分组的重复.在2.1中,我们将每个分组进行编号,保证分组不会因为重传而出现重复.</p>
<h4 id="可靠运输2-2"><a href="#可靠运输2-2" class="headerlink" title="可靠运输2.2"></a>可靠运输2.2</h4><p>为了提高确认机制的效率,我们采用累计确认机制.</p>
<p>所谓的累计确认是这样的: 收到分组后,需要给发送方发送一个ACK来表示已经收到分组.在发送分组的同时,附加上该分组的编号,来表示小于该编号之前的分组都已经被成功接收了.</p>
<p>既然引入了累计确认机制,NACK也就显得有点多余,在2.2中,我们把NACK去掉.</p>
<h4 id="可靠传输3-0"><a href="#可靠传输3-0" class="headerlink" title="可靠传输3.0"></a>可靠传输3.0</h4><p>前面的2.0~2.2版本都是针对如何解决保证分组在传输的过程中不出错,在3.0中,我们来考虑如何保证传输的分组不丢失?</p>
<p>为了保证分组在传输的时候不丢失,我们可以为每个传输的分组设置一个定时器,如果在定时器期限到达之前,没有收到ACK的话,就认为分组在传输的过程中丢失了,于是我们就重传该分组.</p>
<p>现在,我们基本可以保证分组不丢失了.但是,我们仔细想一下,会发现传输的信道利用率很低,因为,每次发送完一个分组,都得等待收到接收方的ACK后才能发送另外一个分组.由此看来,信道大部分时间都是处于等待状态的.</p>
<h4 id="可靠运输3-1"><a href="#可靠运输3-1" class="headerlink" title="可靠运输3.1"></a>可靠运输3.1</h4><p>为了解决3.0中信道利用率低的问题.我们可以采用流水线机制.即:每次发送完一个分组不必等待接收方的ACK才发送下一个分组.也就是可以连续发送多个分组.</p>
<p>由于我们引入了连续发送分组的这种协议,我们不得不面临多一个问题:如何解决分组乱序到达的情况?</p>
<h4 id="可靠运输3-2"><a href="#可靠运输3-2" class="headerlink" title="可靠运输3.2"></a>可靠运输3.2</h4><p>我们可以使用回退N步或者选择重传这两种机制来解决分组乱序的问题.</p>
<p>回退N步,本文下面会讲到,这里不多说.<br>选择重传: 对于乱序到达的分组,选择重传机制会将它们缓存起来,等待失序的分组到达后再发送ACK.</p>
<blockquote>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3></blockquote>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p><img src="/uploads/计网/运输层/TCP/无差错情况.png" alt=""></p>
<p>上图为最简单的无差错情况. A发送分组M1,发完就暂停发送,等待B确认.当B收到了M1就向A发送确认.A收到了M1的确认后,就再次发送M2分组.同样, 在收到B对M2的确认后, A再发送M3.</p>
<h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p><img src="/uploads/计网/运输层/TCP/出现差错.png" alt=""></p>
<p>上图为分组在传输的过程中出现差错的情况. B接收M1时检测出了差错, 就丢弃M1,其他什么都不做.也可能是M1在传输的过程中丢失了. 这两种情况下, B都不会发送任何信息. 可靠传输协议是这样设计: A只要超过一段时间仍然没有接收到确认, 就认为刚才发送的分组丢失了, 因此重传前面发送过的分组,这叫做超时重传.为了实现超时重传, 要在每发送完一个分组设置一个超时计时器. 如果在超时计时器到期之前收到了对方的确认, 就撤销计时器.</p>
<p>注意:</p>
<ol>
<li>A发送完一个分组后, 必须暂时保存已发送的分组的副本.只有在收到相应的确认后才能清除暂时保留的分组副本.</li>
<li>分组和确认分组都必须进行编号. 这样才能明确是哪一个发送出去的分组收到了确认, 而哪一个分组没收到确认.</li>
<li>超时计时器设置的重传时间应当比数据在分组传送的平均往返时间更长一些.</li>
</ol>
<h4 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h4><p><img src="/uploads/计网/运输层/TCP/确认丢失.png" alt=""></p>
<p>上图为B发送的确认分组丢失的情况. A在设定的超时重传时间内没有收到确认, 但无法知道是自己发送的分组出错,丢失,或者是B发送的确认丢失了. 此时A必须重传M1分组. 假定B收到了重传M1,此时应采取两个行动.</p>
<ol>
<li>丢弃这个重复的分组M1,不向上层交付.</li>
<li>向A发送确认.</li>
</ol>
<p><img src="/uploads/计网/运输层/TCP/确认迟到.png" alt=""></p>
<p>上图为确认迟到的情况. 传输过程没有出错, 但B对M1的确认迟到了. A会收到重复的确认. 这时, A只要收下后丢弃.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述的确认和重传机制, 可以在不可靠的传输网路上实现可靠的通信. 这种可靠传输协议称为自动重传请求ARQ(Automatic Repeat Request).ARQ协议的优点是简单, 但是缺点是信道利用率太低了.</p>
<blockquote>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3></blockquote>
<p>为了提高信道的利用率, 发送方可以采用流水线传输.流水线传输就是发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认.</p>
<p><img src="/uploads/计网/运输层/TCP/发送窗口.png" alt=""></p>
<p>上图为发送方维护的发送窗口, 它表示位于发送窗口内的3个分组都可以连续发送出去,而不需要对方等待. 这样信道利用率就提高了.</p>
<p><img src="/uploads/计网/运输层/TCP/滑动窗口.png" alt=""></p>
<p>发送方每接收到一个确认,就把滑动窗口向前滑动一个分组的位置.接收方一般都是采取累计确认的方式.也就是说, 接收方不必对收到的分组逐个发送确认,而是在收到几个分组后,对按序到达的最后一个分组发送确认, 这就表示: 到这个分组为止的所有分组都已经正确收到.</p>
<p>累计确认的缺点是不能向发送方反映接收方已经正确接收的所有分组信息.例如,如果发送了5个分组,而中间的3个分组丢失了. 这时接收方只能前两个分组发出确认.发送方无法知道后面三个分组的下落, 只好把后面三个分组都再传一次, 这叫做回退N步(Go Back N).</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)<br>计算机网络-自顶向下</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[路由器工作原理]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>输入端口</li>
<li>交换结构</li>
<li>输出端口</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>路由器是一种具有多个输入和输出端口的专用计算机,其任务是转发分组.路由器的转发分组是网络层的主要工作之一. 下面给出典型的路由器构成图:</p>
<p><img src="/uploads/计网/路由选择协议/路由器工作原理.png" alt=""></p>
<blockquote>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3></blockquote>
<p><img src="/uploads/计网/路由选择协议/输入端口.png" alt=""></p>
<ul>
<li>输入端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层.</li>
<li>路由器使用转发表来查找输出端口,使得到达的分组将能经过交换结构转发到输出端口.</li>
<li>转发表是由路由器处理和更新的,但转发表的一份影子副本通常会被存放在每个输入端口, 有了影子副本,转发决策能在每个输入端口本地做出,无须调用中央路由选择处理器, 因此也避免了集中式处理的瓶颈.</li>
</ul>
<blockquote>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3></blockquote>
<p>交换结构位于一台路由器的核心部位.正是通过这种交换结构,分组才能实际从一个输入端口交换到一个输出端口.交换可以由下面的三种交换技术完成.</p>
<p><img src="/uploads/计网/路由选择协议/内存交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/纵横式交换结构.png" alt=""><br><img src="/uploads/计网/路由选择协议/总线交换结构.png" alt=""></p>
<h4 id="内存交换结构"><a href="#内存交换结构" class="headerlink" title="内存交换结构"></a>内存交换结构</h4><ul>
<li>在输入端口和输出之间交换是在CPU的直接控制下完成的.</li>
<li>一个分组到达一个输入端口时, 该端口会先通过中断方式向路由选择处理器发送信号.于是,该分组从输入端口处被复制到处理器内存中.路由器选择处理器从其首部提取目的地址,在转发表中找出合适的输出端口,并将该分组复制到输出端口的缓存中.需要注意的是:不能同时发送两个分组,即使他们有不同的端口,因为经过共享系统总线一次仅能执行一次内存读/写.</li>
</ul>
<h4 id="总线交换"><a href="#总线交换" class="headerlink" title="总线交换"></a>总线交换</h4><ul>
<li>输入端口经过一根共享总线将分组直接传送到输出端口,不需要路由选择处理器的干预.</li>
<li>当一个分组到达路由器时, 输入端口为分组预先计划一个交换机内部标签, 用于指示本地输出端口,是分组在总线上传送和传输到输出端口.该分组能由所有输出端口收到, 但只有与该标签匹配的端口才能保存该分组.</li>
<li>如果多个分组同时到达路由器,每个位于不同的输出端口,除了正在总线上传输的分组外,其他分组必须等待,因为一次只有一个分组能够跨越总线.</li>
</ul>
<h4 id="纵横式交换结构"><a href="#纵横式交换结构" class="headerlink" title="纵横式交换结构"></a>纵横式交换结构</h4><ul>
<li>纵横式交换机是一种由2N条总线组成的互联网络.网络互联使得它能克服单一,共享式总宽带限制的缺点.</li>
<li>当某个分组到达A端口时, 需要转发到端口Y,交换机控制器闭合总线A和Y交叉部位的叉点,然后端口A在其总线上发送该分组, 该分组仅由总线Y安排接收.注意:来自端口B的一个分组在同一时间能够转发到端口X,因为A到Y和B到X的分组使用不同的输入和输出总线.然而,如果来自不同端口的两个分组其目的地为相同的输出端口,那么其中一个分组必须等待, 因为在某个时刻,总线上仅有一个分组能被传送.</li>
</ul>
<blockquote>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3></blockquote>
<p>输出端口处理取出存放在输出端口内存中的分组并将其发送到输出链路上.这包括选择和取出排队的分组进行传输,执行所需的链路层和物理层传输功能.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络自顶向下<br>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[路由选择协议]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>内部网关协议RIP</li>
<li>内部网关协议OSPF</li>
<li>外部网关协议BGP</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>从路由算法能否随网络的通信或者拓扑自适应地进行调整变化来划分, 可将路由选择分为两大类:静态路由选择策略和动态路由选择策略.<ul>
<li>静态路由选择策略: 也叫做非自适应路由选择, 其特点是简单和开销较小, 但不能及时适应网络状态变化, 适用于小型网络.</li>
<li>动态路由选择协议: 也叫做自适应路由选择, 其特点是能较好地适应网络状态的变化, 但实现起来复杂, 开销也较大. 因此, 动态路由选择适合复杂的大型网络.</li>
</ul>
</li>
<li>因特网采用的路由选择协议主要是自适应的分布式路由选择协议.</li>
<li>因特网采用分层次的路由选择协议的两个原因:<ul>
<li>因特网的规模宏大. 如果让所有的路由器知道所有的网络应怎么样到达,则这种路由表非常大, 处理起来也花费很多时间.</li>
<li>许多单位不愿意让外界了解自己单位网络的布局细节和本部门所采用的路由选择协议,同时还希望能接上因特网.</li>
</ul>
</li>
<li>基于上面的两个原因, 因特网将整个互联网划分为许多较小的自治系统(autonomous system),一般称为AS.</li>
<li>一个AS对外表现出是一个单一的和一致的路由选择策略.</li>
<li>一个大的ISP就是一个自治系统, 因特网把路由选择协议分为两大类:<ul>
<li>内部网关协议IGP: 在一个自治系统内使用的路由选择协议,而这与互联网中的其他自治系统选用什么路由选择协议无关,目前用得最多的内部网关协议有:RIP, OSPF.</li>
<li>外部网关协议EGP: 若元源主机和目的主机处于两个不同的自治系统内, 当数据报传到一个自治系统的边界时, 就需要使用一种协议将路由选择信息传递到另外一个自治系统中. 目前使用得最多的外部网关协议: BGP</li>
</ul>
</li>
<li>自治系统之间的路由选择也叫做域间路由选择, 而在自治系统内的路由选择叫做域间内部选择.</li>
</ul>
<blockquote>
<h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3></blockquote>
<p>RIP是一种分布式,异步,收敛,迭代的基于距离向量的路由选择协议.</p>
<ol>
<li>分布: 每个节点将自己的路由表发给自己直接相邻的节点.</li>
<li>异步: 节点不需要在某个固定的时间同时发送和交换信息.</li>
<li>收敛: 在有限次的信息交换次数内, 不管初始值是多少, 路由表中的每一项一定会收敛成某个固定值, 也就是真正的最短路径.</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>从一个路由器到直接连接的网络距离定义为1.</li>
<li>从路由器到非直接连接的网络距离定义为所经过的路由器数+1,</li>
<li>RIP允许一条路径只能包含15个路由器,因此,当距离等于16时,相当于不可达.</li>
<li>RIP不能在两个网络之间同时使用多条路由, RIP只会选择一条具有最少路由器的路径.</li>
</ul>
<p>RIP协议下的路由器都需要不断和其他的路由器交换路由信息,那么,是和哪些路由器交换信息?交换什么信息?在什么时候交换信息?</p>
<h5 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点:"></a>RIP协议的特点:</h5><ul>
<li>仅和相邻路由器交换信息</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息,即自己的路由表.也就是,交换的信息是: 一个路由器到本自治系统内所有网络的最短距离,以及到每个网络应经过的下一个路由器.</li>
<li>按固定时间交换路由信息.路由表中的最主要信息:到某个网络的距离,以及经过的下一跳地址和下一跳路由的地址.</li>
</ul>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p>对每个相邻路由器发来的RIP报文, 将进行一下步骤:</p>
<ol>
<li>对地址为X的相邻路由器发送过来的RIP报文, 先修改此报文中的所有项目, 把下一跳字段中的地址改为X, 把所有距离都+1.每个项目都有三个关键数据:到目的网络N, 距离d, 下一跳路由器X.</li>
<li>对修改的RIP报文中的每一个项目,进行一下步骤:<br><br>若原来的路由表没有目的网络N, 则把该项目添加到路由表.<br><br>否则,若下一跳路由器地址为X, 则把收到项目替换掉原来路由表中的项目.否则什么也不做</li>
<li>若3分钟还没有收到相邻路由器的更新路由表,则把此相邻路由器记录为不可到达网络,即把距离设置为16.</li>
<li>返回.</li>
</ol>
<h5 id="“坏消息传得慢”"><a href="#“坏消息传得慢”" class="headerlink" title="“坏消息传得慢”"></a>“坏消息传得慢”</h5><p>RIP存在一个缺点是当网络发生故障时, 要经过比较长的时间才能将信息传送到所有的路由器.例如:</p>
<p><img src="/uploads/计网/路由选择协议/RIP缺点.png" alt=""></p>
<p>假定路由器1到网1的链路出了故障, R1无法到达网1. 于是路由器R1把到网1的距离设置为16, 因而在R1的路由表中相应的项目变为”1, 16, 直接”. 但是很可能要经过30秒后才能把更新信息发给R2.然而R2可能已经先把自己的路由信息”1, 2, R1”发给R1, R1收到这个报文后,误认为可以通过R2到达网1, 于是更新”1, 2, R1”修改为”1, 3, R2”,并发给R2.同理,R2接着又更新自己的路由表信息为”1, 4, R1”.这样的更新一直持续到R1,R2到网1的距离都增大到16,R1, R2才知道网1原来不可达.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>RIP最大的优点是实现简单,开销小.</li>
<li>RIP只能使用的最大距离为15, 这样限制了网络的规模.</li>
<li>路由器之间的路由交换信息是路由器中完整的路由表,因而随着网络规模的扩大, 开销也就增加.</li>
<li>坏消息传播得慢,使得更新过程的收敛时间过长.</li>
<li>对于较大规模的网络应该换用OSPF协议.</li>
</ul>
<blockquote>
<h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3></blockquote>
<p>OSPF最主要的特征是使用了分布式的链路状态协议.</p>
<h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><h5 id="向本自治系统中的所有路由器发送信息"><a href="#向本自治系统中的所有路由器发送信息" class="headerlink" title="向本自治系统中的所有路由器发送信息"></a>向本自治系统中的所有路由器发送信息</h5><p>路由器通过所有输出端口向所有相邻路由器发送信息,也就是端口洪泛.而每个相邻路由器又再将此信息发往其所有的相邻路由器.这样整个区域中所有路由器都得到了这个信息的一个副本.</p>
<h5 id="发送的信息"><a href="#发送的信息" class="headerlink" title="发送的信息"></a>发送的信息</h5><p>发送的信息是与本路由器相邻的所有路由器的链路状态.所谓”链路状态”是本路由器都和哪些路由器相邻,以及该链路的度量.</p>
<h5 id="何时发送信息"><a href="#何时发送信息" class="headerlink" title="何时发送信息"></a>何时发送信息</h5><p>只有当链路状态发生改变时,路由器才向所有路由器洪泛此信息.</p>
<h5 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h5><p>由于各个路由器之间频繁进行链路状态交换,因此所有路由器最终都能建立一个链路状态数据库.这个数据库实际上就是全网的拓扑结构.链路状态数据库能较快地进行更新,使各个路由器能及时更新路由表.</p>
<h5 id="链路状态更新"><a href="#链路状态更新" class="headerlink" title="链路状态更新"></a>链路状态更新</h5><p>只有当链路状态发生变化时, 路由器才向所有路由器用洪泛法发送此消息.</p>
<h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><p>OFPS将一个自治系统再划分为几个更小的范围,叫作区域.划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是一个完整的自治系统.</p>
<blockquote>
<h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3></blockquote>
<p>不同自治系统之间的路由选择不使用RIP或者OSPF的原因:</p>
<ol>
<li>因特网的规模太大,使得AS之间的路由变得非常困难.如果使用链路状态协议, 则每个路由器需要维持一个很大的链路状态数据库.另外,不同的自治系统各自运行着自己选定的内部路由选择协议, 并使用本AS指明的路径度量.因此当一条路径通过不同的自治系统时,路径的度量可能会出歧义.例如:对某AS来说, 代价为1000可能表示一条比较长的路由, 但对另外一AS代价为1000, 可能表示不可接受的坏路由.</li>
<li>AS之间的路由选择必须考虑策略. 由于相连的网络性能相差很大, 如果根据最少跳数找出来的路径, 可能并不合适.也有的代价啊很高或不安全.</li>
</ol>
<p>基于上述的情况, 边界网关协议BGP只能力求寻找一条能够到达目的网络比较好的路由,而非寻找一条最佳路由.BGP采用了路径向量路由选择协议.</p>
<h4 id="BGP发言人"><a href="#BGP发言人" class="headerlink" title="BGP发言人"></a>BGP发言人</h4><ul>
<li><p>在配置BGP时, 每个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人.一般来说,这两个BGP发言人都是通过一个网络共享连接在一起的,而BGP发言人往往是边界路由器.</p>
</li>
<li><p>一个BGP发言人与其他AS的BGP发言人要交换路由信息,就要先建立TCP连接,然后在此连接上交换BGP报文以建立BGP会话,利用BGP会话交换路由信息,如增加了新的路由,或者撤销过时的路由,以及报告差错等.使用TCP连接交换路由信息的两个BGP发言人,彼此成为对方的邻站或对等站.</p>
</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机网络(谢希仁)</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网际控制报文协议ICMP]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP/</url>
      <content type="html"><![CDATA[<h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>ICMP报文种类</li>
<li>ICMP应用举例</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>为了更有效地转发IP数据报和提高交付成功的机会, 在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol). ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告.ICMP报文作为IP层的数据报的数据.</p>
<blockquote>
<h3 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h3></blockquote>
<ul>
<li>网际报文的种类有两种, 即ICMP差错报告报文和ICMP询问报文.</li>
<li>几种常用的ICMP报文类型</li>
</ul>
<table>
<thead>
<tr>
<th>ICMP报文类型</th>
<th>类型的值</th>
<th>ICMP报文的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>差错报告报文</td>
<td>3</td>
<td>终点不可达</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>4</td>
<td>源点抑制</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>11</td>
<td>时间超过</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>12</td>
<td>参数问题</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>5</td>
<td>改变路由</td>
</tr>
<tr>
<td>询问报文</td>
<td>8或0</td>
<td>回送请求或回答</td>
</tr>
<tr>
<td>询问报文</td>
<td>13或14</td>
<td>时间戳请求或回答</td>
</tr>
</tbody>
</table>
<h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p>当路由器或者主机不能交付数据报时就向源点发送终点不可达报文</p>
<h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p>当路由器或者主机因拥塞而丢弃数据报时, 就向源点发送源点抑制报文, 使源点知道应当把数据报的发送速率放慢.</p>
<h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p>当路由器收到生存时间为0的数据报时, 除了丢弃数据报外, 还要向源点发送时间超过报文.</p>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p>当路由器或者目的主机收到的数据报的首部中有的字段的值不正确时, 就丢弃该数据报,并向源点发送参数问题报文.</p>
<h4 id="改变路由-路由重定向"><a href="#改变路由-路由重定向" class="headerlink" title="改变路由(路由重定向)"></a>改变路由(路由重定向)</h4><p>路由器把改变路由报文发送给主机, 让主机知道下次应该将数据报发送给另外的路由器.</p>
<h4 id="回送请求和回答"><a href="#回送请求和回答" class="headerlink" title="回送请求和回答"></a>回送请求和回答</h4><p>ICMP回送请求报文是由主机或者路由器向一个特定的目的主机发送询问. 收到此报文的主机必须给源主机或者路由发送ICMP回送回答报文.</p>
<h4 id="时间戳请求和回答"><a href="#时间戳请求和回答" class="headerlink" title="时间戳请求和回答"></a>时间戳请求和回答</h4><p>ICMP时间戳请求报文是请某个主机或者路由器回答当前的日期和时间.</p>
<blockquote>
<h3 id="ICMP的应用举例"><a href="#ICMP的应用举例" class="headerlink" title="ICMP的应用举例"></a>ICMP的应用举例</h3></blockquote>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><ul>
<li>ICMP一个重要应用就是分组网间探测PING, 用来测试两个主机之间的连通性.</li>
<li>PING使用了ICMP的回送请求和回送回答报文.</li>
<li>PING是应用层直接使用网络层ICMP的例子, 它没有通过运输层的TCP或UDP.</li>
</ul>
<h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><ul>
<li>traceroute是用来跟踪一个分组从源点到终点的路径.</li>
<li>traceroute从源主机向目的主机发送一连串IP数据报, 数据报中封装的是无法交付的UDP用户数据报.第一个数据报P1的生存时间为TTL设置为1.当P1到达路径上的第一个路由器R1时, 路由器R1先收下它, 接着把TTL的值减1.由于TTL等于0了, R1就把P1丢弃了, 并向源主机发送一个ICMP时间超过的差错报告报文.</li>
<li>如此循环下去, 当最后一个数据报刚刚达到目的主机时, 数据报的TTL是1, 主机不转发数据, 也不把TTL减1.但因IP数据报封装的是无法交付的运输层UDP用户数据报, 因此目的主机要向源主机发送ICMP终点不可达差错报告报文.</li>
</ul>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[子网的划分和构成超网]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/</url>
      <content type="html"><![CDATA[<h1 id="子网的划分和构成超网"><a href="#子网的划分和构成超网" class="headerlink" title="子网的划分和构成超网"></a>子网的划分和构成超网</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>划分子网</li>
<li>使用子网时的分组转发</li>
<li>无分类编址CIDR</li>
</ul>
<blockquote>
<h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2></blockquote>
<h3 id="两级IP地址的不合理"><a href="#两级IP地址的不合理" class="headerlink" title="两级IP地址的不合理"></a>两级IP地址的不合理</h3><h4 id="IP空间利用率低"><a href="#IP空间利用率低" class="headerlink" title="IP空间利用率低"></a>IP空间利用率低</h4><p>一个A类网路可容纳的主机数超过1000W, 而B类网络可容纳主机超过6W.但是有些网络对连接在网络上的主机数量是有限制的, 这就导致了地址空间的利用率低下.</p>
<h4 id="路由表变大导致网络性能低下"><a href="#路由表变大导致网络性能低下" class="headerlink" title="路由表变大导致网络性能低下"></a>路由表变大导致网络性能低下</h4><p>给每个物理网络分配一个网络号的话, 会导致路由表中的项目大大增大, 同时查找路由的耗时也就变得更长.</p>
<p>为了解决二级IP带来的问题,从1985年起,将IP地址中增加了一个”子网号字段”, 使得二级IP地址变成三级IP地址.这种做法叫做划分子网.</p>
<blockquote>
<h3 id="划分子网的基本思路"><a href="#划分子网的基本思路" class="headerlink" title="划分子网的基本思路"></a>划分子网的基本思路</h3></blockquote>
<ul>
<li>一个拥有许多物理地址的单位, 可将所属的物理网络划分为多个子网.划分子网属于单位内部的事情,对外还是表现为一个网络.</li>
<li>划分子网的方法是从网路的主机号借用若干位作为子网号,于是二级IP地址在单位内部就变成了三级IP地址,即 network-id:subnet-id-host-id</li>
</ul>
<blockquote>
<h3 id="子网划分实例"><a href="#子网划分实例" class="headerlink" title="子网划分实例"></a>子网划分实例</h3></blockquote>
<p><img src="/uploads/计网/划分子网/子网.png" alt=""></p>
<p>上图的网络被划分为三个子网, 整个网络对外表现为一个网络, 其网络地址为145.13.0.0.但是网络145.13.0.0上的路由器R1在收到外来的数据报后, 再根据数据报的目的地址将它转发到对应的子网.</p>
<blockquote>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3></blockquote>
<p>我们知道, 从IP数据报的首部无法看出源主机或目的主机是否进行了子网的划分,路由器是如何将数据报转发到子网?使用子网掩码可以解决这个问题.</p>
<h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><ul>
<li>子网掩码是一个32位2进制数, 对应的网络地址全为1,主机地址全为0.</li>
<li>A类网络的默认子网掩码为:255.0.0.0, B类为255.255.0.0, C类为255.255.255.0</li>
</ul>
<h4 id="通过目的IP地址和子网掩码计算子网的网络地址"><a href="#通过目的IP地址和子网掩码计算子网的网络地址" class="headerlink" title="通过目的IP地址和子网掩码计算子网的网络地址"></a>通过目的IP地址和子网掩码计算子网的网络地址</h4><ul>
<li>将数据报的目的IP地址与子网掩码逐位相”与”.</li>
</ul>
<p>例如: IP地址为141.14.72.24, 子网掩码为255.255.192.0,求网络地址<br>解析: 子网掩码为11111111 11111111 11000000 00000000, 由于子网掩码的前两个字节的位全为1, 最后一个字节的位全为0,因此, 可暂时推断网络地址为: 141.14.X.0. 此时, 只需要将72对应的二进制数与11000000逐位相”与”,就可得出完整的网络地址: 141.14.64.0.</p>
<h4 id="利用子网数来计算子网掩码"><a href="#利用子网数来计算子网掩码" class="headerlink" title="利用子网数来计算子网掩码"></a>利用子网数来计算子网掩码</h4><p>在求子网掩码时, 必须弄清楚划分子网的数目,以及每个子网内所需的主机数目.<br><br><br>1)将子数目转为二进制<br><br>2)取得二进制的位数N<br><br>3)取得该IP地址的类子网掩码, 将其主机号的前N位置1,即可得该IP地址划分子网的子网掩码<br></p>
<p>eg: 将B类IP地址168.192.0.0划分为27个子网.<br><br>1) 27 = 11011<br><br>2) N = 5<br><br>3) B类子网掩码: 255.255.0.0<br><br>4) 该IP地址划分的子网掩码: 255.255.248.0.</p>
<h4 id="子网的划分选择"><a href="#子网的划分选择" class="headerlink" title="子网的划分选择"></a>子网的划分选择</h4><p>下面给出B类子网的划分选择(使用固定的长度子网)</p>
<table>
<thead>
<tr>
<th>子网号位数</th>
<th>子网掩码</th>
<th>子网数</th>
<th>每个子网的主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>255.255.192.0</td>
<td>2^2-2</td>
<td>2^14-2</td>
</tr>
<tr>
<td>3</td>
<td>255.255.224.0</td>
<td>2^3-2</td>
<td>2^13-2</td>
</tr>
<tr>
<td>4</td>
<td>255.255.240.0</td>
<td>2^4-2</td>
<td>2^12 -2</td>
</tr>
<tr>
<td>5</td>
<td>255.255.248.0</td>
<td>2^5-2</td>
<td>2^11-2</td>
</tr>
<tr>
<td>6</td>
<td>255.255.252.0</td>
<td>2^6-2</td>
<td>2^10-2</td>
</tr>
<tr>
<td>7</td>
<td>255.255.254.0</td>
<td>2^7-2</td>
<td>2^9-2</td>
</tr>
<tr>
<td>8</td>
<td>255.255.255.0</td>
<td>2^8-2</td>
<td>2^8-2</td>
</tr>
<tr>
<td>9</td>
<td>255.255.255.128</td>
<td>2^9-2</td>
<td>2^7-2</td>
</tr>
<tr>
<td>10</td>
<td>255.255.248.192</td>
<td>2^10-2</td>
<td>2^6-2</td>
</tr>
<tr>
<td>11</td>
<td>255.255.252.224</td>
<td>2^11-2</td>
<td>2^5-2</td>
</tr>
<tr>
<td>12</td>
<td>255.255.254.240</td>
<td>2^12-2</td>
<td>2^4-2</td>
</tr>
<tr>
<td>13</td>
<td>255.255.255.248</td>
<td>2^13-2</td>
<td>2^3-2</td>
</tr>
<tr>
<td>14</td>
<td>255.255.255.252</td>
<td>2^14-2</td>
<td>2^2-2</td>
</tr>
</tbody>
</table>
<p><br><br>上面-2是因为去掉全0和全1的情况, 子网号位数没有0,1,15,16这四种情况是因为这几种情况没有意义.</p>
<blockquote>
<h3 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h3></blockquote>
<p>使用子网划分后, 路由表必须包含这三项内容:目的网络地址,子网掩码和下一跳地址.</p>
<h4 id="路由转发算法"><a href="#路由转发算法" class="headerlink" title="路由转发算法"></a>路由转发算法</h4><ol>
<li>从收到的数据报的首部提取目的IP地址D.</li>
<li>先判断是否可以直接交付. 对路由器相连的网络逐个检查:用各个网络的子网掩码与D逐位相”与”, 看结果是否和相应的网络地址匹配.若匹配,则把分组直接交付, 否则执行(3).</li>
<li>若路由器表中有目的地址为D的特定主机路由, 则把数据报传送给下一跳的路由器,否则执行(4)</li>
<li>对路由表中的每一行,用其中的子网掩码和D逐位相”与”,若结果与目的网络地址匹配,把数据报传送下一跳的路由器, 否则执行(5).</li>
<li>若路由表中有一个默认的路由, 则把数据报传给默认路由, 否则执行(6)</li>
<li>报告转发分组时出错.</li>
</ol>
<h4 id="转发实例"><a href="#转发实例" class="headerlink" title="转发实例"></a>转发实例</h4><p><img src="/uploads/计网/划分子网/子网转发分组.png" alt=""></p>
<p>讨论R1收到H1向H2发送分组后,查找路由表的过程</p>
<ol>
<li>H1把本子网的子网掩码 255.255.255.128 与目的主机的ip地址逐位相”与”, 得出 128.30.33.128,它不等于H1的网络地址,说明H1与H2不在同一个子网内, 因此H1不能把分组直接交付给H2,必须交给子网上的默认路由器R1,由R1来进行转发</li>
<li>R1收到一个分组后, 就在路由表中寻找有无匹配的网络地址.(1)计算出目的网络地址为128.30.33.128, 与路由表中的第二行的目的网络地址匹配, 说明这个网络就是分组想要寻找的目的网络, 于是R1将分组从接口1,直接交付给主机H2.</li>
</ol>
<blockquote>
<h2 id="无分类编址CIDR-构成超网"><a href="#无分类编址CIDR-构成超网" class="headerlink" title="无分类编址CIDR(构成超网)"></a>无分类编址CIDR(构成超网)</h2></blockquote>
<p>无分类域间路由选择CIDR解决的问题:</p>
<ol>
<li>B类地址眼看就快要分配完了</li>
<li>因特网主干网上的路由表项目数急剧增长.</li>
</ol>
<blockquote>
<h3 id="CIDR的两个主要的特点"><a href="#CIDR的两个主要的特点" class="headerlink" title="CIDR的两个主要的特点"></a>CIDR的两个主要的特点</h3></blockquote>
<ul>
<li>CIDR消除了传统的A类,B类,C类地址以及子网的划分的概念,把32位的IP地址划分了两个部分.前一部分用来表示网络前缀,以表示网络. 后一部分则用来表主机.</li>
<li>CIDR把网络前缀相同的连续IP地址组成一块”CIDR地址块”.</li>
</ul>
<blockquote>
<h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3></blockquote>
<ul>
<li><strong>由于一个CIDR地址块中有很多地址,所以在路由表中就利用CIDR地址块来查找目的网络. 这种地址的聚合称为路由聚合.</strong></li>
<li>它使得一个路由表可以表示更多地址. 路由聚合也称为构成子网.</li>
</ul>
<blockquote>
<h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3></blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在使用CIDR时, 由于采用了网络前缀这种记法, 因此在路由表中的项目也要有相应的改变.在查找路由表时, 可能会得到不止一个匹配结果, 那么我们应该选择哪条结果?</p>
<h4 id="最长匹配"><a href="#最长匹配" class="headerlink" title="最长匹配"></a>最长匹配</h4><p>为了解决上述问题, 应该从匹配结果中选择具有最长网络前缀的路由, 这叫做最长前缀匹配.</p>
<h4 id="使用二叉线索查找路由表"><a href="#使用二叉线索查找路由表" class="headerlink" title="使用二叉线索查找路由表"></a>使用二叉线索查找路由表</h4><p>使用CIDR后, 由于要查找最长前缀匹配, 使路由表的查找过程变得更加复杂.为了更有效的查找, 通常是把无分类编址的路由表存放在一种层次的数据结构中, 然后,自上而下进行查找.这里最常用的是二叉线索.为了提高二叉线索的查找速度,可以使用压缩技术.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.360doc.com/content/10/0205/11/276520_15184122.shtml" target="_blank" rel="external">http://www.360doc.com/content/10/0205/11/276520_15184122.shtml</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IP地址分类]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>分类</li>
<li>特殊IP地址</li>
<li>共有IP地址</li>
<li>私有IP地址</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<ul>
<li>IP地址是连接在因特网上的主机的唯一标识, 通过特定的IP地址能找到被该IP地址标识的主机.例如:我们的家地址可以看作一个IP地址, 通过这个地址,可以找到我们,也就是主机.</li>
<li>在TCP/IP协议中, IP地址是以二进制数字形式出现, 共32Bit, 1Bit就是二进制中的1位, 由于二进制的形式不适合人们阅读.因此换用一种”点分十进制法”表示IP地址.</li>
<li>例如:<br><br>点分十进制: 192.168.1.1<br><br>二进制: 11000000.10101000.00000001.00000001</li>
</ul>
<blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></blockquote>
<table>
<thead>
<tr>
<th></th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
<th>8 Bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class A</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class B</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
<td>HOST</td>
</tr>
<tr>
<td>Class C</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>NETWORK</td>
<td>HOST</td>
</tr>
<tr>
<td>Class D</td>
<td>多播</td>
</tr>
<tr>
<td>Class E</td>
<td>科研用</td>
</tr>
</tbody>
</table>
<h4 id="Class-A"><a href="#Class-A" class="headerlink" title="Class A"></a>Class A</h4><ul>
<li>A类地址的第一个8 Bit 表示网络位, 且<code>网络位的第一个Bit为0</code>, 1-7Bit表示网络标识,格式为:0XXXXXXXX.</li>
<li>后3个8 Bit 表示主机位.</li>
<li>A类地址的网络范围:00000001~01111111, 用十进制表示: 1.0.0.0到126.0.0.0,一共有126个网络.</li>
<li>主机标识为2的24次幂-2个(去掉全0和全1的地址), 全0的主机号字段表示该IP地址是”本机”连接到的单个网络地址,而1的主机号表示该网络上的所有主机.每个网络可容纳的主机数为16777214个.</li>
<li>A类地址支持巨型网络,一般分给有大量主机的网络使用.</li>
</ul>
<h4 id="Class-B"><a href="#Class-B" class="headerlink" title="Class B"></a>Class B</h4><ul>
<li>B类地址的前两个8 Bit表示网络标位, 且网络位的前两个Bit总是10, 即格式为: 10XXXXXX XXXXXXXX.</li>
<li>B类地址可指派的网络数为: 2的14次幂-1, -1的原因是128.0.0.0是不指派的.</li>
<li>后两个8 Bit表示主机位.</li>
<li>B类的每个网络可容纳的主机数是2的16次幂-2, 即65534.</li>
</ul>
<h4 id="Class-C"><a href="#Class-C" class="headerlink" title="Class C"></a>Class C</h4><ul>
<li>C类地址的前3个字节表示网路号, 且开头必须为<code>110</code>, 可以指派的最小网络地址为:192.0.1.0, 指派的网络范围为2的21次幂-1, -1的原因是192.0.0.0是不指派的.</li>
<li>每个C类地址可容纳的主机数为:2的8次幂-2.</li>
</ul>
<blockquote>
<h3 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h3></blockquote>
<h4 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h4><ul>
<li>它表示所有不清楚的主机和目的网络.</li>
<li>不清楚的是意思是本机路由表中没有指定如何到达.</li>
<li>如果在网络设置中设置了缺省网关, 那么系统会自动生成一个目的地址为0.0.0.0的缺省路由,所有不清楚的目的网络和主机都会被送到这里.</li>
</ul>
<h4 id="255-255-255-255"><a href="#255-255-255-255" class="headerlink" title="255.255.255.255"></a>255.255.255.255</h4><ul>
<li>对本机来说, 这个地址指本网段内的所有主机. 这个地址不能被路由器所转发.</li>
</ul>
<h4 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h4><ul>
<li>A类网络中的127是一个保留地址, 用于网络软件测试和本机进程间的通信.</li>
<li>无论什么程序, 只要发送了该地址的数据, 就会被立刻发送回本机.</li>
<li>127网络号的分组不能出现在网络传输上.</li>
</ul>
<h4 id="局域网内的IP"><a href="#局域网内的IP" class="headerlink" title="局域网内的IP"></a>局域网内的IP</h4><ul>
<li>当主机号的全为0时,表示一个网络本身.</li>
<li>当主机号全为1时, 表示网络中的全部主机.</li>
<li>网络号代表一个网络本身, 同时也是一个网段的第一个地址. 广播地址是网段的最后一个地址,这两个地址是不能配在主机上的.</li>
</ul>
<blockquote>
<h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3></blockquote>
<ul>
<li>属于非注册地址, 专门为组织机构(学校,企业)内部使用, 简单来说私有地址不能直接上网.</li>
<li>私有IP的范围:<ul>
<li>A类私有IP地址: 10.0.0.0~10.255.255.255</li>
<li>B类私有IP地址: 172.16.0.0~172.31.255.255</li>
<li>C类私有地址: 192.168.0.0~192.168.255.255</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="公有IP"><a href="#公有IP" class="headerlink" title="公有IP"></a>公有IP</h3></blockquote>
<ul>
<li>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Internet NIC提出申请的组织机构。通过它直接访问因特网，它是广域网范围内的。</li>
</ul>
<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45337405" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45337405</a></li>
<li><a href="http://blog.csdn.net/txx9010/article/details/7712438" target="_blank" rel="external">http://blog.csdn.net/txx9010/article/details/7712438</a></li>
<li><a href="https://www.zhihu.com/question/27714563" target="_blank" rel="external">https://www.zhihu.com/question/27714563</a></li>
<li><a href="http://blog.csdn.net/tennysonsky/article/details/45226275" target="_blank" rel="external">http://blog.csdn.net/tennysonsky/article/details/45226275</a></li>
<li>计算机网络(谢希仁)</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重拾Dagger2]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/Dagger2%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>最近项目没什么bug,也没什么新的需求, 闲得有点慌(其实一直很闲…), 既然那么闲, 那就重新深入学习Dagger2吧. 之前虽然有学过Dagger2, 但是并没研究其中的原理, 用起来总感觉很不踏实, 于是借此机会研究了一波Dagger2, 并准备分为三篇来讲, 分别为: 使用篇, 原理篇和组织篇. 本篇的目的就指在介绍Dagger2</p>
<h3 id="Dagger2是什么"><a href="#Dagger2是什么" class="headerlink" title="Dagger2是什么?"></a>Dagger2是什么?</h3><p>Dagger2是之前由Square公司开源的Dagger的分支, 它运行在Android或者Java上的编译时注入依赖的框架, 关于什么是依赖注入,这里就不多说啦</p>
<h3 id="为什么要使用Dagger2"><a href="#为什么要使用Dagger2" class="headerlink" title="为什么要使用Dagger2"></a>为什么要使用Dagger2</h3><p>回想一下, 在我们的项目中, 什么代码是有用的? 什么代码是没什么用但我们必须要写的? 这个问题真的值得思考.举个例子, 平常我们实现网络请求的功能, 我们为了解耦, 会写一堆工厂类将网络请求的各个组件连接起来, 在这个场景中,我们真正关注的是网络请求, 而那些将网络请求连接起来的工厂类我们其实对它并不感兴趣, 它只是我们实现网络请求的一个工具而已. 面对这样的问题, Dagger利用依赖注入的模式来替代工厂类, 将我们从编写一堆的工厂类中解放出来,从而让我们把精力放在我们感兴趣的代码</p>
<h3 id="使用Dagger2的好处"><a href="#使用Dagger2的好处" class="headerlink" title="使用Dagger2的好处"></a>使用Dagger2的好处</h3><p>利用Dagger2, 能让我们从一堆的引用模板代码中解放出来, 将更多的精力放在业务需求上; 由于Dagger2会帮我们自动生成需要依赖的代码, 这能极大的减少我们的工作量. 更有趣的是:Dagger2帮我们管理依被赖对象的生命周期, 比如使用Singleton注解就能实现单例, 不过这个单例实现是有条件的, 通过Dagger2管理被依赖的对象能让我们的项目结构更清晰</p>
<h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>接下来, 我会写一下系列的Dagger2文章</p>
<blockquote>
<p><a href="https://cristianoro7.github.io/2017/03/29/%E9%87%8D%E6%8B%BEDagger2-%E4%BD%BF%E7%94%A8Dagger2/">重拾Dagger2-使用Dagger2</a><br><a href="https://cristianoro7.github.io/2017/03/30/%E9%87%8D%E6%8B%BEDagger2-%E7%90%86%E8%A7%A3Dagger2/">重拾Dagger2-理解Dagger2</a><br><a href="https://cristianoro7.github.io/2017/03/30/%E9%87%8D%E6%8B%BEDagger2-%E7%BB%84%E7%BB%87/">重拾Dagger2-组织依赖注入</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重拾Dagger2-组织]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E7%BB%84%E7%BB%87/</url>
      <content type="html"><![CDATA[<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在<a href="https://cristianoro7.github.io/2017/03/30/%E9%87%8D%E6%8B%BEDagger2-%E7%90%86%E8%A7%A3Dagger2/">上一篇</a>中, 我们从源码的角度分析了Dagger的工作原理, 在这一篇中, 我们来重点讲解Dagger2依赖组织的方式, 在讲解之前, 我们先来理解Component dependencies和SubComponent</p>
<h3 id="Component-dependencies-VS-SubComponent"><a href="#Component-dependencies-VS-SubComponent" class="headerlink" title="Component dependencies VS SubComponent"></a>Component dependencies VS SubComponent</h3><p>为了提高一个Component中代码的复用度, 我们可以利用 Component dependencies 和 SubComponent来获取Component中的依赖, 那么这两种方式有什么区别?</p>
<h4 id="Component-dependencies"><a href="#Component-dependencies" class="headerlink" title="Component dependencies"></a>Component dependencies</h4><p>我们还是用前两篇中的Demo来讲解, 首先我们定义一个AppComponent和AppModule, 并且在AppModule提供一个Student的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;AppModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Application <span class="title">providesApp</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Application application;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppModule</span><span class="params">(Application application)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.application = application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Application <span class="title">providesApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们有另外一个StudentComponent和StudentModule, 其中StudentModule需要Student实例, 由于我们在AppModule已经提供了Student实例, 我们可以在StudentComponent中定义dependencies, 这样就可以实现复用Student实例了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PerActivity</span></div><div class="line"><span class="meta">@Component</span>(dependencies = AppComponent.class, modules = StudentModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@PerActivity</span></div><div class="line">    <span class="function">Data <span class="title">providesData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是Component dependencies的使用</p>
<h4 id="SubComponent"><a href="#SubComponent" class="headerlink" title="SubComponent"></a>SubComponent</h4><p>SubComponent也可以实现Component的代码复用, 我们具体来看看怎么使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;AppModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">StudentComponent <span class="title">getComponent</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function">Application <span class="title">providesApp</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//    Student providesSyudent();</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PerActivity</span></div><div class="line"><span class="meta">@Subcomponent</span>(modules = StudentModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别?"></a>两者区别?</h4><p>既然两者都可以实现Component代码的复用, 那么他们的区别的是什么?</p>
<ul>
<li>Component dependencies方式的代码复用, 父Component必须显式暴露依赖给 dependencies的Component, 如上面的AppComponent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Student <span class="title">providesStudent</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>显式暴露了Student依赖给dependencies的Component, 而对于SubComponent不用显式暴露, 直接在父Component定义一个返回SubComponent的方法, 并在对应的类标注SubComponent注解</p>
<ul>
<li>从设计的角度来看, SubComponent是为了让两个Component更具有内聚性. 而Component dependencies则是让两个Component彼此独立</li>
</ul>
<h3 id="源码读解"><a href="#源码读解" class="headerlink" title="源码读解"></a>源码读解</h3><p>为什么 Component dependencies方式必须要显式暴露? 且听我道来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">providesApp</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> providesApplicationProvider.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">providesSyudent</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> providesStudentProvider.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面两个方法是AppComponent具体实现类的重写的两个方法, 在AppComponent暴露方法的主要目的是在对应的实现类提供依赖, 而在依赖于AppComponent的StudentComponent中,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Student&gt; providesSyudentProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Provider&lt;Data&gt; providesDataProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesSyudentProvider =</div><div class="line">        <span class="keyword">new</span> dagger.internal.Factory&lt;Student&gt;() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> AppComponent appComponent = builder.appComponent;</div><div class="line"></div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">                appComponent.providesSyudent(),</div><div class="line">                <span class="string">"Cannot return null from a non-@Nullable component method"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesDataProvider =</div><div class="line">        DoubleCheck.provider(StudentModule_ProvidesDataFactory.create(builder.studentModule));</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(providesSyudentProvider, providesDataProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> StudentModule studentModule;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AppComponent appComponent;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (studentModule == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (appComponent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(AppComponent.class.getCanonicalName() + <span class="string">" must be set"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">studentModule</span><span class="params">(StudentModule studentModule)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.studentModule = Preconditions.checkNotNull(studentModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">appComponent</span><span class="params">(AppComponent appComponent)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.appComponent = Preconditions.checkNotNull(appComponent);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看看内部类Builder中, 有AppComponent成员变量, 因为我们依赖了AppComponent, 所以在创建StudentComponent的实例时, Builder强制要求我们调用 appComponent(AppComponent)方法时把StudentComponent依赖的AppComponent实例传递进来, 接下来, Student实例会通过传递进来的appComponent实例, 进行赋值</p>
<p>我们来看看SubComponent为什么不用显式暴露</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComponentImpl</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StudentModule studentModule;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Provider&lt;Data&gt; providesDataProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StudentComponentImpl</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">    initialize();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesDataProvider =</div><div class="line">        DoubleCheck.provider(StudentModule_ProvidesDataFactory.create(studentModule));</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(</div><div class="line">            DaggerAppComponent.<span class="keyword">this</span>.providesStudentProvider, providesDataProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的StudentComponentImpl是StudentComponent具体实现类, 它是AppComponent实现类的内部类, 这样要实现复用就不用显式暴露接口了, 利用内部类的特性直接访问</p>
<p>经过我们上面分析, 我们也可以回答设计的区别了,  因为SubComponent对应的实现类会作为父Component的内部类, 这样两个Component的内聚性也就增强了, 而dependencies则会生成两个对应的分开的两个类, 通过暴露接口和传递实例进行沟通, 从而达到两个Component独立分离的目的</p>
<h3 id="两者的使用场景"><a href="#两者的使用场景" class="headerlink" title="两者的使用场景"></a>两者的使用场景</h3><ul>
<li>如果你想让两个Component的内聚性更强, 你应该用SubComponent</li>
<li>如果你想让两个Component彼此独立分离, 你应该用dependencies</li>
</ul>
<h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><h4 id="利用Singleton标注AppComponent"><a href="#利用Singleton标注AppComponent" class="headerlink" title="利用Singleton标注AppComponent"></a>利用Singleton标注AppComponent</h4><p>Singleton实现单例必须保证Component只会被初始化一次, 那么我们可以把需要定义成单例的类都定义在AppModule, 并且在AppComponent暴露对应单例给依赖的Component, 并在Application初始化AppComponent, 这样就保证了AppComponent只初始化一次</p>
<h4 id="自定义Scope标注Activity"><a href="#自定义Scope标注Activity" class="headerlink" title="自定义Scope标注Activity"></a>自定义Scope标注Activity</h4><p>为了更好的组织项目结构, 我们可以定义PerAc(名字随意)注解, 标注基类ActivityComponent并且依赖与AppComponent, 接下来, 每个Activity可以定义对应的XXActivityComponent, 都让每个XXXActivity继承基类ActivityComponent, 并且依赖于AppComponent</p>
<h4 id="SubComponent-1"><a href="#SubComponent-1" class="headerlink" title="SubComponent"></a>SubComponent</h4><p>我们的Activity可以能会有Fragment, 那Fragment对应的Component是要依赖于AppComponent还是做为对应ActivityComponent的SubComponent?<br>由于Fragment是包含在Activity中的, 更好的做法是将FragmentComponent作为对应的ActivtyComponent的SubComponent</p>
<h3 id="告别Dagger2"><a href="#告别Dagger2" class="headerlink" title="告别Dagger2"></a>告别Dagger2</h3><p>写了三篇Dagger2的文章, 总算对Dagger2了解多了, 现在用得了很踏实.  所以该暂时告别Dagger2的学习了, 不过, 最后我还准备了一个Dagger2的使用的Demo, 这个Demo准备用MVP + Dagger2 + RxJava实现一个知乎日报, 嘻嘻, 如果你喜欢的话, 手抖给个star咯,</p>
<p>Demo在项目地址的RxJava+MVP+Dagger2分支中</p>
<p><a href="https://github.com/cristianoro7/Daily/tree/RxJava+MVP+Dagger2" target="_blank" rel="external">项目地址</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p><a href="https://guides.codepath.com/android/Dependency-Injection-with-Dagger-2#setup" target="_blank" rel="external">https://guides.codepath.com/android/Dependency-Injection-with-Dagger-2#setup</a><br><a href="http://jellybeanssir.blogspot.jp/2015/05/component-dependency-vs-submodules-in.html" target="_blank" rel="external">http://jellybeanssir.blogspot.jp/2015/05/component-dependency-vs-submodules-in.html</a><br><a href="http://stackoverflow.com/questions/29587130/dagger-2-subcomponents-vs-component-dependencies" target="_blank" rel="external">http://stackoverflow.com/questions/29587130/dagger-2-subcomponents-vs-component-dependencies</a><br><a href="https://google.github.io/dagger/users-guide.html" target="_blank" rel="external">https://google.github.io/dagger/users-guide.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重拾Dagger2-理解Dagger2]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E7%90%86%E8%A7%A3Dagger2/</url>
      <content type="html"><![CDATA[<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><a href="https://cristianoro7.github.io/2017/03/29/%E9%87%8D%E6%8B%BEDagger2-%E4%BD%BF%E7%94%A8Dagger2/">上一篇</a>我们主要介绍了如何用Dagger2在Android应用中进行依赖注入, 在这一篇中, 我们主要来理解Dagger2中的原理, 毕竟知己知彼后才用得踏实</p>
<h3 id="API关系"><a href="#API关系" class="headerlink" title="API关系"></a>API关系</h3><ul>
<li>Provider<t>: provider<t>是一个接口, 它的作用是包装被依赖的类</t></t></li>
<li>Factory<t>: 继承于Provider, 作用是创建依赖的对应实例</t></li>
<li>MembersInjector<t>:  也是一个接口, 作用是将依赖注入到需要依赖的地方, 其中的T为注入地点</t></li>
</ul>
<p>理解上面的接口的作用后, 我们来理解Dagger2不会太难啦</p>
<h3 id="Inject注入解读"><a href="#Inject注入解读" class="headerlink" title="Inject注入解读"></a>Inject注入解读</h3><p>我们利用上篇中的Demo来解读Inject注入. Dagger2生成的源代码可以在app目录下的build目录中的apt目录找到.</p>
<p>既然Component是注入依赖的桥梁, 那我们就先来看看它是怎么出入的吧. 回顾一下上次我们在StudentActivity注入的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">    DaggerStudentComponent.builder()</div><div class="line">            .build()</div><div class="line">            .inject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">    Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在onCreate方法中进行了注入, 仔细看注入的代码, 我们可以大概猜测是用Builder模式创建StudentComponenet实例, 既然这样, 我们先进入build()方法研究一波</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在build()中, 实例了DaggerStudentComponent, DaggerStudentComponent是StudentComponent具体的实现类, 我们顺着思路, 进入DaggerStudentComponent看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(Student_Factory.create());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>上面的代码中, 主要调用了initialize方法进行初始化, 在其中, 创建了StudentActivity_MemberInjector实例</p>
<p>还记得我们在StudentActivity中调用了build()方法后, 还会调用inject(this)吗?  调用该方法后, 会调用我们刚刚在initialize方法中创建出来的StudentActivity_MemberInjector的injectMembers(activity), 我们看看对应的方法都干了什么事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(StudentActivity instance)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</div><div class="line">  &#125;</div><div class="line">  instance.mStudent = mStudentProvider.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到上面的代码, 有没有一种熟悉的感觉? instance.mStudent正是我们在StudentActivity中需要注入的成员变量, 而给它赋值的又是谁?</p>
<p>mStudentProvider变量是我们实例化StudentActivity_MemberInjector传进来的, 我们自然进入对应的类探究探究</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student_Factory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Student_Factory INSTANCE = <span class="keyword">new</span> Student_Factory();</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Student&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> INSTANCE;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StudentFactory中的get()方法返回了对应的Student实例</p>
<p>分析到这里, Inject注解已经完成了一次依赖注入, 因此我们来串联一下各个步骤吧</p>
<p>首先提供依赖的是Stduent_Factory类, 它是Factory的具体实现类, 给我们需要依赖的地方new出实例,</p>
<p>StudentActivity_MemberInjector, 它是MemberInjector的具体实现类, 它在injectMembers(StudentActivity中, 拿到我们需要依赖的实例, 并给被Inject标注的成员变量赋值, 而实例的来源正是我们刚才分析的</p>
<p>讲到这里, 我想大家都对Component的作用加深了, Component就像一座桥梁, 将提供依赖的工厂类, 和需要依赖的地方联系起来, 从而完成依赖注入</p>
<h3 id="Moduley依赖注入"><a href="#Moduley依赖注入" class="headerlink" title="Moduley依赖注入"></a>Moduley依赖注入</h3><p>Module依赖注入的讲解, 我们也是用Student的Demo来讲解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">    DaggerStudentComponent.builder()</div><div class="line">            .build()</div><div class="line">            .inject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">    Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们按照来老套路, 进入build()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> StudentModule studentModule;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (studentModule == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Builder <span class="title">studentModule</span><span class="params">(StudentModule studentModule)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.studentModule = Preconditions.checkNotNull(studentModule);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是熟悉的套路, 只不过这次多了一个StduentModule变量, StudentModule是我们事先写好用于提供依赖的类, 我们可以看到在build()方法中, 实例化了StudentModule和DaggerStduentComponent, 又是老套路, 进入DaggerStduentComponent看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Student&gt; providesStudentProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.providesStudentProvider =</div><div class="line">        StudentModule_ProvidesStudentFactory.create(builder.studentModule);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(providesStudentProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>跟我们上面分析Inject的代码差不多, 不同的是这次在initialize中创建的是StudentModule_ProvidesStudentFactory, 接下来的流程和Inject都差不多, 我们现在主要来分析StudentModule_providesStduentFactory怎么拿到依赖实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">      <span class="keyword">module</span>.providesStudent(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在get()方法中, 利用module.providesStudent() 提供实例, 这个方法是我们事先在StudentModule中定义的</p>
<p>总体来说Module依赖注入的方式和Inject差不多, 只是提供依赖时生成的工厂方法不一样而已</p>
<p>分析完了Inject和Module注入, 我们来看看Name注解是如何解决依赖迷失,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student1"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student2"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">proStudnet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们make一下工程, 再到app-&gt;build-&gt;source-&gt;apt-&gt;debug目录下, 可以看看这两个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule_ProvidesStudentFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StudentModule <span class="keyword">module</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StudentModule_ProvidesStudentFactory</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> <span class="keyword">module</span> != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">        <span class="keyword">module</span>.providesStudent(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Student&gt; <span class="title">create</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StudentModule_ProvidesStudentFactory(<span class="keyword">module</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Proxies &#123;<span class="doctag">@link</span> StudentModule#providesStudent()&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">proxyProvidesStudent</span><span class="params">(StudentModule instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance.providesStudent();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule_ProStudnetFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StudentModule <span class="keyword">module</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StudentModule_ProStudnetFactory</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> <span class="keyword">module</span> != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">        <span class="keyword">module</span>.proStudnet(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Student&gt; <span class="title">create</span><span class="params">(StudentModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StudentModule_ProStudnetFactory(<span class="keyword">module</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Proxies &#123;<span class="doctag">@link</span> StudentModule#proStudnet()&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">proxyProStudnet</span><span class="params">(StudentModule instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance.proStudnet();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信聪明的你,已经知道Name注解解决的思路. 很简单, 就是每一个方法对应生成一个工厂类提供对应的依赖, 至于类的命名规则我就不说啦, 自己看</p>
<h3 id="迷之Scope"><a href="#迷之Scope" class="headerlink" title="迷之Scope"></a>迷之Scope</h3><p>Scope是作用域, Singleton是被Scope包装的一个注解, 在Dagger2中如果被Singleton标注的话, 该依赖可以在一定程度上实现单例 只不过这种单例是需要条件的, 这个条件是什么? 代码是最好的老师, 我们还是来看看被Sington标注的依赖会生成什么代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerStudentComponent</span> <span class="keyword">implements</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Student&gt; proStudnetProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;StudentActivity&gt; studentActivityMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerStudentComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.proStudnetProvider =</div><div class="line">        DoubleCheck.provider(StudentModule_ProStudnetFactory.create(builder.studentModule));</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.studentActivityMembersInjector =</div><div class="line">        StudentActivity_MembersInjector.create(proStudnetProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span> </span>&#123;</div><div class="line">    studentActivityMembersInjector.injectMembers(activity);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> StudentModule studentModule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> StudentComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (studentModule == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.studentModule = <span class="keyword">new</span> StudentModule();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerStudentComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">studentModule</span><span class="params">(StudentModule studentModule)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.studentModule = Preconditions.checkNotNull(studentModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仔细观察上面代码, 我们看到唯一不同的provider赋值的时候, 多了一个DoubleCheck, 其中的奥妙</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">T</span>&gt;, <span class="title">Lazy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNINITIALIZED = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Provider&lt;T&gt; provider;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Object instance = UNINITIALIZED;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">(Provider&lt;T&gt; provider)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> provider != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.provider = provider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// cast only happens when result comes from the provider</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Object result = instance;</div><div class="line">    <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        result = instance;</div><div class="line">        <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">          result = provider.get();</div><div class="line">          <span class="comment">/* Get the current instance and test to see if the call to provider.get() has resulted</span></div><div class="line">           * in a recursive call.  If it returns the same instance, we'll allow it, but if the</div><div class="line">           * instances differ, throw. */</div><div class="line">          Object currentInstance = instance;</div><div class="line">          <span class="keyword">if</span> (currentInstance != UNINITIALIZED &amp;&amp; currentInstance != result) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Scoped provider was invoked recursively returning "</span></div><div class="line">                + <span class="string">"different results: "</span> + currentInstance + <span class="string">" &amp; "</span> + result + <span class="string">". This is likely "</span></div><div class="line">                + <span class="string">"due to a circular dependency."</span>);</div><div class="line">          &#125;</div><div class="line">          instance = result;</div><div class="line">          <span class="comment">/* Null out the reference to the provider. We are never going to need it again, so we</span></div><div class="line">           * can make it eligible for GC. */</div><div class="line">          provider = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns a &#123;<span class="doctag">@link</span> Provider&#125; that caches the value from the given delegate provider. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Provider&lt;T&gt; <span class="title">provider</span><span class="params">(Provider&lt;T&gt; delegate)</span> </span>&#123;</div><div class="line">    checkNotNull(delegate);</div><div class="line">    <span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> DoubleCheck) &#123;</div><div class="line">      <span class="comment">/* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped</span></div><div class="line">       * binding, we shouldn't cache the value again. */</div><div class="line">      <span class="keyword">return</span> delegate;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DoubleCheck&lt;T&gt;(delegate);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns a &#123;<span class="doctag">@link</span> Lazy&#125; that caches the value from the given provider. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Lazy&lt;T&gt; <span class="title">lazy</span><span class="params">(Provider&lt;T&gt; provider)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (provider <span class="keyword">instanceof</span> Lazy) &#123;</div><div class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">      <span class="keyword">final</span> Lazy&lt;T&gt; lazy = (Lazy&lt;T&gt;) provider;</div><div class="line">      <span class="comment">// Avoids memoizing a value that is already memoized.</span></div><div class="line">      <span class="comment">// <span class="doctag">NOTE:</span> There is a pathological case where Provider&lt;P&gt; may implement Lazy&lt;L&gt;, but P and L</span></div><div class="line">      <span class="comment">// are different types using covariant return on get(). Right now this is used with</span></div><div class="line">      <span class="comment">// DoubleCheck&lt;T&gt; exclusively, which is implemented such that P and L are always</span></div><div class="line">      <span class="comment">// the same, so it will be fine for that case.</span></div><div class="line">      <span class="keyword">return</span> lazy;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DoubleCheck&lt;T&gt;(checkNotNull(provider));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DoubleCheck是Provider的具体体现类, 在provider方法中, 返回了DoubleCheck实例, DoubleCheck的精华主要是在get方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">SuppressWarnings(<span class="string">"unchecked"</span>) <span class="comment">// cast only happens when result comes from the provider</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  Object result = instance;</div><div class="line">  <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      result = instance;</div><div class="line">      <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">        result = provider.get();</div><div class="line">        <span class="comment">/* Get the current instance and test to see if the call to provider.get() has resulted</span></div><div class="line">         * in a recursive call.  If it returns the same instance, we'll allow it, but if the</div><div class="line">         * instances differ, throw. */</div><div class="line">        Object currentInstance = instance;</div><div class="line">        <span class="keyword">if</span> (currentInstance != UNINITIALIZED &amp;&amp; currentInstance != result) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Scoped provider was invoked recursively returning "</span></div><div class="line">              + <span class="string">"different results: "</span> + currentInstance + <span class="string">" &amp; "</span> + result + <span class="string">". This is likely "</span></div><div class="line">              + <span class="string">"due to a circular dependency."</span>);</div><div class="line">        &#125;</div><div class="line">        instance = result;</div><div class="line">        <span class="comment">/* Null out the reference to the provider. We are never going to need it again, so we</span></div><div class="line">         * can make it eligible for GC. */</div><div class="line">        provider = <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (T) result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法中的代码有没有很熟悉?? 咋一看, 我还以为是DCL单例模式, 其实不然, 它是利用DCL的思想, 将依赖对象缓存到DoubleCheck中, 下次提供依赖时, 直接从缓存拿. 说了这么多, 你可能会问: 究竟Singleton怎么实现单例啊? 其实这个问题在get()方法中已经体现出来了</p>
<p>既然后一次提供依赖时会从缓存拿, 那我们只要保证DoubleCheck之会被初始化一次, 那么每次用到这个依赖时, 都是从缓存拿的, 也就变相的实现了单例, 为了保证DoubleCheck只会被初始化一次, 我们可以在Appication中实现注入, 那就保证整个应用中DoubleCheck只会被初始化一次.  </p>
<p>细心的你可能会注意到, 有被Singleton标注的依赖都会在Component实例中被DoubleCheck包装, 而没有的依赖则会直接被工厂类创建出来. 那么我们可以自定义一个注解PerActivity, 那么它就可以管理依赖对象在需要注入依赖的Activity实现局部单例</p>
<p>看完Dagger2这个实现单例的思想瞬间膜拜.</p>
<p>总体来说, Scope注解还是很有用的, 利用它我们可以有效的管理依赖对象的生命周期, 让我们不用再去写一堆的单例类</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本篇主要讲了Dagger注入依赖的原理, 重点讲了Scope实现单例的原理, 对于Component和SubComponent我想留到下一篇讲, 下篇我会针对Component和SubComponent来分析, 并利用他们有效的组织依赖注入. 今天就到这里啦…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重拾Dagger2-使用Dagger2]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E9%87%8D%E6%8B%BEDagger2-%E4%BD%BF%E7%94%A8Dagger2/</url>
      <content type="html"><![CDATA[<h2 id="常用注解解释"><a href="#常用注解解释" class="headerlink" title="常用注解解释"></a>常用注解解释</h2><p>在学习Dagger2之前,我们最好就是将Dagger2中的常用的注解的含义捋清一遍, 这样上手Dagger2就不会显得那么难,所以下面我准备介绍Dagger2中常用的注解的含义,这些注解包括</p>
<ul>
<li>Inject</li>
<li>Provides</li>
<li>Module</li>
<li>Component</li>
<li>Qualifiers</li>
<li>Scope</li>
</ul>
<h3 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h3><p>Inject的中文意思是注射,在Dagger2中它在不同的地方代表不同的含义．当Inject是标注在类的属性域时,那么它代表Dagger会给我们提供被Inject标注的实例; 当Inject标注的是类的构造方法时,它表示Dagger会帮我们实例化这个类并提供给需要这个类的地方</p>
<h3 id="Provides"><a href="#Provides" class="headerlink" title="Provides"></a>Provides</h3><p>Provides提供一种通过注解方法来提供依赖的机制, 它主要是用来弥补Inject的缺陷, 如果类的方法被Provides标注后, 它相当于告诉Dagger, 通过方法可以提供项目中所需要的依赖</p>
<h3 id="Modue"><a href="#Modue" class="headerlink" title="Modue"></a>Modue</h3><p>Module的作用是来管理被Provides标注的方法, 有点类似工厂</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>通过上面介绍的三个注解, 我们可以归纳出: 在Dagger2中可以有两种方式进行依赖注入,一种是利用Inject来进行注解, 另一种是通过在被Module标注的类中,将Provides注解标注方法,并在方法中返回需要被依赖的实例．Component的作用就是将被依赖的对象提供给需要依赖的对象，也就是说Component其实就是连接依赖方和被依赖方的桥梁,只有通过Component，依赖方和被依赖方才能联系在一起．</p>
<h3 id="Qualifiers"><a href="#Qualifiers" class="headerlink" title="Qualifiers"></a>Qualifiers</h3><p>在Dagger2中, 如果在被Module标注的类中, 有两个方法都是返回相同类型的实例时，此时，Dagger并不知道要调用哪个方法才好，因此Dagger干脆就不干了，直接在编译时就报错．这种情况叫做依赖注入迷失．而Qualifiers的作用正是来解决依赖注入迷失的问题, 具体的看代码咯</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>Scope代表作用域，Scope常常用于管理依赖对象的生命周期，Dagger中提供的Singleton注解被Scope标注，用于实现单例，不过这个单例的实现跟我们平时所写的单例不一样,具体的我会在下篇中讲到．</p>
<p>其实只看上面的几个注解可能会让你很蒙, 那下面我们来结合代码开始来使用Dagger2</p>
<h3 id="Inject注入"><a href="#Inject注入" class="headerlink" title="Inject注入"></a>Inject注入</h3><p>我们先来看看如何用Inject实现注入</p>
<ul>
<li><p>首先新建Student类, 并在其构造方法添加Inject注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"xiaoming"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接着新建StudentComponent, 用于连接依赖方和被依赖方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>; <span class="comment">//表示需要被注入依赖的地方为StudentActivity</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后实现依赖注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">        DaggerStudentComponent.builder()</div><div class="line">                .build()</div><div class="line">                .inject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">        Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>经过这三个步骤我们就完成了一次 依赖注入．在StudentActivity中，我们需要用到Stduent类，因此我们用Inject注解标注Student属性域, 接着在Student的构造函数上标注Inject，表示当需要Student依赖时，Dagger会帮我们实例化出Student类, 现在依赖方和被依赖方都有了，就剩下最后连接彼此，而连接彼此需要在StudentComponent中添加需要注入到哪个类中,在这个例子中, 需要被注入的类是StudentActivity, 最后调用inject方法实现注入．</p>
<h3 id="Inject注入的缺陷"><a href="#Inject注入的缺陷" class="headerlink" title="Inject注入的缺陷"></a>Inject注入的缺陷</h3><p>使用Inject注入有一个缺点: 当我们需要注入的是第三方库的类时，我们无法直接在其构造方法标注Inject，最简单的解决办法就是新建一个类并继承我们需要的第三方库中的类．但是这种解决方法太笨拙了，如果我们需要注入的类有很多的话，我们岂不是要新建很多类? 显然这种体力活不适合程序员．关于这个问题，Dagger早就帮我们考虑好了，Dagger针对这种情况给我们提供了Provides注解来解决这种问题．</p>
<h3 id="Provides实现注入"><a href="#Provides实现注入" class="headerlink" title="Provides实现注入"></a>Provides实现注入</h3><p>我们来看看Provides怎么解决Inject的缺陷</p>
<ul>
<li><p>首先定义StudentModule类, 用来管理提供的依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接着在StudentComponent中添加moule = StudentModule.class, 相当于告诉Dagger. 可以到该类中找依赖</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(modules = StudentModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(StudentActivity activity)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>最后连接彼此</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">        DaggerStudentComponent.builder()</div><div class="line">                .studentModule(<span class="keyword">new</span> StudentModule())</div><div class="line">                .build();</div><div class="line"></div><div class="line">        <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">        Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在StudentModule中, 我们通过Provides标注告诉Dagger, 这个方法返回的实例是被依赖的, 而我们在StudentComponent中添加modules = StudentModule.class, 相当于在StduentComponent注入StudentActivity时, 让Dagger去StudentModule类中找提供依赖的方法．</li>
</ul>
<h3 id="Qualifiers解决依赖迷失"><a href="#Qualifiers解决依赖迷失" class="headerlink" title="Qualifiers解决依赖迷失"></a>Qualifiers解决依赖迷失</h3><p>如果我们在StudentModule中提供两个返回类型相同的实例方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">proStudnet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码在编译时会报错, 原因是我们之前讲的依赖注入迷失. 为了解决这个问题, 我们可以用Qualifiers注解. Dagger2中已经给我们提供了一个Named注解, Named注解是被Qualifiers修饰的一个注解, 使用Named就可以解决依赖迷失, 我们先来看看Named源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Named &#123;</div><div class="line">    <span class="comment">/** The name. */</span></div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以根据我们业务需求仿照Named来自定义注解. 看完Named注解,  我们来瞧瞧怎么用, 由于使用比较简单, 我只贴代码咯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student1"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">providesStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student2"</span>)</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Student <span class="title">proStudnet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student1"</span>)</div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent;</div><div class="line"></div><div class="line">    <span class="meta">@Named</span>(<span class="string">"student2"</span>)</div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Student mStudent2;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">//连接依赖方和被依赖方</span></div><div class="line">        DaggerStudentComponent.builder()</div><div class="line">                .studentModule(<span class="keyword">new</span> StudentModule())</div><div class="line">                .build();</div><div class="line"></div><div class="line">        <span class="comment">//之后就可以mStudent实例了</span></div><div class="line">        Toast.makeText(<span class="keyword">this</span>, mStudent.name(), Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="依赖注入优先级"><a href="#依赖注入优先级" class="headerlink" title="依赖注入优先级"></a>依赖注入优先级</h3><p>试想一下, 如果同时提供了Inject和Module依赖注入, Dagger会优先注入哪个? 答案是 Module. 在依赖注入时, Dagger会优先从Module查找, 如果没的话, 在从Inject构造函数, 两者只有其中一者会提供依赖</p>
<h3 id="Dagger依赖查找策略"><a href="#Dagger依赖查找策略" class="headerlink" title="Dagger依赖查找策略"></a>Dagger依赖查找策略</h3><p>当我们需要依赖注入时, Dagger会采取以下策略来查找依赖:</p>
<ol>
<li>首先从Module中查找, 如果查找得到的并且Provides方法中没有参数的话, 直接提供依赖返回, 如果Module中查找不到时, 如果被依赖的对象的构造函数有Inject标注并且没有参数的话, 提供依赖并且返回</li>
<li>步骤一的都是在Provides标注的方法或Inject标注的构造函数中没有参数的情况下,  现在讨论有参数的情况</li>
<li>首先先从Module查找, 如果Module有提供对应的依赖并且方法中有参数, Dagger会按照先Module后Inject的顺序去查找参数的依赖, 然后重复步骤一递归查找, 查不到的话再从Inject查, 如果Inject标注的构造函数有参数的话, 也是递归步骤1进行查找</li>
</ol>
<h3 id="Scope实现生命周期的管理"><a href="#Scope实现生命周期的管理" class="headerlink" title="Scope实现生命周期的管理"></a>Scope实现生命周期的管理</h3><p>Dagger中采用Scope来实现被依赖对象的生命周期管理, 最直接的一个标注就是Singleton. 被Singleton标注的对象可以实现单例, 但是这种单例跟我们平常写的不太一样, 具体实现下篇我会分析, 现在我们把重点放在怎么使用上</p>
<ul>
<li>首先在Component标注Singleton</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;AppModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>接着在Modue中的Provides方法中标注Singleton</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Application application;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppModule</span><span class="params">(Application application)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.application = application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Application <span class="title">providesApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> application;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">Student <span class="title">providesData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>最后在Application实现注入就可以实现单例了, 具体代码不贴了.</li>
<li>Scope由于比较特殊, 关于它的实现原理和具体是使用, 准备留到源码篇和组织篇的时候再分析</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果Modue中的Provides有标注作用域的话, 必须和对应的Component标注的作用域相同, 不然编译时会报错.</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本篇文章主要讲Dagger2的最基本的使用, 目的指在熟悉Dagger2中的基本使用, 注入规则以及需要注意的地方, 关于Dagger2的实现原理和Dagger的组织方式, 准备开两篇来讲..嗯…今天就到这里了哈</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类文件结构]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>Class类文件结构<ul>
<li>特殊字符串概念</li>
<li>魔数与Class文件的版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引,父类索引与接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="类文件结构-1"><a href="#类文件结构-1" class="headerlink" title="类文件结构"></a>类文件结构</h3></blockquote>
<p>Class文件结构只有两种数据类型:无符号和表.<br>无符号数属于基本的数据类型,以u1,u2,u4,u8分别代表1个字节,2个字节,4个字节和8个字节的无符号数,它用来描述数字,索引引用,数量值或者UTF-8编码构成字符串值.<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型,所有表都习惯以”_info” 结尾<br>整个class文件本质就是一张表:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count</td>
</tr>
<tr>
<td>u2</td>
<td>access_flag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interface</td>
<td>interface_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h4 id="特殊字符串的概念"><a href="#特殊字符串的概念" class="headerlink" title="特殊字符串的概念"></a>特殊字符串的概念</h4><ul>
<li>全限定名: 把类的全名中的”.”替换成”/“,最后再加上”;”</li>
<li>简单名称: 没有类型和参数修饰的方法或者字段名称.</li>
<li>方法和字段的描述符: 描述符的作用是用来描述字段的数据类型,方法参数列表和返回值.</li>
<li>描述符标识字符含义:</li>
</ul>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>特殊类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型</td>
</tr>
</tbody>
</table>
<h4 id="魔数与Class文件版本"><a href="#魔数与Class文件版本" class="headerlink" title="魔数与Class文件版本"></a>魔数与Class文件版本</h4><ul>
<li>每个Class文件的头4个字节称为魔数,它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件.</li>
<li>紧接魔数后面的4个字节储存的是Class文件的版本号: 第5,6个字节是此版本号(Minor Version),第7和第8个字节是主版本号.JDK的版本号是从45开始的.</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li>常量池可以理解为Class文件之中的资源仓库,它同时是Class文件关联其他项目最多的数据类型,也是占用Class文件空间最大的数据项目之一.</li>
<li>由于常量池中的常量是不固定的,所以需要在常量池入口放置一项u2类型的数据,代表常量池容量计数值.</li>
<li>常量池中主要储存两大类常量:字面量和符号引用．字面量比较接近Java语言层面的常量概念,如字符串,声明为final常量值等. 而符号引用则属于编译原理方面的概念,主要包含了下面三类常量:<ul>
<li>类和接口的全称限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>常量池的项目类型:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或者方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标识方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeType_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><ul>
<li>access_flags用于识别一些类或者接口层次的访问信息.例如:这个class是类还是接口;是否定义为public类型;是否定义为abstract类型等. 具体标记:</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final,只有类可设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令心新语意</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstact类型, 对于接口或者抽象类来说, 这个标志为真,其他值为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识这个类并非由用户代码生成</td>
</tr>
<tr>
<td>ACC_ANNOTION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这个一个枚举</td>
</tr>
</tbody>
</table>
<h4 id="类索引-父类索引与接口索引集合"><a href="#类索引-父类索引与接口索引集合" class="headerlink" title="类索引,父类索引与接口索引集合"></a>类索引,父类索引与接口索引集合</h4><ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名</li>
<li>接口索引集合用于描述这个类实现了哪些接口</li>
</ul>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><ul>
<li>字段表集合用于描述接口或者类中声明的变量.</li>
<li>字段包括类级变量和实例级变量, 但不包括在方法内的局部变量</li>
</ul>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><ul>
<li>方法表结构:</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<ul>
<li>方法表集合结构跟字段表结构大致相同</li>
<li>如果父类分方法没有被子类重写,方法表集合中就不会出现父类方法的信息.</li>
</ul>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><ul>
<li>虚拟机规范预定义的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量值</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类,方法表字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EbcloseingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性,这个属性用于标识这个类所在的外围方法.</td>
</tr>
<tr>
<td>InnerClasses</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令对应的关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部属性描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性, 供新的类型检查验证器检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配.</td>
</tr>
<tr>
<td>Signature</td>
<td>类,方法表,字段表</td>
</tr>
</tbody>
</table>
<p>待续…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java内存分配与回收策略]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>对象优先在Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活对象将进入老年代</li>
<li>动态对象年龄判定</li>
<li>空间分配担保</li>
</ul>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><ul>
<li>大多数情况下, 对象主要分配在新生代的Eden区上.</li>
<li>当Eden区没有足够的空间进行分配时, 虚拟机将进行一次 Minor GC</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul>
<li>大对象指的是需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串以及数组.</li>
<li>经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”他们.</li>
</ul>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul>
<li>为了采用分代收集来管理内存,虚拟机给每个对象定义了一个对象年龄计数器.</li>
<li>如果对象在Eden出生并经历第一次Minor GC后仍然存活, 并且能被Survivor容纳的话,将被移动到Survivor,并且年龄就增加1岁.</li>
<li>当它的年龄增加到一定程度(默认为15岁),就会被晋升到老年代.</li>
</ul>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ul>
<li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或者等于该年龄的对象就可以直接进入老年代,无需等到MaxTenuringThreshold2中要求的年龄.</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>如果老年代最大可用连续空间大于新生代所有对象总空间,那么Minor GC可以确保是安全的.</li>
<li>如果老年代最大可用连续空间不大于新生代所有对象总空间的话且老年代最大可用连续空间是大于历次晋升到老年代对象的平均大小,那么Minor GC是冒险的.</li>
<li>如果老年代最大可用连续空间不大于新生代所有对象总空间的话且老年代最大可用连续空间是小于历次晋升到老年代对象的平均大小,那这时要进行一次Full GC.</li>
</ul>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java垃圾回收器]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>判定对象存活<ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
<li>再谈引用<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
</li>
<li>生存还是死亡</li>
<li>回收方法区</li>
</ul>
</li>
<li>垃圾收集算法<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-整理算法</li>
<li>分代收集算法</li>
</ul>
</li>
<li>HotSpot的算法实现<ul>
<li>枚举根节点</li>
<li>安全点</li>
<li>安全区域</li>
</ul>
</li>
<li>垃圾收集器<ul>
<li>Serial收集器</li>
<li>ParNew收集器</li>
<li>Parallel收集器</li>
<li>Serial Old 收集器</li>
<li>Parallel Old 收集器</li>
<li>CMS收集器</li>
<li>G1收集器</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="判定对象的存活"><a href="#判定对象的存活" class="headerlink" title="判定对象的存活"></a>判定对象的存活</h3></blockquote>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li>给一个对象添加一个计数器,每当有一处地方引用对象时,计数器值加1; 当引用失效时, 计数器值就减1; 任何时刻计数器为0对象就是不可能再被使用的.</li>
<li>引用计数算法最大的缺点就是很难解决对象之间的循环引用.</li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li>通过一系列的称为 “ GC Root “ 对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链, 当一个对象到” GC Root “ 没有任何引用链相连时,则证明此对象是不可用的.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收-1.png" alt=""></p>
<ul>
<li>在Java语言中, 可作为 GC Root的对象包括下面几种:<ul>
<li>虚拟机栈(栈帧中的本地变量表)引用的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(一般指Native方法)引用的对象</li>
</ul>
</li>
</ul>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK1.2后,Java对引用进行了扩充,将引用分强引用, 软引用, 弱引用和虚引用四种.</p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>程序代码中普遍存在的,类似”Object obj = new Object()”这类引用, 只要强引用存在的话, 对象就永远不会被回收</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用用于描述一些还有用但是又是非必需对象. 对于软引用关联着的对象, 在系统将要发生内存溢出之前, 将会把对象列进回收范围之中进行第二次回收, 如果这次回收没有足够的内存,才抛出内存溢出异常</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用也是用来描述非必需对象, 但是它的强度比软引用弱一些, 被弱引用关联的对象只能生存到下次垃圾收集发生之前.<br>当垃圾收集器工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象.</p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><ul>
<li>它是最弱的一种引用关系.</li>
<li>一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象的实例</li>
<li>一个对象虚引用关联的目的就是这个对象被收集器回收时收到一个系统通知.</li>
</ul>
<h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><ul>
<li>一个对象需要至少经历两次标记才能宣告死亡</li>
<li>如果一个对象在可达性分析后发现没有GC Roots相连接时, 那么它第一次被标记并且进行一次筛选, 筛选的条件是该对象是否有必要执行finalize()方法.当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过一次, 这两种情况虚拟机都是视为不必要调用.</li>
<li>如果这个对象被判定为需要执行finalize()方法的话, 那么对象将会被放置在F-Queue队列中, 稍后虚拟机会启动一个优先级较低的线程去执行它.</li>
<li>执行finalize()方法时, 虚拟机并不会等待它执行结束, 这样做是为了避免执行finalize()方法缓慢或者发生死循环. 这样可能会导致F-Queue队列中的对象处于永久等待中,甚至导致整个内存回收崩溃.</li>
<li>finalize()方法是对象逃脱死亡命运的最后一次机会, GC会在finalize()中进行第二次小规模的标记, 如果对象被第二次标记后,那么就宣告了一个对象的死亡.</li>
</ul>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><ul>
<li>方法区的回收主要回收两部分内容:废弃常量和无用的类.</li>
<li>回收废弃常量和回收Java堆很相似.例如: 字符串 “abc” 已经进入了常量池, 但是当前系统没有一个String对象叫做”abc”的,也就是没有任何String对象引用常量池之中的”abc”, 如果这时候发生内存回收, 而且必要的话, 这个”abc”会被清除出常量池.常量池中的其他类(接口),方法,字段的符号引用也与此类似.</li>
<li>一个类被视为无用的条件<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用, 无法通过反射获取类的方法.</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3></blockquote>
<h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><ul>
<li>首先标记出所有需要回收的对象,在完成标记后统一回收所有被标记的对象</li>
<li>不足的地方<ul>
<li>效率问题, 标记和清除的两个过程效率都不是很高</li>
<li>空间问题, 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时, 无法找到足够的连续内存而不得不提前触发另外一次GC</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/mark-sweep.png" alt=""></p>
<h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><ul>
<li>复制算法是为了解决标记-清除算法的效率问题而出现的</li>
<li>它将内存按照容量划分为相等的两块, 每次只用其中一块.当这一块内存快用完了, 就将还存活的对象复制到另一块内存,然后再把空间一次清理掉</li>
<li>复制算法的代价是将内存空间缩小为原来的一半.</li>
<li>HotSpot虚拟机默认Eden和Survivor的大小比例为8:1,只有10%的内存空间会被浪费.</li>
<li>如果另外一块Survivor空间没有足够的内存放上次新生代存活下来的对象时, 这些对象将直接通过分配担保直接进入老年代.</li>
</ul>
<h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><ul>
<li>标记过程仍然与”标记-清除”算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉边界以外的内存.</li>
</ul>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ul>
<li>一般将Java堆划分为新生代和老年代, 这样就可以根据各个年代的特点采用适当的算法</li>
<li>在新生代中,每次GC时,都发现大量对象死去, 只有少量对象存活, 那就选用复制算法.</li>
<li>而老年代中因为对象的存活率高, 没有额外的空间进行担保,就必须使用”标记-清除”或者”标记-整理”.</li>
</ul>
<blockquote>
<h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3></blockquote>
<p>在HotSpot上实现垃圾收集算法, 必须对算法的执行效率必须经过严格的考证, 才能保证虚拟机的执行效率</p>
<h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><ul>
<li>目前主流的Java虚拟机使用的都是标准式的GC, 所以当执行系统停顿下来时, 并不需要一个不漏的检查完所有执行上下文和全局的引用位置, 虚拟机使用一组称为OopMap的数据结构来得知哪些地方存放着对象引用.</li>
</ul>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><ul>
<li>HotSpot没有为每条指令都生成OopMap, 它只是在特定的位置记录了”这些信息”,这些位置被称为安全点(Safepoint),即程序并非在所有的地方都能停下来GC, 只有在安全点时才能停下来</li>
<li>安全点的选定基本上是以程序”是否具有让程序长时间执行的特征”为标准选定.”长时间执行”的最明显特征就是指令序列复用,例如方法调用,循环引用,循环跳转,异常跳转等,具有这些功能的指令才会生成Safepoint.</li>
<li>对于Safepoint,需要考虑的另外一个问题是如何让GC发生时停止所有线程时,所有线程都跑到安全点. 这里有两种方案可供选择:抢先式中断和主动式中断.<ul>
<li>抢先式中断不需要线程的配合,在发生GC时,首先把所有线程全部中断,如果发现有线程中断在不安全点上, 就恢复线程,让它跑到安全点上. 现在几乎没有虚拟机是这样实现的.</li>
<li>主动式的中断是思想是当GC需要中断线程的时候, 不直接对线程进行操作,仅仅简单的设置一个标志, 各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己挂起.轮询标志的地方和安全点是重合的.</li>
</ul>
</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><ul>
<li>安全区域是指在一段代码之中,引用关系不会发生变化. 在这个区域中的任何地方开始GC都是安全的.</li>
<li>线程执行到Safe Region时, 首先标识自己已经进入安全区域, 那样当在这段时间内JVM要发起GC时,就不用管已经标识为安全区域状态的线程. 在线程要离开安全区域时, 它首先要检查系统是否已经完成了根节点枚举, 如果完成了,就继续执行,否则它就要等到收到安全离开的信号为止.</li>
</ul>
<blockquote>
<h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></blockquote>
<p><img src="/uploads/jvm/垃圾回收/垃圾回收器.png" alt=""></p>
<h4 id="Senial-收集器"><a href="#Senial-收集器" class="headerlink" title="Senial 收集器"></a>Senial 收集器</h4><ul>
<li>Serial 收集器在进行垃圾回收时,必须暂停其他所有的工作线程,直到它收集结束</li>
<li>下面是Serial/Serial Old收集器的工作过程</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/Serial.png" alt=""></p>
<ul>
<li>优点: 简单高效, 对于限定单CPU的环境来说, Serial收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率.</li>
<li>使用场景: 在用户的桌面应用场景中, 分配给虚拟机管理内存不会很大, 停顿时间可控制在10几到100多毫秒, 只要不频繁发生,这点的停顿还是可以接受的. 因此, Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择.</li>
</ul>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><ul>
<li>ParNew收集器其实就是多线程版本的Serial收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParNew.png" alt=""></p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul>
<li>Parallel Scavenge收集器的特点是它关注点与其他的收集器不同, CMS等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间, 而Parallel Scavenge收集器目的是达到一个可控的吞吐量, 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值.</li>
<li>停顿时间越短越适合需要与用户交互的程序; 高吞吐量则可以高效率地利用CPU时间, 尽快完成程序运算任务, 主要适合后台运算而不需要太多交互的任务.</li>
</ul>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ul>
<li>Serial Old是Serial收集器的老年代版本, 使用”标记-整理”算法, 这个收集器的主要意义是给Client模式下的虚拟机使用.</li>
<li>如果在Server模式下, 那么它有两大主要用途:<ul>
<li>在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用.</li>
<li>作为CMS收集器的后备预案,在并发收集发生 Concurrent Mode Failure时使用.</li>
</ul>
</li>
</ul>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ul>
<li>Parallel Old 是Parallel Scavenge收集器的老年代版本.</li>
<li>在吞吐量以及CPU资源敏感的场合, 都可以优先考虑Parallel Scavenge加Parallel Old收集器.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/ParallelOld.png" alt=""></p>
<h4 id="CMS-收集器-Concurrent-Mark-Sweep"><a href="#CMS-收集器-Concurrent-Mark-Sweep" class="headerlink" title="CMS 收集器(Concurrent Mark Sweep)"></a>CMS 收集器(Concurrent Mark Sweep)</h4><ul>
<li>CMS收集器是一种以获取最短回收停顿时间为目标的收集器.</li>
<li>CMS 收集器是基于 “标记-清除”算法实现,整个过程分为4个步骤:<ul>
<li>初始化标记:仅仅只是标记一下GC Roots能直接关联到的对象, 速度很快.</li>
<li>并发标记:进行GC Roots Tracing的过程.</li>
<li>重新标记:为了修正并发标记期间因用户程序继续运行导致标记产生变动的那一部分对象标记记录,这个阶段的停顿时间一般会比初始化阶段稍微长一些,但远比并发标记的时间短.</li>
<li>并发清除: 清除标记.</li>
</ul>
</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/cms.png" alt=""></p>
<ul>
<li><p>CMS 收集器明显的3个缺点:</p>
<ul>
<li><p>CMS收集器对CPU资源非常敏感,在并发阶段,它虽然不会导致用户线程中断,但是会因为占用了一部分CPU资源而导致应用程序变慢,总吞吐量降低.</p>
</li>
<li><p>CMS 收集器无法处理浮动垃圾, 可能出现 “Concurrent Mode Failure”失败而导致另一次Full GC产生.浮动垃圾指的是CMS并发清理阶段用户线程还在运行, 这期间产生的垃圾.CMS无法像其他收集器那样等到老年代几乎完全被填满时才收集, 需要预留一部分的空间提供并发手机时的程序运行使用.要是CMS运行期间预留内存无法满足程序需要, 就会出现一次”Concurrent Mode Failure” 失败. 这时虚拟机启动后备预案: 临时启动Serial Old收集器重新进行老年代垃圾收集, 这样停顿的时间就变长了.</p>
</li>
<li><p>由于CMS是基于”标记-清除”算法实现的, 这意味者收集结束时会有大量空间碎片产生.空间碎片太多会给大对象分配带来麻烦,因为无法找到连续足够大的空间来给大对象分配,这就不得不提前触发一次Full GC 了. 为了解决这个问题, CMS收集器提供了一个 -XX:+UseCMSCompactAtFullCollection开关参数,用户在CMS收集器顶不住要进行FullGC时开启内存碎片的合并过程整理, 内存整理无法并发进行, 因此会导致停顿时间变长. 虚拟机设计者还提供了一个参数-XX:CMSFullGCsBeforeCompaction,这个参数用于设置执行多少次不压缩的Full GC后,就跟着一次带压缩的(默认值为0,表示每次进入Full GC时都进行碎片整理)</p>
</li>
</ul>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器的使命是在未来替代掉JDK1.5之中发布的CMS收集器,与其他收集器相比, G1具有的特点:</p>
<h5 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h5><p>G1能充分利用多CPU,多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World停顿时间</p>
<h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>虽然G1可以不需要其他收集器配合就能管理整个GC堆,但他能够采用不同的方式去处理新创建的对象和已经存活一段时间,熬过多次GC的旧对象以获取更好的收集效果.</p>
<h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><p>G1整体来看是基于”标记-整理”算法实现的收集器,从局部上来看是基于复制算法实现的.</p>
<h5 id="可预测的停顿"><a href="#可预测的停顿" class="headerlink" title="可预测的停顿"></a>可预测的停顿</h5><p>G1除了要求停顿降低外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒.</p>
<p>如果不计算维护Remembered Set操作,G1收集器的运作大致可划分为以下几个步骤:</p>
<ul>
<li>初始标记:标记一下GC Roots能直接关联到的对象并且修改TAMS的值,让下一阶段用户程序并发运行时,能在正确可用的Region中创建新对象,这个阶段需要停顿线程,但耗时很短.</li>
<li>并发标记:从GC Roots开始对堆中对象进行可达性分析, 找出存活对象,这阶段耗时很长,但可用与用户程序并发运行.</li>
<li>最终标记:为了修正在并发标记期间因用户程序继续运作而导致标记产生百年动的那一部分标记记录,虚拟机将这阶段对象变化记录在线程Remembered Set中, 这阶段需要停顿线程,但可并行执行.</li>
<li>筛选回收:首先对各个Region的回收价值和成本进行排行,根据用户所期望的GC停顿时间来指定回收计划.</li>
</ul>
<p><img src="/uploads/jvm/垃圾回收/g1.png" alt=""></p>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java内存区域]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>运行时数据区<ul>
<li>程序计数器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>运行时常量池</li>
</ul>
</li>
<li>HotSpot虚拟机对象探秘<ul>
<li>对象的创建</li>
<li>对象的内存布局</li>
<li>对象的访问定位</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3></blockquote>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。</li>
<li>如果线程正在执行的是一个Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的方法是一个Native方法的，程序计数器的值为空（Undefine）。</li>
<li>此内存是JVM唯一没有规定任何OOM的区域。</li>
<li>程序计数器是线程私有的。</li>
</ul>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul>
<li>Java虚拟机栈是线程私有的。</li>
<li>Java虚拟机栈指的是Java方法执行的内存模型：即每个方法在执行时都会创建一个栈帧（是方法运行时的一种基础数据结构），用于储存局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机栈的入栈到出栈的过程。</li>
<li>局部变量表存放了编译期可知的各种基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用和returnAddress类型。</li>
<li>局部变量表所需的内存空间在编译期完成分配，在方法运行期间不会改变局部变量表的大小。</li>
<li>该区域会出现两种异常情况<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>发挥的作用与Java虚拟机栈相似。</li>
<li>与Java虚拟机栈之间的区别：<ul>
<li>虚拟机栈执行Java方法服务。</li>
<li>本地方法栈执行本地方法服务。</li>
</ul>
</li>
</ul>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul>
<li>Java虚拟机所管理的内存区域最大的一块。</li>
<li>Java堆是在虚拟机启动时被创建，是被所有线程所共享。</li>
<li>一般情况下：几乎所有对象实例和数组都是在堆上分配。</li>
<li>如果在堆上没有内存完成实例分配，并且堆也无法扩展时，将抛出OOM。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>与堆一样，是各个线程共享的内存区域。</li>
<li>它用于储存已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。</li>
<li>当方法区无法满足内存分配的需求时，将会抛出OOM。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>运行时常量池是方法区的一部分。</li>
<li>当运行时常量池无法满足内存分配的需求时，将会抛出OOM。</li>
</ul>
<hr>
<blockquote>
<h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3></blockquote>
<h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ul>
<li>当虚拟机遇到new指令时，首先检查这个指令的参数是否在常量池能定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析，初始化过。如果没有的话，那必须先进行类的加载</li>
<li>类加载检查通过后，虚拟机将为新生对象分配内存。</li>
<li>对象所需的内存在类加载完成后便完全可确定，为对象分配空间相当于在堆上划分一块内存出来。</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作在TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码可以不赋值就直接使用。程序能访问到这些字段的零值。</li>
<li>接下来，虚拟机需要为对象进行必要的设置。例如：类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：对象头，实例数据和对齐填充。</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><ul>
<li>对象头包含两部分信息。</li>
<li>第一部分用于储存对象自身的运行时数据，如哈希码，GC分代年龄，锁标记，线程持有的锁，偏向线程ID，偏向时间戳等。考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构，它会根据对象的状态来复用自己的内存空间。例如，在32位的虚拟机中，如果对象处于未被锁定的情况下，那么 Mark Word的32bit空间中的25bit用于储存哈希码，4bit用于储存对象分代年龄，2bit储存锁标志，1bit固定为0。</li>
<li>对象头的另一部分为类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><ul>
<li>实例数据为对象真正储存的有效信息，也是代码中所定义的各种类型的字段内容。</li>
</ul>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><ul>
<li>对齐填充不是必然存在的，它仅仅起到占位符的作用</li>
<li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。</li>
<li>对象头部分正好是8字节的倍数。</li>
<li>当实例数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ul>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><ul>
<li>Java程序需要通过栈上的reference数据来操作堆上的具体对象。</li>
<li>目前主流的访问方法有使用句柄和直接指针两种。</li>
<li>如果使用句柄的话，那么Java堆将划分出一块内存来作为句柄池，reference中储存的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</li>
</ul>
<p><img src="/uploads/jvm/java内存区域/句柄指针.png" alt=""></p>
<ul>
<li><p>如果使用指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中储存的直接就是对象地址。<br><img src="/uploads/jvm/java内存区域/直接指针.png" alt=""></p>
</li>
<li><p>两种访问方式的优缺：</p>
<ul>
<li>使用句柄的最大好处就是reference中储存的是稳定的句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference不需要修改。</li>
<li>直接使用指针的最大好处就是速度更快，它节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考资料：《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java集合框架-LinkHashMap]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkHashMap/</url>
      <content type="html"><![CDATA[<p>上篇我们分析了<code>HashMap</code>, 知道了遍历<code>HashMap</code>时, 顺序是不能够保证的.如果遍历时需要顺序, 那么应该用<code>LinkedHashMap</code>, 也就是我们这次要来分析的另外一个集合类.</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fio5jh7fepj30lg0hkgm9.jpg" alt=""></p>
<p>从UML图来看, <code>LinkedHashMap</code>的继承于<code>HashMap</code>, 可见<code>LinkedHashMap</code>是基于<code>HashMap</code>来扩展的. 如果理解了<code>HashMap</code>的话, 那<code>LinkedHashMap</code>应该算是很简单了.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<ul>
<li><p><code>LinkedHashMap</code>是底层的数据结构是<code>HashMap</code>和<code>双向链表</code>. <code>LinkedHashMap</code>内部维护着一条双向链表, 在遍历<code>LinkedHashMap</code>时, 会遍历内部的链表, 这样就可以保证遍历的顺序是特定的.至于遍历的顺序, 有两种可选: 按照插入的顺序(默认); 按照访问的顺序(结点每次被访问时, 都会把结点移动到链表尾).</p>
</li>
<li><p>由于<code>LinkedHashMap</code>内部维护一条链表, 因此它在性能上要稍微逊色于<code>HashMap</code>.</p>
</li>
</ul>
<blockquote>
<h3 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * HashMap.Node subclass for normal LinkedHashMap entries.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>内部的Entry继承于<code>HashMap.Entry</code>, 并且加了两个成员变量, 用来记录前一个结点和后后一个结点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The head (eldest) of the doubly linked list.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The tail (youngest) of the doubly linked list.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</div></pre></td></tr></table></figure>
<p><code>head</code>为头结点, <code>tail</code>为尾结点. 分析到这里, 我们可以确认<code>LinkedHashMap</code>内部确实维护一条双向链表.</p>
<blockquote>
<h3 id="hock函数"><a href="#hock函数" class="headerlink" title="hock函数"></a>hock函数</h3></blockquote>
<p>还记得上次分析<code>HashMap</code>时,说过<code>HashMap</code>留给<code>LinkedHashMap</code>的三个hock函数吗? 不记得的话也没关系, 耐心看下面的分析就会想起来了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125; <span class="comment">//结点被访问后, LinkedHashMap回调的函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125; <span class="comment">//结点插入时, LinkedHashMap回调的函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125; <span class="comment">//结点被移除时, LinkedHashMap回调的函数</span></div></pre></td></tr></table></figure>
<p>上面三个hock函数定义在<code>HashMap</code>内部, 并且为空的函数.这三个函数是预留给<code>LinkedHashMap</code>用的. 当结点被访问, 插入和被移除时,<code>LinkedHashMap</code>回调的函数.</p>
<blockquote>
<h3 id="put-K-V-和afterNodeInsertion-boolean-evict"><a href="#put-K-V-和afterNodeInsertion-boolean-evict" class="headerlink" title="put(K, V)和afterNodeInsertion(boolean evict)"></a>put(K, V)和afterNodeInsertion(boolean evict)</h3></blockquote>
<p><code>LinkedHashMap</code>内部没有重写<code>put(K, V)</code>函数, 意味着它的话复用了<code>HashMap</code>的<code>put(K, V)</code>方法, 那…我们暂且回调<code>HashMap</code>吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict); <span class="comment">//回调函数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>put(K, V)</code>内部会调用<code>afterNodeInsertion(evict)</code>. 回到<code>LinkedHashMap</code>看看这个函数的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>这个函数的实现是为了移除比较<code>老</code>的元素(越<code>老</code>的元素会在链表的越前面).但是这个函数的默认实现总是不会移除<code>老</code>的元素. 因为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法一直返回false. 重写这个方法, 我们可以控制当<code>LinkedHashMap</code>内部的元素数量达到一定数量时, 移除比较老的元素.</p>
<p>前面说<code>LinkedHashMap</code>是可以根据插入的顺序进行遍历, 那么内部肯定在<code>put(K, V)</code>的时候, 会构造链表.那么构造的操作在哪里?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>重写了newNode(int, K, V, Node<v, k="">), 在其中写了构造链表的逻辑. 具体实现<code>linkNodeLast</code></v,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//如果为尾结点为空,证明链表为空, 直接将头结点和为结点指点新插入的结点</span></div><div class="line">        head = p;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//插入新结点</span></div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的逻辑为向双向链表中插入结点.</p>
<blockquote>
<h3 id="get-K-和afterNodeAccess-Node-e"><a href="#get-K-和afterNodeAccess-Node-e" class="headerlink" title="get(K)和afterNodeAccess(Node e)"></a>get(K)和afterNodeAccess(Node<k,v> e)</k,v></h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面我们说过, <code>LinkedHashMap</code>支持按照访问的顺序来遍历.而get(K)操作正是访问操作. 默认情况下, <code>LinkedHashMap</code>是按照插入顺序来遍历的, 因为字段<code>accessOrder</code>字段默认为<code>false</code>, 如果要支持按照访问顺序的话, 需要显示调用这个构造方法, 将<code>accessOrder</code>指定为<code>true</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor,</span></span></div><div class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们接着看看<code>afterNodeAccess</code>这个回调函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的逻辑为: 将访问的结点移动到链表的尾端.</p>
<p>至于<code>remove(K)</code>函数和<code>afterNodeRemoval(Node&lt;K,V&gt; e)</code>的关系和前面将的两个回调函数的思想一样. <code>remove(K)</code>内部会回调<code>afterNodeRemoval(Node&lt;K, V&gt; e)</code>函数, <code>afterNodeRemoval(Node&lt;K, V&gt; e)</code>会将结点从双向链表中移除.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<p>和<code>HashMap</code>一样, 内部有提供了三个视图(KeySet, ValueSet, set<entry<k, v="">), 因此, <code>LinkedHashMap</code>内部也有三个迭代器. 不同的是, <code>LinkedHashMap</code>迭代器的遍历顺序是有的. 下面我只分析<code>LinkedValueIterator</code>.</entry<k,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line"></div><div class="line">    LinkedHashIterator() &#123;</div><div class="line">        next = head;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        current = e;</div><div class="line">        next = e.after;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; p = current;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        K key = p.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedHashIterator</code>是<code>LinkedHashMap</code>内部迭代器的基类, 在构造函数将链表的头结点复制给 <code>next</code>, 然后<code>nextNode()</code>函数内, 顺序的访问之前构造好的链表.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着<code>LinkedValueIterator</code>继承了<code>LinkedHashIterator</code>, 提供了一个<code>next()</code>的方法.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><p><code>LinkedHashMap</code>是基于<code>HashMap</code>来实现的, 它和<code>HashMap</code>不同之处是: 遍历元素的时候的是有序的. 因为它内部维护了一个双向链表. 遍历的顺序可以有两种: 按照结点的插入顺序; 按照元素被访问的顺序.默认是按结点被插入的顺序.</p>
</li>
<li><p><code>LinkedHashMap</code>可以用来实现<code>LRU</code>缓存.</p>
</li>
<li><p>由于<code>LinkedHashMap</code>内部维护了一个双向链表, 因此, 在性能上要稍微逊色于<code>HashMap</code>.</p>
</li>
<li><p>如果对遍历元素的顺序是无要求的话, 应该使用<code>HashMap</code>, 反之应该使用<code>LinkedHashMap</code>.</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java集合框架-set家族]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set%E5%AE%B6%E6%97%8F/</url>
      <content type="html"><![CDATA[<p><code>Set</code>集合的最大特点是能够保证内部的元素唯一性. 这种特性是建立在<code>Map</code>的基础上的. 换句话说: <code>Set</code>通过组合的模式, 在<code>Map</code>的基础上扩展了一些特性. 由于<code>Set</code>是建立在<code>Map</code>的基础上的. 如果理解了<code>Map</code>的话, <code>Set</code>会很好理解. 接下来我们来看看<code>Set</code>家族的UML</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fizhykmqgzj30x10hwq3y.jpg" alt=""></p>
<p><code>Set</code>接口对应<code>Map</code>接口, 定义了<code>Set</code>的一些方法. <code>AbstractSet</code>对应<code>AbstractMap</code>, 为<code>Set</code>家族提供了一些默认的实现. <code>HashSet</code>通过组合<code>HashMap</code>并且利用<code>HashMap</code>的Key值的唯一性, 来保证内部元素的唯一性. <code>LinkedHashSet</code>通过组合<code>LinkedHashMap</code>, 使得Set内部的元素是有序的. 同种道理, <code>TreeSet</code>也是基于<code>TreeMap</code>来实现的.</p>
<blockquote>
<h2 id="Set家族"><a href="#Set家族" class="headerlink" title="Set家族"></a>Set家族</h2></blockquote>
<ul>
<li><code>HashSet</code></li>
<li><code>LinkedHashSet</code></li>
<li><code>TreeSet</code></li>
</ul>
<blockquote>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"></div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>前面说过<code>Set</code>家族都是通过组合<code>Map</code>家族来实现的. 从上面的字段, 可以看出<code>HashSet</code>是基于<code>HashMap</code>来实现的. 而<code>PRESENT</code>则是一个虚假的值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当向<code>HashSet</code>中添加元素时, 将元素作为map的key, 而value则是用一个虚假的值<code>PRESENT</code>. 由于<code>HashMap</code>中的Key是唯一的. 而<code>HashSet</code>中的元素是作为Key储存在<code>HashMap</code>中的.这样就保证了<code>HashSet</code>元素中没有重复的值.</p>
<blockquote>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3></blockquote>
<p><code>LinkedHashSet</code>继承于<code>HashSet</code>, 它对应<code>Map</code>家族的<code>LinkedHashMap</code>. 但是当你查看<code>LinkedHashSet</code>的时候, 可能会发现并没有<code>LinkedHashMap</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</div><div class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个构造函数是<code>HashSet</code>为<code>LinkedHashSet</code>预留的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.keySet().iterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>`LinkedHashSet</code>中还提供了一个迭代器接口, 迭代器遍历时是有序的遍历. 因为该迭代器是<code>LinkedHashMap</code>的一个实现.</p>
<blockquote>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3></blockquote>
<p><code>TreeSet</code>对应于<code>TreeMap</code>, <code>TreeSet</code>的实现思路跟前面两个<code>Set</code>差不多.. 这里不分析.</p>
<blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2></blockquote>
<p>到这里…不知不觉已经分析完了集合框架. 但是并没有包含并发的集合工具. 接下来准备看完并发后再来梳理并发集合工具.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java集合框架-TreeMap]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-TreeMap/</url>
      <content type="html"><![CDATA[<p>这次要介绍的<code>Map</code>跟之前介绍的<code>Map</code>有点不一样. 之前的<code>Map</code>, 例如: <code>HashMap</code>, <code>LinkedHashMap</code>都是基于散列技术. 而这次要介绍的<code>TreeMap</code>则不同, <code>TreeMap</code>是基于一种叫<code>红黑树</code>的数据结构. 接下来, 我们先看看<code>TreeMap</code>的UML图片</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fizax4c2efj30o60c2dgl.jpg" alt=""></p>
<p>跟之前介绍过的<code>Map</code>一样, <code>TreeMap</code>实现了<code>Cloneable</code>和<code>Serializable</code>, 因此它支持克隆(浅克隆)和序列化.</p>
<p><code>SortMap</code>这个接口提供了一些有序的视图, 比如: key有序视图. 实现该接口的数据结构表明其遍历Key或者Value的时候,是有序的. <code>NavigableMap</code>继承<code>SortMap</code>接口, 并提供了更为丰富的视图操作.</p>
<blockquote>
<h2 id="TreeMap特性"><a href="#TreeMap特性" class="headerlink" title="TreeMap特性"></a>TreeMap特性</h2></blockquote>
<p><code>TreeMap</code>是基于红黑树来实现的. 红黑树是一种自平衡的二叉查找树, 插入, 查找, 删除等操作的时间复杂度都是<code>O(logn)</code>. 由于红黑树也是一种二叉查找树, 因此, 遍历<code>Treemap</code>是有序的.</p>
<p><code>TreeMap</code>的结点的默认顺序是<code>Key</code>的自然顺序(<code>Key</code>必须实现<code>Comparator</code>). 当然, <code>TreeMap</code>内部也支持外部提供<code>Comparator</code>来指定结点的排列顺序.</p>
<p><code>TreeMap</code>的Key是不支持null的, 而Value则支持null.</p>
<p>在了解了<code>TreeMap</code>一些特性后, 我们接着来分析<code>TreeMap</code>常用的操作和它的迭代器.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<ul>
<li>常用操作</li>
<li>迭代器</li>
</ul>
<blockquote>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; left; <span class="comment">//左孩子</span></div><div class="line">        Entry&lt;K,V&gt; right; <span class="comment">//右孩子</span></div><div class="line">        Entry&lt;K,V&gt; parent; <span class="comment">//父结点</span></div><div class="line">        <span class="keyword">boolean</span> color = BLACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Entry</code>是红黑树的结点类型, 除了K和V外, 还包含了左孩子, 右孩子和父结点.</p>
<blockquote>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * The comparator used to maintain order in this tree map, or</div><div class="line">   * null if it uses the natural ordering of its keys.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@serial</span></div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器, 可以通过构造函数赋值</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//红黑树的根结点</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The number of entries in the tree</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">//红黑树中的结点数</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The number of structural modifications to the tree.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">//用于实现fast-fail机制</span></div></pre></td></tr></table></figure>
<blockquote>
<h4 id="put-K-V"><a href="#put-K-V" class="headerlink" title="put(K, V)"></a>put(K, V)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//如果没有根结点的话, 证明树是空的</span></div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">//有指定比较器的情况</span></div><div class="line">        do &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用默认的Key自然顺序插入结点</span></div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        do &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key); <span class="comment">//比较</span></div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>); <span class="comment">//找到合适的插入位置</span></div><div class="line">    &#125;</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    fixAfterInsertion(e); <span class="comment">//恢复红黑树的特性</span></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入操作分为两种情况:</p>
<ul>
<li>根结点为空(红黑树为空): 直接将新结点赋值给根结点</li>
<li>根结点不为空:如果有指定比较器的话, 使用比较器来新结点的父节点. 没有的话, 根据Key的自然顺序来找新结点的父结点.</li>
</ul>
<p>插入结点后, 可能会违背红黑树的特性, 因此, 每次插入后, 都需要进行一些操作来恢复红黑树的特性.</p>
<blockquote>
<h4 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get</code>操作是获取key对应的value. 方法中主要调用了<code>getEntry(key)</code>来获取结点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key); <span class="comment">//如果比较器不为空的话, 使用指定的比较器来比较</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">//不支持Key为null的操作</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">//循环比较查找, 如果比较结果是&lt;0的话, 向左子树查找, &gt;0的话向右子树查找, 知道等于.</span></div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据二叉查找树的特性, 先比较结点, 如果大于0, 则向右子树查找, 如果小于0, 则左子树查找, 直到找到等于的结点.<br>如果不存在的话, 返回 null;</p>
<blockquote>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key); <span class="comment">//获取结点</span></div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    V oldValue = p.value;</div><div class="line">    deleteEntry(p); <span class="comment">//从红黑树中删除结点, 并做恢复红黑树特性的操作</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>remove</code>操作分两步: 获取要删除的结点, 找得到的话, 从红黑树中删除, 并且做恢复红黑树的操作, 最后返回被删除的结点; 如果找不到结点, 返回null.</p>
<blockquote>
<h4 id="firstKey和firstEntry"><a href="#firstKey和firstEntry" class="headerlink" title="firstKey和firstEntry"></a>firstKey和firstEntry</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">firstKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> key(getFirstEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>firstKey</code>是获取最小的Key值. 主要实现是在<code>getFirstEntry()</code>中, key(Entry)只是提取Entry中的key.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) <span class="comment">//循环遍历左子树</span></div><div class="line">            p = p.left;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据二叉查找树的特性, 想要获取树的最小值, 只要一直遍历左子树, 就能得到.</p>
<p>firstEntry的实现跟firstKey差不多.  不同的是, firstEntry得到Entry后, 会被包装成一个不可改变的Entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> :</div><div class="line">        <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Entry</code>在这个方法中被包装成了一个不可改变Value的Entry, 我们来看看为什么不改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>setValue</code>是SimpleImmutableEntry中的方法, 只要调用了, 都会抛出一个异常, 因此不支持改变Value.</p>
<p>与<code>firstKey</code>和<code>firstValue</code>对应的有<code>lastKey</code>和<code>lastValue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">lastKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> key(getLastEntry());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exportEntry(getLastEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>操作的思想都差不多, lastXX是获取Key最大的结点. 因此, 在查找时会循环查找右子树.</p>
<blockquote>
<h4 id="NavigableMap接口"><a href="#NavigableMap接口" class="headerlink" title="NavigableMap接口"></a>NavigableMap接口</h4></blockquote>
<p>接着, 我们来看看<code>NavigableMap</code>接口中的一些实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回小于Key的最大结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回小于等于Key的最大结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">floorKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回大于等于该Key的最小结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">ceilingKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span></span>; <span class="comment">//返回大于该Key的最小结点</span></div><div class="line"></div><div class="line"><span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span>; <span class="comment">//删除最小的结点</span></div><div class="line"></div><div class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span>; <span class="comment">//删除最大的结点</span></div></pre></td></tr></table></figure>
<p>上面的接口是获取红黑树中, 指定的结点. 这些接口的实现的思路都差不多, 这里只分析<code>lowerEntry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exportEntry(getLowerEntry(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的实现在<code>getLowerEntry</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; <span class="comment">//如果大于0,</span></div><div class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</div><div class="line">                p = p.right;  <span class="comment">//查找右子树,</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p; <span class="comment">//返回小于Key的最大值</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果&lt;=0</span></div><div class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</div><div class="line">                p = p.left; <span class="comment">//查找左子树</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//回退父结点查找</span></div><div class="line">                Entry&lt;K,V&gt; parent = p.parent;</div><div class="line">                Entry&lt;K,V&gt; ch = p;</div><div class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</div><div class="line">                    ch = parent;</div><div class="line">                    parent = parent.parent;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> parent;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面都是在二叉查找树中查找符合一定条件的结点的算法.没什么好说的.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    Entry&lt;K,V&gt; lastReturned;</div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line"></div><div class="line">    PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = <span class="keyword">null</span>;</div><div class="line">        next = first;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        next = successor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">prevEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        next = predecessor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="comment">// deleted entries are replaced by their successors</span></div><div class="line">        <span class="keyword">if</span> (lastReturned.left != <span class="keyword">null</span> &amp;&amp; lastReturned.right != <span class="keyword">null</span>)</div><div class="line">            next = lastReturned;</div><div class="line">        deleteEntry(lastReturned);</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PrivateEntryIterator</code>是<code>TreeMap</code>的基类迭代器, 提供了默认的一些操作.</p>
<p><code>nextEntry()</code>是获取下一个结点.主要获取的实现是在<code>successor</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123; <span class="comment">//如果右子树不为空的话,</span></div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) <span class="comment">//循环查找左子树, 找到大于t的最小结点</span></div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//为空的话, 回退到父结点, 查找大于t的最小结点</span></div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>successor(Entry)</code>的作用是, 在红黑树中找出比给定结点大的最小结点. <code>PrivateEntryIterator</code>构造函数传入的是红黑树中最小的结点. 所以循环调用<code>successor</code>的话, 得到的结点是按Key排序的, 换句话说: 遍历调用nextEntry函数, 得到的Entry顺序是按Key升序的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">prevEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = next;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    next = predecessor(e);</div><div class="line">    lastReturned = e;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理, <code>preEntry</code>是得到前一个结点.</p>
<p>接着我们来看看<code>PrivateEntryIterator</code>的子类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">     ValueIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">         <span class="keyword">super</span>(first);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> nextEntry().value;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">     KeyIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">         <span class="keyword">super</span>(first);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> nextEntry().key;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>KeyIterator</code> 继承了<code>PrivateEntryIterator</code>, 并提供了next()方法, 用于获取下一个key. <code>ValueIterator</code>也是同样的操作. 我们再来看看, 构造函数传入的是什么结点?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Iterator&lt;K&gt; <span class="title">keyIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(getFirstEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面分析过, <code>getFirstEntry()</code>是获取key最小的一个结点. 所以 循环调用<code>KeyIterator</code>的<code>next()</code>, 得到的是按Key升序的序列.</p>
<p>那有没有按Key降序的迭代器? 有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingKeyIterator</span> <span class="keyword">extends</span> <span class="title">PrivateEntryIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">        DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">            <span class="keyword">super</span>(first);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> prevEntry().key;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            deleteEntry(lastReturned);</div><div class="line">            lastReturned = <span class="keyword">null</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>DescendingKeyIterator</code>为反向Key的迭代器, 使用该迭代器遍历的时候, 得到的序列是Key的降序序列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Iterator&lt;K&gt; <span class="title">descendingKeyIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingKeyIterator(getLastEntry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次传入<code>DescendingKeyIterator</code>构造函数的Entry都是最大的结点.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><code>TreeMap</code>就讲到这里了. <code>Map</code>家族大概在这里就讲完了. 下篇会将<code>Set</code>家族, <code>Set</code>集合是基于<code>Map</code>来操作的, 如果理解<code>Map</code>集合后, <code>Set</code>会很好理解.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java集合框架-WeakHashMap, IdentityHashMap 和 HashTable]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-WeakHashMap,%20IdentityHashMap%20%E5%92%8C%20HashTable/</url>
      <content type="html"><![CDATA[<blockquote>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2></blockquote>
<p><code>WeakHashMap</code>总体实现和<code>HashMap</code>差不多, 不同的时, <code>WeakHashMap</code>中的Key是弱引用类型, <code>WeakHashMap</code>内部的Key是会被自动回收的. 另外需要关注的是, <code>WeakHashMap</code>并没有向<code>HashMap</code>那样, 在1.8做了优化.</p>
<blockquote>
<h3 id="弱引用Key"><a href="#弱引用Key" class="headerlink" title="弱引用Key"></a>弱引用Key</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    V value;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates new entry.</div><div class="line">     */</div><div class="line">    Entry(Object key, V value,</div><div class="line">          ReferenceQueue&lt;Object&gt; queue,</div><div class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(key, queue);</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.hash  = hash;</div><div class="line">        <span class="keyword">this</span>.next  = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (K) WeakHashMap.unmaskNull(get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">        K k1 = getKey();</div><div class="line">        Object k2 = e.getKey();</div><div class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">            V v1 = getValue();</div><div class="line">            Object v2 = e.getValue();</div><div class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        K k = getKey();</div><div class="line">        V v = getValue();</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>内部的结点是继承弱引用类型, 并且指定了一个<code>ReferenceQueue&lt;Object&gt;</code>, 当Key被GC回收时, Key对应的对象会被添加到<code>ReferenceQueue&lt;Object&gt;</code>这个队列中. 这个队列是定义在<code>WeakHashMap</code>内部的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Reference queue for cleared WeakEntries</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</div></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>的实现原理跟<code>HashMap</code>是差不多的. 不过<code>HashMap</code>在1.8后, 做了很多优化, 但是<code>WeakHashMap</code>并没有跟随<code>HashMap</code>进行优化.</p>
<p>由于<code>WeakHashMap</code>和<code>HashMap</code>差不多, 我们只分析重要的实现方法.</p>
<p><code>WeakHashMap</code>的增删查改, 都会做一个同步操作, 什么是同步操作? 因为<code>WeakHashMap</code>的Key是弱引用类型, Key值会随时被GC回收. 虽然Key被回收了,但是对应的Value还是没有被回收的. 所以, 同步操作就是移除被回收Key对应的Value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Expunges stale entries from the table.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123; <span class="comment">//判断queue队列中是否有被回收的Key, 有的话, 需要移除对应Value</span></div><div class="line">        <span class="keyword">synchronized</span> (queue) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</div><div class="line"></div><div class="line">            Entry&lt;K,V&gt; prev = table[i];</div><div class="line">            Entry&lt;K,V&gt; p = prev;</div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                Entry&lt;K,V&gt; next = p.next;</div><div class="line">                <span class="keyword">if</span> (p == e) &#123;</div><div class="line">                    <span class="keyword">if</span> (prev == e)</div><div class="line">                        table[i] = next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        prev.next = next;</div><div class="line">                    <span class="comment">// Must not null out e.next;</span></div><div class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></div><div class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></div><div class="line">                    size--;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                prev = p;</div><div class="line">                p = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是同步操作的方法, <code>WeakHashMap</code>增删改查时, 都会调用的方法. 原理是这样的: 每当弱引用类型Key被GC回收时, 由于<code>WeakHashMap</code>内部指定了<code>ReferenceQueue&lt;Object&gt;</code>, 因此, 被移除的Key会被添加到该队列. 这个方法就是调用队列的<code>poll()</code>方法, 获得被移除的Key, 然后利用该Key, 移除在<code>WeakHashMap</code>内部对应的Value.</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ul>
<li><p><code>WeakHashMap</code>和<code>HashMap</code>一样, Key和Value都支持null.</p>
</li>
<li><p><code>WeakHashMap</code>内部的继承WeakReference, 将Key指定为弱引用类型, 这样Key会被自动回收. 虽然Key会被自动回收, 但是Value不会被自动回收. 因此, <code>WeakHashMap</code>内部每次增删改查时, 都会做同步操作.</p>
</li>
</ul>
<blockquote>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2></blockquote>
<p><code>IdentityHashMap</code>继承于<code>AbstractMap</code>,并实现了<code>Map</code>接口. 总体来说, <code>IdentityHashMap</code>跟<code>HashMap</code>差别还是很大的. 虽然继承结构相同, 但是实现的思想却是截然不同.</p>
<p><code>IdentityHashMap</code>内部并没有结点, 它的Key和Vaule都是储存在数组内的. 因此, <code>IdentityHashMap</code>解决的冲突是开放地址法.</p>
<p>上面说到<code>IdentityHashMap</code>的Key和Value都是存在数组内的. Key和Value总是连续的存放.</p>
<p>另外值得一提的是: <code>IdentityHashMap</code>是利用 <code>==</code>来比较Key的相等性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    init(DEFAULT_CAPACITY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2</span></div><div class="line">    <span class="comment">// assert initCapacity &gt;= MINIMUM_CAPACITY;</span></div><div class="line">    <span class="comment">// assert initCapacity &lt;= MAXIMUM_CAPACITY;</span></div><div class="line"></div><div class="line">    table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>默认的容量是64. 长度跟<code>HashMap</code>一样, 都是2的次幂.还是跟之前的套路一样, 只分析一些重要的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object k = maskNull(key);</div><div class="line"></div><div class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> Object[] tab = table;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</div><div class="line">        <span class="keyword">int</span> i = hash(k, len); <span class="comment">//获得数组的index</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>; <span class="comment">//有冲的话, 查找下一个index</span></div><div class="line">             i = nextKeyIndex(i, len)) &#123;</div><div class="line">            <span class="keyword">if</span> (item == k) &#123;</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</div><div class="line">                tab[i + <span class="number">1</span>] = value;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</div><div class="line">        <span class="comment">// Use optimized form of 3 * s.</span></div><div class="line">        <span class="comment">// Next capacity is len, 2 * current capacity.</span></div><div class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len)) <span class="comment">//当储存的元素大于 容量的3分之一的话, 扩容</span></div><div class="line">            <span class="keyword">continue</span> retryAfterResize;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        tab[i] = k;</div><div class="line">        tab[i + <span class="number">1</span>] = value; <span class="comment">//Value始终是保存在Key的下个index</span></div><div class="line">        size = s;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>hash</code>函数, 获得index, 如果index对应已经存有元素的话, 会调用<code>nextKeyIndex(int, int)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>IdentityHashMap</code>是使用开放地址法解决冲突. 当发生冲突时, 它会寻找下个位置, 而下个位置是 i + 2. 之所以是i + 2,而不是i + 1的原因是 Key和Value总是连续的储存的, 因此寻找下个位置时, 需要跳多一个位置.如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fip01fuwt1j30er06bmx6.jpg" alt=""></p>
<p>如果index没有储存元素的话, 会先检查内部储存元素数量是不是大于容量的1/3, 是的话会进行扩容操作.每次扩容都是扩为原来的2倍.</p>
<blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2></blockquote>
<p><code>HashTable</code>是一个遗留类, 已经被<code>HashMap</code>替代了. 从功能上来说, 跟HashMap差不多. 主要比较它跟<code>HashMap</code>的异同.</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><code>HashMap</code>是允许K或者V为null的, 但是<code>HashTable</code>不允许K或者V为null</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><code>HashMap</code>是线程不安全的, 而<code>HashTable</code>是线程安全的, 因为内部的方法都是加了锁. 但是在并发的环境, 不建议使用<code>HashTable</code>, 应该使用<code>ConcurrentHashMap&lt;K,V&gt;</code>. <code>ConcurrentHashMap&lt;K,V&gt;</code>是使用分段锁来控制同步, 显然性能上要比<code>HashTable</code>好.</p>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p><code>HashMap</code>的容量为2的n次幂, 而<code>HashTable</code>为素数.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java集合框架-LinkedList]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkedList/</url>
      <content type="html"><![CDATA[<p>上篇文章中我们学了<code>ArrayList</code>, 知道了<code>ArrayList</code>比较适合需要频繁访问元素的场景. 但是在插入和删除元素时, 表现得效率低下. 这次, 我们来分析适合使用在频繁插入和删除元素的场景的集合: <code>LinkedList</code>.</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1filur9c5nfj30p10h7dh8.jpg" alt=""></p>
<p>我们先来看看UML图, <code>LinkedList</code>在继承关系上, 跟<code>ArrayList</code>基本相同. 我们这里只分析不同点.</p>
<ul>
<li><code>LinkedList</code>继承<code>AbstractSequentialList</code>, <code>AbstractSequentialList</code>这个是顺序访问列表的默认实现类, 换句话说, <code>LinkedList</code>访问元素时, 是顺序访问的, 不是像<code>ArrayList</code>那样, 具有随机访问元素的能力.</li>
<li>由于<code>LinkedList</code>是顺序访问列表, 因此它并没有实现<code>RandomAccess</code>接口.</li>
<li><code>LinkedList</code>实现了<code>Deque</code>接口, <code>Deque</code>接口是双向队列的一个接口.因此<code>LinkedList</code>可以看做是一个双端队列. 而且它还可以作为栈来使用.</li>
</ul>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Pointer to first node.</div><div class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line"> *            (first.prev == null &amp;&amp; first.item != null)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Pointer to last node.</div><div class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line"> *            (last.next == null &amp;&amp; last.item != null)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</div></pre></td></tr></table></figure>
<p>我们来先看看<code>LinkedList</code>中的字段. <code>size</code>记录集合内部的元素个数.<code>first</code>和<code>next</code>代表表头和表尾. <code>Node</code>是<code>LinkedList</code>的内部类, 代表链表的结点.从这里可以看出, <code>LinkedList</code>的内部实现是基于双向链表来实现的, 这也解释了为什么<code>LinkedList</code>适合使用在频繁插入和删除的场景.</p>
<blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个构造函数是一个空实现.证明一开始初始化时, 内部是不给结点分配内存的.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<p><code>LinkedList</code>既可以作为双向队列, 也可以作为栈. 说明其支持向队头队尾进行操作.我们接下来分析这些操作</p>
<blockquote>
<h4 id="队头插入元素"><a href="#队头插入元素" class="headerlink" title="队头插入元素"></a>队头插入元素</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the beginning of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkFirst(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the front of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to insert</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerFirst&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Pushes an element onto the stack represented by this list.  In other</div><div class="line"> * words, inserts the element at the front of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to push</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面三个操作都是向队头添加元素, 最终调用<code>addFirst(E)</code>, 而<code>addFirst(E)</code>又会调用<code>linkFirst(E)</code>.向队头插入元素的实现都是这个函数, 我们来分析一波:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Links e as first element.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f); <span class="comment">//创建一个新的结点,</span></div><div class="line">    first = newNode;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        last = newNode; <span class="comment">//如果队列为空的话,</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        f.prev = newNode; <span class="comment">// 队列不为空的话.</span></div><div class="line">    size++;</div><div class="line">    modCount++; <span class="comment">//记录内部结构发生变化的次数, 用于实现fast-fail机制.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>linkFirst</code>函数将一个元素插入到队头, 如果队列为空的话, 会将新插入的元素赋值给队列结点. 如果不为空的话, 将该元素复制为插入前的队头结点的前驱.</p>
<blockquote>
<h4 id="队尾插入元素"><a href="#队尾插入元素" class="headerlink" title="队尾插入元素"></a>队尾插入元素</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the end of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to insert</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerLast&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.6</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Adds the specified element as the tail (last element) of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</div><div class="line"> * <span class="doctag">@since</span> 1.5</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> add(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e the element to add</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法都是向队尾添加元素.它们最终都会调用<code>linkLast</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Links e as last element.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    last = newNode;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>linkLast</code>中的实现会向队尾添加一个结点, 思路和前面的大致一样.这里不多分析.</p>
<blockquote>
<h4 id="指定位置插入"><a href="#指定位置插入" class="headerlink" title="指定位置插入"></a>指定位置插入</h4></blockquote>
<p>既然<code>LinkedList</code>是基于链表来实现的, 那么<code>LinkedList</code>肯定是支持指定位置插入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts the specified element at the specified position in this list.</div><div class="line"> * Shifts the element currently at that position (if any) and any</div><div class="line"> * subsequent elements to the right (adds one to their indices).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</div><div class="line"> * <span class="doctag">@param</span> element element to be inserted</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index == size)</div><div class="line">        linkLast(element);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>add(int, E)</code>方法用于向指定位置插入一个元素, 如果index是等于size的话, 会直接插入到队尾. 如果不是的话, 会用<code>linkBefore(element, node(index))</code>. 我们来看看<code>LinkedList</code>怎么通过index定位到一个结点的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the (non-null) Node at the specified element index.</div><div class="line"> */</div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总体是比较index是否大于size / 2, 小于的话,就从队头遍历, 大于的话从队尾开始遍历. 这里虽然做了一些优化, 但是总体速度还是挺慢的. 接下来的<code>linkBefore</code>就是常规的向一个结点前插入元素的操作.</p>
<blockquote>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3></blockquote>
<p>移除元素的套路跟添加元素的套路一样. 有向队尾,队头,或者指定位置移除元素, 这三种操作, 最后都会调用到下面的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null first node f.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></div><div class="line">    <span class="keyword">final</span> E element = f.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</div><div class="line">    f.item = <span class="keyword">null</span>;</div><div class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    first = next;</div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">        last = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        next.prev = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null last node l.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></div><div class="line">    <span class="keyword">final</span> E element = l.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</div><div class="line">    l.item = <span class="keyword">null</span>;</div><div class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    last = prev;</div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</div><div class="line">        first = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null node x.</div><div class="line"> */</div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert x != null;</span></div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下去的获得元素的操作跟插入元素的思路都差不多.这里不多说.我们接下来看看<code>LinkedList</code>中的迭代器.</p>
<blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote>
<p><code>LinkedList</code>中实现了两个迭代器, 一个是双向迭代器, 另外一个是单向迭代器.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>LinkedList</code>是基于链表来实现的, 决定了它比较适合使用在需要频繁插入和删除的场景. 但是不适合使用在经常要访问特定位置的元素. 因为每次都会遍历链表.</li>
<li><code>LinkedList</code>既可以作为双向队列,也可以作为栈来使用.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java集合框架-ArrayList]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-ArrayList/</url>
      <content type="html"><![CDATA[<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1filh3gnlr2j30n90iw75f.jpg" alt=""></p>
<p>从上面的UML图, 我们可以看出 ArrayList实现了三个标记接口, 他们分别是:RandomAccess, Serializable, Cloneable. RandomAccess接口表示ArrayList支持随机访问其中的元素, 也就是ArrayList可以随机访问其中的元素, 并且时间复杂度为O(1). Serializable接口表示ArrayList可以被序列化. Cloneable接口说明ArrayList可以被克隆(内部实现为浅克隆).</p>
<p>回到UML图, <code>Collection</code>接口是集合的一个基类接口,它继承了<code>Iterable</code>接口,将遍历的任务交给了Iterable接口. <code>AbstracCollection</code>是一个抽象类, 他实现了<code>Collection</code>接口, 在其内部实现了一些默认行为, 同理<code>AbstractList</code>也是一个抽象类, 实现了<code>List</code>接口的一些默认行为. 从这里可以看出, Java的集合框架用到了适配器的模式, 利用AbstractXX一系列抽象类来实现一些默认行为, 其他的让具体子类去实现或者重写.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>分析完<code>ArrayList</code>的继承结构后, 我们开始来分析<code>ArrayList</code>的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Default initial capacity.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for empty instances.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Shared empty array instance used for default sized empty instances. We</div><div class="line">    * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line">    * first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The array buffer into which the elements of the ArrayList are stored.</div><div class="line">    * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line">    * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line">    * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line">    */</div><div class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * The size of the ArrayList (the number of elements it contains).</div><div class="line">    *</div><div class="line">    * <span class="doctag">@serial</span></div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>上面为<code>ArrayList</code>中的字段, 其中<code>elementData</code>字段是保存 <code>ArrayList</code>中的元素, 从这点可以看出, <code>ArrayList</code>的底层数据结构是数组. <code>size</code>字段记录集合中的元素.</p>
<blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with an initial capacity of ten.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>平常我们使用ArrayList时, 都会调用空的构造方法, 如上.这个构造方法中, 只是简单的将<code>elementData</code>赋值为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>, 也就是一个空的数组对象. 因为此时我们并没有添加元素, 构造一个空的数组也是合情合理的.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<p>实例已经得到了, 我们来看看添加元素的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Appends the specified element to the end of this list.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们要向集合添加元素, 由于之前我们构造的是一个空的数组, 那么内部肯定会帮我们扩容数组, 也就是<code>ensureCapacityInternal(size + 1)</code>. 我们进入该方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个方法主要是比较一下<code>elementData</code>对象是不是为空, 空的话, 就取<code>DEFAULT_CAPACITY</code>和<code>minCapacity</code>字段的最大值. 由于我们数组的大小为0, 所以, 取得的是<code>DEFAULT_CAPACITY</code>(也就是10). 进入:<code>ensureExplicitCapacity(minCapacity)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>modCount</code>是用来记录<code>ArrayList</code>内部结构发生变化的次数, 主要用来实现<code>fast-fail</code>机制. 接着会调用<code>grow(int)</code>, 该方法是<code>ArrayList</code>扩容的方法.</p>
<p> 我们接下去,看看<code>ArrayList</code>的扩容策略:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//右移1位,也就是除以2</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>扩容的大小为: 新容量 = 旧容量+旧容量 / 2. 在计算出新容量后, 会与旧容量作差, 再根据结果进行扩容. 主要有下面两种情况:</p>
<ul>
<li>当初始化时(也就是调用空的构造方法), 首次添加会扩容为10.</li>
<li>下次扩容时, 会加上原来容量的一半.</li>
</ul>
<blockquote>
<h3 id="随机访问元素"><a href="#随机访问元素" class="headerlink" title="随机访问元素"></a>随机访问元素</h3></blockquote>
<p>经过前面的分析, <code>ArrayList</code>实现了<code>RandomAccess</code>接口, 表示<code>ArrayList</code>具有随机访问元素的能力, 这种能力是数组本身就有的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>get(E)</code>中, 会首先检查一下index是否会越界, 会的话, 直接抛异常, 不会的话, 直接访问数组对应的index.</p>
<blockquote>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>ArrayList</code>中的移除元素的方法. 首先检查边界, 没有越界的话, 通过index访问元素. 接着再将index后面的元素向先移动. 最后手动将被移除的元素复制为null, 让其能够被GC回收.</p>
<p>这里需要注意的是: 虽然元素被移除了, 但是空间还是留着.</p>
<blockquote>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3></blockquote>
<p>在Java集合框架中, 使用了迭代器模式去遍历集合中的元素, 这使得在遍历元素时, 不用去关心集合的底层实现的数据结构, 各种集合只需要实现符合自己数据结构的迭代器.</p>
<p>在<code>ArrayList</code>中, 默认实现了两个迭代器, 它们分别是:单向迭代器, 双向迭代器.</p>
<blockquote>
<h4 id="单向迭代器"><a href="#单向迭代器" class="headerlink" title="单向迭代器"></a>单向迭代器</h4></blockquote>
<p>单向迭代器是众多迭代器的最简单的,也是最常用的. 内部实现是只能向一个方向遍历数据.</p>
<blockquote>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4></blockquote>
<p>与单向迭代器比, 双向迭代器能够向两个方向遍历数据</p>
<blockquote>
<h4 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h4></blockquote>
<p>如果一个线程利用迭代器遍历集合时, 另外一个线程向集合中添加元素. 这时会抛出异常. 这也说明了<code>ArrayList</code>是线程不安全的.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>ArrayList</code>实现的底层数据结构为数组.</li>
<li>由于<code>ArrayList</code>是基于数组来实现的, 因此决定了<code>ArrayList</code>的使用场景. 它适合用在需要频繁访问元素的场景, 因为其快速访问特性. 但是它不适合使用在需要频繁随机插入和删除的场景, 因为数组每次随机插入和删除元素时, 都需要移动后面的元素.</li>
<li><code>ArrayList</code>具有自动扩容的特性, 默认的容量为10, 后面每次扩容都会增加原来的一半.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java集合-HashMap]]></title>
      <url>http://cristianoro7.github.io/2017/09/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88-HashMap/</url>
      <content type="html"><![CDATA[<p>前两篇文章分别介绍了<code>ArrayList</code>和<code>LinkedList</code>, 这次我们来分析另外一个key-value键值对的映射集合-HashMap.按照前面的习惯,我们先来看看<code>HashMap</code>的UML</p>
<blockquote>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2></blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimu0do73tj30ii0cv3z0.jpg" alt=""></p>
<p><code>HashMap</code>实现了<code>Cloneable</code>, <code>Serializable</code>, 所以<code>HashMap</code>支持克隆(浅克隆)和序列化. <code>Map</code>接口提供了一系列接口和三个视图. <code>AbstractMap</code>则是实现了<code>Map</code>接口, 并且实现了<code>Map</code>接口中的一些方法, 换句话说<code>AbstractMap</code>是<code>Map</code>家族里面的一个基本骨架, 具体的子类根据需要重写<code>AbstractMap</code>中的方法即可.</p>
<blockquote>
<h2 id="回顾Hash表"><a href="#回顾Hash表" class="headerlink" title="回顾Hash表"></a>回顾Hash表</h2></blockquote>
<p>学过数据结构的都应该清楚, Hash表是将一个key的hash值取模后映射到一个数组中的特定位置. 但是, 随着Hash表中的键值对的增多, 会出现冲突. 所谓的冲突是两个key的hash值取模后得到的数定位到了数组中的相同位置.对于冲突这种情况, 常用的解决方法有:开放地址法和链地址法.</p>
<blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></blockquote>
<p>回顾完了Hash表的基础知识后, 我们来讲讲<code>HashMap</code>的实现方式.</p>
<p>总体来说, <code>HashMap</code>的实现为: 数组+链表+红黑树. 当出现冲突时, <code>HashMap</code>是使用链地址法来解决冲突.但是如果冲突越来越多, 链表就会变得越来越长.这样导致的结果是:原本访问一个Key对应的value的时间复杂度会从O(1)退化为O(n).因此, <code>HashMap</code>使用一种名为红黑树的数据结构来解决时间复杂度退化的这个问题.红黑树查找key值对应的value的时间复杂度为O(log n)(优于O(n)).</p>
<p>下面, 先来看看<code>HashMap</code>中的字段, 我们将重点介绍两个字段. 这两个字段影响着<code>HashMap</code>的性能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The table, initialized on first use, and resized as</div><div class="line"> * necessary. When allocated, length is always a power of two.</div><div class="line"> * (We also tolerate length zero in some operations to allow</div><div class="line"> * bootstrapping mechanics that are currently not needed.)</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//内部的数组</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</div><div class="line"> * for keySet() and values().</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//返回包含key-value的视图</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of key-value mappings contained in this map.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//内部储存的key-value的个数</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of times this HashMap has been structurally modified</div><div class="line"> * Structural modifications are those that change the number of mappings in</div><div class="line"> * the HashMap or otherwise modify its internal structure (e.g.,</div><div class="line"> * rehash).  This field is used to make iterators on Collection-views of</div><div class="line"> * the HashMap fail-fast.  (See ConcurrentModificationException).</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//记录内部数据结构发生变化的次数, 主要用来实现fail-fast</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next size value at which to resize (capacity * load factor).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></div><div class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></div><div class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></div><div class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The load factor for the hash table.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<p>loadFactor是负载因子, 这个字段表示<code>HashMap</code>内部容量满载的一个界限. threshold为扩容的界限,它的计算公式为: threshold = capacity * loadFactor.当size &gt; threshold时, <code>HashMap</code>内部就会扩容.</p>
<p><code>loadFactor</code>内部默认实现为0.75. 这个数值是时间和空间的一个折中值.<code>loadFactor</code>如果设置为比较大, 也就是<code>threshold</code>会比较大, 那么空间的利用率就会变大, 但是空间利用率变大的代价是查找速度变慢了, 因因为冲突率会提高. 如果<code>loadFactor</code>设置为比较小的话, <code>threshold</code>会比较小, 虽然冲突率会变小, 因为会频繁扩容.但这也一定程度上浪费空间内存.</p>
<blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote>
<p><code>HashMap</code>的构造函数有几个重载, 我们既可以使用无参的构造方法, 使用内部默认指定的<code>capacity</code>和<code>loadFactor</code>.也可以调用指定这两个参数的构造函数.</p>
<p>如果没有特殊情况.我们一般调用无参的构造函数.它会帮我们指定默认的<code>loadFactor</code>.</p>
<blockquote>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>put</code>函数是往<code>HashMap</code>中添加元素, 在分析添加元素的实现之前, 我们先来看看<code>hash(key)</code>函数,得到的hash值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4></blockquote>
<p><code>hash</code>函数的实现思路: 将key的hashCode的高16位和低16位作异或操作.至于为什么是要这样操作?</p>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<p>分析完了<code>hash(int key)</code>函数, 我们回到<code>put(K key)</code>, 来看看真正的添加操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//检查HashMap是否为空</span></div><div class="line">        n = (tab = resize()).length; <span class="comment">//空的话, 先进行扩容</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断HashMap中有没有存该Key</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//没有存该值, 直接赋值.</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//HashMap不为空的情况.</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//判断HashMap有没存该Key</span></div><div class="line">            e = p; <span class="comment">//没有的话直接赋值</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断这个结点是不是红黑树结点</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); 是的话, 插入到红黑树结构中</div><div class="line">        <span class="keyword">else</span> &#123; <span class="comment">//插入到链表结构中</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash); <span class="comment">//如果链表的结点个数为8的话, 将链表转化为红黑树, 这样提高查找的速度</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e); <span class="comment">//hock函数, 用于LinkHashMap中</span></div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//如果size &gt; threshold的话, 需要进行扩容</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面注释已经将函数解析得挺清楚了, 下面主要介绍这个<code>hash &amp; (n - 1)</code>操作. <code>hash &amp; (n - 1)</code>其实等价于取模操作, 但是比普通的 % 操作高效, 因为<code>hash &amp; (n - 1)</code>运用的位运算.</p>
<p>一个数和2的n次方进行去模操作, 余数是由这个数的低n决定,所以<code>hash &amp; (n - 1)</code>就是取得hash的底n位,也就是余数.如下图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fimz01cbwzj30d60dm74h.jpg" alt=""></p>
<p>前面说过<code>HashMap</code>内部的长度总是为2的次方, <code>n</code>为<code>HashMap</code>的长度,所以跟上面的例子原理一样.</p>
<p><code>afterNodeAccess(e);</code>和<code>afterNodeInsertion(evict);</code>是hock函数, 是预留给<code>LinkedHashMap</code>使用的.</p>
<p>链表的构造使用的是头插法, 后插入的会在链表头.</p>
<p>如果一直向<code>HashMap</code>中添加元素的话, 其内部会扩容, 扩容通俗地说就是用更大的数组来代替之前的小数组以装下更多的元素.1.8的<code>HashMap</code>内部的扩容机制做了一些优化, 接下来, 我们来详细分析其中的优化.</p>
<blockquote>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩大为原来的两倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>resize()</code>函数为<code>HashMap</code>的扩容机制,扩容的情况有两种, 一种的初始化默认的容量, 另外一种是扩大为原来的两倍.</p>
<p>扩大容量后, 还需要把原来的数据搬到新的数组中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">            oldTab[j] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//定位到新的位置, 并且赋值</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">//如果结点是红黑树的结点的话, 会进行修剪树的操作</span></div><div class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order 头结点后面有元素,且为链表的结构</span></div><div class="line">              <span class="comment">//重新定位链表的策略: 定义两条链表, 构造完链条链表后, 再将他们的头结点定位到数组对应的index</span></div><div class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">//留在原来的位置的链表</span></div><div class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">//移动在原来位置+2的n次方位置的链表</span></div><div class="line">                Node&lt;K,V&gt; next;</div><div class="line">                do &#123;</div><div class="line">                    next = e.next;</div><div class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//新增位为0</span></div><div class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                            loHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            loTail.next = e;</div><div class="line">                        loTail = e;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//新增位为1</span></div><div class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                            hiHead = e;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            hiTail.next = e;</div><div class="line">                        hiTail = e;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    loTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                    hiTail.next = <span class="keyword">null</span>;</div><div class="line">                    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合代码中的注释, 我们来解析这个扩容机制, 首先遍历原来的数组, 然后拿到每个位置的头结点, 再判断头结点后面有没有元素, 没有的话, 直接用<code>&amp;</code>运算定位到新的位置.如果有的话, 先判断这个结点是不是红黑树的结点, 是的话做修剪树的操作.不是的话, 说明后面的结点的结构是链表.</p>
<p>前面说过, <code>HashMap</code>的每次扩容为原来的2倍, 这样的话, 原来的元素不是定位到原地, 就是在原地移动2的次幂.我们结合扩容前和扩容后的图来解释:</p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin22vrzufj30nb0c50tb.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006VdOYcgy1fin27c3g43j30o10bpmxq.jpg" alt=""></p>
<p>扩容后,决定位置的位数多了一位, 拿16扩容到32来说, 16的时候, 决定位置是由结果的后4位来决定, 如果扩容为32位后, 决定位置是由结果的后5位.如果新增的那一位为0的话,表示新的位置是原来的位置, 如果为1的话, 新的位置为原来的位置 + 原来的容量(原来的容量为2的n次方).</p>
<p>所以代码中<code>e.hash &amp; oldCap</code>就是为了取得新增的那一位, 如果为0的话, 说明新的位置为原来的位置, 如果为1的话,则需要移动2的n次幂(也就是 原来的位置 + 旧的容量).</p>
<p>上面重新组装链表的时候, 思路是这样的: 因为新的位置不是在原来的位置, 就是需要在原来的位置上移动2的次幂.所以, 定义两条链表, 一条表示新位置是原来的位置的链表(简称L1), 另外一条表示新的位置在原来的位置移动2的次幂(简称L2). 接着会先遍历原来的链表, 再进行<code>e.hash &amp; oldCap</code>, 如果为0的话, 将该结点插入到L1, 如果为1的话, 插入到L2. 插入的方法为尾插法, 这样重构后的链表不会乱序(1.7之前的版本是会乱序的). 最后,将新构造的两条链表定位到对应的位置,也就是下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">    loTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j] = loHead; <span class="comment">//将链表定位到原来的位置</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">    hiTail.next = <span class="keyword">null</span>;</div><div class="line">    newTab[j + oldCap] = hiHead; <span class="comment">//将链表定位到原来的位置 + 2的n次方</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.8的扩容机制的优化主要是不需要再重新计算hash值, 只是做个<code>&amp;</code>操作就行了, 并且重构后的链表不会乱序. 这种优化的一个重要的前提是容量为2的n次幂. 因此 <code>HashMap</code>内部的容量为什么不定义为素数而是定义为2的n次幂. 这样做是为了减少扩容时的<code>rehash</code>操作.</p>
<p>到这里, 我们已经把<code>HashMap</code>内部的精华都分析完了, 其他操作都挺简单的, 也没什么好讲的.最后, 做个总结</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<ul>
<li><code>hash</code>函数</li>
<li>扩容机制</li>
<li>冲突优化</li>
<li>其他</li>
</ul>
<blockquote>
<h3 id="hash函数-1"><a href="#hash函数-1" class="headerlink" title="hash函数"></a><code>hash</code>函数</h3></blockquote>
<p>一般而言, 哈希表的长度设置为一个素数的话, 发生冲突的次数会比较少.但是为了优化<code>HashMap</code>的扩容和<code>rehash</code>操作, <code>HashMap</code>的长度被设置为总是为2的次方(不是一个素数).既然被设置为一个合数, 那么冲突的次数肯定会还比较多. <code>hash</code>函数通过再次散列来减少冲突率. 但 <code>HashMap</code>内部的hash函数没有被设置得很复杂,<code>HashMap</code>内部的<code>hash</code>函数只是简单的高低16位进行异或操作. 面对冲突的情况, <code>HashMap</code>内部的优化有红黑树,并且本来key的hashCode已经挺分散了. 从质量和系统消耗的角度出发, 没有必要设置复杂的<code>hash</code>函数.</p>
<blockquote>
<h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3></blockquote>
<ul>
<li><p><code>HashMap</code>的扩容后的长度总是2的次幂, 这个设置主要是为了优化扩容机制. <code>HashMap</code>内部扩容时,不需要重新计算hash值,并且链表的顺序还是保持原来的顺序.</p>
</li>
<li><p>频繁进行扩容会一定程度上影响<code>HashMap</code>性能.因此,如果预先知道需要储存的数据有很多的话, 可以直接设置一个较大的容量来减少扩容的次数.</p>
</li>
</ul>
<blockquote>
<h3 id="冲突优化"><a href="#冲突优化" class="headerlink" title="冲突优化"></a>冲突优化</h3></blockquote>
<p>对于hash冲突的情况, 如果冲突的链表结点个数大于8的话, <code>HashMap</code>会将链表转化为红黑树的结构, 将查找的复杂度从O(N)优化为O(logN).</p>
<blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></blockquote>
<ul>
<li><p><code>HashMap</code>既支持<code>Key</code>为<code>null</code>, 也支持<code>value</code>为<code>null</code>.</p>
</li>
<li><p>遍历<code>HashMap</code>时, 顺序是不保证的, 如果需要有序的遍历, 应该使用<code>LinkedHashMap</code></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构-栈]]></title>
      <url>http://cristianoro7.github.io/2017/06/29/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*顺序储存结构*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> top;</div><div class="line">&#125;SqStack;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>入栈操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">push</span><span class="params">(SqStack &amp;S, ElemType elemType)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top == MAXSIZE - <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    S.data[++S.top] = elemType;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">pop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = S.data[S.top - <span class="number">1</span>];</div><div class="line">    S.top--;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈和入栈都没有涉及到循环语句,因此时间复杂度为0(1)</li>
</ul>
<h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><ul>
<li>适合一个栈同增加的同时另一个栈在减少</li>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 共享栈结构体</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> top1;</div><div class="line">    <span class="keyword">int</span> top2;</div><div class="line">&#125;SqShareStack;</div></pre></td></tr></table></figure>
<ul>
<li><p>当top1 + 1 == top2时视为栈满</p>
</li>
<li><p>入栈</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sharePush</span><span class="params">(SqShareStack &amp;S, ElemType e, <span class="keyword">int</span> stackNumber)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (S.top1 + <span class="number">1</span> == S.top2) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (stackNumber == <span class="number">1</span>) &#123;</div><div class="line">        S.data[++S.top1] = e;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">2</span>) &#123;</div><div class="line">        S.data[--S.top2] = e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sharePop</span><span class="params">(SqShareStack &amp;S, ElemType &amp;e, <span class="keyword">int</span> stackNumber)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(S.top1 == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        e = S.data[S.top1--];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(S.top2 == MAXSIZE) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        e = S.data[S.top2++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链式储存结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> StackNode &#123;</div><div class="line">    ElemType data;</div><div class="line">    <span class="keyword">struct</span> StackNode *next;</div><div class="line">&#125;StackNode, *LinkStackPtr;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> LinkStack &#123;</div><div class="line">    LinkStackPtr top;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">&#125;LinkStack;</div></pre></td></tr></table></figure>
<ul>
<li>入栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sPush</span><span class="params">(LinkStack &amp;S, ElemType e)</span> </span>&#123;</div><div class="line">    LinkStackPtr ptr = (LinkStackPtr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</div><div class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    ptr-&gt;data = e;</div><div class="line">    ptr-&gt;next = S.top;</div><div class="line">    S.top = ptr;</div><div class="line">    S.count++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sPop</span><span class="params">(LinkStack &amp;S, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(S.top != <span class="literal">NULL</span>) &#123;</div><div class="line">        LinkStackPtr ptr;</div><div class="line">        ptr = S.top;</div><div class="line">        S.top = ptr-&gt;next;</div><div class="line">        e = ptr-&gt;data;</div><div class="line">        <span class="built_in">free</span>(ptr);</div><div class="line">        S.count--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>顺序栈与链栈的时间复杂度都是O(1)</li>
<li>空间上链栈没有空间限制,但是链栈要求每个元素都要有指针域,者也一定程度上增加了内存的开销.顺序栈需要事先规定一个固定长度，可能会造成内存浪费,但是它对于存取时定位很方便</li>
</ul>
<blockquote>
<p>参考资料:《大话数据结构》<br><a href="https://github.com/cristianoro7/data-structure-practice" target="_blank" rel="external">源码</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机组成原理-储存系统和结构]]></title>
      <url>http://cristianoro7.github.io/2017/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="储存系统和结构"><a href="#储存系统和结构" class="headerlink" title="储存系统和结构"></a>储存系统和结构</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>储存器的分类</li>
<li>随机储存器</li>
<li>高速储存缓冲器</li>
<li>虚拟储存器</li>
</ul>
<blockquote>
<h3 id="储存器的分类"><a href="#储存器的分类" class="headerlink" title="储存器的分类"></a>储存器的分类</h3></blockquote>
<p>下面针对常见的储存器分类进行讨论</p>
<h4 id="按储存器在计算机系统中的作用分类"><a href="#按储存器在计算机系统中的作用分类" class="headerlink" title="按储存器在计算机系统中的作用分类"></a>按储存器在计算机系统中的作用分类</h4><h5 id="高速缓冲储存器"><a href="#高速缓冲储存器" class="headerlink" title="高速缓冲储存器"></a>高速缓冲储存器</h5><p>位于CPU和主储存器之间, 用来缓存正在执行的程序段和数据,以便CPU能高速使用它们.高速缓冲器的速度与CPU匹配.</p>
<h5 id="主储存器"><a href="#主储存器" class="headerlink" title="主储存器"></a>主储存器</h5><p>用来存放正在运行的程序和数据,CPU可以直接随机地进行访问主存.由于访问主存的速度与CPU运算的速度差别很大,因此,主存的性能一定程度上影响了整个计算机的性能.</p>
<h5 id="辅助储存器"><a href="#辅助储存器" class="headerlink" title="辅助储存器"></a>辅助储存器</h5><p>用来存放当前暂不参与运行的程序和数据以及一些需要永久性保存的数据.辅助储存器的存取速度很慢并且CPU不能直接访问它.辅助储存器中的信息需要先读入主存后,才能被CPU访问.</p>
<h4 id="按存取分类"><a href="#按存取分类" class="headerlink" title="按存取分类"></a>按存取分类</h4><h5 id="随机存取储存器-RAM"><a href="#随机存取储存器-RAM" class="headerlink" title="随机存取储存器(RAM)"></a>随机存取储存器(RAM)</h5><p>随机储存指的是CPU能够随机对储存器中的内容进行操作, CPU对任何一个储存单元的操作时间都一样,与储存单元的物理位置无关.</p>
<h5 id="只读储存器-ROM"><a href="#只读储存器-ROM" class="headerlink" title="只读储存器(ROM)"></a>只读储存器(ROM)</h5><p>ROM可以看做是RAM的一种特殊形式, 其特殊在:储存器的内容只能随机读取而不能写入.这类储存器常用来储存那些不需要改变的信息.</p>
<h4 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a>按信息的可保存性分类</h4><h5 id="非易失性储存器"><a href="#非易失性储存器" class="headerlink" title="非易失性储存器"></a>非易失性储存器</h5><p>断电后信息仍然能够保存的储存器称为非易失性储存器.</p>
<h5 id="易失储存器"><a href="#易失储存器" class="headerlink" title="易失储存器"></a>易失储存器</h5><p>断电后信息不能够保存的储存器称为易失性储存器.</p>
<blockquote>
<h3 id="随机储存器RAM"><a href="#随机储存器RAM" class="headerlink" title="随机储存器RAM"></a>随机储存器RAM</h3></blockquote>
<p>RAM细分为静态RAM(SRAM)和动态RAM(DRAM).</p>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>SRAM的记忆单元为双稳态触发器.由于双稳态触发器的工作特性,SRAM中保存的信息一直处于充电状态,这使得SRAM不像DRAM那样需要定时刷新电路来保存信息.因此,SRAM的存取速度要比DRAM快.但SRAM的集成度较低,功耗也较大,所以一般用来组成高速缓冲储存器.</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>DRAM的记忆单元为3个MOS管组成的记忆单元.DRAM中的信息是靠MOS管中的栅极电容保存的,因此需要定时给电容充电,以保证信息不丢失.DRAM虽然储存速度没有SRAM快,但是其集成度高,功耗较小.</p>
<blockquote>
<h3 id="高速缓冲器"><a href="#高速缓冲器" class="headerlink" title="高速缓冲器"></a>高速缓冲器</h3></blockquote>
<p>由于主存的存取速度跟不上CPU的运算速度,主存的速度影响了计算机的整体性能.出于各个方面的考虑,计算机的设计者在主存和CPU之间架设由SRAM组成的高速缓冲器,利用高速缓冲器的运行速度接近CPU的特点,来解决主存的性能瓶颈.</p>
<h4 id="高速缓冲器的工作原理"><a href="#高速缓冲器的工作原理" class="headerlink" title="高速缓冲器的工作原理"></a>高速缓冲器的工作原理</h4><p>首先介绍一下程序局部性原理这个概念. 程序局部性包含两个方面:时间局部性和空间局部性.</p>
<p>时间局部性指的是如果一个储存单元被访问,则可能该储存单元很快会被访问到,这是因此程序中存在循环.</p>
<p>空间局部性指的是如果一个储存单元被访问,则该储存单元邻近的单元很可能很快就被访问, 这是因此程序中大部分指令是顺序储存,顺序执行,数据一般也是以数组,向量,树,表等形式簇聚在一起.</p>
<p>高速缓冲技术就是利用程序局部性原理,把程序中正在使用的部分存放在一个高速但容量较小的Cache中,使得CPU的访存操作大部分都针对Cache进行,从而提高程序的执行速度.</p>
<h4 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h4><h5 id="Cache的读操作"><a href="#Cache的读操作" class="headerlink" title="Cache的读操作"></a>Cache的读操作</h5><p>当CPU发出读请求时,如果请求的数据存在Cache时,就直接对Cache进行操作.否则访问主存,并把该块信息一次从主存调入Cache内.若此时Cache的容量已满的话,则需要根据某些替换算法来替换.</p>
<h5 id="Cache的写操作"><a href="#Cache的写操作" class="headerlink" title="Cache的写操作"></a>Cache的写操作</h5><p>当CPU发出写请求时, 如果要写入的数据存在Cache中的话,需要进行一定的写处理,比如:写直达法和写回法.如果写Cache不命中的话,就直接把信息写入主存,并有两种处理方法:</p>
<ul>
<li>不按写分配法,即只把要写的信息写入主存.</li>
<li>按写分配法,即把要写的信息写入主存后还需要写入Cache中.</li>
</ul>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>当Cache的空间被占满后,就需要进行数据的替换.常用的替换算法有如下三种:</p>
<h5 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h5><p>简单的根据一个随机数来进行替换</p>
<h5 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h5><p>按照调入Cache的顺序来决定替换的顺序.先Cache的数据会先被替换掉.这种方法容易实现并且系统开销小.其缺点是当遇到循环程序块时,效率会不高.</p>
<h5 id="近期最少使用算法-LRU"><a href="#近期最少使用算法-LRU" class="headerlink" title="近期最少使用算法(LRU)"></a>近期最少使用算法(LRU)</h5><p>LRU算法是把CPU近期最少使用的块作为被替换的目标.LRU算法相对上面两种方法合理,但是实现起来比较复杂,系统开销也大.</p>
<h4 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h4><p>为了保证Cache与主存的内容一致,必须选择合适的更新策略.</p>
<h5 id="写直达法"><a href="#写直达法" class="headerlink" title="写直达法"></a>写直达法</h5><p>在CPU执行写操作时,必须同时把数据写入Cache和主存中.这种方法实现简单,而且能够随时保证主存数据的正确性.但是由于每次进行写操作时,都得写入主存,这一定程度上会降低存取速度.</p>
<blockquote>
<h3 id="虚拟储存器"><a href="#虚拟储存器" class="headerlink" title="虚拟储存器"></a>虚拟储存器</h3></blockquote>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>虚拟储存器是将主存或者辅助储存的地址空间进行统一的编址,形成一个庞大的储存空间.这样一来,可以不必考虑程序在主存中是否装得下以及这些程序在主存中的存放位置.</p>
<p>虚拟地址:通常程序员编写程序用到的地址称为虚拟地址.<br><br>物理地址:实际主存单元地址称为物理地址.</p>
<p>虚地址和物理地址是一一对应的关系,实现这个一一映射的关系需要硬件和操作系统的协助.在操作系统的管理下,程序和数据会先存放在磁盘,然后操作系统将当前需要的程序和数据调入主存中,供CPU使用,还没使用到的程序和数据都存放在磁盘中.</p>
<p>当程序运行时,CPU以虚地址来访问主存,在硬件找出虚地址和物理地址之间对应的关系后,判断该虚地址对应的内容是否已经调入主存.如果已经装入主存的话,则通过CPU变址来访问主存中的内容.如果不存在主存中,则将虚拟地址对应的数据从磁盘中装入内存,再由CPU访问.如果此时主存已满,根据替换算法将主存中暂时不需要的数据调回辅存中,再从辅存中调入需要的数据.</p>
<h4 id="页式虚拟储存器"><a href="#页式虚拟储存器" class="headerlink" title="页式虚拟储存器"></a>页式虚拟储存器</h4><p>以页为基本单位的虚拟储存器称为页式虚拟储存器.主存空间和虚拟空间都被分为若干个大小相等的页.主存的页称为实页,虚存的页称为虚页.</p>
<p><img src="/uploads/计算机组成原理/页式虚拟储存.png" alt=""></p>
<p>上图为虚拟地址到物理地址的映射过程.</p>
<p>虚地址是由虚页号和页内地址所组成的.虚页号为页表中的索引号,页表是用于虚地址到物理地址的转换,简单的说就是虚页号的集合.每个虚页号和储存在页面基址寄存器的页表起始地址组成一个页表地址,页表地址指向页表中的一项,项目中含有装入位和实页号.如果装入位1为的话,说明该页面已经被调入主存,实页号和虚地址中的页内地址组成物理地址.如果装入位为0的话,证明该页面还没有被调入主存,需要启动IO系统,将该页从辅存中主存后再拱CPU使用.</p>
<h4 id="段式虚拟储存"><a href="#段式虚拟储存" class="headerlink" title="段式虚拟储存"></a>段式虚拟储存</h4><p>段式虚拟储存中的段是按照程序中的逻辑结构划分的,各个段的长度是因程序而异.在页式虚拟储存中,虚地址到物理地址的映射需要一个页表,同样的,在段式储存中,虚地址到物理地址的转换也需要一个段表.段表中的每一个项目记录了段号,装入位,段起点和段长度等.</p>
<p><img src="/uploads/计算机组成原理/段式储存.png" alt=""></p>
<p>上图为段式虚拟储存中,虚地址到物理地址的映射过程,原理跟虚拟地址差不多,这里不多做记录.</p>
<h4 id="段页式虚拟储存"><a href="#段页式虚拟储存" class="headerlink" title="段页式虚拟储存"></a>段页式虚拟储存</h4><p>结合段式和页式虚拟储存的特点,这种虚拟储存方式为段页式虚拟储存.段页式将程序其逻辑结构分段,每段再划分为若干个大小相同的页,主存空间也划分为若干同样大小的页.</p>
<p>虚存和实存之间以页为基本单位进行传送,每个程序对应一个段表,每段对应一个页表.</p>
<p>CPU访问时,虚地址包括段号,段内页号,页内地址3部分.</p>
<p>首先将段表起始地址和段号合成,得到页表地址,然后从段表中取出该段的页表起始地址,与段内页号合成,得到页表地址.最后从页表中得到实页号,与页内地址拼接成主存的实地址.</p>
<p>段页式虚拟储存整合了前面两种结构的优点.但是要经过两级查询才能完成地址转换,费时自然也会增多.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机组成原理</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机组成原理概述]]></title>
      <url>http://cristianoro7.github.io/2017/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h1 id="计算机组成原理概述"><a href="#计算机组成原理概述" class="headerlink" title="计算机组成原理概述"></a>计算机组成原理概述</h1><blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></blockquote>
<ul>
<li>概述</li>
<li>储存程序概念</li>
<li>计算机硬件的组成</li>
<li>储存器的设计思想</li>
<li>计算机的主要性能指标</li>
</ul>
<blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>最近,突然对操作系统感兴趣,于是提前看了网上关于操作系统的视频. 但是在看的过程中对操作系统启动时从实模式到保护模式的切换,分段机制和分页机制, CPU的工作模型和总线等概念不怎么熟悉. 于是Google了一番, 发现这些大都是涉及到计算机组成原理的知识,刚好这学期学校有开设计算机组成原理课程.于是乎, 系统的学习了一波计算机组成原理的知识.</p>
<p>由于自己的方向是偏软件开发的, 因此,在学习的过程中,主要理解计算机的工作原理以及设计思想, 对于硬件的设计和工作原理就基本没深入了解. 接下来关于计算机组成原理的文章,都是偏向与理论并且不涉及到硬件的具体工作原理等.</p>
<blockquote>
<h3 id="储存程序概念"><a href="#储存程序概念" class="headerlink" title="储存程序概念"></a>储存程序概念</h3></blockquote>
<p>储存程序是由冯*诺依曼为首的研究小组提出来的概念.储存程序的诞生主要是为了解决使用线路连接编程的缺点.</p>
<p>储存程序的要点可以概括为下面三点:</p>
<ul>
<li>计算机应由运算器,储存器,控制器,输入设备和输出设备5大基本部件组成.</li>
<li>计算机内部统一使用二进制表示指令和数据.</li>
<li>将编好的程序和原始数据事先存入储存器中,然后再启动计算机工作.</li>
</ul>
<p>但是随着计算机的高速发展, 访问CPU的速度远远快于访问主存的速度.因此,储存器的访问成为了计算机性能的瓶颈.</p>
<blockquote>
<h3 id="计算机硬件的组成"><a href="#计算机硬件的组成" class="headerlink" title="计算机硬件的组成"></a>计算机硬件的组成</h3></blockquote>
<h4 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h4><h5 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h5><p>输入设备的作用是将编好的程序和数据输入到计算机,并且将他们转换为计算机内部能够识别和接受的信息.</p>
<h5 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h5><p>输出设备的任务是将计算机内部处理的结果以数字,字符,图像等方式展示给人们看.</p>
<h5 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h5><p>储存器是用来存放程序和数据的部件,是实现”储存程序”的基础.</p>
<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>运算器是对信息进行处理和运算的部件.进行的运算有:算术运算和逻辑运算.</p>
<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>控制器的主要工作是指挥各个部件工作.</p>
<h4 id="连接各个部件的总线"><a href="#连接各个部件的总线" class="headerlink" title="连接各个部件的总线"></a>连接各个部件的总线</h4><p>总线可以实现各个部件之间的信息共享.例如:主存中的数据通过总线传递到CPU.</p>
<p>最简单的总线结构为单总线结构,也称为系统总线:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Computer_system_bus.svg/350px-Computer_system_bus.svg.png" alt=""></p>
<p>各个部件都连接在总线上, CPU与主存,CPU与外部设备之间可以直接通信.主存与外部设备,外部设备和外部设备之间可以直接通信,而无须经过CPU的干预.</p>
<p>系统总线的结构限定了同一时刻只允许一对设备之间传递信息.</p>
<p>系统总线按传递信息的不同,可以细分为:</p>
<ul>
<li>数据总线: CPU可以沿数据总线从主存或者外部设备读入信息,也可以向主存或者外部设备写入信息.</li>
<li>地址总线: 用于CPU向主存,外部设备传输地址信息.</li>
<li>控制总线: 传递CPU发出的控制命令和主存返回给CPU的信号.</li>
</ul>
<blockquote>
<h3 id="储存器的设计思想"><a href="#储存器的设计思想" class="headerlink" title="储存器的设计思想"></a>储存器的设计思想</h3></blockquote>
<p>储存器的设计思想可以分为:冯*诺依曼结构和哈佛结构.</p>
<h4 id="冯-诺依曼结构"><a href="#冯-诺依曼结构" class="headerlink" title="冯*诺依曼结构"></a>冯*诺依曼结构</h4><p>在冯诺依曼结构下的储存器结构,指令和数据是不加以区分地储存在储存器中,并共享数据总线.</p>
<p><img src="/uploads/计算机组成原理/冯诺依曼.png" alt=""></p>
<p>由于指令和数据存放在同一储存器中,因此,在这种结构下,不能同时进行取指令和取操作数.</p>
<p>又由于储存器的访问速度远远慢于CPU的运算速度,从而使得计算机运算速度受到了很大的影响.</p>
<h4 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h4><p>哈佛结构的指令和数据是分开的.储存器分为两部分:程序储存器和数据储存器.前者是用来存放指令,而后者则是存放数据.</p>
<p><img src="/uploads/计算机组成原理/哈佛结构.png" alt=""></p>
<blockquote>
<h3 id="计算机的主要性能指标"><a href="#计算机的主要性能指标" class="headerlink" title="计算机的主要性能指标"></a>计算机的主要性能指标</h3></blockquote>
<h4 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h4><p>机器字长是指运算器进行一次运算所处理的位数,它通常是由寄存器,加法器的位数决定的,所以机器字长一般等于寄存器的位数.</p>
<h4 id="数据通路宽度"><a href="#数据通路宽度" class="headerlink" title="数据通路宽度"></a>数据通路宽度</h4><p>数据总线一次并行传送信息的位数,称为数据通路宽度.它影响到信息传送能力,从而影响到计算机的有效处理速度.</p>
<h4 id="储存容量"><a href="#储存容量" class="headerlink" title="储存容量"></a>储存容量</h4><p>一个主储存器所能储存的全部信息量成为主存容量.计算机的主存容量越大,存放的信息就越多,处理问题的能力就越强.</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>计算机组成原理<br><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%8C%AF%E6%B5%81%E6%8E%92" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%8C%AF%E6%B5%81%E6%8E%92</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构-队列]]></title>
      <url>http://cristianoro7.github.io/2017/05/21/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h3><ul>
<li>由于队列的顺序储存本身会由于删除等操作而发生假溢出.因此使用循环队列可以解决这个问题<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4>把队列的头尾相接的顺序储存结构称为循环队列</li>
</ul>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li>在使用循环队列时,会出现front == rear 对应队列为空或者队列满的情况</li>
</ul>
<h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><ul>
<li>设置一个标志位： 当队列为空时，flag = 0，当队列满时，flag = 1;</li>
<li>当队列为空时，front == rear，当队列满时，修改其条件，空出一个元素空间</li>
</ul>
<a id="more"></a>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 循环队列的顺序结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> front;</div><div class="line">    <span class="keyword">int</span> rear;</div><div class="line">&#125;SqQueue;</div></pre></td></tr></table></figure>
<ul>
<li>初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">init</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</div><div class="line">    Q.front = <span class="number">0</span>;</div><div class="line">    Q.rear = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>队列长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">length</span><span class="params">(SqQueue Q)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">enQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    Q.data[Q.rear] = e;</div><div class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">deQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q.front == Q.rear) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = Q.data[Q.front];</div><div class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><ul>
<li>结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 链队列</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> QNode &#123;</div><div class="line">    ElemType data;</div><div class="line">    <span class="keyword">struct</span> QNode *next;</div><div class="line">&#125;QNode, *QueuePrt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    QueuePrt front, rear;</div><div class="line">&#125;LinkQueue;</div></pre></td></tr></table></figure>
<ul>
<li>入队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sEnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType e)</span> </span>&#123;</div><div class="line">    QueuePrt p = (QueuePrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    p-&gt;data = e;</div><div class="line">    p-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    Q.rear-&gt;next = p;</div><div class="line">    Q.rear = p;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出队操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">sDeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q.front == Q.rear) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    QueuePrt p = Q.front-&gt;next;</div><div class="line">    e = p-&gt;data;</div><div class="line">    Q.front-&gt;next = p-&gt;next;</div><div class="line"></div><div class="line">    <span class="comment">/*如果被删除的结点是最后一个的话，将尾指针指向头结点*/</span></div><div class="line">    <span class="keyword">if</span>(Q.rear == p) &#123;</div><div class="line">        Q.rear = Q.front;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><h4 id="时间上："><a href="#时间上：" class="headerlink" title="时间上："></a>时间上：</h4><ul>
<li>两者的基本操作的时间复度都是O(1)</li>
<li>对于循环队列来说，事先申请好空间，试用期间不释放</li>
<li>对于链队列来说，每次申请和释放结点也会存在一些时间开销</li>
<li>如果入队频繁的话，两者还是有细微差别</li>
</ul>
<h4 id="空间上"><a href="#空间上" class="headerlink" title="空间上"></a>空间上</h4><ul>
<li>循环队列需要事先确定一个长度，所以就有了储存个数和空间浪费的问题</li>
<li>链队列则不存在上述问题，但是它需要指针域，也会在空间上产生一定的开销</li>
<li>总体来说，链队列在空间上更加灵活</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>在确定队列长度的最大值的情况下，使用循环队列较为适宜，否则使用链队列比较适合</li>
</ul>
<blockquote>
<p>参考资料：《大话数据结构》<br><a href="https://github.com/cristianoro7/data-structure-practice" target="_blank" rel="external">源码</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大话数据结构-线性表]]></title>
      <url>http://cristianoro7.github.io/2017/03/05/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><ul>
<li>零个或多个数据元素的有限序列</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>顺序储存结构</li>
<li>链式储存结构<ul>
<li>单链表</li>
<li>静态链表</li>
<li>循环链表</li>
<li>双向链表</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="顺序储存结构"><a href="#顺序储存结构" class="headerlink" title="顺序储存结构"></a>顺序储存结构</h3><ul>
<li>宏定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></div><div class="line"><span class="comment">//静态链表的最大空间</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_MAXSIZE 1000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</div></pre></td></tr></table></figure>
<ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 顺序储存结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">&#125; SqList;</div></pre></td></tr></table></figure>
<h4 id="获得元素"><a href="#获得元素" class="headerlink" title="获得元素"></a>获得元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">getElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length || L.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = L.data[i - <span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><h5 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h5><ul>
<li>如果插入位置不合理，抛出异常</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或者动态扩容</li>
<li>从最后一个元素开始向前遍历到第ｉ的位置，分别将他们向后移动一个位置</li>
<li>将要插入的元素填入到位置i处</li>
<li>表长 + 1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">insert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (L.length == MAXSIZE) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (L.length &gt;= i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--) &#123;</div><div class="line">            L.data[j + <span class="number">1</span>] = L.data[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    L.data[i - <span class="number">1</span>] = e;</div><div class="line">    L.length++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>如果删除的位置不合理，抛出异常</li>
<li>去出删除的元素</li>
<li>从删除的元素开始遍历到最后一个元素，分别将他们都向前移动一个位置<br>*表长 - 1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">deleteElem</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    e = L.data[i - <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(i &lt; L.length) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &lt;= L.length; ++j) &#123;</div><div class="line">            L.data[j] = L.data[j + <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    L.length--;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最好情况下，如果插入的元素是最后一个，或者删除的元素是最后一个，意味着元素不用移动，那么时间复杂度为O(1)。</li>
<li>最坏情况，如果插入的元素在第一个，或者删除的元素在第一个，那么意味着全部元素将要向前或者向后移动，时间复杂度为O(n)。</li>
<li>平均情况： 时间复杂度为O(n)</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>快速存取表中的任一元素</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>插入和删除需要大量移动元素</li>
<li>当线性表长度变化较大时，难以确定储存空间</li>
</ul>
<h3 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h3><ul>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 链式储存结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ElemType e;</div><div class="line">    <span class="keyword">struct</span> Node *next;</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">&#125; Node, *LinkList;</div></pre></td></tr></table></figure>
<h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><h5 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一个指针ｐ指向链表第一个结点，初始化ｊ从１开始 </li>
<li>当ｊ&lt;ｉ时，就遍历链表，让ｐ的指针向后移动，不断指向下一个结点，ｊ累加１</li>
<li>若到链表末尾ｐ为空，则说明第ｉ个结点不存在</li>
<li>否则查找成功，返回结点ｐ的数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lGetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    LinkList p;</div><div class="line">    p = L-&gt;next;</div><div class="line">    j = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!p || j &gt; i) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    e = p-&gt;e;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><h5 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h5><ul>
<li>声明一指针指向链表头结点，初始化ｊ从１开始</li>
<li>当ｊ&lt;ｉ时，遍历链表，让ｐ的指针向后移动，不断指向下一个结点，ｊ累加１</li>
<li>若到链表末尾为空，则说明第ｉ的结点不存在</li>
<li>否则查找成功，在系统中生成一个空的结点ｓ</li>
<li>将数据元素ｅ赋值给ｓ－&gt;data</li>
<li>进行单链表插入操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lInsertElem</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">    LinkList p;</div><div class="line">    p = L-&gt;next;</div><div class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//第i个结点不存在</span></div><div class="line">    <span class="keyword">if</span>(!p || j &gt; i) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    LinkList s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    s-&gt;e = e;</div><div class="line">    s-&gt;next = p-&gt;next;</div><div class="line">    p-&gt;next = s;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><h5 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一指针指向链表头结点，初始化ｊ从１开始</li>
<li>当ｊ&lt;ｉ时，遍历链表，让ｐ的指针向后移动，不断指向下一个结点，ｊ累加１</li>
<li>若到链表末尾为空，则说明第ｉ的结点不存在</li>
<li>若查找成功，将欲删除的结点p-&gt;next赋值给ｑ</li>
<li>删除结点</li>
<li>将ｑ结点中的数据赋值给ｅ并返回</li>
<li>释放ｑ结点</li>
<li>返回成功</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lDeleteElem</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">    LinkList p, q;</div><div class="line"></div><div class="line">    p = L;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i) &#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j &gt; i) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    q = p-&gt;next;</div><div class="line">    p-&gt;next = q-&gt;next;</div><div class="line">    e = q-&gt;e;</div><div class="line">    <span class="built_in">free</span>(q);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建单链表"><a href="#创建单链表" class="headerlink" title="创建单链表"></a>创建单链表</h4><h5 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一指针ｐ和计数器变量ｉ</li>
<li>初始化空链表Ｌ</li>
<li>让空链表的头结点指向ＮＵＬＬ，即建立头结点</li>
<li>循环创建结点</li>
<li>头插法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lCreateLinkListHead</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    LinkList p;</div><div class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == L) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    L-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</div><div class="line">        p = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == p) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        p-&gt;e = <span class="number">0</span>;</div><div class="line">        <span class="comment">//插到表头</span></div><div class="line">        p-&gt;next = L-&gt;next;</div><div class="line">        L-&gt;next = p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>尾插法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lCreateLinkListTail</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    LinkList p,r;</div><div class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    L-&gt;next;</div><div class="line">    r = L; <span class="comment">//表尾</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        p = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        r-&gt;next = p;</div><div class="line">        r = p;</div><div class="line">    &#125;</div><div class="line">    r-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表的整体删除"><a href="#单链表的整体删除" class="headerlink" title="单链表的整体删除"></a>单链表的整体删除</h4><h5 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>声明一个结点ｐ和ｑ</li>
<li>将第一个结点赋值给ｐ</li>
<li>循环<ul>
<li>将下一个结点赋值给ｑ</li>
<li>释放ｑ</li>
<li>将ｑ赋值给ｐ</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">lClearLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</div><div class="line">    LinkList p, q;</div><div class="line">    p = L-&gt;next;</div><div class="line">    <span class="keyword">while</span>(p) &#123;</div><div class="line">        q = p-&gt;next;</div><div class="line">        <span class="built_in">free</span>(p);</div><div class="line">        p = q;</div><div class="line">    &#125;</div><div class="line">    L-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h4><ul>
<li>顺序储存结构用一端连续的储存单元储存元素</li>
<li>单链表用链式储存元素</li>
</ul>
<h4 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li>顺序结构：O(1)</li>
<li>链式储存结构O(n)</li>
</ul>
<h5 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h5><ul>
<li>顺序储存结构需要平均移动毕表长的一半，时间为O(n)</li>
<li>单链表在线出某个位置指针后，插入和删除为O(1)</li>
</ul>
<h5 id="空间性能"><a href="#空间性能" class="headerlink" title="空间性能"></a>空间性能</h5><ul>
<li>顺序结构需要预分配储存空间，分大了浪费，分小了溢出</li>
<li>单链表可以实时分配空间</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><ul>
<li>用数组描述的链表，是为了解决一个语言中没有指针的问题</li>
<li>结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用数组实现的静态链表</div><div class="line"> */</div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">     ElemType data;</div><div class="line">     <span class="keyword">int</span> cur; <span class="comment">//游标,为0时表示无指向</span></div><div class="line">     <span class="keyword">int</span> length;</div><div class="line"> &#125; StaticLinkList[STATIC_MAXSIZE];</div></pre></td></tr></table></figure>
<ul>
<li>通常把未被使用的数组称为备用链表</li>
<li>数组的第一个元素的cur存放备用链表的第一个结点下标</li>
<li>数组最后一个元素的cur存放第一个元素的下标，相当与头结点</li>
<li>初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">initStaticLinkList</span><span class="params">(StaticLinkList &amp;L)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; STATIC_MAXSIZE - <span class="number">1</span>; ++i) &#123;</div><div class="line">        L[i].cur = i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    L[STATIC_MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;</div><div class="line">    L-&gt;length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">freeIndex</span><span class="params">(StaticLinkList &amp;L, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    L[k].cur = L[<span class="number">0</span>].cur; <span class="comment">//把第一个元素从cur赋值给要删除的cur分量</span></div><div class="line">    L[<span class="number">0</span>].cur = k;</div><div class="line">&#125;</div><div class="line"><span class="function">status <span class="title">staticDelete</span><span class="params">(StaticLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> k = STATIC_MAXSIZE - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; ++j) &#123;</div><div class="line">        k = L[k].cur;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    j = L[k].cur;</div><div class="line">    L[k].cur = L[j].cur;</div><div class="line">    freeIndex(L, j);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function">status <span class="title">staticInsert</span><span class="params">(StaticLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = STATIC_MAXSIZE - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> j = mallocFreeIndex(L);</div><div class="line">    <span class="keyword">if</span>(j) &#123;</div><div class="line">        L[j].data = e;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; ++l) &#123;</div><div class="line">            k = L[k].cur;</div><div class="line">        &#125;</div><div class="line">        L[j].cur = L[k].cur;</div><div class="line">        L[k].cur = j;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">status <span class="title">mallocFreeIndex</span><span class="params">(StaticLinkList &amp;L)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = L[<span class="number">0</span>].cur; <span class="comment">//当前数组第一个元素的cur值，就是返回第一个备用空闲下表</span></div><div class="line">    <span class="keyword">if</span>(L[<span class="number">0</span>].cur) &#123;</div><div class="line">        L[<span class="number">0</span>].cur = L[i].cur; <span class="comment">//设置下一个空闲下表分量</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>在插入和删除元素时，只需移动修改下标，从而改进顺序储存结构中插入和删除元素需要大量移动元素的缺点</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没有解决难以确定表长的缺点</li>
<li>失去了顺序储存结构中随机存取元素的特性</li>
</ul>
<blockquote>
<p>以上笔记来源《大话数据结构》中<br><a href="https://github.com/cristianoro7/data-structure-practice" target="_blank" rel="external">源码</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java基础]]></title>
      <url>http://cristianoro7.github.io/2017/03/03/java%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="使用-连接字符串"><a href="#使用-连接字符串" class="headerlink" title="使用+连接字符串"></a>使用+连接字符串</h4><ul>
<li>使用+连接字符串每次都会构建一个新的对象，在需要频繁拼接字符串的场景时，会比较耗时和浪费空间，因为String创建后就不可以再改变，因此+ 操作是线程安全的</li>
</ul>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><ul>
<li>该类可以解决String拼接字符串时出现的问题，但是StringBuilder线程不安全。</li>
</ul>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><ul>
<li>StringBuilder可以保证线程安全，但是也因此效率变得低</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>如果只需要简单的拼接字符串的话，可以直接使用+号拼接</li>
<li>如果需要频繁拼接而且无需考虑线程安全的，可以使用StringBuilder</li>
<li>如果需要频繁拼接但要考虑到线程安全的话，可以使用StringBuffer<a id="more"></a>
<h3 id="对象与克隆"><a href="#对象与克隆" class="headerlink" title="对象与克隆"></a>对象与克隆</h3></li>
</ul>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul>
<li>只能对类中的基本数据进行拷贝，类中的对象还是引用原对象</li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul>
<li>通过重写clone使得类中的子对象也能进行克隆</li>
<li>深拷贝步骤：<ul>
<li>实现Cloneable接口（该接口只是拷贝的标记接口）</li>
<li>使用public访问修饰符重新定义clone方法</li>
</ul>
</li>
</ul>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><ul>
<li>异常对象都派生于Throwable类</li>
<li>Throwable分为Error和Exception</li>
</ul>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ul>
<li>Error层次结构描述了java运行时系统内部错误和资源耗尽错误，这种情况很少出现</li>
</ul>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><ul>
<li>Exception派生出两个分支，一个是RuntimeException，另外一个是其他异常</li>
<li>划分规则：由程序导致的是RuntimeExeption；而程序本身没有问题，但由像I/O错误这类问题导致的异常属于其他异常</li>
</ul>
<h4 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h4><ul>
<li>java语言规范：将派生于Error或者RuntimeException类的所有异常称为未检查异常，所有其他异常称为已检查异常。</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>final通常指的是不可改变的, 不想改变的原因往往出于两种原因：设计和效率</li>
<li>final可能使用到的情况：数据、方法和类</li>
</ul>
<h4 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h4><ul>
<li>一个既是static又是final的数据只占一段不能改变的内存空间，如果final定义的变量是引用类型的话，表明该引用一定被初始化指向一个对象后，就不能再更改引用，但是可以对象自身是可以被修改的</li>
</ul>
<h4 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h4><ul>
<li>当参数被声明为final时，意味着你不能修改其值，只能读取，这一特性主要用来向匿名内部类传递数据</li>
</ul>
<h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><ul>
<li>使用final方法有两个原因：<ul>
<li>把方法锁定，以防止任何继承类来修改它的含义，这是处于设计的考虑</li>
</ul>
</li>
<li>出于效率的考虑（由于虚拟机的优化，通常已经不需要final来进行优化）</li>
</ul>
<h4 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a>final和private关键字</h4><ul>
<li>类中所有private方法都隐式地指定为final。由于无法取用private，也就无法覆盖它</li>
</ul>
<h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><ul>
<li>当一个类被定义为final时，就表明你不打算继承该类了，这是出于设计或者安全的考虑<blockquote>
<p>参考资料：java核心技术，java编程思想</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解HTTP-确认访问用户的身份-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/02/21/%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E7%9A%84%E8%BA%AB%E4%BB%BD-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>﻿### HTTP使用的认证方式</p>
<ul>
<li>BASIC认证(基本认证)</li>
<li>DIGEST(摘要认证)</li>
<li>SSL客户端认证</li>
<li>FormBase认证(基于表单认证)</li>
</ul>
<h4 id="BASIC认证步骤"><a href="#BASIC认证步骤" class="headerlink" title="BASIC认证步骤"></a>BASIC认证步骤</h4><p><img src="/uploads/图解HTTP/确保Web安全的HTTPS01.jpg" alt=""></p>
<a id="more"></a>
<p>步骤1:当请求的资源需要 BASIC 认证时,服务器会随状态码 401Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式(BASIC) 及 Request-URI 安全域字符串(realm)。</p>
<p>步骤2:接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成,两者中间以冒号(:)连接后,再经过 Base64 编码处理。</p>
<p>步骤3:接收到包含首部字段 Authorization 请求的服务器,会对认证信息的正确性进行验证。如验证通过,则返回一条包含 Request-URI资源的响应。</p>
<ul>
<li>BASIC 认证虽然采用 Base64 编码方式,但这不是加密处理。不需要任何附加信息即可对其解码。换言之,由于明文解码后就是用户 ID和密码,在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中,如果被人窃听,被盗的可能性极高。</li>
<li>另外,除此之外想再进行一次 BASIC 认证时,一般的浏览器却无法实现认证注销操作,这也是问题之一。</li>
<li>BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用</li>
</ul>
<h4 id="DIGEST-认证"><a href="#DIGEST-认证" class="headerlink" title="DIGEST 认证"></a>DIGEST 认证</h4><ul>
<li>DIGEST 认证同样使用质询 / 响应的方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS02.jpg" alt=""></p>
<ul>
<li>DIGEST 认证的认证步骤</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS03.jpg" alt=""></p>
<p>步骤 1: 请求需认证的资源时,服务器会随着状态码 401Authorization Required,返 回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码(随机数,nonce)。首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式,但实际内容依赖服务器的具体实现。</p>
<p>步骤 2: 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。</p>
<p>步骤 3: 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。</p>
<h4 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a>SSL 客户端认证</h4><ul>
<li>如果用户 ID 和密码被盗,就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。</li>
<li>为达到 SSL 客户端认证的目的,需要事先将客户端证书分发给客户端,且客户端必须安装此证书。</li>
</ul>
<p>步骤1: 接收到需要认证资源的请求,服务器会发送 CertificateRequest 报文,要求客户端提供客户端证书。</p>
<p>步骤 2: 用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p>
<p>步骤 3: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通信。</p>
<ul>
<li>SSL客户端认证一般会结合表单一起认证</li>
</ul>
<h4 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h4><ul>
<li>基于表单认证的标准规范尚未有定论,一般会使用 Cookie 来管理Session(会话)。</li>
<li>为了弥补 HTTP 协议中不存在的状态管理功能,我们会使用 Cookie 来管理 Session</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS04.jpg" alt=""></p>
<p>步骤1: 客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务器。而这时,会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。</p>
<p>步骤 2: 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证,然后把用户的认证状态与Session ID 绑定后记录在服务器端。</p>
<p>另外,为减轻跨站脚本攻击(XSS)造成的损失,建议事先在 Cookie内加上 httponly 属性。</p>
<p>步骤 3: 客户端接收到从服务器端发来的 Session ID 后,会将其作为Cookie 保存在本地。下次向服务器发送请求时,浏览器会自动发送Cookie,所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</p>
<ul>
<li>由于服务端没有如何保存用户的密码,因此,一种安全的保存方法是,先利用给密码加盐(salt) 1 的方式增加额外信息,再使用散列(hash)函数计算出散列值后保存。</li>
<li>salt 其实就是由服务器随机生成的一个字符串,但是要保证长度足够长,并且是真正随机生成的。然后把它和密码字符串相连接(前后都可以)生成散列值。当两个用户使用了同一个密码时,由于随机生成的 salt 值不同,对应的散列值也将是不同的。这样一来,很大程度上减少了密码特征,攻击者也就很难利用自己手中的密码特征库进行破解。</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解HTTP-报文信息-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E6%8A%A5%E6%96%87%E4%BF%A1%E6%81%AF-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h3><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><ul>
<li>用于HTTP协议交互的信息被称为报文</li>
<li>请求端（客户端）的HTTP报文称为请求报文</li>
<li>相应端（服务器端）的HTTP报文称为响应报文</li>
<li>HTTP报文分为报文首部和报文主体（不一定有报文主体）</li>
</ul>
<h5 id="HTTP报文结构："><a href="#HTTP报文结构：" class="headerlink" title="HTTP报文结构："></a>HTTP报文结构：</h5><p><img src="/uploads/图解HTTP/ 01.jpg" alt=""></p>
<a id="more"></a>
<h4 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h4><h5 id="请求报文和响应报文结构："><a href="#请求报文和响应报文结构：" class="headerlink" title="请求报文和响应报文结构："></a>请求报文和响应报文结构：</h5><p><img src="/uploads/图解HTTP/02.jpg" alt=""></p>
<h5 id="响应的实例"><a href="#响应的实例" class="headerlink" title="响应的实例"></a>响应的实例</h5><p><img src="/uploads/图解HTTP/03.jpg" alt=""></p>
<h4 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h4><ul>
<li>HTT在传输数据时可以直接将数据原貌传输，但也可以在传输的过程中通过编码来提升传输效率。虽然编码传输可以提升传输效率，但是编码的过程是由计算机来完成，所以会比较消耗计算机的ｃｐｕ资源</li>
</ul>
<h5 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h5><ul>
<li>报文（Message）：是 HTTP 通信中的基本单位,由 8 位组字节流(octet sequence,其中 octet 为 8 个比特)组成,通过 HTTP 通信传输。</li>
<li>实体（entity）：作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成。</li>
<li>通常情况下，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化时，才导致它和报文主体产生差异。</li>
</ul>
<h5 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h5><ul>
<li>内容编码指明应用在实体内容上的编码，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</li>
</ul>
<p><img src="/uploads/图解HTTP/04.jpg" alt=""></p>
<ul>
<li>内容编码的常用格式：<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>ide ntity（不进行编码）</li>
</ul>
</li>
</ul>
<h5 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h5><ul>
<li>把实体分块的功能称为分块传输功能（Chunked Transfer Coding）。该功能适应于大数据量传输时，可以逐步的显示内容，不必让用户等待太久</li>
</ul>
<p><img src="/uploads/图解HTTP/05.jpg" alt=""></p>
<h5 id="发送多种数据的多部分集合"><a href="#发送多种数据的多部分集合" class="headerlink" title="发送多种数据的多部分集合"></a>发送多种数据的多部分集合</h5><ul>
<li>发送报文的主体内包含多类型实体</li>
<li>多部分对象集合包含的对象如下：<ul>
<li>multipart/form-data:在 Web 表单文件上传时使用。</li>
<li>multipart/byteranges:状态码 206(Partial Content,部分内容)响应报文包含了多个范围的内容时使用。</li>
</ul>
</li>
</ul>
<h5 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h5><ul>
<li>范围请求指的是对一份字节资源，进行部分范围内的请求</li>
</ul>
<p><img src="/uploads/图解HTTP/06.jpg" alt=""></p>
<ul>
<li>执行请求时可以根据Range首部字段来指定字节的范围：<ul>
<li>5001~10 000 字节<br><code>Range: bytes=5001-10000</code></li>
</ul>
</li>
<li>请求范围的返回状态码为206 Partial Content的响应报文。</li>
<li>另外,对于多重范围的范围请求,响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</li>
<li>如果服务器端无法响应范围请求,则会返回状态码 200 OK 和完整的实体内容。</li>
</ul>
<h5 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h5><ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Picasso中值得学习的技巧]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/Picasso%E4%B8%AD%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h4 id="Picasso中的线程池"><a href="#Picasso中的线程池" class="headerlink" title="Picasso中的线程池"></a>Picasso中的线程池</h4><ul>
<li>Picasso中的线程池主要是对对网络状态进行了监听,并且包装了一个FutureTask实现请求的优先级比较。</li>
</ul>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h5><ul>
<li>首先在Picasso中,定义了一个优先级枚举类型:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * The priority of a request.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@see</span> RequestCreator#priority(Priority)</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</div><div class="line">    LOW,</div><div class="line">    NORMAL,</div><div class="line">    HIGH</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<a id="more"></a> 
<ul>
<li>上面的priority就是请求优先级的类型。</li>
<li><p>有了优先级,我们就可以在创建Request的时候这只设置优先等级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Set the priority of this request.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * This will affect the order in which the requests execute but does not guarantee it.</div><div class="line">   * By default, all requests have &#123;<span class="doctag">@link</span> Priority#NORMAL&#125; priority, except for</div><div class="line">   * &#123;<span class="doctag">@link</span> #fetch()&#125; requests, which have &#123;<span class="doctag">@link</span> Priority#LOW&#125; priority by default.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> RequestCreator <span class="title">priority</span><span class="params">(Priority priority)</span> </span>&#123;</div><div class="line">    data.priority(priority);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过阅读上面的代码,我们知道可以这样来设置请求的优先等级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(url)</div><div class="line">                .priority(Picasso.Priority.HIGH)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>需要主要的是,虽然设置了优先等级,但是并不是绝对的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hunter.future = service.submit(hunter);</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到,BitmapHunter被提交到了Picasso的线程池,我们进去其中的sumbit(BitmapHunter)方法中看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">    PicassoFutureTask ftask = <span class="keyword">new</span> PicassoFutureTask((BitmapHunter) task);</div><div class="line">    execute(ftask);</div><div class="line">    <span class="keyword">return</span> ftask;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>传进来的BitmapHunter被包装成了一个PicassoFutureTask,在PicassoFutureTask中重写compareTo(PicassoFutureTask other)实现优先级的比较:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PicassoFutureTask other)</span> </span>&#123;</div><div class="line">      Picasso.Priority p1 = hunter.getPriority();</div><div class="line">      Picasso.Priority p2 = other.hunter.getPriority();</div><div class="line">      <span class="comment">/* High-priority requests are "lesser" so they are sorted to the front.*/</span></div><div class="line">      <span class="comment">/* Equal priorities are sorted by sequence number to provide FIFO ordering.*/</span></div><div class="line">      <span class="keyword">return</span> (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们再看看线程池中对网络状态的监听:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustThreadCount</span><span class="params">(NetworkInfo info)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span> || !info.isConnectedOrConnecting()) &#123;</div><div class="line">      setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span> (info.getType()) &#123;</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_WIFI:</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_WIMAX:</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_ETHERNET:</div><div class="line">        setThreadCount(<span class="number">4</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_MOBILE:</div><div class="line">        <span class="keyword">switch</span> (info.getSubtype()) &#123;</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_LTE:  <span class="comment">/* 4G*/</span></div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_HSPAP:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EHRPD:</div><div class="line">            setThreadCount(<span class="number">3</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_UMTS: <span class="comment">/*3G*/</span></div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_CDMA:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_0:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_A:</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_B:</div><div class="line">            setThreadCount(<span class="number">2</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_GPRS: <span class="comment">/* 2G*/</span></div><div class="line">          <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EDGE:</div><div class="line">            setThreadCount(<span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">default</span>:</div><div class="line">            setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>adjustThreadCount方法中根据传进来的NetworkInfo来判断当前手机网络的状态,分别在4G,3G,2G的情况下调整线程数</p>
</li>
<li>传进来的网络状态是在创建分发器的时候注册的广播:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);</div><div class="line">   <span class="keyword">this</span>.receiver = <span class="keyword">new</span> NetworkBroadcastReceiver(<span class="keyword">this</span>);</div><div class="line">   receiver.register();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Picasso中加载适应图片的宽高"><a href="#Picasso中加载适应图片的宽高" class="headerlink" title="Picasso中加载适应图片的宽高"></a>Picasso中加载适应图片的宽高</h4><ul>
<li><p>我们知道,当我们加载图片时,如果图片的大小与我们ImageView的规格不符合的时候,加载出来的图片的效果是很差的。因此,Picasso也提供了方法给我们调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(url)</div><div class="line">               .fit()</div><div class="line">                .priority(Picasso.Priority.HIGH)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>我们只要添加fit方法时,就能够实现宽高自适应。接下来我们看看Picasso是怎么实现这个功能。</p>
</li>
<li><p>既然是添加了fit()方法,那么我们先进入fit方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Internal use only. Used by &#123;<span class="doctag">@link</span> DeferredRequestCreator&#125;. */</span></div><div class="line">  <span class="function">RequestCreator <span class="title">fit</span><span class="params">()</span> </span>&#123;</div><div class="line">    deferred = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中仅仅只是对deferred = true; 在上一篇的源码分析中,在into(ImageView)中,有deferred出现的身影,我们来看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (deferred) &#123;</div><div class="line">      <span class="keyword">if</span> (data.hasSize()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with resize."</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> width = target.getWidth();</div><div class="line">      <span class="keyword">int</span> height = target.getHeight();</div><div class="line">      <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">          setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">        &#125;</div><div class="line">        picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      data.resize(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = createRequest(started);</div><div class="line">    String requestKey = createKey(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        picasso.cancelRequest(target);</div><div class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">"from "</span> + MEMORY);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">          callback.onSuccess();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">      setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Action action =</div><div class="line">        <span class="keyword">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</div><div class="line">            errorDrawable, requestKey, tag, callback, noFade);</div><div class="line">    picasso.enqueueAndSubmit(action);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面的代码节选自 into(ImageView)方法,deferred默认值是false,因此默认情况下是不会进入if语句块的,但是当我们调用了fit()后,deferred被设置为true,所以当我们调用into是时候,会进入if语句块。接着,调用了<code>picasso.defer(target, new DeferredRequestCreator(this, target, callback));</code></p>
</li>
<li><p>我们进入DeferredRequestCreator对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeferredRequestCreator</span> <span class="keyword">implements</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnPreDrawListener</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">final</span> RequestCreator creator;</div><div class="line">  <span class="keyword">final</span> WeakReference&lt;ImageView&gt; target;</div><div class="line">  Callback callback;</div><div class="line"></div><div class="line">  <span class="meta">@TestOnly</span> DeferredRequestCreator(RequestCreator creator, ImageView target) &#123;</div><div class="line">    <span class="keyword">this</span>(creator, target, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  DeferredRequestCreator(RequestCreator creator, ImageView target, Callback callback) &#123;</div><div class="line">    <span class="keyword">this</span>.creator = creator;</div><div class="line">    <span class="keyword">this</span>.target = <span class="keyword">new</span> WeakReference&lt;ImageView&gt;(target);</div><div class="line">    <span class="keyword">this</span>.callback = callback;</div><div class="line">    target.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    ViewTreeObserver vto = target.getViewTreeObserver();</div><div class="line">    <span class="keyword">if</span> (!vto.isAlive()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> width = target.getWidth();</div><div class="line">    <span class="keyword">int</span> height = target.getHeight();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vto.removeOnPreDrawListener(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>.creator.unfit().resize(width, height).into(target, callback);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    ViewTreeObserver vto = target.getViewTreeObserver();</div><div class="line">    <span class="keyword">if</span> (!vto.isAlive()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    vto.removeOnPreDrawListener(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>DeferredRequestCreator实现了ViewTreeObserver.OnPreDrawListener接口,拿到ImageView宽高后,再接调用<code>this.creator.unfit().resize(width, height).into(target, callback);</code></p>
</li>
<li>unfit()方法中仅仅对deferred设置为false,当再次调用into的方法时,也就不会进入if语句块,接着调用了resize(width, height)将得到ImageView的宽高设置到请求中,最后调用into进行重新加载。</li>
</ul>
<h4 id="Picasso中-通过设置Tag对图片进行生命周期的管理"><a href="#Picasso中-通过设置Tag对图片进行生命周期的管理" class="headerlink" title="Picasso中,通过设置Tag对图片进行生命周期的管理"></a>Picasso中,通过设置Tag对图片进行生命周期的管理</h4><ul>
<li><p>通过上一篇源码分析知道,我们可以通过设置tag来管理图片的生命周期,接下来我们来分析其中的实现,先点进入tag(Object)来看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Assign a tag to this request. Tags are an easy way to logically associate</div><div class="line">   * related requests that can be managed together e.g. paused, resumed,</div><div class="line">   * or canceled.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * You can either use simple &#123;<span class="doctag">@link</span> String&#125; tags or objects that naturally</div><div class="line">   * define the scope of your requests within your app such as a</div><div class="line">   * &#123;<span class="doctag">@link</span> android.content.Context&#125;, an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, or a</div><div class="line">   * &#123;<span class="doctag">@link</span> android.app.Fragment&#125;.</div><div class="line">   *</div><div class="line">   * &lt;strong&gt;WARNING:&lt;/strong&gt;: Picasso will keep a reference to the tag for</div><div class="line">   * as long as this tag is paused and/or has active requests. Look out for</div><div class="line">   * potential leaks.</div><div class="line"></div><div class="line">   *</div><div class="line">   * <span class="doctag">@see</span> Picasso#cancelTag(Object)</div><div class="line">   * <span class="doctag">@see</span> Picasso#pauseTag(Object)</div><div class="line">   * <span class="doctag">@see</span> Picasso#resumeTag(Object)</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> RequestCreator <span class="title">tag</span><span class="params">(Object tag)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tag == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Tag invalid."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tag != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Tag already set."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.tag = tag;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中的tag最好是Activity和Fragment,因为Fragment和Activity的生命周期系统自动帮我们管理好了,把tag设置为它们的话,我们只要根据它们的生命周期来调用Picasso#cancelTag(Object)、Picasso#pauseTag(Object)、Picasso#resumeTag(Object)</p>
</li>
<li><p>设置玩tag后,当我们要暂停加载时,可以调用Picasso#pauseTag(Object),接着Picasso再调用分发器的<code>dispatcher.dispatchPauseTag(tag);</code>,dispatchPauseTag(tag)中又通过Handler发送一条<code>TAG_PAUSE</code>的消息,Handler接受到消息后,回调分发器的<code>dispatcher.performResumeTag(tag);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performPauseTag</span><span class="params">(Object tag)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Trying to pause a tag that is already paused.*/</span></div><div class="line">    <span class="keyword">if</span> (!pausedTags.add(tag)) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Go through all active hunters and detach/pause the requests*/</span></div><div class="line">    <span class="comment">/* that have the paused tag.*/</span></div><div class="line">    <span class="keyword">for</span> (Iterator&lt;BitmapHunter&gt; it = hunterMap.values().iterator(); it.hasNext();) &#123;</div><div class="line">      BitmapHunter hunter = it.next();</div><div class="line">      <span class="keyword">boolean</span> loggingEnabled = hunter.getPicasso().loggingEnabled;</div><div class="line"></div><div class="line">      Action single = hunter.getAction();</div><div class="line">      List&lt;Action&gt; joined = hunter.getActions();</div><div class="line">      <span class="keyword">boolean</span> hasMultiple = joined != <span class="keyword">null</span> &amp;&amp; !joined.isEmpty();</div><div class="line">      <span class="comment">/* Hunter has no requests, bail early.*/</span></div><div class="line">      <span class="keyword">if</span> (single == <span class="keyword">null</span> &amp;&amp; !hasMultiple) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (single != <span class="keyword">null</span> &amp;&amp; single.getTag().equals(tag)) &#123;</div><div class="line">        hunter.detach(single);</div><div class="line">        pausedActions.put(single.getTarget(), single);</div><div class="line">        <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">          log(OWNER_DISPATCHER, VERB_PAUSED, single.request.logId(),</div><div class="line">              <span class="string">"because tag '"</span> + tag + <span class="string">"' was paused"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (hasMultiple) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = joined.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">          Action action = joined.get(i);</div><div class="line">          <span class="keyword">if</span> (!action.getTag().equals(tag)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          hunter.detach(action);</div><div class="line">          pausedActions.put(action.getTarget(), action);</div><div class="line">          <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">                <span class="string">"because tag '"</span> + tag + <span class="string">"' was paused"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/*/ Check if the hunter can be cancelled in case all its requests*/</span></div><div class="line">      <span class="comment">/* had the tag being paused here.*/</span></div><div class="line">      <span class="keyword">if</span> (hunter.cancel()) &#123;</div><div class="line">        it.remove();</div><div class="line">        <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">          log(OWNER_DISPATCHER, VERB_CANCELED, getLogIdsForHunter(hunter), <span class="string">"all actions paused"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中将Tag缓存在pausedActions这个Map中</p>
</li>
<li><p>设置了暂停后,如果请求在加载过程中,会被停止。我们可以看<code>performSubmit</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</div><div class="line">      pausedActions.put(action.getTarget(), action);</div><div class="line">      <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">            <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最先判断pausedTags中是否存在Action携带的tag,如果存在的话,把Action缓存到pausedActions中,便于恢复,接着就直接return;从而实现了不加载图片。</p>
</li>
<li>暂停的Action被缓存到了pausedActions中,因此当我们要恢复的时候,就可以去该map中拿去。</li>
<li><p>恢复tag的调用路程的跟暂停基本是同一个套路,最后<code>performResumeTag(Object tag)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performResumeTag</span><span class="params">(Object tag)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Trying to resume a tag that is not paused.*/</span></div><div class="line">    <span class="keyword">if</span> (!pausedTags.remove(tag)) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Action&gt; batch = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (Iterator&lt;Action&gt; i = pausedActions.values().iterator(); i.hasNext();) &#123;</div><div class="line">      Action action = i.next();</div><div class="line">      <span class="keyword">if</span> (action.getTag().equals(tag)) &#123;</div><div class="line">        <span class="keyword">if</span> (batch == <span class="keyword">null</span>) &#123;</div><div class="line">          batch = <span class="keyword">new</span> ArrayList&lt;Action&gt;();</div><div class="line">        &#125;</div><div class="line">        batch.add(action);</div><div class="line">        i.remove();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (batch != <span class="keyword">null</span>) &#123;</div><div class="line">      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过遍历从<code>pausedActions</code>中取出Actions,再发送一条恢复的消息,最后会调用到<code>resumeAction(Action action)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resumeAction</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(action.memoryPolicy)) &#123;</div><div class="line">      bitmap = quickMemoryCacheCheck(action.getKey());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">/* Resumed action is cached, complete immediately.*/</span></div><div class="line">      deliverAction(bitmap, MEMORY, action);</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), <span class="string">"from "</span> + MEMORY);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/* Re-submit the action to the executor.*/</span></div><div class="line">      enqueueAndSubmit(action);</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_RESUMED, action.request.logId());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先会尝试从内存缓存中读取Bitmap,不存在的话,再调用<code>enqueueAndSubmit(action);</code>去排队加载图片,过程在上一篇中已经分析了,这里不多介绍。</p>
</li>
<li>值得注意的是,当图片正在加载和暂停加载图片时,Picasso会持有tag,如果我们设置的tag是Activity或者Fragment的话,如果不Activity或者Fragment销毁时,如果不取消tag的话,就会造成内存泄露。</li>
<li>总结:<ul>
<li>如果我们要设置tag的话,最好就是设置为Activity或者Fragment,因为系统管理了它们的声明周期,我们只要跟随它们的生命周期来调用暂停、恢复、取消操作就行。</li>
<li>在Activity或者Fragment暂停时,应当调用pauseTag,位于前台的时候再resumeTag,当Activity或者Fragment销毁时调用cancelTag释放持有的tag对象等一系列操作。</li>
</ul>
</li>
</ul>
<h4 id="Picasso中对不同类型的请求的处理"><a href="#Picasso中对不同类型的请求的处理" class="headerlink" title="Picasso中对不同类型的请求的处理"></a>Picasso中对不同类型的请求的处理</h4><ul>
<li>我们知道Picasso不仅支持从网络上加载图片,还支持从Drawable,Asset,File等中加载图片。</li>
<li>那么Picasso是如何处理?</li>
</ul>
<h5 id="定义基类RequestHandler"><a href="#定义基类RequestHandler" class="headerlink" title="定义基类RequestHandler"></a>定义基类RequestHandler</h5><ul>
<li>Picasso中定义了抽象类RequestHandler,也就是请求处理器来。在请求处理器中,定义了canHandleRequest(Request data)方法让子类实现,同时也定义了loadload(Request request, int networkPolicy)让子类实现。</li>
<li><p>请求处理器派生而来的有七种处理器,这里只分析网络请求处理器,主要分析<code>canHandleRequest(Request data)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleRequest</span><span class="params">(Request data)</span> </span>&#123;</div><div class="line">    String scheme = data.uri.getScheme();</div><div class="line">    <span class="keyword">return</span> (SCHEME_HTTP.equals(scheme) || SCHEME_HTTPS.equals(scheme));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过判断URI的scheme是不是HTTP或者HTTPS,是的话,返回true,证明,该类型的请求在网络处理器的处理范围内。</p>
</li>
<li><p>接下来,我们来看看Picasso是如何进行请求处理器的筛选的,通过上一篇分析,我们知道,请求处理器的筛选是在forRequest方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> BitmapHunter <span class="title">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span></span></div><div class="line">      Action action) &#123;</div><div class="line">    Request request = action.getRequest();</div><div class="line">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</div><div class="line">    <span class="comment">/* Index-based loop to avoid allocating an iterator.*/</span></div><div class="line">    <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</div><div class="line">      RequestHandler requestHandler = requestHandlers.get(i);</div><div class="line">      <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码中的逻辑是这样的:先通过Picasso拿到预先实例化好的请求处理器集合,接着通过遍历来拿到请求处理器,拿到后再调用其<code>canHandleRequest(request)</code>方法,从而筛选出能处理这条请求的请求处理器。</p>
</li>
</ul>
<h4 id="Picasso中的BitmapHunter队列控制"><a href="#Picasso中的BitmapHunter队列控制" class="headerlink" title="Picasso中的BitmapHunter队列控制"></a>Picasso中的BitmapHunter队列控制</h4><ul>
<li>Picasso中的是在BitmapBunter将存放在List集合的基础上来控制队列的</li>
<li><p>在BitmapHunter的run方法中会将BitmapHunter通过分发器回调回分发器中,接着还是按照之前的老套路,通过Handler发送消息,最后来到<code>batch(BitmapHunter)</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    batch.add(hunter);</div><div class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</div><div class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中将BitmapHunter存放入List,接着通过通过Handler发送消息</p>
</li>
<li>if()语句的判断和句内的发送消息是整个队列的控制精华。为什么这么说?handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)如果返回false的话,证明没有请求在处理,所以直接发送一条延迟消息,如果返回true,那么不会进入if语句之内,也就不会被分发出去,只是被添加到了List集合内,等带下次有BitmapHunter进来是,且没有图片正在加载,才一起发送出去。而且发送的消息是发送延迟消息,这样也给了执行请求的一定的缓冲时间。</li>
<li><p>List<bitmaphunter>最终会被发送到Picasso中运行在主线程的Handler</bitmaphunter></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> HUNTER_BATCH_COMPLETE: &#123;</div><div class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</div><div class="line">         <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class="line">           BitmapHunter hunter = batch.get(i);</div><div class="line">           hunter.picasso.complete(hunter);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后通过遍历每个BitmapHunter来设置到Target上。</p>
</li>
</ul>
<h4 id="Picasso中的设计"><a href="#Picasso中的设计" class="headerlink" title="Picasso中的设计"></a>Picasso中的设计</h4><ul>
<li>Picasso中的设计思路是将加载图片这个任务细分出来许多个小任务,分配给对应的对象,比如:请求处理器,内存缓存器,下载器。</li>
<li>既然有这么对人干活,Picasso设计了分发器来指挥这些人干活。</li>
<li>分发器听谁的指令去指挥别人? 答案是Picasso,Picasso观察大局,有什么情况出现再分发器,分发器听到命令后,指挥对应的人员去工作,对应人员都干好各自的任务后,再告诉Dispatcher,最后Dispatcher汇报给Picasso。</li>
<li>整个框架能够井然有序的运行起来的关键是Handler,可以说Handler是整个框架能运行起来的能源。</li>
<li>Picasso中,将Handler的作用发挥得淋漓尽致。是Handler运用的典例。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解HTTP-简单的HTTP协议-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="通过请求和响应来交换信息"><a href="#通过请求和响应来交换信息" class="headerlink" title="通过请求和响应来交换信息"></a>通过请求和响应来交换信息</h4><p><img src="/uploads/图解HTTP/简单的HTTP协议01.jpg" alt=""><br><a id="more"></a></p>
<ul>
<li>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</li>
<li>请求报文的构成</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议02.jpg" alt=""></p>
<ul>
<li>响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议03.jpg" alt=""></p>
<h4 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h4><ul>
<li>HTTP协议自身不对请求和响应之间的状态进行保存, 也就是HTTP不对请求和响应做持久化处理</li>
<li>不保存状态这种设计的优点:更快的处理大量事物</li>
</ul>
<h4 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h4><ul>
<li>GET:获取资源</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议04.png" alt=""></p>
<ul>
<li>POST:传输实体主体</li>
<li>PUT:PUT 方法用来传输文件。就像 FTP 协议的文件上传一样,要求在请求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置。36但是,鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制,任何人都可以上传文件 , 存在安全性问题,因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制,或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web 网站,就可能会开放使用 PUT 方法。</li>
<li>HEAD:获得报文首部, 返回的不包含主体部分,常用于URI的有效期以及更新日期</li>
<li>OPTIONS:询问支持的方法, OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li>
<li>CONNECT:要求用隧道协议连接代理。CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP通信。主要使用 SSL(Secure Sockets Layer,安全套接层)和 TLS(Transport Layer Security,传输层安全)协议把通信内容加 密后经网络隧道传输。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议05.jpg" alt=""></p>
<h4 id="持久连接减少通信量"><a href="#持久连接减少通信量" class="headerlink" title="持久连接减少通信量"></a>持久连接减少通信量</h4><p>在HTTP协议初始的几个版本中, 每次HTTP请求都得断开一次, 这样TCP频繁的连接和断开会增加通信量的开销</p>
<p><img src="/uploads/图解HTTP/简单的HTTP协议06.jpg" alt=""></p>
<ul>
<li>为了解决该问题, 在HTTP1.1和部分HTTP1.0中想出了持久连接(HTTP Persistent Connections,也称为 HTTP keep-alive 或<br>HTTP connection reuse)的方法。该方法的特点是:只要任意一端没有明确提出断开连接,则保持 TCP 连接状态。</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议07.jpg" alt=""></p>
<ul>
<li>线管化技术<br>在之前的HTTP请求都是要一个请求完另外一个才能继续,但是持久化连接使得请求线管化成为了可能。即一次性可以请求多个</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议08.jpg" alt=""></p>
<h4 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h4><ul>
<li>HTTP是无状态协议,无状态指的是它不对之前发生的请求和响应进行管理。例如:一个需要登录的Web网站,无法对是否登录进行状态管理,每次跳转页面不是要重新登录就是要在报文中添加附加的数据来进行登录状态管理</li>
<li>无协议状态的优点:减少服务器的CPU及内存消耗</li>
<li>为了解决这一矛盾,由此引进了Cookie技术来进行状态管理</li>
</ul>
<h5 id="Cookie技术简介"><a href="#Cookie技术简介" class="headerlink" title="Cookie技术简介"></a>Cookie技术简介</h5><ul>
<li><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>
</li>
<li><p>服务器端发现客户端发送过来的Cookie后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息。</p>
</li>
<li>没有Cookie下的请求:</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议09.jpg" alt=""></p>
<ul>
<li>第 2 次以后(存有 Cookie 信息状态)的请求</li>
</ul>
<p><img src="/uploads/图解HTTP/简单的HTTP协议10.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解HTTP-确保Web安全的HTTPS-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/%E7%A1%AE%E4%BF%9DWeb%E5%AE%89%E5%85%A8%E7%9A%84HTTPS/</url>
      <content type="html"><![CDATA[<h3 id="HTTP存在的不足"><a href="#HTTP存在的不足" class="headerlink" title="HTTP存在的不足"></a>HTTP存在的不足</h3><ul>
<li>通信使用明文(不加密), 内容可能会被窃听</li>
<li>不验证对方身份,因此有可能遭遇伪装</li>
<li>无法证明报文的完整性,所以有可能遭到篡改</li>
</ul>
<h4 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h4><ul>
<li>HTTP本身是不具备加密的功能的,因此在发送报文时是采用明文传输.</li>
<li>如何采用明文进行传输的话,内容可以通过抓取传输时的数据包,再由工具进行解析,就可以得到通信的内容</li>
</ul>
<a id="more"></a>
<h4 id="不验证通信对方就有可能在遇到伪装"><a href="#不验证通信对方就有可能在遇到伪装" class="headerlink" title="不验证通信对方就有可能在遇到伪装"></a>不验证通信对方就有可能在遇到伪装</h4><ul>
<li>HTTP 协议的实现本身非常简单,不论是谁发送过来的请求都会返回响应,因此不确认通信方,会存在以下各种隐患。<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息,只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service,拒绝服务攻击)。</li>
</ul>
</li>
<li>查明对手的证书<ul>
<li>虽然使用 HTTP 协议无法确定通信方,但如果使用 SSL 则可以。SSL 不仅提供加密处理,而且还使用了一种被称为证书的手段,可用于确定方。</li>
</ul>
</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS01.jpg" alt=""></p>
<h4 id="无法证明报文完整性-可能已遭篡改"><a href="#无法证明报文完整性-可能已遭篡改" class="headerlink" title="无法证明报文完整性,可能已遭篡改"></a>无法证明报文完整性,可能已遭篡改</h4><h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3><h4 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h4><ul>
<li>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已。</li>
<li>通常,HTTP 直接和 TCP 通信。当使用 SSL 时,则演变成先和 SSL 通信,再由 SSL 和 TCP 通信了。简言之,所谓 HTTPS,其实就是身披SSL 协议这层外壳的 HTTP。</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS02.jpg" alt=""></p>
<h4 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h4><h5 id="共享密钥加密的困境"><a href="#共享密钥加密的困境" class="headerlink" title="共享密钥加密的困境"></a>共享密钥加密的困境</h5><ul>
<li>加密和解密同用一个密钥的方式称为共享密钥加密(Common keycrypto system),也被叫做对称密钥加密。</li>
<li>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交?在互联网上转发密钥时,如果通信被监听那么密钥就可会落入攻击者之手,同时也就失去了加密的意<br>义。另外还得设法安全地保管接收到的密钥。</li>
</ul>
<h5 id="使用两把密钥的公开密钥加密"><a href="#使用两把密钥的公开密钥加密" class="headerlink" title="使用两把密钥的公开密钥加密"></a>使用两把密钥的公开密钥加密</h5><ul>
<li>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)。顾名思义,私有密钥不能让其他任何人知道,而公开密钥则可以随意发<br>布,任何人都可以获得。</li>
<li>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密。利用这种方式,不需要发送用来解密的私有密钥,也<br>不必担心密钥被攻击者窃听而盗走。</li>
</ul>
<h5 id="HTTPS-采用混合加密机制"><a href="#HTTPS-采用混合加密机制" class="headerlink" title="HTTPS 采用混合加密机制"></a>HTTPS 采用混合加密机制</h5><ul>
<li>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</li>
<li>采用混合加密的机制是因为公开密钥加密的速度慢</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS03.jpg" alt=""></p>
<h4 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h4><ul>
<li>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。</li>
<li>为了解决这个问题,可以使用由数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密钥证书</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS04.jpg" alt=""></p>
<h4 id="HTTPS-的安全通信机制"><a href="#HTTPS-的安全通信机制" class="headerlink" title="HTTPS 的安全通信机制"></a>HTTPS 的安全通信机制</h4><p><img src="/uploads/图解HTTP/确保Web安全的HTTPS05.jpg" alt=""></p>
<ul>
<li><p>步骤 1: 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。</p>
</li>
<li><p>步骤 2: 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应154答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>
</li>
<li><p>步骤 3: 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
</li>
<li><p>步骤 4: 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。</p>
</li>
<li><p>步骤 5: SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>
</li>
<li><p>步骤 6: 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>
</li>
<li><p>步骤 7: 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。</p>
</li>
<li><p>步骤 8: 服务器同样发送 Change Cipher Spec 报文。</p>
</li>
<li><p>步骤 9: 服务器同样发送 Finished 报文。</p>
</li>
<li><p>步骤 10: 服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。</p>
</li>
<li><p>步骤 11: 应用层协议通信,即发送 HTTP 响应。</p>
</li>
<li><p>步骤 12: 最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</p>
</li>
</ul>
<h4 id="HTTPS存在的不足"><a href="#HTTPS存在的不足" class="headerlink" title="HTTPS存在的不足"></a>HTTPS存在的不足</h4><ul>
<li>HTTPS使用了SSL,因此速度会变慢</li>
</ul>
<p><img src="/uploads/图解HTTP/确保Web安全的HTTPS06.jpg" alt=""></p>
<ul>
<li>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源,导致处理速度变慢。<ul>
<li>和使用 HTTP 相比,网络负载可能会变慢 2 到 100 倍。除去和TCP 连接、发送 HTTP 请求 • 响应以外,还必须进行 SSL 通信,因此整体上处理通信量不可避免会增加。</li>
</ul>
</li>
<li>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲,比起 HTTP 会更多地消耗服务器和客户端的硬件资源,导致负载增强。</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解HTTP-与HTTP协议的Web服务器-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h3><h4 id="通信数据转发程序-代理、网关、隧道"><a href="#通信数据转发程序-代理、网关、隧道" class="headerlink" title="通信数据转发程序:代理、网关、隧道"></a>通信数据转发程序:代理、网关、隧道</h4><ul>
<li>在HTTP通信时,代理、网关和隧道是用于通信数据的转发的应用程序,他们可以配合服务器进行工作</li>
<li>代理就像一个中介,他接收客户端发来的信息继而转发给服务器,同时也可以接受服务器的信息转发给客户端</li>
<li>网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。</li>
<li>隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。</li>
</ul>
<h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器01.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>每次通过代理服务器转发请求或响应时,会追加写入 Via 首部信息</li>
<li>利用代理的作用:<ul>
<li>利用缓存技术减少宽带流量</li>
<li>对特定网站的控制访问,以获取访问日志为主要目的</li>
</ul>
</li>
<li>代理的分类:<ul>
<li>缓存代理(Caching Proxy):代理转发响应时,缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。</li>
<li>透明代理:转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理(TransparentProxy)。反之,对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
</li>
</ul>
<h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器02.jpg" alt=""></p>
<ul>
<li>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</li>
<li>利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如,网关可以连接数据库,使用SQL 语句查询数据。另外,在 Web 购物网站上进行信用卡结算时,网关可以和信用卡结算系统联动。</li>
</ul>
<h5 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h5><ul>
<li>隧道可按要求建立起一条与其他服务器的通信线路,届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
</ul>
<h4 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h4><ul>
<li>利用缓存技术可以减少对服务器的访问,以及通信流量和通信时间。</li>
</ul>
<h5 id="缓存的有限期限"><a href="#缓存的有限期限" class="headerlink" title="缓存的有限期限"></a>缓存的有限期限</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器03.jpg" alt=""></p>
<h5 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h5><p><img src="/uploads/图解HTTP/与HTTP协议的Web服务器04.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源与图解HTTP一书</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解HTTP-返回结果的状态码-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="状态码类别："><a href="#状态码类别：" class="headerlink" title="状态码类别："></a>状态码类别：</h4><p>类别    原因短语<br>1XX    Informational(信息性状态码)    接收的请求正在处理<br>2XX    Success(成功状态码)    请求正常处理完毕<br>3XX    Redirection(重定向状态码)    需要进行附加操作以完成请求<br>4XX    Client Error(客户端错误状态码)    服务器无法处理请求<br>5XX    Server Error(服务器错误状态码)    服务器处理请求出错</p>
<a id="more"></a>
<h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h5><ul>
<li>200 OK：表示客户端的请求被服务器成功处理</li>
<li><p>204 No Content：该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</p>
</li>
<li><p>206 Partial Content：该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h5><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<ul>
<li><p>301 Moved Permanently:永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</p>
</li>
<li><p>302 Found:临时性重定向：该状态码表示请求的资源已被分配了新的URI，希望用户本次请求能使用新的URI。302和301很相似，302表示的URI并不是永久性移动，换句话说就是URI还有可能发生变化。</p>
</li>
<li><p>303 See Other：该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。303和302有着相似的功能，他们之间的区别是303状态码表示明确客户端采用GET请求获取资源</p>
</li>
<li><p>304 Not Modified  </p>
</li>
</ul>
<h5 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h5><p>4XX响应结果表示错误发生在客户端</p>
<ul>
<li><p>400 Bad Request:该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。</p>
</li>
<li><p>403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。</p>
</li>
<li><p>404 Not Found：该状态码表明服务器上无法找到请求的资源。</p>
</li>
</ul>
<h5 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h5><p>5XX 的响应结果表明服务器本身发生错误。</p>
<ul>
<li><p>500 Internal Server Error:该状态码表明服务器端在执行请求时发生了错误。</p>
</li>
<li><p>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。</p>
</li>
</ul>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Picasso基本用法及源码浅析]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/Picasso%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%8F%8A%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><h4 id="加载图片："><a href="#加载图片：" class="headerlink" title="加载图片："></a>加载图片：</h4><ul>
<li><p>picasso支持从Resource，MediaStore，content，contacts，url 加载图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(uri)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>以上是最简单的通用加载图片的方法</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>添加加载错误以及加载中的展示图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(uri)</div><div class="line">                .error(R.drawable.error)</div><div class="line">                .placeholder(R.drawable.placeholder)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>如果加载得到的Bitmap的大小不符合我们设置的ImageView的大小，我们可以调用以下代码来调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(uri)</div><div class="line">                .fit()</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>与fit()相似的是resize（int，int），两者都可以调整图片的大小，但是fit()只能用在ImageView上。需要注意的是两者不能同时使用。</p>
</li>
<li>我们还可以制定ImageView的模式<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(R.drawable.cangjinyou)</div><div class="line">                .resize(<span class="number">150</span>, <span class="number">150</span>)</div><div class="line">                .centerCrop()</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">        .load(R.drawable.cangjinyou)</div><div class="line">        .resize(<span class="number">150</span>, <span class="number">150</span>)</div><div class="line">        .centerInside()</div><div class="line">        .into(mImageView);</div></pre></td></tr></table></figure>
<ul>
<li>需要注意的是centerInside()和centerCrop()不能同时设置。</li>
</ul>
<h4 id="设置Tag"><a href="#设置Tag" class="headerlink" title="设置Tag"></a>设置Tag</h4><ul>
<li>加载图片的同时设置tag来为图片添加生命周期</li>
<li><p>添加tag</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Picasso.with(<span class="keyword">this</span>)</div><div class="line">                .load(R.drawable.cangjinyou)</div><div class="line">                .fit()</div><div class="line">                .centerInside()</div><div class="line">                .tag(<span class="keyword">this</span>)</div><div class="line">                .into(mImageView);</div></pre></td></tr></table></figure>
</li>
<li><p>设置tag可以为图片设置生命周期，通常这个tag可以为Activity或者Fragment，设置tag的好处就是可以根据tag的生命周期来管理图片的生命周期。在设置tag的同时需要避免内存泄露，因为当图片正在加载或者暂停加载的时候，Picasso会持有这个tag。</p>
</li>
<li>设置tag后，我们可以调用Picasso中的cancelTag（Object）,pauseTag（Object）和resumeTag（Object）来管理图片的生命周期。</li>
</ul>
<h4 id="开启Debug模式和指示模式"><a href="#开启Debug模式和指示模式" class="headerlink" title="开启Debug模式和指示模式"></a>开启Debug模式和指示模式</h4><ul>
<li>开启后会在image左上方绘制一个小小小的三角形，三角形的颜色代表图片是从哪里加载得来的，绿色，蓝色，红色分别表示从内存，硬盘，网络加载得来<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDebug</span><span class="params">()</span> </span>&#123;</div><div class="line">       Picasso.with(<span class="keyword">this</span>)</div><div class="line">               .setLoggingEnabled(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openIndicator</span><span class="params">()</span> </span>&#123;</div><div class="line">       Picasso.with(<span class="keyword">this</span>).setIndicatorsEnabled(<span class="keyword">true</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="with-Context-创建Picasso全局单例"><a href="#with-Context-创建Picasso全局单例" class="headerlink" title="with(Context)创建Picasso全局单例"></a>with(Context)创建Picasso全局单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (Picasso.class) &#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">          singleton = <span class="keyword">new</span> Builder(context).build();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> singleton;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>很明显上面的代码逻辑是使用DCL模式创建一个Picasso单例,但是创建对象的方式是使用建造者模式,这样做的好处就是可以让我们自己来配置Picasso。那么怎么配置Picasso?<br>1.使用Picasso.Builder创建配置;<br>2.设置配置完的Picasso: setSingletonInstance(Picasso picasso).</li>
<li><p>回到with()中,我们来看看 singleton = new Builder(context).build();中做了哪些初始化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> Picasso&#125; instance. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">this</span>.context;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</div><div class="line">        downloader = Utils.createDefaultDownloader(context); <span class="comment">/*创建下载器*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</div><div class="line">        cache = <span class="keyword">new</span> LruCache(context); <span class="comment">/*创建内存缓存器*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">        service = <span class="keyword">new</span> PicassoExecutorService(); <span class="comment">/*创建Picasso优化后的线程池*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (transformer == <span class="keyword">null</span>) &#123;</div><div class="line">        transformer = RequestTransformer.IDENTITY; <span class="comment">/*创建请求转换器*/</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Stats stats = <span class="keyword">new</span> Stats(cache); <span class="comment">/*创建状态管理器*/</span></div><div class="line"></div><div class="line">      Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats); <span class="comment">/*创建分发器*/</span></div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled); <span class="comment">/*创建Picasso实例*/</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从上面注释可以看到,Picasso将每个任务分派给不同的对象去处理,最后再指挥这些一系列的’器’去工作。那么下面,我们先来简单介绍以下他们。</p>
</li>
</ul>
<h5 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h5><ul>
<li>我们先来看看下载器的基础接口: Downloader</li>
<li>下载器内部提供两个方法,分别是load(Uri uri, int networkPolicy)和shutdown();load(Uri uri, int networkPolicy)方法是从网络上加载图片,返回内部类Response对象,该对象主要是储存着下载来的Bitmap或者字节流。</li>
<li><p>介绍完下载器基础接口,我们回到创建默认下载器的方法内部:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Downloader <span class="title">createDefaultDownloader</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class.forName(<span class="string">"com.squareup.okhttp.OkHttpClient"</span>); <span class="comment">/*检查是不是存在OkHttpClient,*/</span></div><div class="line">      <span class="keyword">return</span> OkHttpLoaderCreator.create(context);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UrlConnectionDownloader(context);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先检查环境中是不是存在Okhttp,存在的话证明已经添加了Okhttp依赖,因而直接使用Okhttp来创建下载器</p>
</li>
<li>如果不存直接创建UrlConnectionDownloader下载器</li>
</ul>
<h5 id="内存缓存器"><a href="#内存缓存器" class="headerlink" title="内存缓存器"></a>内存缓存器</h5><ul>
<li>内存内存缓存器使用的是Lru,最大的缓存大小是堆内存的最大数的7分之一</li>
</ul>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><ul>
<li>线程池中根据网络状态动态调整了线程数量,以及包装了一个FutureTask来进行实现优先级的比较</li>
</ul>
<h5 id="请求转换器"><a href="#请求转换器" class="headerlink" title="请求转换器"></a>请求转换器</h5><ul>
<li>Picasso里面并没有进行特殊的请求转换,只是原封不动返回了一个请求</li>
</ul>
<h5 id="状态管理器"><a href="#状态管理器" class="headerlink" title="状态管理器"></a>状态管理器</h5><ul>
<li>对Picasso运转的情况做了记录,便于当发生oom时,打印出Picasso的运行情况</li>
</ul>
<h5 id="分发器"><a href="#分发器" class="headerlink" title="分发器"></a>分发器</h5><ul>
<li>上面几个’器’最终都是在分发器中被其指挥调度</li>
</ul>
<h5 id="Picasso实例"><a href="#Picasso实例" class="headerlink" title="Picasso实例"></a>Picasso实例</h5><ul>
<li>分发器指挥调度各个’器’去工作.那么分发器什么时候进行调度? 发送这个命令是就是Picasso, Picasso-&gt;Dispatcher-&gt;各个’器’</li>
</ul>
<h4 id="调用load方法创建RequestCreator"><a href="#调用load方法创建RequestCreator" class="headerlink" title="调用load方法创建RequestCreator"></a>调用load方法创建RequestCreator</h4><ul>
<li>load方法有四个重载方法,用于加载不同的资源。但是最终目的都是创建一个RequestCreator</li>
<li>在介绍RequestCreator之前,我们先来看看Request,</li>
</ul>
<h5 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h5><ul>
<li>顾名思义,就是一条请求,Picasso中会将要加载的图片包装成一条请求</li>
</ul>
<h5 id="RequestCreator"><a href="#RequestCreator" class="headerlink" title="RequestCreator"></a>RequestCreator</h5><ul>
<li>请求的创建任务是交给RequestCreator</li>
<li>RequestCreator可以在创建完请求后,把该请求设置到目标Target中</li>
</ul>
<h4 id="into"><a href="#into" class="headerlink" title="into"></a>into</h4><ul>
<li>into方法有五个重载方法,支持将加载得到的图片设置到ImageView,RemoteViews, Target(自定义View)</li>
<li><p>几个重载方法原理都是相同的,这里我只分析ImageView。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target, Callback callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> started = System.nanoTime();</div><div class="line">    checkMain(); <span class="comment">/*保证into方法是在主线程中被调用的*/</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123; <span class="comment">/*如果在load()方法中有传入ResId或者uri的话,是不会进入if语句中的*/</span></div><div class="line">      picasso.cancelRequest(target);</div><div class="line">      <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">        setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (deferred) &#123; <span class="comment">/*deferred默认值为false,只有再调用了fit方法后deferred才为true,才会进入该方法*/</span></div><div class="line">      <span class="keyword">if</span> (data.hasSize()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with resize."</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> width = target.getWidth();</div><div class="line">      <span class="keyword">int</span> height = target.getHeight();</div><div class="line">      <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">          setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      data.resize(width, height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = createRequest(started);</div><div class="line">    String requestKey = createKey(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        picasso.cancelRequest(target);</div><div class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">"from "</span> + MEMORY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">          callback.onSuccess();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;</div><div class="line">      setPlaceholder(target, getPlaceholderDrawable());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Action action =</div><div class="line">        <span class="keyword">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</div><div class="line">            errorDrawable, requestKey, tag, callback, noFade);</div><div class="line"></div><div class="line">    picasso.enqueueAndSubmit(action);</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中的Callback接口可以不传入,如果要传入的话,要注意内存泄露。</p>
</li>
<li>结合代码中的注释,首先先创建根据当前时间戳来创建一个请求,接着再拼接请求的key</li>
<li>拼接完key之后,会判断是不是要从内存缓存中读取Bitmap,有的话,直接从内存拿走最后设置到target中;</li>
<li>如果设置了placeholder的话,会显示一张预加载的图片</li>
<li>最后实例化一个ImageViewAction并把这个action提交给picasso对象去处理。</li>
<li>Action是一个对一个请求进行包装,里面对target进行弱引用包装,是的我们不必关心内存泄露.</li>
<li><p>我们接着看看看Picasso对传入的action进行了什么操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueAndSubmit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    Object target = action.getTarget();</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</div><div class="line">      <span class="comment">/* This will also check we are on the main thread.*/</span></div><div class="line">      cancelExistingRequest(target);</div><div class="line">      targetToAction.put(target, action);</div><div class="line">    &#125;</div><div class="line">    submit(action);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面逻辑很简单,这里不多说,我们直接看看submit:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    dispatcher.dispatchSubmit(action);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>前面说过了,Picassso是一个总指挥,既然有action来了,Picasso肯定会给他的直接下属Dispatcher发命令,我们看看dispatcher对Picasso交给它的action怎么分派:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchSubmit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们看到,在dispatchSubmit中,通过Handler发送一个REQUEST_SUBMIT消息,该Handler是Dispatcher的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        <span class="keyword">case</span> REQUEST_SUBMIT: &#123;</div><div class="line">          Action action = (Action) msg.obj;</div><div class="line">          dispatcher.performSubmit(action);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接收到消息时,又调用了performSubmit(action)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123; <span class="comment">/*判断action对应的tag是不是被设置为暂停了, 如果设置了暂停,直接去取消加载图片*/</span></div><div class="line">      pausedActions.put(action.getTarget(), action);</div><div class="line">      <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">            <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BitmapHunter hunter = hunterMap.get(action.getKey());</div><div class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</div><div class="line">      hunter.attach(action);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (service.isShutdown()) &#123;</div><div class="line">      <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class="string">"because shut down"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</div><div class="line">    hunter.future = service.submit(hunter);</div><div class="line">    hunterMap.put(action.getKey(), hunter);</div><div class="line">    <span class="keyword">if</span> (dismissFailed) &#123;</div><div class="line">      failedActions.remove(action.getTarget());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>结合上面注释,我们直接来看看<code>hunter = forRequest(action.getPicasso(), this, cache, stats, action);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> BitmapHunter <span class="title">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span></span></div><div class="line">      Action action) &#123;</div><div class="line">    Request request = action.getRequest();</div><div class="line">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</div><div class="line"></div><div class="line">    <span class="comment">/* Index-based loop to avoid allocating an iterator.*/</span></div><div class="line">    <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</div><div class="line">      RequestHandler requestHandler = requestHandlers.get(i);</div><div class="line">      <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>既然有了请求,dispatcher就得来指挥对应的’人’来处理</p>
</li>
<li>接下来,通过遍历取得RequestHandler来能够处理该请求的RequestHandler来处理</li>
<li>那么这些RequestHandler怎么来的?</li>
<li><p>其实这些RequestHandler是创建Picasso的时候,就已经实例化了,我们暂且回到Picasso来看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">List&lt;RequestHandler&gt; allRequestHandlers =</div><div class="line">        <span class="keyword">new</span> ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount);</div><div class="line"></div><div class="line">    <span class="comment">/* ResourceRequestHandler needs to be the first in the list to avoid*/</span></div><div class="line">    <span class="comment">/* forcing other RequestHandlers to perform null checks on request.uri*/</span></div><div class="line">    <span class="comment">/* to cover the (request.resourceId != 0) case.*/</span></div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> ResourceRequestHandler(context));</div><div class="line">    <span class="keyword">if</span> (extraRequestHandlers != <span class="keyword">null</span>) &#123;</div><div class="line">      allRequestHandlers.addAll(extraRequestHandlers);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> ContactsPhotoRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> MediaStoreRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> ContentStreamRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> AssetRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> FileRequestHandler(context));</div><div class="line">    allRequestHandlers.add(<span class="keyword">new</span> NetworkRequestHandler(dispatcher.downloader, stats));</div><div class="line">    requestHandlers = Collections.unmodifiableList(allRequestHandlers);</div></pre></td></tr></table></figure>
</li>
<li><p>Picasso默认帮我们创建了7个请求处理器,这些处理器,分别对应响应的不同的请求类型,当然,Picasso也考虑到了这7中可能会不够我们使用,如果是这样的话,我们可以继承RequestHandler,并且调用Picasso.Builder.addRequestHandler(RequestHandler)}来扩展RequestHandler。</p>
</li>
</ul>
<h5 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h5><ul>
<li>请求处理器,其中预留了<code>canHandleRequest(Request data)</code>和<code>load(Request request, int networkPolicy)</code>给具体子类去实现。</li>
<li>继承RequestHandler的子类,<code>canHandleRequest(Request data)</code>判断该请求是不是在自己的处理范围内,是的话返回true,而load则是加载图片</li>
<li>RequestHandler内部的Result是由load完的数据进行包装而成的对象。</li>
<li>介绍完RequestHandler,我们回到forResquest方法中:在for循环中,找到能处理该请求的RequestHandler并实例化返回一个BitmapHunter,</li>
<li><p>得到BitmapHunter,提交给线程池,得到一个Future,所以此时,我们得去PicassoExecutorService去看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoFutureTask</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">BitmapHunter</span>&gt;</span></div><div class="line">      <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">PicassoFutureTask</span>&gt; &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitmapHunter hunter;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PicassoFutureTask</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(hunter, <span class="keyword">null</span>);</div><div class="line">      <span class="keyword">this</span>.hunter = hunter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PicassoFutureTask other)</span> </span>&#123;</div><div class="line">      Picasso.Priority p1 = hunter.getPriority();</div><div class="line">      Picasso.Priority p2 = other.hunter.getPriority();</div><div class="line"></div><div class="line">      <span class="comment">/* High-priority requests are "lesser" so they are sorted to the front.*/</span></div><div class="line">      <span class="comment">/* Equal priorities are sorted by sequence number to provide FIFO ordering.*/</span></div><div class="line">      <span class="keyword">return</span> (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>将提交的BitmapHunter包装成一个PicassoFutureTask,主要的操作就是进行优先级的比较</p>
</li>
<li><p>提交完后,我们自然要去BitmapHunter中,因为BitmapHunter是继承自Runnable对象,提交的BitmapHunter会在其Run函数中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     updateThreadName(data);</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">       log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>));</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     result = hunt();</div><div class="line">     <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">       dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       dispatcher.dispatchComplete(<span class="keyword">this</span>);</div><div class="line">     &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Downloader.ResponseException e) &#123;</div><div class="line">     <span class="keyword">if</span> (!e.localCacheOnly || e.responseCode != <span class="number">504</span>) &#123;</div><div class="line">       exception = e;</div><div class="line">     &#125;</div><div class="line">     dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (NetworkRequestHandler.ContentLengthException e) &#123;</div><div class="line">     exception = e;</div><div class="line">     dispatcher.dispatchRetry(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">     exception = e;</div><div class="line">     dispatcher.dispatchRetry(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</div><div class="line">     StringWriter writer = <span class="keyword">new</span> StringWriter();</div><div class="line">     stats.createSnapshot().dump(<span class="keyword">new</span> PrintWriter(writer));</div><div class="line">     exception = <span class="keyword">new</span> RuntimeException(writer.toString(), e);</div><div class="line">     dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">     exception = e;</div><div class="line">     dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">     Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面代码中主要调用了hunt()方法得到Bitmap对象,现在,我们直接进入该方法看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function">Bitmap <span class="title">hunt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">      bitmap = cache.get(key);</div><div class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        stats.dispatchCacheHit();</div><div class="line">        loadedFrom = MEMORY;</div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), <span class="string">"from cache"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data.networkPolicy = retryCount == <span class="number">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</div><div class="line">    RequestHandler.Result result = requestHandler.load(data, networkPolicy);</div><div class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">      loadedFrom = result.getLoadedFrom();</div><div class="line">      exifRotation = result.getExifOrientation();</div><div class="line">      bitmap = result.getBitmap();</div><div class="line"></div><div class="line">      <span class="comment">/* If there was no Bitmap then we need to decode it from the stream.*/</span></div><div class="line">      <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">        InputStream is = result.getStream();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          bitmap = decodeStream(is, data);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          Utils.closeQuietly(is);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      stats.dispatchBitmapDecoded(bitmap);</div><div class="line">      <span class="keyword">if</span> (data.needsTransformation() || exifRotation != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (DECODE_LOCK) &#123;</div><div class="line">          <span class="keyword">if</span> (data.needsMatrixTransform() || exifRotation != <span class="number">0</span>) &#123;</div><div class="line">            bitmap = transformResult(data, bitmap, exifRotation);</div><div class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (data.hasCustomTransformations()) &#123;</div><div class="line">            bitmap = applyCustomTransformations(data.transformations, bitmap);</div><div class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), <span class="string">"from custom transformations"</span>);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">          stats.dispatchBitmapTransformed(bitmap);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> bitmap;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先判断内存缓存是不是存在该Bitmap,存在的话返回Bitmap对象</p>
</li>
<li>不存在的话,进行网络加载,进行网络加载时,会先判断硬盘缓存中是不是存在,不存在的话再从网络上下载</li>
<li>如果是从网络上下载的话,会得到字节流,接着解析字节流,最后返回该Bitmap。</li>
<li><p>得到Bitmap后,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dispatcher.dispatchComplete(<span class="keyword">this</span>);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>是分发器出场把BitmapHunter对象回调出去</p>
</li>
<li><p>回调的套路跟之前一样,通过Handler发送一条加载完成的消息,再会回调加载完成的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</div><div class="line">      cache.set(hunter.getKey(), hunter.getResult());</div><div class="line">    &#125;</div><div class="line">    hunterMap.remove(hunter.getKey());</div><div class="line">    batch(hunter);</div><div class="line">    <span class="keyword">if</span> (hunter.getPicasso().loggingEnabled) &#123;</div><div class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), <span class="string">"for completion"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后会回调上面的方法,主要操作是缓存该Bitmap</p>
</li>
<li><p>缓存完Bitmap后,调用batch(hunter)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    batch.add(hunter);</div><div class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</div><div class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中,通过Hnadler发送一条消息,我们跟踪一下这条信息,最后会调用以下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBatchComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</div><div class="line">   batch.clear();</div><div class="line">   mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</div><div class="line">   logBatch(copy);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法中也是通过Hnadler发送一条消息,而这次发送的消息是发送到运行在主线程的Hnadler,该Handler是实例化Picasso的时候传入Dispatcher的,因而我们自然来到Picasso中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    Action single = hunter.getAction();</div><div class="line">    List&lt;Action&gt; joined = hunter.getActions();</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> hasMultiple = joined != <span class="keyword">null</span> &amp;&amp; !joined.isEmpty();</div><div class="line">    <span class="keyword">boolean</span> shouldDeliver = single != <span class="keyword">null</span> || hasMultiple;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!shouldDeliver) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Uri uri = hunter.getData().uri;</div><div class="line">    Exception exception = hunter.getException();</div><div class="line">    Bitmap result = hunter.getResult();</div><div class="line">    LoadedFrom from = hunter.getLoadedFrom();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (single != <span class="keyword">null</span>) &#123;</div><div class="line">      deliverAction(result, from, single);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasMultiple) &#123;</div><div class="line">      <span class="comment">/*noinspection ForLoopReplaceableByForEach*/</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = joined.size(); i &lt; n; i++) &#123;</div><div class="line">        Action join = joined.get(i);</div><div class="line">        deliverAction(result, from, join);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span> &amp;&amp; exception != <span class="keyword">null</span>) &#123;</div><div class="line">      listener.onImageLoadFailed(<span class="keyword">this</span>, uri, exception);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过分析,最终会回调Picasso的complete方法:方法中我们只分析单一的Action,也就是会调用<code>deliverAction(result, from, single);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverAction</span><span class="params">(Bitmap result, LoadedFrom from, Action action)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (action.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!action.willReplay()) &#123;</div><div class="line">      targetToAction.remove(action.getTarget());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (from == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LoadedFrom cannot be null."</span>);</div><div class="line">      &#125;</div><div class="line">      action.complete(result, from);</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), <span class="string">"from "</span> + from);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      action.error();</div><div class="line">      <span class="keyword">if</span> (loggingEnabled) &#123;</div><div class="line">        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面代码,我们可以看到最后会调用<code>action.complete(result, from);</code>,因为我们实例化Action的时候是实例化ImageView,因此,我们来看看ImageViewAction中的complete:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</div><div class="line">          String.format(<span class="string">"Attempted to complete action with no result!\n%s"</span>, <span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Context context = picasso.context;</div><div class="line">    <span class="keyword">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</div><div class="line">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">      callback.onSuccess();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>很明显,上面代码中调用了PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);设置来Bitmap,也就是说设置到ImageView中,有趣的是,PicassoDrawable是继承自BitmapDrawable的,并重写了onDraw方法,根据是否开启指示器模式,来判断是否要在图片的左上角画一个小小的三角形,其中不同颜色的三角形代表从Image的来源,这里具体不多说了。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>总体来说,Picasso的设计是将不同的任务分派给不同的’器’,再有分发器调度,而分发器直接接受Picasso的命令,也就是说整个加载的过程中,Picasso始终存在</li>
<li>Picasso内部的实现还是有很多地方值得学习,比如Action队列的控制,请求处理器的分类,线程池的优化,图片生命周期的管理等。既然Picasso有这么多值得学习的地方,所以打算专门写一篇来分析其中的技巧。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解HTTP-网络基础-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/02/17/%E5%9B%BE%E8%A7%A3HTTP-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h4 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h4><h5 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h5><ul>
<li>我们通常使用到的网络是在<strong>TCP/IP</strong>协议族的基础上运作的。而HTTP属于它内部的一个子集。</li>
<li>TCP/IP是互联网各类协议族的总称, 如图:<br><img src="/uploads/图解HTTP/网络基础01.jpg" alt=""><a id="more"></a></li>
<li>协议中存在各式各样的内容,从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序,以及 Web 页面显示需要处理的步骤,等等。像这样把互联网通信的相关协议集合起来的协议族就叫做TCP/IP协议</li>
</ul>
<h5 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h5><ul>
<li>TCP/IP中一个重要的点就是分层设计。</li>
<li>层次: 应用层,传输层,网路层,链路层</li>
<li>分层设计的好处:<ul>
<li>利于修改:这样不会因某些地方要修改而导致整个协议都得修改,只需要各层把借口规范好,需要改动的时候就在相应的层次改动</li>
<li>各层只需完成自己的任务,无需关注其他层次。比如:应用层不需知道怎么传输和接收方在哪里</li>
</ul>
</li>
<li><strong>TCP/IP协议族各层的作用</strong><ul>
<li>应用层: 该层决定了想用户提供服务时的通信活动。TCP/IP协议族中预存了各类通用的应用服务,比如, FTP(File Transfer Protocol, 文件传输协议) 和 DNS (Domain Name System, 域名解析系统), HTTP协议处于应用层。</li>
<li>传输层: 该层对上层应用层, 提供处于网络连接中的两台计算机之间的数据传输。传输层中有两个性质不同的协议:<strong>TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User Data Protocol, 用户数据报协议)</strong></li>
<li>网络层(网路互连层): 该层用来处理在网络上流动的数据包, 数据包是在网络传输时的最小数据单位, 网络层规定了通过怎么样的路径到达对方的计算机,并把数据包发给对方</li>
<li>链路层(有名:数据链路层, 网络接口层):用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card,网络适配器,即网卡),及光纤等物理可见部分(还包括连接器等一切传输媒介)。硬件上的范畴均在<br>链路层的作用范围之内。</li>
</ul>
</li>
</ul>
<h5 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h5><p><img src="/uploads/图解HTTP/网络基础02.jpg" alt=""></p>
<ul>
<li>从上图,我们可以清楚:使用TCP/IP协议进行网络通信时,发送端是从应用层往下走,接收端是往应用层上走</li>
<li>我们用 HTTP 举例来说明,首先作为发送端的客户端在应用层(HTTP 协议)发出一个想看某个 Web 页面的 HTTP 请求。接着,为了传输方便,在传输层(TCP 协议)把从应用层处收到的数据(HTTP 请求报文)进行分割,并在各个报文上打上标记序号及端口号后转发给网络层。在网络层(IP 协议),增加作为通信目的地的 MAC地址后转发给链路层。这样一来,发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据,按序往上层发送,一直到应用层。当传输到应用层,才能算真正接收到由客户端发送过来的 HTTP请求。</li>
</ul>
<p><img src="/uploads/图解HTTP/网络基础03.jpg" alt=""></p>
<ul>
<li>发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息。反之,接收端在层与层传输数据时,经过一层时会把对应的首部消去。</li>
</ul>
<h5 id="与HTTP关系密切的协议-TCP-IP-DNS"><a href="#与HTTP关系密切的协议-TCP-IP-DNS" class="headerlink" title="与HTTP关系密切的协议: TCP IP DNS"></a>与HTTP关系密切的协议: TCP IP DNS</h5><ul>
<li>负责传输的IP协议:<br>1.按层次分,IP(Internet Protocol)网际协议位于网络层。<br>2.IP协议的作用是把各种数据包发送给对方,其中发送成功的;两个重要条件时:IP地址和MAC地址(Media Access Control Address)<br>3.MAC地址所指的是网卡地址,不可以改变,而IP地址则可以变换<br>4.在网络条通信中,双方同时位于同一个局域网内的情况是很少的,通常是是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时,会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时,会采用 ARP 协议(AddressResolution Protocol)。ARP 是一种用以解析地址的协议,根据通信方的 IP 地址就可以反查出对应的 MAC 地址。<br>5.无论哪台计算机、哪台网络设备,它们都无法全面掌握互联网中的细节。</li>
</ul>
<p><img src="/uploads/图解HTTP/网络基础04.jpg" alt=""></p>
<ul>
<li>确保可靠性的TCP协议</li>
</ul>
<ol>
<li>按层次分,TCP 位于传输层,提供可靠的字节流服务。所谓的字节流服务(Byte Stream Service)是指,为了方便传输,将大<br>块数据分割成以报文段(segment)为单位的数据包进行管理。而可靠的传输服务是指,能够把数据准确可靠地传给对方。一言以蔽之,TCP 协议为了更容易传送大数据才把数据分割,而且 TCP 协议能够确认数据最终是否送达到对方。</li>
<li>TCP协议采用三次握手(three-way-handshaking)策略来保证数据能准确无误的送达</li>
<li>握手过程中使用了 TCP 的标志(flag) —— SYN(synchronize) 和ACK(acknowledgement)。</li>
<li>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后,回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后,发送端再回传一个带ACK标志的数据包,代表“握手”结束。若在握手过程中某个阶段莫名中断,TCP协议会再次以相同的顺序发送相同的数据包。</li>
<li>除了上面的三次握手,TCP协议还有其他的协议来保证通信的可靠。</li>
</ol>
<p><img src="/uploads/图解HTTP/网络基础05.jpg" alt=""></p>
<ul>
<li>DNS:</li>
</ul>
<ol>
<li>DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址,或逆向从 IP 地址反查域名的服务。</li>
</ol>
<p><img src="/uploads/图解HTTP/网络基础06.jpg" alt=""></p>
<h5 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h5><p><img src="/uploads/图解HTTP/网络基础07.jpg" alt=""></p>
<blockquote>
<p>以上笔记来源于图解HTTP一书</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[universal-image-loader缓存策略]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/universal-image-loader%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>有看过UIL源码的人都应该知道，库中缓存使用了策略模式来对bitmap进行缓存。这次来单独来分析其中的内存缓存策略<br><a id="more"></a></p>
<h5 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h5><p>接口：</p>
<ul>
<li>MemoryCacheAware：底层接口，里面定义了基本的缓存操作方法</li>
<li>MemoryCache：单纯继承了MemoryCacheAware接口</li>
</ul>
<p>抽象类：</p>
<ul>
<li>BaseMemoryCache：实现了MemoryCahce，运用弱引用包装Bitmap后缓存存在HashMap中。同时也实现了MemoryCacheAware中的接口的方法</li>
<li>LimitedMemoryCache：这个类继承BaseMemoryCahce，并在类中扩展了一级强引用缓存，也就是说LimitedMemoryCache是拥有双级缓存的（强引用缓存，弱引用缓存）。<ul>
<li>LimitedMemoryCache会限制内存的缓存大小，当达到缓存达到最大的内存缓存时，会移除缓存，至于移除的策略，库中有提供几个实现策略。</li>
</ul>
</li>
</ul>
<p>具体实现类：</p>
<ul>
<li>WeakMeoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakMemoryCache</span> <span class="keyword">extends</span> <span class="title">BaseMemoryCache</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WeakMemoryCache是继承自BaseMemoryCache，并且只是重写了createReference，所有WeakMemoryCache只有弱引用的缓存。</p>
<ul>
<li>LruMemoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Bitmap&gt; map;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</div><div class="line">    <span class="comment">/** Size of this cache in bytes */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@param</span> maxSize Maximum sum of the sizes of the Bitmaps in this cache */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruMemoryCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;String, Bitmap&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the Bitmap for &#123;<span class="doctag">@code</span> key&#125; if it exists in the cache. If a Bitmap was returned, it is moved to the head</div><div class="line">     * of the queue. This returns null if a Bitmap is not cached.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">return</span> map.get(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Caches &#123;<span class="doctag">@code</span> Bitmap&#125; for &#123;<span class="doctag">@code</span> key&#125;. The Bitmap is moved to the head of the queue. */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            size += sizeOf(key, value);</div><div class="line">            Bitmap previous = map.put(key, value);</div><div class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                size -= sizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        trimToSize(maxSize);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove the eldest entries until the total of remaining entries is at or below the requested size.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1 to evict even 0-sized elements.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            String key;</div><div class="line">            Bitmap value;</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName() + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Map.Entry&lt;String, Bitmap&gt; toEvict = map.entrySet().iterator().next();</div><div class="line">                <span class="keyword">if</span> (toEvict == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                key = toEvict.getKey();</div><div class="line">                value = toEvict.getValue();</div><div class="line">                map.remove(key);</div><div class="line">                size -= sizeOf(key, value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists. */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Bitmap previous = map.remove(key);</div><div class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                size -= sizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> previous;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;String&gt;(map.keySet());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        trimToSize(-<span class="number">1</span>); <span class="comment">// -1 will evict 0-sized elements</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the size &#123;<span class="doctag">@code</span> Bitmap&#125; in bytes.</div><div class="line">     * &lt;p/&gt;</div><div class="line">     * An entry's size must not change while it is in the cache.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(<span class="string">"LruCache[maxSize=%d]"</span>, maxSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LruMemoryCache继承自MemoryCache，因此只有强引用的缓存，LruMemoryCache移除缓存的策略是使用最近最少使用算法，即每次通过get得到的Bitmap都会放在队列头，移除的时候就会先从队列尾移除，这样就保证了最少使用的最先被移除</p>
<ul>
<li>LimitedAgeMemoryCache：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedAgeMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxAge;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Long&gt; loadingDates = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Long&gt;());</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> cache  Wrapped memory cache</div><div class="line">     * <span class="doctag">@param</span> maxAge Max object age &lt;b&gt;(in seconds)&lt;/b&gt;. If object age will exceed this value then it'll be removed from</div><div class="line">     *               cache on next treatment (and therefore be reloaded).</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitedAgeMemoryCache</span><span class="params">(MemoryCache cache, <span class="keyword">long</span> maxAge)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.cache = cache;</div><div class="line">        <span class="keyword">this</span>.maxAge = maxAge * <span class="number">1000</span>; <span class="comment">// to milliseconds</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> putSuccesfully = cache.put(key, value);</div><div class="line">        <span class="keyword">if</span> (putSuccesfully) &#123;</div><div class="line">            loadingDates.put(key, System.currentTimeMillis());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> putSuccesfully;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Long loadingDate = loadingDates.get(key);</div><div class="line">        <span class="keyword">if</span> (loadingDate != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() - loadingDate &gt; maxAge) &#123;</div><div class="line">            cache.remove(key);</div><div class="line">            loadingDates.remove(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        loadingDates.remove(key);</div><div class="line">        <span class="keyword">return</span> cache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.keys();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        cache.clear();</div><div class="line">        loadingDates.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>LimitedAgeMemoryCache是MemoryCache的装饰类，也就是说LimitedAgeMemoryCache可以装饰实现了MemoryCache接口的类，比如LruMemoryCache。那么装饰的新功能是什么？</li>
<li><p>通过上面源码，可以清楚的得出，LimitedAgeMemoryCache是通过判断Bitmap的缓存时间是否超过在初始化传入时的缓存最大时间。超过的话就从内存中移除。</p>
</li>
<li><p>FuzzyKeyMemoryCache：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuzzyKeyMemoryCache</span> <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;String&gt; keyComparator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FuzzyKeyMemoryCache</span><span class="params">(MemoryCache cache, Comparator&lt;String&gt; keyComparator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.cache = cache;</div><div class="line">        <span class="keyword">this</span>.keyComparator = keyComparator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Search equal key and remove this entry</span></div><div class="line">        <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line">            String keyToRemove = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (String cacheKey : cache.keys()) &#123;</div><div class="line">                <span class="keyword">if</span> (keyComparator.compare(key, cacheKey) == <span class="number">0</span>) &#123;</div><div class="line">                    keyToRemove = cacheKey;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (keyToRemove != <span class="keyword">null</span>) &#123;</div><div class="line">                cache.remove(keyToRemove);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cache.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        cache.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cache.keys();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FuzzyKeyMemoryCache也是继承自MemoryCache，同时也是MemoryCache的装饰类，装饰的新功能是：</li>
<li><p>当添加Bitmap进缓存时，如果添加进去的key跟之前添加过的key值相同的话，从内存移除之前key值对应的Bitmap，添加新传进来的Bitmap到内存。至于key相同的标准是什么,这个得根据自身的需求在重写Comparator对象并在初始化的时候传入。</p>
</li>
<li><p><strong>UsingFreqLimitedMemoryCache</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingFreqLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Contains strong references to stored objects (keys) and last object usage date (in milliseconds). If hard cache</div><div class="line">     * size will exceed limit then object with the least frequently usage is deleted (but it continue exist at</div><div class="line">     * &#123;<span class="doctag">@link</span> #softMap&#125; and can be collected by GC at any time)</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, Integer&gt; usingCounts = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Bitmap, Integer&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsingFreqLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            usingCounts.put(value, <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="comment">// Increment usage count for value if value is contained in hardCahe</span></div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            Integer usageCount = usingCounts.get(value);</div><div class="line">            <span class="keyword">if</span> (usageCount != <span class="keyword">null</span>) &#123;</div><div class="line">                usingCounts.put(value, usageCount + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            usingCounts.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        usingCounts.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer minUsageCount = <span class="keyword">null</span>;</div><div class="line">        Bitmap leastUsedValue = <span class="keyword">null</span>;</div><div class="line">        Set&lt;Entry&lt;Bitmap, Integer&gt;&gt; entries = usingCounts.entrySet();</div><div class="line">        <span class="keyword">synchronized</span> (usingCounts) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;Bitmap, Integer&gt; entry : entries) &#123;</div><div class="line">                <span class="keyword">if</span> (leastUsedValue == <span class="keyword">null</span>) &#123;</div><div class="line">                    leastUsedValue = entry.getKey();</div><div class="line">                    minUsageCount = entry.getValue();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Integer lastValueUsage = entry.getValue();</div><div class="line">                    <span class="keyword">if</span> (lastValueUsage &lt; minUsageCount) &#123;</div><div class="line">                        minUsageCount = lastValueUsage;</div><div class="line">                        leastUsedValue = entry.getKey();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        usingCounts.remove(leastUsedValue);</div><div class="line">        <span class="keyword">return</span> leastUsedValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>UsingFreqLimitedMemoryCache继承自LimitedMemoryCache，所以他拥有双级缓存用能（强弱引用缓存）。</li>
<li><p>UsingFreqLimitedMemoryCache的移除缓存的策略：每次使用get获得Bitmap时都会记录Bitmap使用的次数。要移除时，移除使用最少的次数的Bitmap，移除的只是强引用的缓存，弱引用中的缓存并不一定有被移除</p>
</li>
<li><p><strong>LRULimit</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">1.1f</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** Cache providing Least-Recently-Used logic */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Bitmap&gt; lruCache = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap&lt;String, Bitmap&gt;(INITIAL_CAPACITY, LOAD_FACTOR, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@param</span> maxSize Maximum sum of the sizes of the Bitmaps in this cache */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(maxSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            lruCache.put(key, value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        lruCache.get(key); <span class="comment">// call "get" for LRU logic</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        lruCache.remove(key);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        lruCache.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Bitmap mostLongUsedValue = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (lruCache) &#123;</div><div class="line">            Iterator&lt;Entry&lt;String, Bitmap&gt;&gt; it = lruCache.entrySet().iterator();</div><div class="line">            <span class="keyword">if</span> (it.hasNext()) &#123;</div><div class="line">                Entry&lt;String, Bitmap&gt; entry = it.next();</div><div class="line">                mostLongUsedValue = entry.getValue();</div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mostLongUsedValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>LRULimitedMemoryCache继承自LimitedMemoryCache，同样也是具有两级缓存。而移除的策略是lru算法，这里不多分析。</p>
</li>
<li><p><strong>LargestLimitedMemoryCache</strong> </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Contains strong references to stored objects (keys) and sizes of the objects. If hard cache</div><div class="line">     * size will exceed limit then object with the largest size is deleted (but it continue exist at</div><div class="line">     * &#123;<span class="doctag">@link</span> #softMap&#125; and can be collected by GC at any time)</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, Integer&gt; valueSizes = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Bitmap, Integer&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LargestLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            valueSizes.put(value, getSize(value));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            valueSizes.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        valueSizes.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer maxSize = <span class="keyword">null</span>;</div><div class="line">        Bitmap largestValue = <span class="keyword">null</span>;</div><div class="line">        Set&lt;Entry&lt;Bitmap, Integer&gt;&gt; entries = valueSizes.entrySet();</div><div class="line">        <span class="keyword">synchronized</span> (valueSizes) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;Bitmap, Integer&gt; entry : entries) &#123;</div><div class="line">                <span class="keyword">if</span> (largestValue == <span class="keyword">null</span>) &#123;</div><div class="line">                    largestValue = entry.getKey();</div><div class="line">                    maxSize = entry.getValue();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Integer size = entry.getValue();</div><div class="line">                    <span class="keyword">if</span> (size &gt; maxSize) &#123;</div><div class="line">                        maxSize = size;</div><div class="line">                        largestValue = entry.getKey();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        valueSizes.remove(largestValue);</div><div class="line">        <span class="keyword">return</span> largestValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LargestLimitedMemoryCache继承自LimitedMemoryCache，拥有双级缓存。移除缓存的策略是移除占内存最大的Bitmap</p>
<ul>
<li><strong>FIFOLimitedMemoryCache</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FIFOLimitedMemoryCache</span> <span class="keyword">extends</span> <span class="title">LimitedMemoryCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Bitmap&gt; queue = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;Bitmap&gt;());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOLimitedMemoryCache</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sizeLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.put(key, value)) &#123;</div><div class="line">            queue.add(value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        Bitmap value = <span class="keyword">super</span>.get(key);</div><div class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">            queue.remove(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.clear();</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.remove(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理也是具有双级缓存功能，移除缓存的策略是移除头部的Bitmap</p>
<h5 id="内存缓存策略总结："><a href="#内存缓存策略总结：" class="headerlink" title="内存缓存策略总结："></a>内存缓存策略总结：</h5><ul>
<li><p>类库中提供的三个接口：</p>
<ul>
<li>MemoryCache：实现该接口的类只有强引用的缓存功能</li>
<li>BaseMemoryCache：实现该接口的类只有弱引用的缓存功能</li>
<li>LimitedMemoryCache：实现该类的拥有两级缓存功能（强弱引用功能）</li>
</ul>
</li>
<li><p>库中针对这三个接口，都给出了具体的实现类，我们可以根据自己的需求来设置缓存策略，默认的是LruMemoryCache</p>
</li>
<li>关于双级缓存：实现了LimitMemoryCache的类都具有双级缓存，但是为什么要使用双级缓存？<ul>
<li>理解：缓存内存的最大值是固定的，超过这个值后，我们就得从内存中移除Bitmap，但是我们有时不是想要移除，只是内存不足了，我们被迫移除了Bitmap，所以增加了一级强引用的缓存，当内存不足 时，首先移除强引用的Bitmap，弱引用并没有被移除。这样下次如果请求相同的Bitmap时，就可以从弱引用的缓存中取出。但是这样做也有缺点，牺牲了内存。</li>
<li>总体说就是双级缓存就是通过牺牲内存来提高响应速度。</li>
</ul>
</li>
<li>如果觉得库中提供给我们的策略不符合自己的业务需求的话，可以根据自己的业务需求来定制缓存策略。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[universal-image-loader源码浅读]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/universal-image-loader%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul>
<li>UIL是一款经典的图片加载框架，该类库的设计运用了多种设计模式，使得它的可拓展性增加，比如缓存的策略，如果默认的缓存策略不能够满足你的需求的话，你完全可以自己定制自己的缓存策略。</li>
<li>使用者不必关心加载图片时会发生OOM，其中发生的概率还是很小的，因为类库中对图片进行了三级缓存，其中的内存缓存使用了双级缓存（强引用和弱引用）。</li>
<li>库中考虑到用户可能会使用ListView，GridView或者RecyclerView来展示图片，因此在库中提供了一个PauseOnScrollListener来控制滑动时是否要加载图片。</li>
<li>这次，简单来分析类库的使用流程<a id="more"></a>
</li>
</ul>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul>
<li>使用过UIL的都知道，需要先在Application中初始化：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建默认的ImageLoader配置参数  </span></div><div class="line">       ImageLoaderConfiguration configuration = ImageLoaderConfiguration  </div><div class="line">               .createDefault(<span class="keyword">this</span>);  </div><div class="line">         </div><div class="line">       <span class="comment">//Initialize ImageLoader with configuration.  </span></div><div class="line">       ImageLoader.getInstance().init(configuration);</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码是在Application中初始化UIL，ImageLoaderConfiguration.createDefault(this)是创建默认的参数配置</li>
<li>点入该方法中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoaderConfiguration <span class="title">createDefault</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder(context).build();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以看到，在方法中，new了一个Builder，也就是说用建造者模式来初始化默认配置</li>
<li>再进入build()中，发现其中会调initEmptyFieldsWithDefaultValues()来初始化默认配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEmptyFieldsWithDefaultValues</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (taskExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">                taskExecutor = DefaultConfigurationFactory</div><div class="line">                        .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                customExecutor = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (taskExecutorForCachedImages == <span class="keyword">null</span>) &#123;</div><div class="line">                taskExecutorForCachedImages = DefaultConfigurationFactory</div><div class="line">                        .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                customExecutorForCachedImages = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (diskCacheFileNameGenerator == <span class="keyword">null</span>) &#123;</div><div class="line">                    diskCacheFileNameGenerator = DefaultConfigurationFactory.createFileNameGenerator();</div><div class="line">                &#125;</div><div class="line">                diskCache = DefaultConfigurationFactory</div><div class="line">                        .createDiskCache(context, diskCacheFileNameGenerator, diskCacheSize, diskCacheFileCount);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</div><div class="line">                memoryCache = DefaultConfigurationFactory.createMemoryCache(memoryCacheSize);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (denyCacheImageMultipleSizesInMemory) &#123;</div><div class="line">                memoryCache = <span class="keyword">new</span> FuzzyKeyMemoryCache(memoryCache, MemoryCacheUtils.createFuzzyKeyComparator());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</div><div class="line">                downloader = DefaultConfigurationFactory.createImageDownloader(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (decoder == <span class="keyword">null</span>) &#123;</div><div class="line">                decoder = DefaultConfigurationFactory.createImageDecoder(writeLogs);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (defaultDisplayImageOptions == <span class="keyword">null</span>) &#123;</div><div class="line">                defaultDisplayImageOptions = DisplayImageOptions.createSimple();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>该方法内会判断使用者是否有自定义的参数，没有的话，就在默认的参数工厂DefaultConfigurationFactory中创建对应的配置实例</li>
<li><p>至于配置参数是什么，这里就不详细讲</p>
</li>
<li><p>初始化完配置参数后，会调用Image Loader的init方法来初始化imageLoader，下面来看看init中做了那些初始化操作：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ImageLoaderConfiguration configuration)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (configuration == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ERROR_INIT_CONFIG_WITH_NULL);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configuration == <span class="keyword">null</span>) &#123;</div><div class="line">            L.d(LOG_INIT_CONFIG);</div><div class="line">            engine = <span class="keyword">new</span> ImageLoaderEngine(configuration);</div><div class="line">            <span class="keyword">this</span>.configuration = configuration;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            L.w(WARNING_RE_INIT_CONFIG);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>init方法中实例化了ImageLoaderEngine对象，该类的作用主要是用来控制任务的执行</li>
</ul>
<h5 id="displayImage"><a href="#displayImage" class="headerlink" title="displayImage"></a>displayImage</h5><ul>
<li>初始化完成后，我们就可以调用displayImage来展示图片，该方法有多个重载方法，不过最后都会调用到一下的重载方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String uri, ImageAware imageAware, DisplayImageOptions options,</span></span></div><div class="line">            ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</div><div class="line">        checkConfiguration();</div><div class="line">        <span class="keyword">if</span> (imageAware == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ERROR_WRONG_ARGUMENTS);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</div><div class="line">            listener = emptyListener;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (options == <span class="keyword">null</span>) &#123;</div><div class="line">            options = configuration.defaultDisplayImageOptions;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(uri)) &#123;</div><div class="line">            engine.cancelDisplayTaskFor(imageAware);</div><div class="line">            listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line">            <span class="keyword">if</span> (options.shouldShowImageForEmptyUri()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ImageSize targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</div><div class="line">        String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);</div><div class="line">        engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</div><div class="line"></div><div class="line">        listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line"></div><div class="line">        Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);</div><div class="line">        <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; !bmp.isRecycled()) &#123;</div><div class="line">            L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (options.shouldPostProcess()) &#123;</div><div class="line">                ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                        options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">                ProcessAndDisplayImageTask displayTask = <span class="keyword">new</span> ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</div><div class="line">                        defineHandler(options));</div><div class="line">                <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                    displayTask.run();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    engine.submit(displayTask);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</div><div class="line">                listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (options.shouldShowImageOnLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.isResetViewBeforeLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">            LoadAndDisplayImageTask displayTask = <span class="keyword">new</span> LoadAndDisplayImageTask(engine, imageLoadingInfo,</div><div class="line">                    defineHandler(options));</div><div class="line">            <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                displayTask.run();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                engine.submit(displayTask);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在看方法的代码之前，先来看看其中的参数</li>
<li>uri：图片的路径</li>
<li>ImageAware：该接口的具体实现类会将ImageView包装成弱引用，这样使得GC能够及时回收ImageView，具体的实现类这里也不做多分析</li>
<li>DisplayImageOptions：展示图片时的参数配置，比如：默认的加载图片，加载失败展示的图片，是否开启内存缓存，磁盘缓存等</li>
<li>ImageLoadingListener：加载图片过程中的监听接口，类库中有提供缺省的类，方便我们重写其中的任何一个方法</li>
<li><p>ImageLoadingProgressListener：加载的进度监听接口</p>
</li>
<li><p>OK，解释完上面的参数，我们来看看方法：</p>
</li>
<li>首先会先调用checkConfiguration来见检查Configuration是否已经初始化，没有的话，抛出异常</li>
</ul>
<h5 id="传入的uri为空时的操作"><a href="#传入的uri为空时的操作" class="headerlink" title="传入的uri为空时的操作"></a>传入的uri为空时的操作</h5><ul>
<li>接着我们来分步剖析该方法，先来看下面的一段代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (TextUtils.isEmpty(uri)) &#123;</div><div class="line">            engine.cancelDisplayTaskFor(imageAware);</div><div class="line">            listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line">            <span class="keyword">if</span> (options.shouldShowImageForEmptyUri()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码的逻辑是对传入的uri为null时的处理</li>
<li><p>首先调用engine将缓存的imageAware的key值取消掉，接着如果有设置默认展示的图片的话，就展示，没有的话就直接调用回调接口的onLoadingComplte来表示展示完图片</p>
</li>
<li><p>下面来看看传入uri不为空的处理：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ImageSize targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</div><div class="line">    String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);</div><div class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</div><div class="line"></div><div class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</div><div class="line"></div><div class="line">    Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);</div></pre></td></tr></table></figure>
<ul>
<li><p>先获得Image的大小，接着生成image的缓存key值，最后调用engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);将image的key缓存在map中（在执行完后会被移除出缓存），最后从缓存中取出bitmap。</p>
</li>
<li><p>接下来，对该bitmap进行分情况的处理：存在缓存和不存在缓存</p>
</li>
</ul>
<h5 id="从内存中取出的Bitmap为空的操作"><a href="#从内存中取出的Bitmap为空的操作" class="headerlink" title="从内存中取出的Bitmap为空的操作"></a>从内存中取出的Bitmap为空的操作</h5><ul>
<li>不存在缓存中，也就是bitmap为null：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (options.shouldShowImageOnLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.isResetViewBeforeLoading()) &#123;</div><div class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">            LoadAndDisplayImageTask displayTask = <span class="keyword">new</span> LoadAndDisplayImageTask(engine, imageLoadingInfo,</div><div class="line">                    defineHandler(options));</div><div class="line">            <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                displayTask.run();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                engine.submit(displayTask);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在这种情况下，会先判断是否有设置加载图片过程中要展示的图片和图片在加载的过程中是否有被重新设置，有的话分别做相应的操作</li>
<li>接着将展示图片需要用到的配置参数包装成一个ImageLoadingInfo对象</li>
<li>再紧接着实例化LoadAndDisplayImageTask，该类的作用主要是从网络上或者文件系统中加载图片</li>
<li><p>最后判断是否需要同步加载，是的话在当前线程中run，否则调用engine中的submit提交一个任务</p>
</li>
<li><p>下面我们来分别对同步和异步加载两种情况进行分析：</p>
<h5 id="同步展示图片："><a href="#同步展示图片：" class="headerlink" title="同步展示图片："></a>同步展示图片：</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (waitIfPaused()) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (delayIfNeed()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        ReentrantLock loadFromUriLock = imageLoadingInfo.loadFromUriLock;</div><div class="line">        L.d(LOG_START_DISPLAY_IMAGE_TASK, memoryCacheKey);</div><div class="line">        <span class="keyword">if</span> (loadFromUriLock.isLocked()) &#123;</div><div class="line">            L.d(LOG_WAITING_FOR_IMAGE_LOADED, memoryCacheKey);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        loadFromUriLock.lock();</div><div class="line">        Bitmap bmp;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            checkTaskNotActual();</div><div class="line"></div><div class="line">            bmp = configuration.memoryCache.get(memoryCacheKey);</div><div class="line">            <span class="keyword">if</span> (bmp == <span class="keyword">null</span> || bmp.isRecycled()) &#123;</div><div class="line">                bmp = tryLoadBitmap();</div><div class="line">                <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// listener callback already was fired</span></div><div class="line"></div><div class="line">                checkTaskNotActual();</div><div class="line">                checkTaskInterrupted();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (options.shouldPreProcess()) &#123;</div><div class="line">                    L.d(LOG_PREPROCESS_IMAGE, memoryCacheKey);</div><div class="line">                    bmp = options.getPreProcessor().process(bmp);</div><div class="line">                    <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">                        L.e(ERROR_PRE_PROCESSOR_NULL, memoryCacheKey);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.isCacheInMemory()) &#123;</div><div class="line">                    L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</div><div class="line">                    configuration.memoryCache.put(memoryCacheKey, bmp);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                loadedFrom = LoadedFrom.MEMORY_CACHE;</div><div class="line">                L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.shouldPostProcess()) &#123;</div><div class="line">                L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</div><div class="line">                bmp = options.getPostProcessor().process(bmp);</div><div class="line">                <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">                    L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            checkTaskNotActual();</div><div class="line">            checkTaskInterrupted();</div><div class="line">        &#125; <span class="keyword">catch</span> (TaskCancelledException e) &#123;</div><div class="line">            fireCancelEvent();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            loadFromUriLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</div><div class="line">        runTask(displayBitmapTask, syncLoading, handler, engine);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先会做出两种判断：一种是是否暂停加载（库中有一个PauseOnScrollListener来控制是否要暂停加载图片）和是否要延迟进行</li>
<li>接下来尝试从内存内存缓存中取出Bitmap，如果Bitmap为null或者被回收了的话调用tryLoadBitmap</li>
<li>在tryLoadBitmap中会先尝试从硬盘缓存中取出存放Bitmap流的文件，如果存在的话返回获得的Bitmap，否则尝试从网络上加载图片，加载完成后顺便写进硬盘（如果设置了硬盘缓存的话）</li>
<li><p>再得到Bitmap以后回到run方法中，将bitmap写进内存缓存</p>
</li>
<li><p>如果bitmap存在缓存中的话，就直接使用该Bitmap</p>
</li>
<li><p>最后：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</div><div class="line">runTask(displayBitmapTask, syncLoading, handler, engine);</div></pre></td></tr></table></figure>
<ul>
<li><p>包装成一个展示Bitmap的Task，并调用runTask来执行展示Image的Task</p>
</li>
<li><p>以上的就是同步时，展示Image的操作，下面我们来分析异步展示图片</p>
</li>
</ul>
<h5 id="异步展示图片："><a href="#异步展示图片：" class="headerlink" title="异步展示图片："></a>异步展示图片：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Submits task to execution pool */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(<span class="keyword">final</span> LoadAndDisplayImageTask task)</span> </span>&#123;</div><div class="line">        taskDistributor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                File image = configuration.diskCache.get(task.getLoadingUri());</div><div class="line">                <span class="keyword">boolean</span> isImageCachedOnDisk = image != <span class="keyword">null</span> &amp;&amp; image.exists();</div><div class="line">                initExecutorsIfNeed();</div><div class="line">                <span class="keyword">if</span> (isImageCachedOnDisk) &#123;</div><div class="line">                    taskExecutorForCachedImages.execute(task);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    taskExecutor.execute(task);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法中有三个线程池：一：taskDistributor：任务分派线程池；二：taskExecutorForCachedImages缓存执行线程池；三：taskExecutor普通执行线程池</li>
<li>主要逻辑：通过从硬盘缓存中取出存放bitmap流的文件，如果该文件存在的话，在taskExecutorForCachedImages中执行传入的task，否则在普通线程池中执行task，至于怎么执行，我们在刚刚已经分析了。</li>
</ul>
<h5 id="取出的Bitmap不为空的操作"><a href="#取出的Bitmap不为空的操作" class="headerlink" title="取出的Bitmap不为空的操作"></a>取出的Bitmap不为空的操作</h5><ul>
<li><p>回到displayImage中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; !bmp.isRecycled()) &#123;</div><div class="line">            L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (options.shouldPostProcess()) &#123;</div><div class="line">                ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</div><div class="line">                        options, listener, progressListener, engine.getLockForUri(uri));</div><div class="line">                ProcessAndDisplayImageTask displayTask = <span class="keyword">new</span> ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</div><div class="line">                        defineHandler(options));</div><div class="line">                <span class="keyword">if</span> (options.isSyncLoading()) &#123;</div><div class="line">                    displayTask.run();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    engine.submit(displayTask);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</div><div class="line">                listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面代码中一开始包装了ProcessAndDisplayImageTask对象，该对象主要是Bitmap存在缓存中的Task对象，接着判断是要异步执行还是同步执行，最后的操作跟前面分析的逻辑差不多，这里也不做分析了</p>
</li>
</ul>
<h5 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h5><ul>
<li>上面主要分析了常用的一个displayImage而已，并且只是分析了一个调用流程，并没有分析其中的缓存策略还有其他的细节</li>
<li>在上面分析的流程中，我们可以清楚得体会ImageLoader中的分层思想。比如：对Bitmap存在内存与否分了两个展示图片的Task，执行不同类型的任务的线程池等。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Volley--网络优化和缓存]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/Volley--%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E5%92%8C%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>volley的特点都大家很清楚，volley适合数据量小且通信频繁的请求，但是不适合数据量大的请求。volley有这样的特点是由其内部网络优化和缓存所决定的，这次分析其中的原理。<br><a id="more"></a></p>
<h4 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h4><h5 id="ByteArrayPool"><a href="#ByteArrayPool" class="headerlink" title="ByteArrayPool"></a>ByteArrayPool</h5><ul>
<li>首先Volley网络优化跟两个类息息相关，他们分别是ByteArrayPool和PoolingByteArrayOutputStream。接下来首先分析前者。</li>
<li>进入该类中，可以看到该类很长的文档注释。主要的意思是为了减少堆内存的压力而在将该类作为一个字节缓冲池。</li>
<li><p>首先看看该类中的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** The buffer pool, arranged both by last use and by buffer size */</span></div><div class="line">  <span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersByLastUse = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">byte</span>[]&gt;();</div><div class="line">  <span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersBySize = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(<span class="number">64</span>);</div><div class="line"></div><div class="line">  <span class="comment">/** The total size of the buffers in the pool */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> mCurrentSize = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay</div><div class="line">   * under this limit.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mSizeLimit;</div></pre></td></tr></table></figure>
</li>
<li><p>两个List集合都是存放byte数组，也就是字节缓冲。mCurrentSize是记录当前缓冲池的大小。mSizeLimit是缓冲池的大小。</p>
</li>
<li><p>了解完成员变量的作用后，我们来看看其中的核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns a buffer from the pool if one is available in the requested size, or allocates a new</div><div class="line">     * one if a pooled one is not available.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> len the minimum size, in bytes, of the requested buffer. The returned buffer may be</div><div class="line">     *        larger.</div><div class="line">     * <span class="doctag">@return</span> a byte[] buffer is always returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] getBuf(<span class="keyword">int</span> len) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class="line">            <span class="keyword">byte</span>[] buf = mBuffersBySize.get(i);</div><div class="line">            <span class="keyword">if</span> (buf.length &gt;= len) &#123;</div><div class="line">                mCurrentSize -= buf.length;</div><div class="line">                mBuffersBySize.remove(i);</div><div class="line">                mBuffersByLastUse.remove(buf);</div><div class="line">                <span class="keyword">return</span> buf;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[len];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法的作用是向字节数组缓冲池中取出大于或者等于len长度的字节数组，取完后字节数组缓冲池的大小会减小。如果一直取的话，字节数组池肯定会被取完，所以也就有了向缓冲池中添加字节数组的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted</div><div class="line">    * size.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> buf the buffer to return to the pool.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnBuf</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (buf == <span class="keyword">null</span> || buf.length &gt; mSizeLimit) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       mBuffersByLastUse.add(buf);</div><div class="line">       <span class="keyword">int</span> pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class="line">       <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</div><div class="line">           pos = -pos - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">       mBuffersBySize.add(pos, buf);</div><div class="line">       mCurrentSize += buf.length;</div><div class="line">       trim();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Removes buffers from the pool until it is under its size limit.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">while</span> (mCurrentSize &gt; mSizeLimit) &#123;</div><div class="line">           <span class="keyword">byte</span>[] buf = mBuffersByLastUse.remove(<span class="number">0</span>);</div><div class="line">           mBuffersBySize.remove(buf);</div><div class="line">           mCurrentSize -= buf.length;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法的逻辑是向字节数组缓冲池中添加字节数组，并且当添加后，当前的缓冲池大小大于缓冲池的最大大小时，会控制其大小不超出规定的范围。</p>
</li>
<li>分析到里，为什么要用两个集合来存放Byte数组？</li>
<li>个人理解：<br>1.首先问题，我觉得在returnBuf中可用得到答案。因为在这个方法的最后，调用了trim（），该方法的作用是确保字节数组缓冲池的大小不超过最大限度。其中的移除思想是移除LastUseList的0号位的byte[]对象，然后也在BufSizeList中移除该Byte[]对象，直到字节数组缓冲池的大小不超过最大限度。<br>2.从移除LastUseList中的0号位，这使我想到的LinkList的特点，LinkList是用链表来实现的，链表的插入的话是直接插入到链表尾部的，换句话说，越晚插入的在List的越尾部，也就是越新的缓存，移除0号位的缓存是移除比较旧的缓存<br>3.因此，我觉得LastUseList的作用是来配合BufSiseList移除比较旧的缓存区</li>
</ul>
<hr>
<h5 id="PoolingByteArrayOutputStream"><a href="#PoolingByteArrayOutputStream" class="headerlink" title="PoolingByteArrayOutputStream"></a>PoolingByteArrayOutputStream</h5><p>接下来，我们来看看和ByteArrayPool配合使PoolingByteArrayOutputStream。</p>
<ul>
<li>该类继承了ByteArrayOutputStream，ByteArrayOutputStream的作用是在将数据源输入到其中的Byte数组中，也就是内存缓冲区。</li>
<li>该类的就是通过向字节数组缓冲池拿字节数组和添加字节数组。</li>
</ul>
<h5 id="BasicNetwork"><a href="#BasicNetwork" class="headerlink" title="BasicNetwork"></a>BasicNetwork</h5><ul>
<li>在BasicNetwork的performRequest方法中进行网络时，得到httpResponse后，再调用了：<br>  responseContents = entityToBytes(httpResponse.getEntity());</li>
<li><p>我们来看看entityToBytes方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Reads the contents of HttpEntity into a byte[]. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException, ServerError &#123;</div><div class="line">        PoolingByteArrayOutputStream bytes =</div><div class="line">                <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</div><div class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream in = entity.getContent();</div><div class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</div><div class="line">            &#125;</div><div class="line">            buffer = mPool.getBuf(<span class="number">1024</span>);</div><div class="line">            <span class="keyword">int</span> count;</div><div class="line">            <span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">                bytes.write(buffer, <span class="number">0</span>, count);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> bytes.toByteArray();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Close the InputStream and release the resources by "consuming the content".</span></div><div class="line">                entity.consumeContent();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="comment">// This can happen if there was an exception above that left the entity in</span></div><div class="line">                <span class="comment">// an invalid state.</span></div><div class="line">                VolleyLog.v(<span class="string">"Error occured when calling consumingContent"</span>);</div><div class="line">            &#125;</div><div class="line">            mPool.returnBuf(buffer);</div><div class="line">            bytes.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该类主要就是进行输入流的读取，但是它的读取不同于一般的读取，它内部的通过实例化PoolingByteArrayOutputStream，将读取的流都读到内部的字节数组，而字节数组的来源是字节数组缓冲池。这样做的好处是：由于不用再频繁给byte[]分配内部，而是通过从回收和利用字节数组，减少了堆的开销，将读取的数据全都读到缓冲中后，再一次性送出去。这样就大大提高了效率。</p>
</li>
</ul>
<hr>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>上面分析了ByteArrayPool和PoolByteArrayOutputStream的配合使用，<br>接着来分析缓存。缓存的操作主要是在DiskBaseCache中。</p>
<ul>
<li>现在我需要先来分析该类中的内部类CacheHeaher和CountingInputStream</li>
<li>在CacheHeader主要是对响应头进行缓存，其中readHeader和WriteHeader是将响应头读取和写进文件中</li>
<li>而CountingInputStream继承于FileInputStream中，主要扩展了记录读取的数据的长度</li>
<li>介绍完这两个内部类，我们来切入正题：</li>
<li><p>先看看类中初始化的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Initializes the DiskBasedCache by scanning for all files currently in the</div><div class="line">     * specified root directory. Creates the root directory if necessary.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mRootDirectory.exists()) &#123;</div><div class="line">            <span class="keyword">if</span> (!mRootDirectory.mkdirs()) &#123;</div><div class="line">                VolleyLog.e(<span class="string">"Unable to create cache dir %s"</span>, mRootDirectory.getAbsolutePath());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        File[] files = mRootDirectory.listFiles();</div><div class="line">        <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">            FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                fis = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">                CacheHeader entry = CacheHeader.readHeader(fis);</div><div class="line">                entry.size = file.length();</div><div class="line">                putEntry(entry.key, entry);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</div><div class="line">                   file.delete();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</div><div class="line">                        fis.close();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法的逻辑主要是如果读取文件中内容到内存中保存缓存头的map，该方法会在缓存线程总的run方法中的调用</p>
</li>
<li><p>接着看将数据写进文件的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Puts the entry with the specified key into the cache.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span> </span>&#123;</div><div class="line">        pruneIfNeeded(entry.data.length);</div><div class="line">        File file = getFileForKey(key);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">            CacheHeader e = <span class="keyword">new</span> CacheHeader(key, entry);</div><div class="line">            e.writeHeader(fos);</div><div class="line">            fos.write(entry.data);</div><div class="line">            fos.close();</div><div class="line">            putEntry(key, e);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> deleted = file.delete();</div><div class="line">        <span class="keyword">if</span> (!deleted) &#123;</div><div class="line">            VolleyLog.d(<span class="string">"Could not clean up file %s"</span>, file.getAbsolutePath());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>pruneIfNeeded（int）该方法会判断内存缓存的大小是不是够用，不够的话，就通过遍历删除，直到增加后的内存小于内存缓存最大的90%。</p>
</li>
<li>接着就是实例化CacheHeader对象，再将缓存头和数据一起写进文件，最后将缓存头添加进map中</li>
<li><p>再来看看从文件中读取的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Entry <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        CacheHeader entry = mEntries.get(key);</div><div class="line">        <span class="comment">// if the entry does not exist, return.</span></div><div class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        File file = getFileForKey(key);</div><div class="line">        CountingInputStream cis = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            cis = <span class="keyword">new</span> CountingInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">            CacheHeader.readHeader(cis); <span class="comment">// eat header</span></div><div class="line">            <span class="keyword">byte</span>[] data = streamToBytes(cis, (<span class="keyword">int</span>) (file.length() - cis.bytesRead));</div><div class="line">            <span class="keyword">return</span> entry.toCacheEntry(data);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            VolleyLog.d(<span class="string">"%s: %s"</span>, file.getAbsolutePath(), e.toString());</div><div class="line">            remove(key);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (cis != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    cis.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>先读取数据再和缓存头包装成一个Entry对象返回</p>
</li>
</ul>
<hr>
<ul>
<li>通过上面的分析，对Volley的高效等特点总算有了一个全新的认识。Volley内部通过使用字节数组缓存池的利用与回收来减少堆内存的频繁分配，以及通过缓存响应头来控制是否从缓存中读取数据，这样适合一些小数据但通信频繁的操作，而至于为什么会不适合用于数据量大的操作主要是由于请求读取的结果都是一次性存在内存中，当数据量大时可能导致内存爆炸。</li>
<li>Volley总体来说是面向接口编程，再将这些接口功能组合起来，具体的封装交给具体类，这样扩展性会突出</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AsyncTask源码浅析]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/AsyncTask%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h5 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h5><ul>
<li>概述<br>AsyncTask是一个执行异步任务的小型框架，里面封装了Handler，使得使用者不必关心线程之间的切换，虽然现在执行异步任务都不会用AsyncTask，用得更多的是Bolt Tasks 和RxJava，但是AsyncTask中的设计思想还是很多值得学习的，比如：内部中，串行运行任务时的队列控制，handler的将结果回调回主线程，以及如何取消正在执行的任务等。。<a id="more"></a></li>
<li>我们知道，使用AsyncTask的要先实例化该类再调用其中的execute（）方法，那么自然先要来看其中的构造方法都初始化了哪些操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               Result result = doInBackground(mParams);</div><div class="line">               Binder.flushPendingCommands();</div><div class="line">               <span class="keyword">return</span> postResult(result);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面的代码中，分别实例化了WorkRunnable对象和FutureTask对象，其中，WorkRunnable是一个内部类，我们来看看该内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</div><div class="line">       Params[] mParams;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该类实现了Callable接口，其中保存了Params参数，也就是AsyncTask传入的参数</p>
</li>
<li><p>我们接下去看看execute（Params)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>该方法返回AsyncTask本身，调用者可以根据需要保持对其的引用</p>
</li>
<li><p>execute（Params… params）executeOnExecutor(sDefaultExecutor, params)；我们点进该方法中看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">            Params... params) &#123;</div><div class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">            <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">                <span class="keyword">case</span> RUNNING:</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                            + <span class="string">" the task is already running."</span>);</div><div class="line">                <span class="keyword">case</span> FINISHED:</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                            + <span class="string">" the task has already been executed "</span></div><div class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">        onPreExecute();</div><div class="line"></div><div class="line">        mWorker.mParams = params;</div><div class="line">        exec.execute(mFuture);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Status是类中的枚举，作用是记录Task的运行状态。onPreExecute()，我们可以在该方法中做一些UI线程的初始化操作</p>
</li>
<li>接着将传进的参数赋值给mWork.parmas,也就是在构造函数初始化的WorkRunnable对象，保存了传入的参数</li>
<li>最后调用了传入的线程池的execute（Runnable）并且返回本身</li>
<li>传入的线程池是里面默认的线程池，该线程池是一个串行执行的</li>
<li><p>我们来看看该默认的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">        Runnable mActive;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        r.run();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        scheduleNext();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">                scheduleNext();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内部类中，将传入的Runnable对象添加到mTask队列中，并且在scheduleNext()方法中从mTask队列中拿出头元素，将该元素在后台线程池中执行</p>
</li>
<li>讲到这里，我们可以看出AsyncTask中的串行执行是通过在默认的线程池中进行队列控制，真正执行的是在后台线程池中执行，并且在执行完再安排下一个任务到后台线程池，这样就巧妙的完成了串行运行</li>
<li>我们回来execute（Runnable），传入的参数是mFutureTask，该对象是在之前构造函数实例化的，让我们回到构造函数：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               Result result = doInBackground(mParams);</div><div class="line">               Binder.flushPendingCommands();</div><div class="line">               <span class="keyword">return</span> postResult(result);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在FutureTask中，将callable对象出传入，现在看看mWorker其中的操作</p>
<ul>
<li>首先设置一个任务被调用的标记</li>
<li>接着调用doInBackground(mParams);该方法是我们重写的方法</li>
<li>最后将结果传入postResult(Result)中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">               <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">       message.sendToTarget();</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法中的逻主要是通过handler发送一条消息，该消息是包含结果对象的消息</li>
<li><p>我们先来看看内部类AsyncTaskResult<result>：</result></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">        <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">            mTask = task;</div><div class="line">            mData = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类中主要是保存了传入的结果以及AsyncTask自身</p>
</li>
<li>接着来看看InternalHandler()：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">           <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">               <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                   <span class="comment">// There is only one result</span></div><div class="line">                   result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                   result.mTask.onProgressUpdate(result.mData);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该内部类重写的Handler是运行在线程的handler，在handleMessage中接收处理消息</p>
</li>
<li><p>分析完了这两个内部类，我们回到postResult中发送消息，消息到达的是InternalHandler的 handleMessage，</p>
</li>
<li>result.mTask.finish(result.mData[0])，该语句调用了finish。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">           onCancelled(result);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           onPostExecute(result);</div><div class="line">       &#125;</div><div class="line">       mStatus = Status.FINISHED;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法中会先判断任务是不是被取消，如果没有的话，就地调用onPostExecute(result);也就是我们重写的结果方法</p>
</li>
<li><p>以上就是AsyncTask的执行流程。publishProgress方法的执行跟postResult差不多，这里不分析</p>
</li>
<li><p>关于AsyncTask现在支持并行运行，如果想要并且并行运行的话，可以调用executeOnExecutor(THREAD_POOL_EXECUTOR,<br>Params… params)。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Volley--队列控制]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/Volley--%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h4 id="Volley之四个队列的配合使用"><a href="#Volley之四个队列的配合使用" class="headerlink" title="Volley之四个队列的配合使用"></a>Volley之四个队列的配合使用</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>在Volley中，存在这四个重要的队列，这次想单独来分析一下这四个队列的配合使用。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><ul>
<li><p>先看看源码中的四个队列，这四个队列在RequestQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Staging area for requests that already have a duplicate request in flight.</div><div class="line"> *</div><div class="line"> * &lt;ul&gt;</div><div class="line"> *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache</div><div class="line"> *          key.&lt;/li&gt;</div><div class="line"> *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request</div><div class="line"> *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The set of all requests currently being processed by this RequestQueue. A Request</div><div class="line"> * will be in this set if it is waiting in any queue or currently being processed by</div><div class="line"> * any dispatcher.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** The cache triage queue. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mCacheQueue =</div><div class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** The queue of requests that are actually going out to the network. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mNetworkQueue =</div><div class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</div></pre></td></tr></table></figure>
</li>
<li><p>上面的四个队列中，有两个队列的类型是一样的，都是无界阻塞队列，而剩下的一个是HashSet队列，另一个则是Hashmap。</p>
</li>
<li>Set集合最大的一个特点就是集合中的元素是不能重复的，如果向其中添加重复的元素的话，就出现返回false来表示添加失败。</li>
<li><p>在分析队列之前，我们先来看看start方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">       stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></div><div class="line">       <span class="comment">// Create the cache dispatcher and start it.</span></div><div class="line">       mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">       mCacheDispatcher.start();</div><div class="line"></div><div class="line">       <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">           NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                   mCache, mDelivery);</div><div class="line">           mDispatchers[i] = networkDispatcher;</div><div class="line">           networkDispatcher.start();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在实例化缓存线程和网络线程的时候将对应的队列都传入构造方法中，也就是缓存线程和网路线程中的对应的队列都是引用指向该类中实例化的队列，这样在向队列添加元素的时候，对应的线程就能处理，换句话说，所有添加队列元素的操作都在该类中的一个add方法中。那么，接下来自然要看看add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Adds a Request to the dispatch queue.</div><div class="line">     * <span class="doctag">@param</span> request The request to service</div><div class="line">     * <span class="doctag">@return</span> The passed-in request</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></div><div class="line">        request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">            mCurrentRequests.add(request);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Process requests in the order they are added.</span></div><div class="line">        request.setSequence(getSequenceNumber());</div><div class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></div><div class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span></div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">                <span class="comment">// There is already a request in flight. Queue up.</span></div><div class="line">                Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">                <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                    stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</div><div class="line">                &#125;</div><div class="line">                stagedRequests.add(request);</div><div class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></div><div class="line">                <span class="comment">// flight.</span></div><div class="line">                mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">                mCacheQueue.add(request);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>一开始就向mCurrentRequest中添加请求，由于set集合的特点，添加相同的元素是不能成功添加的，所以该队列的作用是记录所有不同的网络请求。</p>
</li>
<li>接下来的逻辑是这样的：先判断mWaitingRequests中是不是存在该请求的key值，不存在的话在mWaitingRequests中添加key-value：cacheKey-null，这样的操纵是为了下一次有相同的请求添加进来的情况作准备，如果下次有相同的请求添加进来，mWaitingRequests中已经有了该关键子，所以会进入if语句中，在if中，主要的操作就是将该相同的请求放进一个Queue中，该Queue对应一个key值，放进mWaitingRequest中，</li>
<li>现在我们来梳理一下这个方法：总的来说mWaitingRequest中存放的是相同的请求的队列，而mCurrentRequest则是存放所有的不同的请求的队列。</li>
<li><p>我们在add方法中看到，添加进来的请求会有两个去向（假设该请求是第一次发送，也就是说缓存队列中没有该请求），一是被放进网络队列，二是被添加进缓存队列，这样的话，我们先来看看网络线程中的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">       Request request;</div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// Take a request from the queue.</span></div><div class="line">               request = mQueue.take();</div><div class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">               <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">               <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// If the request was cancelled already, do not perform the</span></div><div class="line">               <span class="comment">// network request.</span></div><div class="line">               <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                   request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Tag the request (if API &gt;= 14)</span></div><div class="line">               <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class="line">                   TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Perform the network request.</span></div><div class="line">               NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">               request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// If the server returned 304 AND we delivered a response already,</span></div><div class="line">               <span class="comment">// we're done -- don't deliver a second identical response.</span></div><div class="line">               <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Parse the response here on the worker thread.</span></div><div class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">               request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// Write to cache if applicable.</span></div><div class="line">               <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></div><div class="line">               <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                   mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                   request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Post the response back.</span></div><div class="line">               request.markDelivered();</div><div class="line">               mDelivery.postResponse(request, response);</div><div class="line">           &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">               parseAndDeliverNetworkError(request, volleyError);</div><div class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">               VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">               mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在while循环中，从网络队列拿出了一条请求，也就是我们之前放的（当网络队列为空时，该线程会出现阻塞情况），接着就是网络访问，我们这里先不讨论网路访问的细节，我们来看看请求完得到Response对象后的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mDelivery.postResponse(request, response);</div></pre></td></tr></table></figure>
</li>
<li><p>这句话的意思就是把得到的请求通过Delivery post出去，这时候我们就得来看看该类的具体实现类中的方法了的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Deliver a normal response or error, depending.</span></div><div class="line">           <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">               mRequest.deliverResponse(mResponse.result);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               mRequest.deliverError(mResponse.error);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class="line">           <span class="comment">// and the request can be finished.</span></div><div class="line">           <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">               mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               mRequest.finish(<span class="string">"done"</span>);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果isSuccess的话，就deliverResponse，该方法是我们具体的请求实现类中重写的方法，也就是我们在客户端的网络请求回掉</p>
</li>
<li><p>接着我们看到还调用了Request的finish，而finish又是调用了Request中的finish，我们来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">       <span class="comment">// Remove from the set of requests currently being processed.</span></div><div class="line">       <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">           mCurrentRequests.remove(request);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">               String cacheKey = request.getCacheKey();</div><div class="line">               Queue&lt;Request&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">               <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                       VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                               waitingRequests.size(), cacheKey);</div><div class="line">                   &#125;</div><div class="line">                   <span class="comment">// Process all queued up requests. They won't be considered as in flight, but</span></div><div class="line">                   <span class="comment">// that's not a problem as the cache has been primed by 'request'.</span></div><div class="line">                   mCacheQueue.addAll(waitingRequests);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先在mCurrentRequest中移除已经成功访问的请求</p>
</li>
<li>接着判断该请求是不是该缓存（默认是缓存的），再移除mWaitingRequests中持有该请求key的相同请求，最后添加进缓存队列</li>
<li>我们来小结：在finish方法中主要是在mWaitingQueue中移除成功响应的请求，接着如果mWaitingQueue中有相同的请求的话，就把这相同的请求添加进缓存队列。</li>
<li><p>最后，我们来分析分析缓存线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"></div><div class="line">       <span class="comment">// Make a blocking call to initialize the cache.</span></div><div class="line">       mCache.initialize();</div><div class="line"></div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// Get a request from the cache triage queue, blocking until</span></div><div class="line">               <span class="comment">// at least one is available.</span></div><div class="line">               <span class="keyword">final</span> Request request = mCacheQueue.take();</div><div class="line">               request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line"></div><div class="line">               <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></div><div class="line">               <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                   request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Attempt to retrieve this item from cache.</span></div><div class="line">               Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">               <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                   request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                   <span class="comment">// Cache miss; send off to the network dispatcher.</span></div><div class="line">                   mNetworkQueue.put(request);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// If it is completely expired, just send it to the network.</span></div><div class="line">               <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                   request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                   request.setCacheEntry(entry);</div><div class="line">                   mNetworkQueue.put(request);</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></div><div class="line">               request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                       <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">               request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                   <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></div><div class="line">                   mDelivery.postResponse(request, response);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></div><div class="line">                   <span class="comment">// but we need to also send the request to the network for</span></div><div class="line">                   <span class="comment">// refreshing.</span></div><div class="line">                   request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                   request.setCacheEntry(entry);</div><div class="line"></div><div class="line">                   <span class="comment">// Mark the response as intermediate.</span></div><div class="line">                   response.intermediate = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                   <span class="comment">// Post the intermediate response back to the user and have</span></div><div class="line">                   <span class="comment">// the delivery then forward the request along to the network.</span></div><div class="line">                   mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                       <span class="meta">@Override</span></div><div class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                           <span class="keyword">try</span> &#123;</div><div class="line">                               mNetworkQueue.put(request);</div><div class="line">                           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                               <span class="comment">// Not much we can do about this.</span></div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">               <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">               <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>第一步的操作跟网络线程中差不多，先从缓存队列中拿出请求，接着判断该缓存请求的结果是不是有被写进缓存和是不是完全过期。如果没有被写进缓存的话，就添加进网络队列（也就是让网路线程处理该请求）；如果完全过期的话，也添加进网络队列。</p>
</li>
<li>接下来判断从缓存中拿出的请求是不是需要更新，需要的话，就post到线程池中，将请求添加网络队列，接下来的处理跟上面分析网络线程一样。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>从上面的分析，可以看出来，mCurrentRequests中保存的是所有不同的网络请求，该唯一性是有set集合的特点来保证的；mWaitingRequests则是暂存相同的请求，缓存队列和网络队列就不用说都明白了。</li>
<li>至于他们之间的配合，看看下面这张图的话，会更清晰：<br><img src="/uploads/Volley队列配合.png" alt=""></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓开发艺术探索-View的工作原理（一）-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h4 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h4><h5 id="初始ViewRoot和DecorView"><a href="#初始ViewRoot和DecorView" class="headerlink" title="初始ViewRoot和DecorView"></a>初始ViewRoot和DecorView</h5><a id="more"></a>
<ul>
<li><p>ViewRoot对应的实体类是ViewRootImpl类，它时连接WindowManager和DecorView的纽带</p>
</li>
<li><p>View的三大流程都是通过ViewRoot完成的</p>
</li>
<li><p>在ActivityThread中，当Activity对象被创建后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewImpl对象和DecorView建立关联：</p>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext, display);</div><div class="line">root.setView(view, wparams, panelParentView);</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>View的绘制流程是从ViewRoot的performTraversals中开始的，它经过measure，layout，draw三个过程。</p>
</li>
<li><p>performTraversals大致流程：</p>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>childLayoutParams\parentSpecMode</th>
<th>ECACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp/px</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><p>DecorView作为顶级View，本质是一个LinearLayout，该layout中一般情况下包含标题栏和内容栏。</p>
</li>
<li><p>在Activity中，我们setContentView所设置的布局，其实就是被加到内容栏中的</p>
</li>
</ul>
<hr>
<h5 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h5><p>MeasureSpec很大程度上决定了一个View的尺寸规格，之所以说很大程度，其实时因为在这个过程中还受父容器的影响，父容器回影响View的MeasureSpec的创建。</p>
<ul>
<li><p>MeasureSpec代表一个32位的int值，高2位代表SpecMode：测量模式，低30位表示SpecSize：在某种模式下的测量规格。</p>
</li>
<li><p>在下面的源码中，MeasureSpec将SpecMode和SpecSize打包成一个int值来避免过多对象内存的分配。为了方便操作提供了打包和解包的方法</p>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has not imposed any constraint</div><div class="line">         * on the child. It can be whatever size it wants.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has determined an exact size</div><div class="line">         * for the child. The child is going to be given those bounds regardless</div><div class="line">         * of how big it wants to be.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The child can be as large as it wants up</div><div class="line">         * to the specified size.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Like &#123;<span class="doctag">@link</span> #makeMeasureSpec(int, int)&#125;, but any spec with a mode of UNSPECIFIED</div><div class="line">         * will automatically get a size of 0. Older apps expect this.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@hide</span> internal use only for compatibility with system widgets and older apps</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the mode from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the mode from</div><div class="line">         * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#UNSPECIFIED&#125;,</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#AT_MOST&#125; or</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#EXACTLY&#125;</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the size from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the size from</div><div class="line">         * <span class="doctag">@return</span> the size in pixels defined in the supplied measure specification</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</div><div class="line">            <span class="keyword">int</span> size = getSize(measureSpec);</div><div class="line">            <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="comment">// No need to adjust size for UNSPECIFIED mode.</span></div><div class="line">                <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            size += delta;</div><div class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">                Log.e(VIEW_LOG_TAG, <span class="string">"MeasureSpec.adjust: new size would be negative! ("</span> + size +</div><div class="line">                        <span class="string">") spec: "</span> + toString(measureSpec) + <span class="string">" delta: "</span> + delta);</div><div class="line">                size = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>SpecMode有三类：</p>
<ul>
<li><p>UNSPECIFIED：父容器不对View有限制，这种情况一般用于系统内部，表示一种测量的状态</p>
</li>
<li><p>EXACTLY：父容器已经检验出View所需要的大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式</p>
</li>
<li><p>AT_MOST:父容器指定了一个可用的大小，即SpecSize，View的大小不能大于这个值。它对应于LayoutParams中的wrap_content</p>
</li>
</ul>
</li>
<li><p>MeasureSpec和LayoutParams的对应关系</p>
<ul>
<li><p>正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParams。在View测量的时候，系统会将LayoutParams在父容器的约束下转为对应的MeasureSpec，然后再根据这个MeasureSpec来确定View的宽高</p>
</li>
<li><p>LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽高</p>
</li>
<li><p>对于顶级View（DecorView）和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定</p>
</li>
<li><p>DecorView的MeasureSpec创建过程是在ViewRootImpl中的measureHierarchy方法创建的：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>接着看看getRootMeasureSpec：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;pre style="background-color:#21282d;color:#e0e2e4;font-family:'Courier New';font-size:15.0pt;"&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class="line"> int measureSpec;</div><div class="line"> switch (rootDimension) &#123;</div><div class="line"></div><div class="line"> case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line"> // Window can't resize. Force root view to be windowSize.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line"> case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line"> // Window can resize. Set max size for root view.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line"> break;</div><div class="line"> default:</div><div class="line"> // Window wants to be an exact size. Force root view to be that size.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line">&#125;  return measureSpec;&lt;/pre&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>LayoutParams.MATCH_PARENT:精确模式，大小就是窗口的大小；</p>
</li>
<li><p>LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小</p>
</li>
<li><p>固定大小：精确模式，大小为LayoutParams中指定的大小。</p>
</li>
</ul>
<hr>
<ul>
<li>对于普通View来说（指的时我们布局中的View），它的measure过程是由ViewGroup传递过来的，下面看看ViewGroup中的measureChildWithMargins：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">           <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">       <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                       + widthUsed, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                       + heightUsed, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>从上面代码来看，子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，此外还有与View的margin和padding有关，下面再看看ViewGroup的getChildMeasureSpec：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">      <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">      <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">      <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">              <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">              <span class="comment">// be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">              <span class="comment">// big it should be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>从上面的方法来看，它的主要作用时结合父容器发MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，参数中的padding指的是父容器中已被占用的空间大小。</p>
</li>
<li><p>下面的表是对getChildMeasureSpec的工作原理的梳理，其中parentSize指的是父容器中目前可以使用的大小。</p>
</li>
</ul>
<hr>
<p><img src="index_files/f78c4596-e57c-41be-a3ca-a75bdcd06778.jpg" alt=""></p>
<h4 id="View的工作过程"><a href="#View的工作过程" class="headerlink" title="View的工作过程"></a>View的工作过程</h4><h5 id="View的measure过程："><a href="#View的measure过程：" class="headerlink" title="View的measure过程："></a>View的measure过程：</h5><ul>
<li>measure方法时一个final方法，则意味着不能重写该方法，在该方法中会调用View的onMeasure方法（真正测量的方法）， 下面我们看看onMeasure的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">  getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setMeasureDimension方法中会设置View的宽高的测量值，因此，我们来看看getDefaultSize方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = size;</div><div class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">  result = size;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">  <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">  result = specSize;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"> &#125;  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于我我们来说，我们只看AT_MOST和EXACTLY这两种情况。简单的理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，这个specSize就是测量后View的大小，这里说时是测量后，是因为View的最终大小是在layout阶段确定的，除了特殊情况外，View的测量大小和最终大小是相等的。</p>
<ul>
<li>对于UNSPECIFIED来说，一般用于系统内部测量，在这种情况下，View的大小为getDefaultSize第一个参数size，即分别为getSuggestedMinimumWidth/Height：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果View没有设置背景，那么View的高度为mMinHeight，而该属性对应于aandroid：minWidth，如果这个属性不指定的话，默认为0。如果设置了背景则返回minHeight和背景的最小高度中的最大值</p>
<ul>
<li><p>从getDefaultSize的实现来看，我们可以得到以下小结：</p>
<ul>
<li><p>直接继承View的自定义控件需要重写onMeasure方法设置wrap_content时的自身大小，否则在布局中使用就相当于match_parent</p>
</li>
<li><p>通过之前分析，如果View在布局中被设为wrap_content的话，它的specMode时AT_MOST模式，此时它的宽高等于specSize，而View的specSize是parentSize，parentSize是父容器目前所剩余的空间大小。这样这种效果就相当于match_parent</p>
</li>
<li><p>解决方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"> <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"> <span class="keyword">int</span> widthSpecMode = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> widthSpecSize = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecMode = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecSize = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, mHeight);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, heightSpecSize);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(heightSpecMode == View.MeasureSpec.AT_MOST)&#123;</div><div class="line"> setMeasureDimension(widthSpecSize, mHeight);</div><div class="line"></div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于wrap_content的情形，我们直接设置我们默认的大小就可以</p>
<hr>
<h5 id="ViewGroup的measure过程："><a href="#ViewGroup的measure过程：" class="headerlink" title="ViewGroup的measure过程："></a>ViewGroup的measure过程：</h5><ul>
<li><p>ViewGroup除了测量自身的大小外，还会遍历所有的子元素的measure方法，各个子元素再递归去执行这个过程</p>
</li>
<li><p>ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但是提供了一个measureChildren的方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码来看，ViewGroup在meaure的时候，会对每个子元素进行measure，下面来看看measureChild：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>meaureChild中，就是取出子元素的LayoutParams，然后通过getChildMeasureSpec来创建子元素的MeasureSpec。将MeaureSpec直接传递给View的meaure进行测量。</p>
<ul>
<li><p>我们知道ViewGroup是一个抽象类，并没有实现具体的测量过程，所以，我们来看看它子类中的实现，下面用LinearLayout来当例子</p>
</li>
<li><p>首先先来看看其onMeasure方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面代码中，根据不同的布局方向来测量，我们选择来看竖直方向的测量过程中的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// See how tall everyone is. Also remember max width.</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">          <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">              mTotalLength += measureNullChild(i);</div><div class="line">              <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">             i += getChildrenSkipCount(child, i);</div><div class="line">             <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">              mTotalLength += mDividerHeight;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">          totalWeight += lp.weight;</div><div class="line">          </div><div class="line">          <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Optimization: don't bother measuring children who are going to use</span></div><div class="line">              <span class="comment">// leftover space. These views will get measured again down below if</span></div><div class="line">              <span class="comment">// there is any leftover space.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class="line">              skippedMeasure = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></div><div class="line">                  <span class="comment">// child wanted to stretch to fill available space.</span></div><div class="line">                  <span class="comment">// Translate that to WRAP_CONTENT so that it does not end up</span></div><div class="line">                  <span class="comment">// with a height of 0</span></div><div class="line">                  oldHeight = <span class="number">0</span>;</div><div class="line">                  lp.height = LayoutParams.WRAP_CONTENT;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// Determine how big this child would like to be. If this or</span></div><div class="line">              <span class="comment">// previous children have given a weight, then we allow it to</span></div><div class="line">              <span class="comment">// use all available space (and we will shrink things later</span></div><div class="line">              <span class="comment">// if needed).</span></div><div class="line">              measureChildBeforeLayout(</div><div class="line">                     child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</div><div class="line">                     totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">                 lp.height = oldHeight;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                     lp.bottomMargin + getNextLocationOffset(child));</div></pre></td></tr></table></figure>
<p>系统会遍历每个子元素，并且对每个子元素进行measureChildBeforeLayout，这个方法会调用子元素的measure，这样就开始了measure过程，并且系统会通过mToatalLength这个变量来保存LinearLayout在竖直方向上的初步高度，当测量完子元素时，LinearLauout会测量自己的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add in our padding</span></div><div class="line">       mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> heightSize = mTotalLength;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum height</span></div><div class="line">       heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line">       </div><div class="line">       <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></div><div class="line">       <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">       heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line">       </div><div class="line">       <span class="comment">// Either expand children with weight to take up available space or</span></div><div class="line">       <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></div><div class="line">       <span class="comment">// measurement on any children, we need to measure them now.</span></div><div class="line">       <span class="keyword">int</span> delta = heightSize - mTotalLength;</div><div class="line">       <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">           <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line"></div><div class="line">           mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">               <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line">               </div><div class="line">               LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">               </div><div class="line">               <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">               <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                   <span class="comment">// Child said it could absorb extra space -- give him his share</span></div><div class="line">                   <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">                   weightSum -= childExtra;</div><div class="line">                   delta -= share;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                           mPaddingLeft + mPaddingRight +</div><div class="line">                                   lp.leftMargin + lp.rightMargin, lp.width);</div><div class="line"></div><div class="line">                   <span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">                   <span class="comment">// child has been previously measured</span></div><div class="line">                   <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != MeasureSpec.EXACTLY)) &#123;</div><div class="line">                       <span class="comment">// child was measured once already above...</span></div><div class="line">                       <span class="comment">// base new measurement on stored values</span></div><div class="line">                       <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</div><div class="line">                       <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</div><div class="line">                           childHeight = <span class="number">0</span>;</div><div class="line">                       &#125;</div><div class="line">                       </div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// child was skipped in the loop above.</span></div><div class="line">                       <span class="comment">// Measure for this first time here      </span></div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// Child may now not fit in vertical dimension.</span></div><div class="line">                   childState = combineMeasuredStates(childState, child.getMeasuredState()</div><div class="line">                           &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</div><div class="line">               maxWidth = Math.max(maxWidth, measuredWidth);</div><div class="line"></div><div class="line">               <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</div><div class="line">                       lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                       matchWidthLocally ? margin : measuredWidth);</div><div class="line"></div><div class="line">               allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">               mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</div><div class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Add in our padding</span></div><div class="line">           mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">           <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                                          weightedMaxWidth);</div><div class="line"></div><div class="line"></div><div class="line">           <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></div><div class="line">           <span class="comment">// Children will have already been measured once.</span></div><div class="line">           <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                   <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">                       <span class="keyword">continue</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                           (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                   <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">                   <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                       child.measure(</div><div class="line">                               MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</div><div class="line">                                       MeasureSpec.EXACTLY),</div><div class="line">                               MeasureSpec.makeMeasureSpec(largestChildHeight,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">           maxWidth = alternativeMaxWidth;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       maxWidth += mPaddingLeft + mPaddingRight;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum width</span></div><div class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line">       </div><div class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">               heightSizeAndState);</div></pre></td></tr></table></figure>
<ul>
<li><p>分析到这里算是把measure分析完了，下面我们来看看需要注意的一些地方：</p>
<ul>
<li>如果要获取View的测量宽高或者最终宽高的话，比较好的做法是在onLayout中获取，因为在某些极端的情况下，measure可能会被多次调用，这样在onMeasure获取的宽高就不准确</li>
</ul>
</li>
<li><p>四种方法中的三种解决Activity启动时获取View的宽高</p>
<ul>
<li><p>在onWindowFocusChanged中获取： 该方法会在窗口的得到和失去焦点的时候被调用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</div><div class="line">    <span class="keyword">if</span>(hasFocus) &#123;</div><div class="line">        <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">        <span class="keyword">int</span> heigh = view.getMeasureHeight();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>view.post(runnable):将一个runnable投递到消息队列尾部，等待Looper调用此runnable的时候，View已经初始化完成了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        view.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ViewTreeObserver：使用其中的OnGlobalLayoutListener这个接口，当View状态或者View树内部的View可见性发现改变时，onGlobalLayout会被回调。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line"></div><div class="line">        ViewTreeObserver observer = view.getViewTreeObserver();</div><div class="line">        observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">                view.getViewTreeObserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h5><ul>
<li>先看看View的layout方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在layout中首先会通过setFrame方法来设定View的四个顶点位置，即初始化mLeft， mRight， mTop， mBottom，view的顶点确定后，那么View在ViewGroup中的位置也相应的确定；接着调用onLayout的方法，该方法的具体实现是在ViewGroup的子类中，我们来看看LinearLayout中是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           layoutVertical(l, t, r, b);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           layoutHorizontal(l, t, r, b);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们只拿竖直方向上的来分析：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> childTop;</div><div class="line">        <span class="keyword">int</span> childLeft;</div><div class="line">        </div><div class="line">        <span class="comment">// Where right end of child should go</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</div><div class="line">        <span class="keyword">int</span> childRight = width - mPaddingRight;</div><div class="line">        </div><div class="line">        <span class="comment">// Space available for child</span></div><div class="line">        <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</div><div class="line">        </div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (majorGravity) &#123;</div><div class="line">           <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">           <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">           <span class="keyword">case</span> Gravity.TOP:</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                childTop += measureNullChild(i);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">                </div><div class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> gravity = lp.gravity;</div><div class="line">                <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</div><div class="line">                    gravity = minorGravity;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</div><div class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</div><div class="line">                                + lp.leftMargin - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</div><div class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.LEFT:</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        childLeft = paddingLeft + lp.leftMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                    childTop += mDividerHeight;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                childTop += lp.topMargin;</div><div class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                        childWidth, childHeight);</div><div class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line"></div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此方法会遍历所有子元素并调用setChildFrame来为子元素指定相应的位置，该方法中调用了子元素的layout方法，这样就实现了View的一层层测量。</p>
<ul>
<li><p>分析完了layout，我们来看看哪些需要注意的地方：</p>
<ul>
<li>View的getMeasureWidth和getWidth有什么区别：我们首先来看看getWidth的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> mRight - mLeft;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在View的默认实现过程中，View的测量宽高和最终宽高时相等的，只不过两者的赋值时机不同而已，测量宽高是在measure，而最终宽高是在layout。</p>
</li>
</ul>
<hr>
<h5 id="draw过程："><a href="#draw过程：" class="headerlink" title="draw过程："></a>draw过程：</h5><ul>
<li><p>View的绘制过程遵循下面这几步：</p>
<ul>
<li>绘制自己的背景（bakcground.draw(canvas)）</li>
<li>绘制自己（onDraw）</li>
<li>绘制children（dispatchDraw）</li>
<li>绘制装饰（onDrawScrollBars）</li>
</ul>
</li>
<li><p>上面的这个步骤可以在draw源码中看出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">               (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">       <span class="comment">/*</span></div><div class="line">        * Draw traversal performs several drawing steps which must be executed</div><div class="line">        * in the appropriate order:</div><div class="line">        *</div><div class="line">        *      1. Draw the background</div><div class="line">        *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">        *      3. Draw view's content</div><div class="line">        *      4. Draw children</div><div class="line">        *      5. If necessary, draw the fading edges and restore layers</div><div class="line">        *      6. Draw decorations (scrollbars for instance)</div><div class="line">        */</div><div class="line"></div><div class="line">       <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">       <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">           drawBackground(canvas);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">       <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">           <span class="comment">// Step 3, draw the content</span></div><div class="line">           <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Step 4, draw the children</span></div><div class="line">           dispatchDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">           <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">               mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">           onDrawForeground(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// we're done...</span></div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>View的绘制过程的传递时通过dispatchDraw来实现的，该方法回遍历所有子元素的draw（具体的实现实在ViewGroup的子类中），这样draw就可以一层层传递下去。View中的一个特殊方法：setWillNotDraw:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</div><div class="line">       setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>如果一个View不需要绘制任何内容的话，我们就可以把这个标记设为true。默认情况下View没有启动这个标志，但是ViewGroup会默认启动。如果我们自定义控件的时候需要继承ViewGroup时，我们就可以开启这个标记来便于系统的后续优化。</p>
<blockquote>
<p>以上的笔记来源于安卓开发艺术探索</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓开发艺术探索-自定义View的思想-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h4 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h4><h5 id="概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理"><a href="#概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理" class="headerlink" title="概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理"></a>概述：自定义是一项比较综合性的技术，它涉及到了View的层次结构，事件分发机制以及View的工原理</h5><a id="more"></a>
<h5 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h5><ul>
<li>继承View重写onDraw方法：采用这种方式需要自己支持wrap_content和padding</li>
<li>继承ViewGroup派生出特殊的layout：需要根据需求来处理ViewGroup的测量和布局这两个过程，并且同时处理子元素的测量和布局的过程</li>
<li>继承特定的View（比如TextView）：扩展某种View的功能</li>
<li>继承特定的ViewGroup（比如LinearLayout）</li>
</ul>
<h5 id="自定义View须知："><a href="#自定义View须知：" class="headerlink" title="自定义View须知："></a>自定义View须知：</h5><ul>
<li>让View支持wrap_content</li>
<li>如果有必要，让你的View支持padding</li>
<li>尽量要在View中使用Handler，没必要</li>
<li>View中如果有线程或者动画，需要及时停止</li>
<li>View带有滑动嵌套情形时，需要处理好滑动冲突</li>
</ul>
<h5 id="自定义View的实例，具体在书中P202-P216"><a href="#自定义View的实例，具体在书中P202-P216" class="headerlink" title="自定义View的实例，具体在书中P202~P216"></a>自定义View的实例，具体在书中P202~P216</h5><blockquote>
<p>以上笔记来源于安卓开发艺术探索一书中</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓开发艺术探索-View的事件体系-笔记]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="第三章：View的事件体系"><a href="#第三章：View的事件体系" class="headerlink" title="第三章：View的事件体系"></a>第三章：View的事件体系</h4><h5 id="View的位置参数："><a href="#View的位置参数：" class="headerlink" title="View的位置参数："></a>View的位置参数：</h5><a id="more"></a>
<ul>
<li>View的位置参数left， top， right， bottom是相对于VIew的父容器来说的，因此是一种相对坐标</li>
<li>宽高和坐标的关系：<ul>
<li>width = right - left</li>
<li>height = bottom - top</li>
</ul>
</li>
<li>这四个参数对应于源码的mLeft， mRight， mTop， mBottom这四个成员变量，获取方式：<ul>
<li>left = getLeft（）</li>
<li>right = getRight（）</li>
<li>Top = getTop（）</li>
<li>Bottom = 个体Bottom（）</li>
</ul>
</li>
</ul>
<h5 id="MotionEvent和TouchSlop"><a href="#MotionEvent和TouchSlop" class="headerlink" title="MotionEvent和TouchSlop"></a>MotionEvent和TouchSlop</h5><ul>
<li>通过MotionEvent我们可以得到点击事件发生的坐标。</li>
<li>getX和getY得到的是相对于当前View的坐标</li>
<li>getRawX和getRawY是相对于屏幕的坐标</li>
<li>TouchSlop是系统所能识别出的被认为是滑动的最小距离，下面是获取的方式：<ul>
<li>ViewConfiguration.get(getContext()).getScaledTouchSlop();</li>
</ul>
</li>
</ul>
<h5 id="VeloccityTracker和GuestureDetector和Scroller"><a href="#VeloccityTracker和GuestureDetector和Scroller" class="headerlink" title="VeloccityTracker和GuestureDetector和Scroller"></a>VeloccityTracker和GuestureDetector和Scroller</h5><ul>
<li>VelocityTracker：速度追踪，用于追踪手指在滑动中的速度</li>
<li>使用：首先在View的onTouchEvent方法中追踪当前事件的速度：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</div><div class="line">        velocityTracker.addMovement(event);</div><div class="line">        velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">int</span> xv = (<span class="keyword">int</span>) velocityTracker.getXVelocity();</div><div class="line">        <span class="keyword">int</span> yv = (<span class="keyword">int</span>) velocityTracker.getYVelocity();</div></pre></td></tr></table></figure>
<ul>
<li>注意：获取速度之前必须计算速度；第二点：这里的速度指的是一段时间内手指所划过的像素数</li>
<li>最后不用的时候，应当调用clear和recycle来回收</li>
</ul>
<h5 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h5><ul>
<li>使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GestureDetector detector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//解决长按屏幕后无法拖动的现象</span></div><div class="line">        detector.setIsLongpressEnabled(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">boolean</span> resume = detector.onTouchEvent(event);</div><div class="line">        <span class="keyword">return</span> resume;</div></pre></td></tr></table></figure>
<ul>
<li>首先创建一个对象，并实现其监听接口，接着在接管View的onTouchEvent方法中，接管该事件</li>
</ul>
<h5 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h5><ul>
<li>实现View的滑动有三种方式：<ul>
<li>View自身提供的scrollerTo/scrollerBy </li>
<li>通过动画平移</li>
<li>改变View的layoutParams</li>
</ul>
</li>
<li>scrollerTo/scrollerBy</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Set the scrolled position of your view. This will cause a call to</div><div class="line">   * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line">   * invalidated.</div><div class="line">   * <span class="doctag">@param</span> x the x position to scroll to</div><div class="line">   * <span class="doctag">@param</span> y the y position to scroll to</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line">          <span class="keyword">int</span> oldX = mScrollX;</div><div class="line">          <span class="keyword">int</span> oldY = mScrollY;</div><div class="line">          mScrollX = x;</div><div class="line">          mScrollY = y;</div><div class="line">          invalidateParentCaches();</div><div class="line">          onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class="line">          <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">              postInvalidateOnAnimation();</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Move the scrolled position of your view. This will cause a call to</div><div class="line">   * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line">   * invalidated.</div><div class="line">   * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</div><div class="line">   * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      scrollTo(mScrollX + x, mScrollY + y);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>scrollTo是绝对滑动</li>
<li>scrollBy是相对于自身位置滑动</li>
<li>在滑动过程中，mScrollX的值等于View左边缘和View内容左边缘的水平距离，而mscrollY的值总是等于View上边缘和内容边缘在竖直方向上的距离</li>
<li>使用这两种方法不能使得View本身滑动，只能是内容滑动</li>
<li>使用动画：</li>
<li>改变布局参数：通过改变Margin来滑动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) mFriends.getLayoutParams();</div><div class="line">   params.width += <span class="number">10</span>;</div><div class="line">   </div><div class="line">   params.leftMargin += <span class="number">10</span>;</div><div class="line">   </div><div class="line">   mFriends.requestLayout();</div></pre></td></tr></table></figure>
<ul>
<li><p>总结：</p>
<ul>
<li>scrollTo/scrollBy：操作简单，适合对View内容的滑动</li>
<li>动画：操作简单。主要适合用于没有交互的View和实现复杂的动画效果</li>
<li>改变布局参数：操作稍微复杂，用于有交互的View</li>
</ul>
</li>
</ul>
<h5 id="实现弹性滑动"><a href="#实现弹性滑动" class="headerlink" title="实现弹性滑动"></a>实现弹性滑动</h5><ul>
<li>使用Scroller</li>
<li>用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(<span class="keyword">this</span>);</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> desX, <span class="keyword">int</span> desY)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">        <span class="keyword">int</span> deltaX = desX - scrollX;</div><div class="line">        mScroller.startScroll(scrollX, <span class="number">0</span>, deltaX, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">        mFriends.invalidate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(mScroller.computeScrollOffset()) &#123;</div><div class="line">            mFriends.scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">            mFriends.postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先构造一个Scroller对象，接着调用它的startScroll，但是该方法内部知识保存了几个传递的参数</li>
<li>让View是实现弹性滑动的是invalidate（），该方法或导致View的重绘，在View的draw中又会去调用computeScroll，而computeScroll是我们自己实现的一个方法，在computeScroll中又会去获得当前的scrollX， scrollY，然后通过scrollTo实现滑动，接着又调用postInvalidate再进行重绘，如此反复，直到滑动完成</li>
<li>computeScrollOffset：该方法通过计算时间的流逝来计算出当前scrollX和scrollY的值，类似插值器的工作原理</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>Scroller本身并不能够实现View的滑动，它需要配合View的computerScroll来实现弹性滑动，它不断地让View重绘，而每次重绘距滑动起始时间会有一个间隔，通过这个时间间隔Scroller就可以得出View当前的滑动位置，知道了滑动位置就可以通过scrollTo来实现滑动。就这样，每次View的重绘都会导致View进行小幅度的滑动，而多次的小滑动就组成了View的弹性滑动 </li>
<li>使用动画：</li>
<li>使用延时策略：通过使用Handler来实现</li>
</ul>
<h5 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h5><ul>
<li>相关的三个重要的方法：<ul>
<li>public boolean dispatchTouchEvent(MotionEvent event)：用于进行事件的分发。如果时间能够传递给当前的View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent（）方法的影响，表示是否消费当前事件</li>
<li>public boolean onInterceptHoverEvent(MotionEvent event)：在上述方法内部调用，用于判断是不是要拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被调用，返回结果表示是否拦截当前事件。</li>
<li>public boolean onTouchEvent(MotionEvent event)：在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否拦截当前事件，如果不消耗，那么在同一个事件序列当中，当前View将无法接受到事件</li>
</ul>
</li>
<li>概述：对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent会被调用，如果这个ViewGroup的onInterceptHoverEvent返回true表示它要拦截当前事件，接着该事件就会交给这个ViewGroup处理，即它的onTouchEvent会被调用；如果返回false表示不拦截此事件，这时该事件会传给它的子View，接着子View的dispatchTouchEvent会被调用，如此直到该事件被最终处理</li>
</ul>
<h5 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h5><p>1.Activity对点击事件的分发过程</p>
<ul>
<li>当一个点击事件发生时，事件最先传递给当前的Activity，由该Activity的dispatchTouchEvent来进行事件派发，具体的是又Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（framelayout），通过Activity.getWindow().getDecorView()可以获得。 下面是Activity的dispatchTouchEvent的源码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            onUserInteraction();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先事件开始交给Activity所依附的Window进行分发，如果返回true的话，整个事件循环就结束了，返回false的话意味着事件没有人处理，所有的View都返回onTouchEvent都返回false，那么Activity的onTouchEvent就会被调用。</li>
<li>接下来看Window是怎么样传给ViewGroup对象的，首先Window是一个抽象类，superDispatchTouchEvent方法也是抽象方法，其具体实现类是PhoneWindow，那么我们来看看其superDispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>PhoneWindow将事件直接传递给DecorView，我们来看看DecorView是什么？</li>
<li>我们知道，通过getWindow（）.getDecorView().findViewById(android.R.id.content).getChildAt(0)这种方式就可以获取Activity所设置的View，这个mDecorView显然就是getWindow().getDecorView()返回的View，而我们通过setContentView（）就是它的一个子View</li>
<li>在这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般说的是ViewGroup</li>
</ul>
<h5 id="顶级View对点击事件的分发过程"><a href="#顶级View对点击事件的分发过程" class="headerlink" title="顶级View对点击事件的分发过程"></a>顶级View对点击事件的分发过程</h5><ul>
<li>首先看看其dispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check for interception.</span></div><div class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">                   intercepted = onInterceptTouchEvent(ev);</div><div class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   intercepted = <span class="keyword">false</span>;</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">               <span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">               intercepted = <span class="keyword">true</span>;</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<ul>
<li>从上面的代码可以看出，在两种情况下ViewGroup会拦截此事件：事件类型为：ACTION_DOWN或者mFirstTouchTarget ！= null。当是事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向该子元素。</li>
<li>也就是说，当ViewGroup不拦截事件并将事件交给子元素处理时，mFirstTouchTarget ！= null。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget ！= null就不成立。</li>
<li>那么当MOVE和UP事件传递过来的时候，由于（actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null）为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其他事件都会默认交给它处理</li>
<li>还有一种特殊情况，那就是 FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceptTouchEvent来设置的，一旦被设置后，ViewGroup将无法拦截除了DOWN事件以外的点击事件。这时因此ViewGroup在分发事件时，如果是DOWN事件的话就会重置这个标记位，将导致子View中设置的标记无效，面对DOWN事件，ViewGroup总会询问自己是不是要拦截：</li>
<li>小结：当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理，并且不再调用onInterceptTouchEvent。FLAG_DISALLOW_INTERCEPT这个标记的作用是让ViewGroup不再拦截事件，</li>
<li>接着看ViewGroup不拦截事件的时候，事件会向下分发交给它的子View进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> View[] children = mChildren;</div><div class="line">                      <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                          <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">                                  ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">                          <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                                  ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line"></div><div class="line">                          <span class="comment">// If there is a view that has accessibility focus we want it</span></div><div class="line">                          <span class="comment">// to get the event first and if not handled we will perform a</span></div><div class="line">                          <span class="comment">// normal dispatch. We may do a double iteration but this is</span></div><div class="line">                          <span class="comment">// safer given the timeframe.</span></div><div class="line">                          <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">                              <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                  <span class="keyword">continue</span>;</div><div class="line">                              &#125;</div><div class="line">                              childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">                              i = childrenCount - <span class="number">1</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">                                  || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">                              ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                              <span class="keyword">continue</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          newTouchTarget = getTouchTarget(child);</div><div class="line">                          <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                              <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">                              <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">                              newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                              <span class="keyword">break</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          resetCancelNextUpFlag(child);</div><div class="line">                          <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                              <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">                              mLastTouchDownTime = ev.getDownTime();</div><div class="line">                              <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                                  <span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">                                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                                      <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                          mLastTouchDownIndex = j;</div><div class="line">                                          <span class="keyword">break</span>;</div><div class="line">                                      &#125;</div><div class="line">                                  &#125;</div><div class="line">                              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                  mLastTouchDownIndex = childIndex;</div><div class="line">                              &#125;</div><div class="line">                              mLastTouchDownX = ev.getX();</div><div class="line">                              mLastTouchDownY = ev.getY();</div><div class="line">                              newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                              alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                              <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>首先遍历ViewGroup所有子View，然后判断子View是不是能够接收点击事件。是否能够接收点击事件主要由两点来衡量：子元素是否在播放动画和点击事件的坐标是不是落在子元素的区域。如果子View满足两个条件的话，那么事件将交给它处理，</li>
<li>实际调用子元素的dispatchTouchEvent是在dispatchTransformedTouchEvent中，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">           View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line"></div><div class="line">       <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></div><div class="line">       <span class="comment">// or filtering.  The important part is the action, not the contents.</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">       <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">           event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">           <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">               handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               handled = child.dispatchTouchEvent(event);</div><div class="line">           &#125;</div><div class="line">           event.setAction(oldAction);</div><div class="line">           <span class="keyword">return</span> handled;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果传递的字View不为null的话，就会调用子View的dispatchTouchEvent，这样事件就交给子View处理了</li>
<li>如果子View的dispatchTouchEvent返回true的话，那么mFirstTouchTarget就会被赋值并跳出循环：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                                <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码完成了对mFirstTouchTarget赋值并终止了对子View的遍历。</li>
<li>如果子View返回false的话，ViewGroup会将事件分给下一个子View（还有下一个子 View的话）</li>
<li>如果遍历所有子View后事件都没有被合适处理，这包含两种情况： <ul>
<li>ViewGroup没有子View</li>
<li>子元素处理了点击事件，但是在dispatchTouchEvent中返回false。 </li>
</ul>
</li>
<li>上面这两种情况下ViewGroup会自己处理点击事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dispatch to touch targets.</span></div><div class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                       TouchTarget.ALL_POINTER_IDS);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码中第三个参数为null，显然调用super.dispatchTouchEvent</li>
</ul>
<h5 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a>View对点击事件的处理过程</h5><ul>
<li>先看看其dispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">    ListenerInfo li = mListenerInfo;</div><div class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">    mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></div><div class="line"><span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></div><div class="line"><span class="comment">// of the gesture.</span></div><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</div><div class="line">        actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class="line">        (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class="line">    stopNestedScroll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<ul>
<li>可以看到，首先会判断有没有设置OnTouchEventListener，如果OnTouchEventListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，这样做的好处是方便外界处理点击事件</li>
<li>接下来分析onTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">        setPressed(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">    <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">    <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面是View在不可用的状态下点击事件的处理过程，显然不可用的View照样会消费事件，只是没有为点击做出回应</li>
<li>下面看看onTouchEvent对点击事件的具体处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">               (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">               (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">           <span class="keyword">switch</span> (action) &#123;</div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                   <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                   <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</div><div class="line">                       <span class="comment">// take focus if we don't have it already and we should in</span></div><div class="line">                       <span class="comment">// touch mode.</span></div><div class="line">                       <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                           focusTaken = requestFocus();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                           <span class="comment">// The button is being released before we actually</span></div><div class="line">                           <span class="comment">// showed it as pressed.  Make it show the pressed</span></div><div class="line">                           <span class="comment">// state now (before scheduling the click) to ensure</span></div><div class="line">                           <span class="comment">// the user sees it.</span></div><div class="line">                           setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                           <span class="comment">// This is a tap, so remove the longpress check</span></div><div class="line">                           removeLongPressCallback();</div><div class="line"></div><div class="line">                           <span class="comment">// Only perform take click actions if we were in the pressed state</span></div><div class="line">                           <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                               <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                               <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                               <span class="comment">// of the view update before click actions start.</span></div><div class="line">                               <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                   mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                               &#125;</div><div class="line">                               <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                   performClick();</div><div class="line">                               &#125;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                           mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                           postDelayed(mUnsetPressedState,</div><div class="line">                                   ViewConfiguration.getPressedStateDuration());</div><div class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                           <span class="comment">// If the post failed, unpress right now</span></div><div class="line">                           mUnsetPressedState.run();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       removeTapCallback();</div><div class="line">                   &#125;</div><div class="line">                   mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                   mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class="line">                   <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                   <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class="line">                   <span class="comment">// a short period in case this is a scroll.</span></div><div class="line">                   <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                       mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                       <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                           mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                       &#125;</div><div class="line">                       mPendingCheckForTap.x = event.getX();</div><div class="line">                       mPendingCheckForTap.y = event.getY();</div><div class="line">                       postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></div><div class="line">                       setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                       checkForLongClick(<span class="number">0</span>);</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                   setPressed(<span class="keyword">false</span>);</div><div class="line">                   removeTapCallback();</div><div class="line">                   removeLongPressCallback();</div><div class="line">                   mInContextButtonPress = <span class="keyword">false</span>;</div><div class="line">                   mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                   mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                   drawableHotspotChanged(x, y);</div><div class="line"></div><div class="line">                   <span class="comment">// Be lenient about moving outside of buttons</span></div><div class="line">                   <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                       <span class="comment">// Outside button</span></div><div class="line">                       removeTapCallback();</div><div class="line">                       <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                           <span class="comment">// Remove any future long press/tap checks</span></div><div class="line">                           removeLongPressCallback();</div><div class="line"></div><div class="line">                           setPressed(<span class="keyword">false</span>);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>只要View的CLICKABLE和LONG——CLICKABLE有一个为true的话，那么它就会消费这个事件，即onTouchEvent返回true，不管状态是不是DISABLE状态。然后就是当ACTION_UP事件发生时，就会出发performClick，如果View设置了OnClickListener的话，performClick内部就会调用onClick</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">*/</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">     <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">     <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">         playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">         li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">         result = <span class="keyword">true</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         result = <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>View的LONG_CLICKABLE默认设置为false，而CLICKABLE则要看具体的View，可点击的View的CLICKABLE为true，不可点击的为false。</li>
<li><p>setOnClickListener会自动将View的CLICKABLE设置为true，setOnLongClickListener也会将View的LONG_CLICKABLE设置为true，在源码可以找到，这里就不贴代码了。</p>
</li>
<li><p>结论：</p>
<ul>
<li>正常情况下，一个事件序列只能被一个View拦截且消费，因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一事件序列中的事件不能分别由两个View同时处理，但是通过特殊的手段可以实现，比如一个View将本该自己处理的事件通过onTouchEvent返回false，强行传给其他View </li>
<li>某个View一旦决定拦截，那么一个事件序列都只能有它处理，并且onInterceptTouchEvent不会被调用。 </li>
<li>某个View一旦开始处理事件，如果不消耗ACTION_DOWN事件，那么同一事件序列中的其他事件都不会交给它处理，并且事件将重新交给父元素去处理。</li>
<li>如果View不消耗ACTION_DOWN以外的事件，那么这个点击事件会消失，此时父元素的onTouchEvent不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件由Activity来处理。 </li>
<li>ViewGroup内部默认不拦截事件 </li>
<li>View中不能拦截事件，一旦有事件交给它，它的onTouchEvent就会被调用</li>
<li>View的onTouchEvent都默认消费事件，除非它是不可点击的。</li>
<li>View的enable不影响onTouchEvent的默认返回值。</li>
<li>onClick的发生前提时当前View可点击，并且它收到了down和up事件</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，容纳后再由父元素进行分发，通过requestDisalowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发，但是ACTION_DOWN除外</li>
</ul>
</li>
</ul>
<h5 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h5><ul>
<li>在界面中，只要内外两层同时可以滑动，这个时候就会产生滑动冲突</li>
</ul>
<h5 id="常见的滑动冲突场景："><a href="#常见的滑动冲突场景：" class="headerlink" title="常见的滑动冲突场景："></a>常见的滑动冲突场景：</h5><ul>
<li>外部滑动和内部滑动方向不一致；</li>
<li>外部滑动方向和内部滑动方向一致；</li>
<li>上面两种情况的嵌套。</li>
</ul>
<h5 id="滑动冲突的处理规则"><a href="#滑动冲突的处理规则" class="headerlink" title="滑动冲突的处理规则"></a>滑动冲突的处理规则</h5><ul>
<li>对于场景一，处理的规则是：当用户左右（上下）滑动时，需要让外部的View拦截点击事件，当用户上下（左右）滑动的时候，需要让内部的View拦截点击事件。根据滑动的方向判断谁来拦截事件。</li>
<li>对于场景二，由于滑动方向一致，这时候只能在业务上找到突破点，根据业务需求，规定什么时候让外部View拦截事件，什么时候由内部View拦截事件。</li>
<li>场景三的情况相对比较复杂，同样根据需求在业务上找到突破点。</li>
</ul>
<h5 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h5><ul>
<li>外部拦截法：所谓的外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。下面是伪代码：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">     <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line">     <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line">     </div><div class="line">     <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">       <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">  </div><div class="line">      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">           <span class="keyword">if</span> (父容器需要当前事件）&#123;</div><div class="line">               intercepted = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               intercepted = flase;</div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">       &#125;    </div><div class="line">      </div><div class="line">      <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">          intercepted = <span class="keyword">false</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      </div><div class="line">      <span class="keyword">default</span>:</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLastXIntercept=x;</div><div class="line">    mLastYIntercept=y;</div><div class="line">    <span class="keyword">return</span> intercepted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>内部拦截法：内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗，否则就交由父容器进行处理。这种方法与Android事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。下面是伪代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent even)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) even.getX();</div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) even.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (even.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                parent.requestDisallowIntercepttouchEvent(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</div><div class="line">                <span class="keyword">int</span> deltaY = x - mLastY;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(父容器需要此类点击事件) &#123;</div><div class="line">                    parent.requestDisallowIntercepttouchEvent(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            mLastX = x;</div><div class="line">            mLastY = y;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(even);</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>除了子元素需要做处理外，父元素也要默认拦截ACTION_DOWN以外的事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需要的事件，因此，父元素需要修改：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent even)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> action = even.getAction();</div><div class="line">	<span class="keyword">if</span>(about == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Volley浅读]]></title>
      <url>http://cristianoro7.github.io/2017/01/13/Volley%E6%B5%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h4 id="Velloy浅谈"><a href="#Velloy浅谈" class="headerlink" title="Velloy浅谈"></a>Velloy浅谈</h4><a id="more"></a>
<ul>
<li>我们都知道，一般要使用Volley，先要创建该请求队列对象，我们并不是直接调用它的构造方法，而是调用Volley.newRequestQueue(COntext)来创建请求队列,那么我们下面来看看该方法“：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/** Default on-disk cache directory. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CACHE_DIR = <span class="string">"volley"</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a default instance of the worker pool and calls &#123;<span class="doctag">@link</span> RequestQueue#start()&#125; on it.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> context A &#123;<span class="doctag">@link</span> Context&#125; to use for creating the cache dir.</div><div class="line"> * <span class="doctag">@param</span> stack An &#123;<span class="doctag">@link</span> HttpStack&#125; to use for the network, or null for default.</div><div class="line"> * <span class="doctag">@return</span> A started &#123;<span class="doctag">@link</span> RequestQueue&#125; instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</div><div class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line"></div><div class="line">    String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String packageName = context.getPackageName();</div><div class="line"></div><div class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">        userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">            stack = <span class="keyword">new</span> HurlStack();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></div><div class="line">            <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></div><div class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line"></div><div class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">    queue.start();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a default instance of the worker pool and calls &#123;<span class="doctag">@link</span> RequestQueue#start()&#125; on it.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> context A &#123;<span class="doctag">@link</span> Context&#125; to use for creating the cache dir.</div><div class="line"> * <span class="doctag">@return</span> A started &#123;<span class="doctag">@link</span> RequestQueue&#125; instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从上面的代码可以看出，最终调用的是该重载方法newRequestQueue（Context, HttpStack）.我们来看看该方法中的代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">               stack = <span class="keyword">new</span> HurlStack();</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></div><div class="line">               <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></div><div class="line">               stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line"></div><div class="line">       RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">       queue.start();</div><div class="line"></div><div class="line">       <span class="keyword">return</span> queue;</div></pre></td></tr></table></figure>
<ul>
<li>在if语句中判断SDK版本是否大于9，是的话实例化HurlStack（该类为HttpStack的具体实现类，该类访问网络是基于HttpURLConnection来实现的）</li>
<li>如果SDK版本小于9的话，实例化HttpClientStack（该类也是HttpStack的具体实现类，不过它的网络访问实现是基于HttpClient来实现的）</li>
<li>上面为什么要通过判断SDK版本判断实例化不同的具体实现类呢？ 这是有关到HttpClient和HttpURLConnection在不同的SDK版本的性能不同。</li>
<li>接着实例化BasicNetwork（实现了Network接口）</li>
<li>最终实例化ResquestQueue，并且调用start方法。</li>
</ul>
<ul>
<li>既然实际化的ＲｅｓｔｑｕｅｓｔＱｕｅｕｅ，并且调用了start，那么我们来看看start方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Starts the dispatchers in this queue.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></div><div class="line">        <span class="comment">// Create the cache dispatcher and start it.</span></div><div class="line">        mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">        mCacheDispatcher.start();</div><div class="line"></div><div class="line">        <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">            NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                    mCache, mDelivery);</div><div class="line">            mDispatchers[i] = networkDispatcher;</div><div class="line">            networkDispatcher.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先实例化了CacheDispatcher对象（该类继承了Thread，实际上就是一个线程），接着调用了start，也就是启动了线程（从名字来看，该线程为缓存线程）</li>
<li>再来看看for循环：在里面实例化了networkDispatcher数组（该类也是继承Thread，实际上也是一个线程），再分别调用的数组的start，也就是启动了线程，至于启动多少个线程？ 默认启动的是4个线程（数量可以在BasicNetwork中查看到，这里就不多说），并且从名字看，该线程可以理解为是网络线程。</li>
<li>从上面分析我们知道，当我们创建了一个请求队列，在后台默认就启动了5个线程（四个为网络线程，一个为缓存线程）</li>
</ul>
<hr>
<ul>
<li>我们创建好队列之后，就可以通过add（）方法来添加请求。我们接下来自然要来看看add：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></div><div class="line">        request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">            mCurrentRequests.add(request);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Process requests in the order they are added.</span></div><div class="line">        request.setSequence(getSequenceNumber());</div><div class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></div><div class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span></div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">                <span class="comment">// There is already a request in flight. Queue up.</span></div><div class="line">                Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">                <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                    stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</div><div class="line">                &#125;</div><div class="line">                stagedRequests.add(request);</div><div class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></div><div class="line">                <span class="comment">// flight.</span></div><div class="line">                mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">                mCacheQueue.add(request);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们看到一开始，add（Request）就将该请求添加进Set队列中（关于Volley中的4个队列的配合使用，以后会单独拿出来分析一下）</li>
<li>再判断该请求能不能缓存，不能的话就跳过缓存队列，直接添加进网络队列</li>
<li>接下来，首先拿到请求的key值（也就是其url），判断等待队列中是不是有队列的key值，没有的话将该key值和null添加进等待队列，最后把该请求添加进缓存队列</li>
<li>如果有该key值的话通过key值拿出该key值对应的暂存请求队列，如果该队列为空的话，则实例化该队列，接着将含有相同的key（也就是url，相当于同一条请求），将该请求添加进暂存队列，并将该暂存队列添加进等待队列</li>
<li><p>上面的操作中并不是直接将该请求直接添加进缓存队列，而是通过将key值（uel）和暂存队列作为键值对来保存在一个等待队列中，这样的话，当有多条相同的请求添加进来的话，首先第一条会被添加存缓存队列中，接下来相同的请求则不会，而是都保存在暂存队列中。这样保证了相同的请求只会执行一次。</p>
</li>
<li><p>上面我们分析了将请求添加队列了，添加就去了就得被执行，那么会在哪里执行，当然是会在网络线程或者缓存线程中执行，那么下面我们分别来分析下这两个线程中run的处理</p>
</li>
<li><p>网络线程：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request request;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Take a request from the queue.</span></div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line"></div><div class="line">                <span class="comment">// If the request was cancelled already, do not perform the</span></div><div class="line">                <span class="comment">// network request.</span></div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Tag the request (if API &gt;= 14)</span></div><div class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class="line">                    TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Perform the network request.</span></div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line"></div><div class="line">                <span class="comment">// If the server returned 304 AND we delivered a response already,</span></div><div class="line">                <span class="comment">// we're done -- don't deliver a second identical response.</span></div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Parse the response here on the worker thread.</span></div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line"></div><div class="line">                <span class="comment">// Write to cache if applicable.</span></div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></div><div class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Post the response back.</span></div><div class="line">                request.markDelivered();</div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">                mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在while（true）进入一个循环，首先从请求队列中拿出请求，接着判断该请求是不是有被取消，取消了话就不执行，没有取消的话，调用了mNetwork.performRequest(request)，在performRequest中，volley做了相关的优化操作，这也打算接下来单独拿出来分析; 我们进入performRequest看看：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Performs the specified request.</div><div class="line">     * <span class="doctag">@param</span> request Request to process</div><div class="line">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> NetworkResponse&#125; with data and caching metadata; will never be null</div><div class="line">     * <span class="doctag">@throws</span> VolleyError on errors</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>发现它是个很熟悉的接口，没错，该接口的具体实现类是BasicNetwork，而该类我们在之前的newRequestQueue中已经实例化了，在该类中重写了performRequest：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">        <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            HttpResponse httpResponse = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</div><div class="line">            Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Gather headers.</span></div><div class="line">                Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">                addCacheHeaders(headers, request.getCacheEntry());</div><div class="line">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">                <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</div><div class="line"></div><div class="line">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">                <span class="comment">// Handle cache validation.</span></div><div class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</div><div class="line">                            request.getCacheEntry().data, responseHeaders, <span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">                <span class="comment">// if the request is slow, log it.</span></div><div class="line">                <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (statusCode != HttpStatus.SC_OK &amp;&amp; statusCode != HttpStatus.SC_NO_CONTENT) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">                attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">            &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</div><div class="line">                attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="keyword">int</span> statusCode = <span class="number">0</span>;</div><div class="line">                NetworkResponse networkResponse = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</div><div class="line">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</div><div class="line">                &#125;</div><div class="line">                VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</div><div class="line">                <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</div><div class="line">                    networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</div><div class="line">                            responseHeaders, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class="line">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class="line">                        attemptRetryOnException(<span class="string">"auth"</span>,</div><div class="line">                                request, <span class="keyword">new</span> AuthFailureError(networkResponse));</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>该重写方法中代码很长，大多数都是网络请求的细节，我们仔细看会发现该语句：httpResponse = mHttpStack.performRequest(request, headers);</li>
<li>该语句也调用了performRequest，类似的，HttpStack也是一个接口，实现类有HurlStack，HttpClientStack，这两个类中分别重写了performRequest，并且返回了HttpResponse</li>
<li>返回的HttpResponse在BasicNetwork中封装返回一个NetworkReponse对象，再回到NetworkDisoatcher中，我们看看下面这条语句：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div></pre></td></tr></table></figure>
<ul>
<li>返回的NetworkReponse被request的parseNetworkReponse转为一个Response对应。Request是一个抽象类，该抽象类的具体实现类有JsonObjectRequest，StringRequest，，这几个都是Volley提供给我们的。在这些类中，重写了parseNetworkReponse方法，我们用StringRequest来举例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRequest</span> <span class="keyword">extends</span> <span class="title">Request</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Listener&lt;String&gt; mListener;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new request with the given method.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> method the request &#123;<span class="doctag">@link</span> Method&#125; to use</div><div class="line">     * <span class="doctag">@param</span> url URL to fetch the string at</div><div class="line">     * <span class="doctag">@param</span> listener Listener to receive the String response</div><div class="line">     * <span class="doctag">@param</span> errorListener Error listener, or null to ignore errors</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener,</span></span></div><div class="line">            ErrorListener errorListener) &#123;</div><div class="line">        <span class="keyword">super</span>(method, url, errorListener);</div><div class="line">        mListener = listener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new GET request.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> url URL to fetch the string at</div><div class="line">     * <span class="doctag">@param</span> listener Listener to receive the String response</div><div class="line">     * <span class="doctag">@param</span> errorListener Error listener, or null to ignore errors</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(String url, Listener&lt;String&gt; listener, ErrorListener errorListener)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(Method.GET, url, listener, errorListener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">        mListener.onResponse(response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</div><div class="line">        String parsed;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">            parsed = <span class="keyword">new</span> String(response.data);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>该类代码并不多，主要是重写了parseNetworkResponse，并且返回一个Response对象，并且重写deliverResponse方法，将该Response回调。如果我们要定制自己的Request（比如GsonRequest，JackSonRequest）的话，我们也可以通过继承Request并且重写两个方法</li>
</ul>
<p>＊　好，我们接着继续回到ＮｅｔｗｏｒｋＤｉｓｐａｔｃｈｅｒ中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mDelivery.postResponse(request, response);</div></pre></td></tr></table></figure>
<ul>
<li>该语句调用了postResponse，<a href="psi_element://com.android.volley.ResponseDelivery">ResponseDelivery</a>是一个接口，该接口的具体具体实现类是ExecutorDeliver，我们下面来看看其操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Delivers responses and errors.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorDelivery</span> <span class="keyword">implements</span> <span class="title">ResponseDelivery</span> </span>&#123;</div><div class="line">    <span class="comment">/** Used for posting responses, typically to the main thread. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new response delivery interface.</div><div class="line">     * <span class="doctag">@param</span> handler &#123;<span class="doctag">@link</span> Handler&#125; to post responses on</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">        mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">                handler.post(command);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new response delivery interface, mockable version</div><div class="line">     * for testing.</div><div class="line">     * <span class="doctag">@param</span> executor For running delivery tasks</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(Executor executor)</span> </span>&#123;</div><div class="line">        mResponsePoster = executor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</div><div class="line">        postResponse(request, response, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">        request.markDelivered();</div><div class="line">        request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</div><div class="line">        request.addMarker(<span class="string">"post-error"</span>);</div><div class="line">        Response&lt;?&gt; response = Response.error(error);</div><div class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, <span class="keyword">null</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A Runnable used for delivering network responses to a listener on the</div><div class="line">     * main thread.</div><div class="line">     */</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</div><div class="line">            mRequest = request;</div><div class="line">            mResponse = response;</div><div class="line">            mRunnable = runnable;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// If this request has canceled, finish it and don't deliver.</span></div><div class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Deliver a normal response or error, depending.</span></div><div class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">                mRequest.deliverResponse(mResponse.result);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mRequest.deliverError(mResponse.error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class="line">            <span class="comment">// and the request can be finished.</span></div><div class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mRequest.finish(<span class="string">"done"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></div><div class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                mRunnable.run();</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>该类中在线程池中包装了一个运行在主线程的Handler</li>
<li>我们直接先来看看重写的方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">       request.markDelivered();</div><div class="line">       request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">       mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在最后一句中，传入了一个重写的Runable对象，在run方法中，首先判断是不是被取消了，使得话就不执行。</li>
<li>接着如果Response被标记为success的话，调用mRequest.deliverResponse(mResponse.result); 也就是你我们在StringRequest中重写的方法，而该线程池是在实例化请求队列的时候实例的。</li>
<li>分析到这里，Velloy是怎么将数据回调回主线程的？ 我们来看看实例化RequestQueue：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Creates the worker pool. Processing will not begin until &#123;<span class="doctag">@link</span> #start()&#125; is called.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> cache A Cache to use for persisting responses to disk</div><div class="line">     * <span class="doctag">@param</span> network A Network interface for performing HTTP requests</div><div class="line">     * <span class="doctag">@param</span> threadPoolSize Number of network dispatcher threads to create</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(cache, network, threadPoolSize,</div><div class="line">                <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们在之前调用newRequestQueue的时候，我们实例化了RequestQueue，最终会调用到上面的重载方法，该方法中在ExecutorDelivery中传入了一个运行在主线程的Handler。那么我们进入ExecutorDelivery的构造函数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">        mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">                handler.post(command);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在构造函数内，重写了execte（Runnable），通过传入运行在主线程的Handler将runnable post到主线程中的消息队列,这样就将请求的结果回到会主线程处理</li>
</ul>
<hr>
<ul>
<li>上面分析那么多了，我们来总结一个网络线程的工作方式：</li>
<li>首先判断请求是不是被取消了，没有的话，接着调用BasicNetwork中的重写的performRequest，在该方法中有调用了HttpStack中的performRequest（该接口的具体实现类是HurlStack，HttpClientStack），在具体的实现类中处理网络细节，接着返回HttpResponse对象，回到BasicNetwork中，处理网络细节，最后返回NetworResponse对象</li>
<li><p>在NetworkDispatcher中得到返回的NetworkResponse对象，接着将之传入Request中的parseNetworkResponse中（该接口的具体实现类是StringRequest之类的），再得到Response对象，最后通过ResponseDeliver（具体实现类是ExecutorDeliver）将Response回调到主线程中处理。</p>
</li>
<li><p>缓存线程</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"></div><div class="line">        <span class="comment">// Make a blocking call to initialize the cache.</span></div><div class="line">        mCache.initialize();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Get a request from the cache triage queue, blocking until</span></div><div class="line">                <span class="comment">// at least one is available.</span></div><div class="line">                <span class="keyword">final</span> Request request = mCacheQueue.take();</div><div class="line">                request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line"></div><div class="line">                <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Attempt to retrieve this item from cache.</span></div><div class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                    <span class="comment">// Cache miss; send off to the network dispatcher.</span></div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// If it is completely expired, just send it to the network.</span></div><div class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                    request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">                request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                    <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></div><div class="line">                    mDelivery.postResponse(request, response);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></div><div class="line">                    <span class="comment">// but we need to also send the request to the network for</span></div><div class="line">                    <span class="comment">// refreshing.</span></div><div class="line">                    request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line"></div><div class="line">                    <span class="comment">// Mark the response as intermediate.</span></div><div class="line">                    response.intermediate = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                    <span class="comment">// Post the intermediate response back to the user and have</span></div><div class="line">                    <span class="comment">// the delivery then forward the request along to the network.</span></div><div class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                mNetworkQueue.put(request);</div><div class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                <span class="comment">// Not much we can do about this.</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们主要来看看run中。</li>
<li>run方法中，首先从从队列中拿出缓存请求，接着判断是不是被取消，取消了的话就不处理，然后判断该请求是不是丢失了，是的话就添加进网络队列中，再接着判断该缓存请求是不是过期，过期的话就添加进网络队列。</li>
<li>如果都没有丢失和过期的话，下面的逻辑处=处理和网络线程处理大同小异，这里就不分析了</li>
</ul>
<h5 id="体会："><a href="#体会：" class="headerlink" title="体会："></a>体会：</h5><ul>
<li><p>在源码中，处理缓存线程并不是直接添加进来，而是通过将相同的请求添加进暂存队列中。</p>
</li>
<li><p>平常用接口，都是用来回调，而源码中，通过具体类和接口分离来实现，这样能达到解耦的目的，对以后的扩展也留下了很大的空间（只要实现接口，编写自己的操作，就可以在volley的基础扩展）</p>
</li>
<li><p>各线程的责任分明，分层思想很清晰。将线程分为三种，在处理请求时三种线程配合。首先启用缓存线程，如果丢失或者过期的话，传给网络线程，接着将结果回调给主线程。</p>
</li>
</ul>
<ul>
<li>在上面的分析中并没有涉及到volley中4个队列的配合使用以及各个线程之间的配合，还有在网络访问的时候，volley内部做的优化。所以打算把这些单独拿出来分析.</li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
