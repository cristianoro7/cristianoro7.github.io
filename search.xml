<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[3月9日]]></title>
      <url>http://yoursite.com/2016/10/11/3%E6%9C%889%E6%97%A5/</url>
      <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=805204&auto=0&height=66"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓开发艺术探索-View的事件体系-笔记]]></title>
      <url>http://yoursite.com/2016/10/10/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="第三章：View的事件体系"><a href="#第三章：View的事件体系" class="headerlink" title="第三章：View的事件体系"></a>第三章：View的事件体系</h4><h5 id="View的位置参数："><a href="#View的位置参数：" class="headerlink" title="View的位置参数："></a>View的位置参数：</h5><ul>
<li>View的位置参数left， top， right， bottom是相对于VIew的父容器来说的，因此是一种相对坐标</li>
<li>宽高和坐标的关系：<ul>
<li>width = right - left</li>
<li>height = bottom - top</li>
</ul>
</li>
<li>这四个参数对应于源码的mLeft， mRight， mTop， mBottom这四个成员变量，获取方式：<ul>
<li>left = getLeft（）</li>
<li>right = getRight（）</li>
<li>Top = getTop（）</li>
<li>Bottom = 个体Bottom（）<a id="more"></a>
</li>
</ul>
</li>
</ul>
<h5 id="MotionEvent和TouchSlop"><a href="#MotionEvent和TouchSlop" class="headerlink" title="MotionEvent和TouchSlop"></a>MotionEvent和TouchSlop</h5><ul>
<li>通过MotionEvent我们可以得到点击事件发生的坐标。</li>
<li>getX和getY得到的是相对于当前View的坐标</li>
<li>getRawX和getRawY是相对于屏幕的坐标</li>
<li>TouchSlop是系统所能识别出的被认为是滑动的最小距离，下面是获取的方式：<ul>
<li>ViewConfiguration.get(getContext()).getScaledTouchSlop();</li>
</ul>
</li>
</ul>
<h5 id="VeloccityTracker和GuestureDetector和Scroller"><a href="#VeloccityTracker和GuestureDetector和Scroller" class="headerlink" title="VeloccityTracker和GuestureDetector和Scroller"></a>VeloccityTracker和GuestureDetector和Scroller</h5><ul>
<li>VelocityTracker：速度追踪，用于追踪手指在滑动中的速度</li>
<li>使用：首先在View的onTouchEvent方法中追踪当前事件的速度：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</div><div class="line">        velocityTracker.addMovement(event);</div><div class="line">        velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">int</span> xv = (<span class="keyword">int</span>) velocityTracker.getXVelocity();</div><div class="line">        <span class="keyword">int</span> yv = (<span class="keyword">int</span>) velocityTracker.getYVelocity();</div></pre></td></tr></table></figure>
<ul>
<li>注意：获取速度之前必须计算速度；第二点：这里的速度指的是一段时间内手指所划过的像素数</li>
<li>最后不用的时候，应当调用clear和recycle来回收</li>
</ul>
<h5 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h5><ul>
<li>使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GestureDetector detector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//解决长按屏幕后无法拖动的现象</span></div><div class="line">        detector.setIsLongpressEnabled(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">boolean</span> resume = detector.onTouchEvent(event);</div><div class="line">        <span class="keyword">return</span> resume;</div></pre></td></tr></table></figure>
<ul>
<li>首先创建一个对象，并实现其监听接口，接着在接管View的onTouchEvent方法中，接管该事件</li>
</ul>
<h5 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h5><ul>
<li>实现View的滑动有三种方式：<ul>
<li>View自身提供的scrollerTo/scrollerBy </li>
<li>通过动画平移</li>
<li>改变View的layoutParams</li>
</ul>
</li>
<li>scrollerTo/scrollerBy</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Set the scrolled position of your view. This will cause a call to</div><div class="line">   * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line">   * invalidated.</div><div class="line">   * <span class="doctag">@param</span> x the x position to scroll to</div><div class="line">   * <span class="doctag">@param</span> y the y position to scroll to</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line">          <span class="keyword">int</span> oldX = mScrollX;</div><div class="line">          <span class="keyword">int</span> oldY = mScrollY;</div><div class="line">          mScrollX = x;</div><div class="line">          mScrollY = y;</div><div class="line">          invalidateParentCaches();</div><div class="line">          onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class="line">          <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">              postInvalidateOnAnimation();</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Move the scrolled position of your view. This will cause a call to</div><div class="line">   * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</div><div class="line">   * invalidated.</div><div class="line">   * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</div><div class="line">   * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      scrollTo(mScrollX + x, mScrollY + y);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>scrollTo是绝对滑动</li>
<li>scrollBy是相对于自身位置滑动</li>
<li>在滑动过程中，mScrollX的值等于View左边缘和View内容左边缘的水平距离，而mscrollY的值总是等于View上边缘和内容边缘在竖直方向上的距离</li>
<li>使用这两种方法不能使得View本身滑动，只能是内容滑动</li>
<li>使用动画：</li>
<li>改变布局参数：通过改变Margin来滑动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) mFriends.getLayoutParams();</div><div class="line">   params.width += <span class="number">10</span>;</div><div class="line">   </div><div class="line">   params.leftMargin += <span class="number">10</span>;</div><div class="line">   </div><div class="line">   mFriends.requestLayout();</div></pre></td></tr></table></figure>
<ul>
<li><p>总结：</p>
<ul>
<li>scrollTo/scrollBy：操作简单，适合对View内容的滑动</li>
<li>动画：操作简单。主要适合用于没有交互的View和实现复杂的动画效果</li>
<li>改变布局参数：操作稍微复杂，用于有交互的View</li>
</ul>
</li>
</ul>
<h5 id="实现弹性滑动"><a href="#实现弹性滑动" class="headerlink" title="实现弹性滑动"></a>实现弹性滑动</h5><ul>
<li>使用Scroller</li>
<li>用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(<span class="keyword">this</span>);</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> desX, <span class="keyword">int</span> desY)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">        <span class="keyword">int</span> deltaX = desX - scrollX;</div><div class="line">        mScroller.startScroll(scrollX, <span class="number">0</span>, deltaX, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">        mFriends.invalidate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(mScroller.computeScrollOffset()) &#123;</div><div class="line">            mFriends.scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">            mFriends.postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先构造一个Scroller对象，接着调用它的startScroll，但是该方法内部知识保存了几个传递的参数</li>
<li>让View是实现弹性滑动的是invalidate（），该方法或导致View的重绘，在View的draw中又会去调用computeScroll，而computeScroll是我们自己实现的一个方法，在computeScroll中又会去获得当前的scrollX， scrollY，然后通过scrollTo实现滑动，接着又调用postInvalidate再进行重绘，如此反复，直到滑动完成</li>
<li>computeScrollOffset：该方法通过计算时间的流逝来计算出当前scrollX和scrollY的值，类似插值器的工作原理</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>Scroller本身并不能够实现View的滑动，它需要配合View的computerScroll来实现弹性滑动，它不断地让View重绘，而每次重绘距滑动起始时间会有一个间隔，通过这个时间间隔Scroller就可以得出View当前的滑动位置，知道了滑动位置就可以通过scrollTo来实现滑动。就这样，每次View的重绘都会导致View进行小幅度的滑动，而多次的小滑动就组成了View的弹性滑动 </li>
<li>使用动画：</li>
<li>使用延时策略：通过使用Handler来实现</li>
</ul>
<h5 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h5><ul>
<li>相关的三个重要的方法：<ul>
<li>public boolean dispatchTouchEvent(MotionEvent event)：用于进行事件的分发。如果时间能够传递给当前的View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent（）方法的影响，表示是否消费当前事件</li>
<li>public boolean onInterceptHoverEvent(MotionEvent event)：在上述方法内部调用，用于判断是不是要拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被调用，返回结果表示是否拦截当前事件。</li>
<li>public boolean onTouchEvent(MotionEvent event)：在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否拦截当前事件，如果不消耗，那么在同一个事件序列当中，当前View将无法接受到事件</li>
</ul>
</li>
<li>概述：对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent会被调用，如果这个ViewGroup的onInterceptHoverEvent返回true表示它要拦截当前事件，接着该事件就会交给这个ViewGroup处理，即它的onTouchEvent会被调用；如果返回false表示不拦截此事件，这时该事件会传给它的子View，接着子View的dispatchTouchEvent会被调用，如此直到该事件被最终处理</li>
</ul>
<h5 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h5><p>1.Activity对点击事件的分发过程</p>
<ul>
<li>当一个点击事件发生时，事件最先传递给当前的Activity，由该Activity的dispatchTouchEvent来进行事件派发，具体的是又Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（framelayout），通过Activity.getWindow().getDecorView()可以获得。 下面是Activity的dispatchTouchEvent的源码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            onUserInteraction();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先事件开始交给Activity所依附的Window进行分发，如果返回true的话，整个事件循环就结束了，返回false的话意味着事件没有人处理，所有的View都返回onTouchEvent都返回false，那么Activity的onTouchEvent就会被调用。</li>
<li>接下来看Window是怎么样传给ViewGroup对象的，首先Window是一个抽象类，superDispatchTouchEvent方法也是抽象方法，其具体实现类是PhoneWindow，那么我们来看看其superDispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>PhoneWindow将事件直接传递给DecorView，我们来看看DecorView是什么？</li>
<li>我们知道，通过getWindow（）.getDecorView().findViewById(android.R.id.content).getChildAt(0)这种方式就可以获取Activity所设置的View，这个mDecorView显然就是getWindow().getDecorView()返回的View，而我们通过setContentView（）就是它的一个子View</li>
<li>在这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般说的是ViewGroup</li>
</ul>
<h5 id="顶级View对点击事件的分发过程"><a href="#顶级View对点击事件的分发过程" class="headerlink" title="顶级View对点击事件的分发过程"></a>顶级View对点击事件的分发过程</h5><ul>
<li>首先看看其dispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check for interception.</span></div><div class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">                   intercepted = onInterceptTouchEvent(ev);</div><div class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   intercepted = <span class="keyword">false</span>;</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">               <span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">               intercepted = <span class="keyword">true</span>;</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<ul>
<li>从上面的代码可以看出，在两种情况下ViewGroup会拦截此事件：事件类型为：ACTION_DOWN或者mFirstTouchTarget ！= null。当是事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向该子元素。</li>
<li>也就是说，当ViewGroup不拦截事件并将事件交给子元素处理时，mFirstTouchTarget ！= null。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget ！= null就不成立。</li>
<li>那么当MOVE和UP事件传递过来的时候，由于（actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null）为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其他事件都会默认交给它处理</li>
<li>还有一种特殊情况，那就是 FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceptTouchEvent来设置的，一旦被设置后，ViewGroup将无法拦截除了DOWN事件以外的点击事件。这时因此ViewGroup在分发事件时，如果是DOWN事件的话就会重置这个标记位，将导致子View中设置的标记无效，面对DOWN事件，ViewGroup总会询问自己是不是要拦截：</li>
<li>小结：当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理，并且不再调用onInterceptTouchEvent。FLAG_DISALLOW_INTERCEPT这个标记的作用是让ViewGroup不再拦截事件，</li>
<li>接着看ViewGroup不拦截事件的时候，事件会向下分发交给它的子View进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> View[] children = mChildren;</div><div class="line">                      <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                          <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">                                  ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">                          <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                                  ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line"></div><div class="line">                          <span class="comment">// If there is a view that has accessibility focus we want it</span></div><div class="line">                          <span class="comment">// to get the event first and if not handled we will perform a</span></div><div class="line">                          <span class="comment">// normal dispatch. We may do a double iteration but this is</span></div><div class="line">                          <span class="comment">// safer given the timeframe.</span></div><div class="line">                          <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">                              <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                  <span class="keyword">continue</span>;</div><div class="line">                              &#125;</div><div class="line">                              childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">                              i = childrenCount - <span class="number">1</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">                                  || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">                              ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                              <span class="keyword">continue</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          newTouchTarget = getTouchTarget(child);</div><div class="line">                          <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                              <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">                              <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">                              newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                              <span class="keyword">break</span>;</div><div class="line">                          &#125;</div><div class="line"></div><div class="line">                          resetCancelNextUpFlag(child);</div><div class="line">                          <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                              <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">                              mLastTouchDownTime = ev.getDownTime();</div><div class="line">                              <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                                  <span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">                                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                                      <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                          mLastTouchDownIndex = j;</div><div class="line">                                          <span class="keyword">break</span>;</div><div class="line">                                      &#125;</div><div class="line">                                  &#125;</div><div class="line">                              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                  mLastTouchDownIndex = childIndex;</div><div class="line">                              &#125;</div><div class="line">                              mLastTouchDownX = ev.getX();</div><div class="line">                              mLastTouchDownY = ev.getY();</div><div class="line">                              newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                              alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                              <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>首先遍历ViewGroup所有子View，然后判断子View是不是能够接收点击事件。是否能够接收点击事件主要由两点来衡量：子元素是否在播放动画和点击事件的坐标是不是落在子元素的区域。如果子View满足两个条件的话，那么事件将交给它处理，</li>
<li>实际调用子元素的dispatchTouchEvent是在dispatchTransformedTouchEvent中，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">           View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line"></div><div class="line">       <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></div><div class="line">       <span class="comment">// or filtering.  The important part is the action, not the contents.</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">       <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">           event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">           <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">               handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               handled = child.dispatchTouchEvent(event);</div><div class="line">           &#125;</div><div class="line">           event.setAction(oldAction);</div><div class="line">           <span class="keyword">return</span> handled;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果传递的字View不为null的话，就会调用子View的dispatchTouchEvent，这样事件就交给子View处理了</li>
<li>如果子View的dispatchTouchEvent返回true的话，那么mFirstTouchTarget就会被赋值并跳出循环：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                                <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码完成了对mFirstTouchTarget赋值并终止了对子View的遍历。</li>
<li>如果子View返回false的话，ViewGroup会将事件分给下一个子View（还有下一个子 View的话）</li>
<li>如果遍历所有子View后事件都没有被合适处理，这包含两种情况： <ul>
<li>ViewGroup没有子View</li>
<li>子元素处理了点击事件，但是在dispatchTouchEvent中返回false。 </li>
</ul>
</li>
<li>上面这两种情况下ViewGroup会自己处理点击事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dispatch to touch targets.</span></div><div class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                       TouchTarget.ALL_POINTER_IDS);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面的代码中第三个参数为null，显然调用super.dispatchTouchEvent</li>
</ul>
<h5 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a>View对点击事件的处理过程</h5><ul>
<li>先看看其dispatchTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">    ListenerInfo li = mListenerInfo;</div><div class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">    mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></div><div class="line"><span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></div><div class="line"><span class="comment">// of the gesture.</span></div><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</div><div class="line">        actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class="line">        (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class="line">    stopNestedScroll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<ul>
<li>可以看到，首先会判断有没有设置OnTouchEventListener，如果OnTouchEventListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，这样做的好处是方便外界处理点击事件</li>
<li>接下来分析onTouchEvent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">        setPressed(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">    <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">    <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面是View在不可用的状态下点击事件的处理过程，显然不可用的View照样会消费事件，只是没有为点击做出回应</li>
<li>下面看看onTouchEvent对点击事件的具体处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">               (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">               (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">           <span class="keyword">switch</span> (action) &#123;</div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                   <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                   <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</div><div class="line">                       <span class="comment">// take focus if we don't have it already and we should in</span></div><div class="line">                       <span class="comment">// touch mode.</span></div><div class="line">                       <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                           focusTaken = requestFocus();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                           <span class="comment">// The button is being released before we actually</span></div><div class="line">                           <span class="comment">// showed it as pressed.  Make it show the pressed</span></div><div class="line">                           <span class="comment">// state now (before scheduling the click) to ensure</span></div><div class="line">                           <span class="comment">// the user sees it.</span></div><div class="line">                           setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                           <span class="comment">// This is a tap, so remove the longpress check</span></div><div class="line">                           removeLongPressCallback();</div><div class="line"></div><div class="line">                           <span class="comment">// Only perform take click actions if we were in the pressed state</span></div><div class="line">                           <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                               <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                               <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                               <span class="comment">// of the view update before click actions start.</span></div><div class="line">                               <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                   mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                               &#125;</div><div class="line">                               <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                   performClick();</div><div class="line">                               &#125;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                           mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                           postDelayed(mUnsetPressedState,</div><div class="line">                                   ViewConfiguration.getPressedStateDuration());</div><div class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                           <span class="comment">// If the post failed, unpress right now</span></div><div class="line">                           mUnsetPressedState.run();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       removeTapCallback();</div><div class="line">                   &#125;</div><div class="line">                   mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                   mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class="line">                   <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                   <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class="line">                   <span class="comment">// a short period in case this is a scroll.</span></div><div class="line">                   <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                       mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                       <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                           mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                       &#125;</div><div class="line">                       mPendingCheckForTap.x = event.getX();</div><div class="line">                       mPendingCheckForTap.y = event.getY();</div><div class="line">                       postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></div><div class="line">                       setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                       checkForLongClick(<span class="number">0</span>);</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                   setPressed(<span class="keyword">false</span>);</div><div class="line">                   removeTapCallback();</div><div class="line">                   removeLongPressCallback();</div><div class="line">                   mInContextButtonPress = <span class="keyword">false</span>;</div><div class="line">                   mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                   mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                   drawableHotspotChanged(x, y);</div><div class="line"></div><div class="line">                   <span class="comment">// Be lenient about moving outside of buttons</span></div><div class="line">                   <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                       <span class="comment">// Outside button</span></div><div class="line">                       removeTapCallback();</div><div class="line">                       <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                           <span class="comment">// Remove any future long press/tap checks</span></div><div class="line">                           removeLongPressCallback();</div><div class="line"></div><div class="line">                           setPressed(<span class="keyword">false</span>);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>只要View的CLICKABLE和LONG——CLICKABLE有一个为true的话，那么它就会消费这个事件，即onTouchEvent返回true，不管状态是不是DISABLE状态。然后就是当ACTION_UP事件发生时，就会出发performClick，如果View设置了OnClickListener的话，performClick内部就会调用onClick</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">*/</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">     <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">     <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">         playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">         li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">         result = <span class="keyword">true</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         result = <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>View的LONG_CLICKABLE默认设置为false，而CLICKABLE则要看具体的View，可点击的View的CLICKABLE为true，不可点击的为false。</li>
<li><p>setOnClickListener会自动将View的CLICKABLE设置为true，setOnLongClickListener也会将View的LONG_CLICKABLE设置为true，在源码可以找到，这里就不贴代码了。</p>
</li>
<li><p>结论：</p>
<ul>
<li>正常情况下，一个事件序列只能被一个View拦截且消费，因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一事件序列中的事件不能分别由两个View同时处理，但是通过特殊的手段可以实现，比如一个View将本该自己处理的事件通过onTouchEvent返回false，强行传给其他View </li>
<li>某个View一旦决定拦截，那么一个事件序列都只能有它处理，并且onInterceptTouchEvent不会被调用。 </li>
<li>某个View一旦开始处理事件，如果不消耗ACTION_DOWN事件，那么同一事件序列中的其他事件都不会交给它处理，并且事件将重新交给父元素去处理。</li>
<li>如果View不消耗ACTION_DOWN以外的事件，那么这个点击事件会消失，此时父元素的onTouchEvent不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件由Activity来处理。 </li>
<li>ViewGroup内部默认不拦截事件 </li>
<li>View中不能拦截事件，一旦有事件交给它，它的onTouchEvent就会被调用</li>
<li>View的onTouchEvent都默认消费事件，除非它是不可点击的。</li>
<li>View的enable不影响onTouchEvent的默认返回值。</li>
<li>onClick的发生前提时当前View可点击，并且它收到了down和up事件</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，容纳后再由父元素进行分发，通过requestDisalowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发，但是ACTION_DOWN除外</li>
</ul>
</li>
</ul>
<h5 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h5><ul>
<li>在界面中，只要内外两层同时可以滑动，这个时候就会产生滑动冲突</li>
</ul>
<h5 id="常见的滑动冲突场景："><a href="#常见的滑动冲突场景：" class="headerlink" title="常见的滑动冲突场景："></a>常见的滑动冲突场景：</h5><ul>
<li>外部滑动和内部滑动方向不一致；</li>
<li>外部滑动方向和内部滑动方向一致；</li>
<li>上面两种情况的嵌套。</li>
</ul>
<h5 id="滑动冲突的处理规则"><a href="#滑动冲突的处理规则" class="headerlink" title="滑动冲突的处理规则"></a>滑动冲突的处理规则</h5><ul>
<li>对于场景一，处理的规则是：当用户左右（上下）滑动时，需要让外部的View拦截点击事件，当用户上下（左右）滑动的时候，需要让内部的View拦截点击事件。根据滑动的方向判断谁来拦截事件。</li>
<li>对于场景二，由于滑动方向一致，这时候只能在业务上找到突破点，根据业务需求，规定什么时候让外部View拦截事件，什么时候由内部View拦截事件。</li>
<li>场景三的情况相对比较复杂，同样根据需求在业务上找到突破点。</li>
</ul>
<h5 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h5><ul>
<li>外部拦截法：所谓的外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。下面是伪代码：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">     <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line">     <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line">     </div><div class="line">     <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">       <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">  </div><div class="line">      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">           <span class="keyword">if</span> (父容器需要当前事件）&#123;</div><div class="line">               intercepted = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               intercepted = flase;</div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">       &#125;    </div><div class="line">      </div><div class="line">      <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">          intercepted = <span class="keyword">false</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      </div><div class="line">      <span class="keyword">default</span>:</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLastXIntercept=x;</div><div class="line">    mLastYIntercept=y;</div><div class="line">    <span class="keyword">return</span> intercepted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>内部拦截法：内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗，否则就交由父容器进行处理。这种方法与Android事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。下面是伪代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent even)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) even.getX();</div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) even.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (even.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                parent.requestDisallowIntercepttouchEvent(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</div><div class="line">                <span class="keyword">int</span> deltaY = x - mLastY;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(父容器需要此类点击事件) &#123;</div><div class="line">                    parent.requestDisallowIntercepttouchEvent(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            mLastX = x;</div><div class="line">            mLastY = y;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(even);</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>除了子元素需要做处理外，父元素也要默认拦截ACTION_DOWN以外的事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需要的事件，因此，父元素需要修改：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent even)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> action = even.getAction();</div><div class="line">	<span class="keyword">if</span>(about == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android%20-%20%E5%89%AF%E6%9C%AC%20(10)/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android%20-%20%E5%89%AF%E6%9C%AC%20(9)/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android%20-%20%E5%89%AF%E6%9C%AC%20(8)/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android%20-%20%E5%89%AF%E6%9C%AC%20(7)/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android%20-%20%E5%89%AF%E6%9C%AC%20(6)/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android%20-%20%E5%89%AF%E6%9C%AC%20(5)/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android%20-%20%E5%89%AF%E6%9C%AC%20(4)/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓开发艺术探索-View的工作原理（一）-笔记]]></title>
      <url>http://yoursite.com/2016/10/08/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h4 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h4><hr>
<h5 id="初始ViewRoot和DecorView"><a href="#初始ViewRoot和DecorView" class="headerlink" title="初始ViewRoot和DecorView"></a>初始ViewRoot和DecorView</h5><ul>
<li><p>ViewRoot对应的实体类是ViewRootImpl类，它时连接WindowManager和DecorView的纽带</p>
</li>
<li><p>View的三大流程都是通过ViewRoot完成的</p>
</li>
<li><p>在ActivityThread中，当Activity对象被创建后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewImpl对象和DecorView建立关联：</p>
<a id="more"></a>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext, display);</div><div class="line">root.setView(view, wparams, panelParentView);</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>View的绘制流程是从ViewRoot的performTraversals中开始的，它经过measure，layout，draw三个过程。</p>
</li>
<li><p>performTraversals大致流程：</p>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>childLayoutParams\parentSpecMode</th>
<th>ECACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp/px</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
<td>EXACTLY/childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST/parentSize</td>
<td>AT_MOST/parentSize</td>
<td>UNSPECIFIED/0</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><p>DecorView作为顶级View，本质是一个LinearLayout，该layout中一般情况下包含标题栏和内容栏。</p>
</li>
<li><p>在Activity中，我们setContentView所设置的布局，其实就是被加到内容栏中的</p>
</li>
</ul>
<hr>
<h5 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h5><p>MeasureSpec很大程度上决定了一个View的尺寸规格，之所以说很大程度，其实时因为在这个过程中还受父容器的影响，父容器回影响View的MeasureSpec的创建。</p>
<ul>
<li><p>MeasureSpec代表一个32位的int值，高2位代表SpecMode：测量模式，低30位表示SpecSize：在某种模式下的测量规格。</p>
</li>
<li><p>在下面的源码中，MeasureSpec将SpecMode和SpecSize打包成一个int值来避免过多对象内存的分配。为了方便操作提供了打包和解包的方法</p>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has not imposed any constraint</div><div class="line">         * on the child. It can be whatever size it wants.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The parent has determined an exact size</div><div class="line">         * for the child. The child is going to be given those bounds regardless</div><div class="line">         * of how big it wants to be.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Measure specification mode: The child can be as large as it wants up</div><div class="line">         * to the specified size.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Like &#123;<span class="doctag">@link</span> #makeMeasureSpec(int, int)&#125;, but any spec with a mode of UNSPECIFIED</div><div class="line">         * will automatically get a size of 0. Older apps expect this.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@hide</span> internal use only for compatibility with system widgets and older apps</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the mode from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the mode from</div><div class="line">         * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#UNSPECIFIED&#125;,</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#AT_MOST&#125; or</div><div class="line">         *         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec#EXACTLY&#125;</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Extracts the size from the supplied measure specification.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> measureSpec the measure specification to extract the size from</div><div class="line">         * <span class="doctag">@return</span> the size in pixels defined in the supplied measure specification</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</div><div class="line">            <span class="keyword">int</span> size = getSize(measureSpec);</div><div class="line">            <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</div><div class="line">                <span class="comment">// No need to adjust size for UNSPECIFIED mode.</span></div><div class="line">                <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            size += delta;</div><div class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">                Log.e(VIEW_LOG_TAG, <span class="string">"MeasureSpec.adjust: new size would be negative! ("</span> + size +</div><div class="line">                        <span class="string">") spec: "</span> + toString(measureSpec) + <span class="string">" delta: "</span> + delta);</div><div class="line">                size = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> makeMeasureSpec(size, mode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>SpecMode有三类：</p>
<ul>
<li><p>UNSPECIFIED：父容器不对View有限制，这种情况一般用于系统内部，表示一种测量的状态</p>
</li>
<li><p>EXACTLY：父容器已经检验出View所需要的大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式</p>
</li>
<li><p>AT_MOST:父容器指定了一个可用的大小，即SpecSize，View的大小不能大于这个值。它对应于LayoutParams中的wrap_content</p>
</li>
</ul>
</li>
<li><p>MeasureSpec和LayoutParams的对应关系</p>
<ul>
<li><p>正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParams。在View测量的时候，系统会将LayoutParams在父容器的约束下转为对应的MeasureSpec，然后再根据这个MeasureSpec来确定View的宽高</p>
</li>
<li><p>LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽高</p>
</li>
<li><p>对于顶级View（DecorView）和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定</p>
</li>
<li><p>DecorView的MeasureSpec创建过程是在ViewRootImpl中的measureHierarchy方法创建的：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>接着看看getRootMeasureSpec：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;pre style="background-color:#21282d;color:#e0e2e4;font-family:'Courier New';font-size:15.0pt;"&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class="line"> int measureSpec;</div><div class="line"> switch (rootDimension) &#123;</div><div class="line"></div><div class="line"> case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line"> // Window can't resize. Force root view to be windowSize.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line"> case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line"> // Window can resize. Set max size for root view.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line"> break;</div><div class="line"> default:</div><div class="line"> // Window wants to be an exact size. Force root view to be that size.</div><div class="line"> measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line"> break;</div><div class="line">&#125;  return measureSpec;&lt;/pre&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>LayoutParams.MATCH_PARENT:精确模式，大小就是窗口的大小；</p>
</li>
<li><p>LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小</p>
</li>
<li><p>固定大小：精确模式，大小为LayoutParams中指定的大小。</p>
</li>
</ul>
<hr>
<ul>
<li>对于普通View来说（指的时我们布局中的View），它的measure过程是由ViewGroup传递过来的，下面看看ViewGroup中的measureChildWithMargins：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">           <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">       <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                       + widthUsed, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                       + heightUsed, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>从上面代码来看，子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，此外还有与View的margin和padding有关，下面再看看ViewGroup的getChildMeasureSpec：</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">      <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">      <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">      <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">              <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">              <span class="comment">// bigger than us.</span></div><div class="line">              resultSize = size;</div><div class="line">              resultMode = MeasureSpec.AT_MOST;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">      <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">              resultSize = childDimension;</div><div class="line">              resultMode = MeasureSpec.EXACTLY;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">              <span class="comment">// be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">              <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">              <span class="comment">// big it should be</span></div><div class="line">              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">              resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>从上面的方法来看，它的主要作用时结合父容器发MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，参数中的padding指的是父容器中已被占用的空间大小。</p>
</li>
<li><p>下面的表是对getChildMeasureSpec的工作原理的梳理，其中parentSize指的是父容器中目前可以使用的大小。</p>
</li>
</ul>
<hr>
<p><img src="index_files/f78c4596-e57c-41be-a3ca-a75bdcd06778.jpg" alt=""></p>
<h4 id="View的工作过程"><a href="#View的工作过程" class="headerlink" title="View的工作过程"></a>View的工作过程</h4><h5 id="View的measure过程："><a href="#View的measure过程：" class="headerlink" title="View的measure过程："></a>View的measure过程：</h5><ul>
<li>measure方法时一个final方法，则意味着不能重写该方法，在该方法中会调用View的onMeasure方法（真正测量的方法）， 下面我们看看onMeasure的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">  getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setMeasureDimension方法中会设置View的宽高的测量值，因此，我们来看看getDefaultSize方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = size;</div><div class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">  result = size;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">  <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">  result = specSize;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"> &#125;  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于我我们来说，我们只看AT_MOST和EXACTLY这两种情况。简单的理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，这个specSize就是测量后View的大小，这里说时是测量后，是因为View的最终大小是在layout阶段确定的，除了特殊情况外，View的测量大小和最终大小是相等的。</p>
<ul>
<li>对于UNSPECIFIED来说，一般用于系统内部测量，在这种情况下，View的大小为getDefaultSize第一个参数size，即分别为getSuggestedMinimumWidth/Height：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果View没有设置背景，那么View的高度为mMinHeight，而该属性对应于aandroid：minWidth，如果这个属性不指定的话，默认为0。如果设置了背景则返回minHeight和背景的最小高度中的最大值</p>
<ul>
<li><p>从getDefaultSize的实现来看，我们可以得到以下小结：</p>
<ul>
<li><p>直接继承View的自定义控件需要重写onMeasure方法设置wrap_content时的自身大小，否则在布局中使用就相当于match_parent</p>
</li>
<li><p>通过之前分析，如果View在布局中被设为wrap_content的话，它的specMode时AT_MOST模式，此时它的宽高等于specSize，而View的specSize是parentSize，parentSize是父容器目前所剩余的空间大小。这样这种效果就相当于match_parent</p>
</li>
<li><p>解决方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"> <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"> <span class="keyword">int</span> widthSpecMode = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> widthSpecSize = View.MeasureSpec.getMode((widthMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecMode = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">int</span> heightSpecSize = View.MeasureSpec.getMode((heightMeasureSpec));</div><div class="line"> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, mHeight);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(widthSpecMode == View.MeasureSpec.AT_MOST) &#123;</div><div class="line"> setMeasureDimension(mWidth, heightSpecSize);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(heightSpecMode == View.MeasureSpec.AT_MOST)&#123;</div><div class="line"> setMeasureDimension(widthSpecSize, mHeight);</div><div class="line"></div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于wrap_content的情形，我们直接设置我们默认的大小就可以</p>
<hr>
<h5 id="ViewGroup的measure过程："><a href="#ViewGroup的measure过程：" class="headerlink" title="ViewGroup的measure过程："></a>ViewGroup的measure过程：</h5><ul>
<li><p>ViewGroup除了测量自身的大小外，还会遍历所有的子元素的measure方法，各个子元素再递归去执行这个过程</p>
</li>
<li><p>ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但是提供了一个measureChildren的方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码来看，ViewGroup在meaure的时候，会对每个子元素进行measure，下面来看看measureChild：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">           <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">               mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">               mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>meaureChild中，就是取出子元素的LayoutParams，然后通过getChildMeasureSpec来创建子元素的MeasureSpec。将MeaureSpec直接传递给View的meaure进行测量。</p>
<ul>
<li><p>我们知道ViewGroup是一个抽象类，并没有实现具体的测量过程，所以，我们来看看它子类中的实现，下面用LinearLayout来当例子</p>
</li>
<li><p>首先先来看看其onMeasure方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面代码中，根据不同的布局方向来测量，我们选择来看竖直方向的测量过程中的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// See how tall everyone is. Also remember max width.</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">          <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">              mTotalLength += measureNullChild(i);</div><div class="line">              <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">             i += getChildrenSkipCount(child, i);</div><div class="line">             <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">              mTotalLength += mDividerHeight;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">          totalWeight += lp.weight;</div><div class="line">          </div><div class="line">          <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// Optimization: don't bother measuring children who are going to use</span></div><div class="line">              <span class="comment">// leftover space. These views will get measured again down below if</span></div><div class="line">              <span class="comment">// there is any leftover space.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class="line">              skippedMeasure = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></div><div class="line">                  <span class="comment">// child wanted to stretch to fill available space.</span></div><div class="line">                  <span class="comment">// Translate that to WRAP_CONTENT so that it does not end up</span></div><div class="line">                  <span class="comment">// with a height of 0</span></div><div class="line">                  oldHeight = <span class="number">0</span>;</div><div class="line">                  lp.height = LayoutParams.WRAP_CONTENT;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// Determine how big this child would like to be. If this or</span></div><div class="line">              <span class="comment">// previous children have given a weight, then we allow it to</span></div><div class="line">              <span class="comment">// use all available space (and we will shrink things later</span></div><div class="line">              <span class="comment">// if needed).</span></div><div class="line">              measureChildBeforeLayout(</div><div class="line">                     child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</div><div class="line">                     totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">                 lp.height = oldHeight;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">              mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                     lp.bottomMargin + getNextLocationOffset(child));</div></pre></td></tr></table></figure>
<p>系统会遍历每个子元素，并且对每个子元素进行measureChildBeforeLayout，这个方法会调用子元素的measure，这样就开始了measure过程，并且系统会通过mToatalLength这个变量来保存LinearLayout在竖直方向上的初步高度，当测量完子元素时，LinearLauout会测量自己的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add in our padding</span></div><div class="line">       mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> heightSize = mTotalLength;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum height</span></div><div class="line">       heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line">       </div><div class="line">       <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></div><div class="line">       <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">       heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line">       </div><div class="line">       <span class="comment">// Either expand children with weight to take up available space or</span></div><div class="line">       <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></div><div class="line">       <span class="comment">// measurement on any children, we need to measure them now.</span></div><div class="line">       <span class="keyword">int</span> delta = heightSize - mTotalLength;</div><div class="line">       <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">           <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line"></div><div class="line">           mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">               <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line">               </div><div class="line">               LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">               </div><div class="line">               <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">               <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                   <span class="comment">// Child said it could absorb extra space -- give him his share</span></div><div class="line">                   <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">                   weightSum -= childExtra;</div><div class="line">                   delta -= share;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                           mPaddingLeft + mPaddingRight +</div><div class="line">                                   lp.leftMargin + lp.rightMargin, lp.width);</div><div class="line"></div><div class="line">                   <span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">                   <span class="comment">// child has been previously measured</span></div><div class="line">                   <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != MeasureSpec.EXACTLY)) &#123;</div><div class="line">                       <span class="comment">// child was measured once already above...</span></div><div class="line">                       <span class="comment">// base new measurement on stored values</span></div><div class="line">                       <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</div><div class="line">                       <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</div><div class="line">                           childHeight = <span class="number">0</span>;</div><div class="line">                       &#125;</div><div class="line">                       </div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// child was skipped in the loop above.</span></div><div class="line">                       <span class="comment">// Measure for this first time here      </span></div><div class="line">                       child.measure(childWidthMeasureSpec,</div><div class="line">                               MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// Child may now not fit in vertical dimension.</span></div><div class="line">                   childState = combineMeasuredStates(childState, child.getMeasuredState()</div><div class="line">                           &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</div><div class="line">               maxWidth = Math.max(maxWidth, measuredWidth);</div><div class="line"></div><div class="line">               <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</div><div class="line">                       lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                       matchWidthLocally ? margin : measuredWidth);</div><div class="line"></div><div class="line">               allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</div><div class="line"></div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">               mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</div><div class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Add in our padding</span></div><div class="line">           mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">           <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                                          weightedMaxWidth);</div><div class="line"></div><div class="line"></div><div class="line">           <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></div><div class="line">           <span class="comment">// Children will have already been measured once.</span></div><div class="line">           <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                   <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">                       <span class="keyword">continue</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                           (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                   <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">                   <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                       child.measure(</div><div class="line">                               MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</div><div class="line">                                       MeasureSpec.EXACTLY),</div><div class="line">                               MeasureSpec.makeMeasureSpec(largestChildHeight,</div><div class="line">                                       MeasureSpec.EXACTLY));</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</div><div class="line">           maxWidth = alternativeMaxWidth;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       maxWidth += mPaddingLeft + mPaddingRight;</div><div class="line"></div><div class="line">       <span class="comment">// Check against our minimum width</span></div><div class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line">       </div><div class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">               heightSizeAndState);</div></pre></td></tr></table></figure>
<ul>
<li><p>分析到这里算是把measure分析完了，下面我们来看看需要注意的一些地方：</p>
<ul>
<li>如果要获取View的测量宽高或者最终宽高的话，比较好的做法是在onLayout中获取，因为在某些极端的情况下，measure可能会被多次调用，这样在onMeasure获取的宽高就不准确</li>
</ul>
</li>
<li><p>四种方法中的三种解决Activity启动时获取View的宽高</p>
<ul>
<li><p>在onWindowFocusChanged中获取： 该方法会在窗口的得到和失去焦点的时候被调用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</div><div class="line">    <span class="keyword">if</span>(hasFocus) &#123;</div><div class="line">        <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">        <span class="keyword">int</span> heigh = view.getMeasureHeight();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>view.post(runnable):将一个runnable投递到消息队列尾部，等待Looper调用此runnable的时候，View已经初始化完成了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        view.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ViewTreeObserver：使用其中的OnGlobalLayoutListener这个接口，当View状态或者View树内部的View可见性发现改变时，onGlobalLayout会被回调。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line"></div><div class="line">        ViewTreeObserver observer = view.getViewTreeObserver();</div><div class="line">        observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">                view.getViewTreeObserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">int</span> width = view.getMeasureWidth();</div><div class="line">                <span class="keyword">int</span> height = view.getMeasureHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h5><ul>
<li>先看看View的layout方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在layout中首先会通过setFrame方法来设定View的四个顶点位置，即初始化mLeft， mRight， mTop， mBottom，view的顶点确定后，那么View在ViewGroup中的位置也相应的确定；接着调用onLayout的方法，该方法的具体实现是在ViewGroup的子类中，我们来看看LinearLayout中是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">           layoutVertical(l, t, r, b);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           layoutHorizontal(l, t, r, b);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们只拿竖直方向上的来分析：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> childTop;</div><div class="line">        <span class="keyword">int</span> childLeft;</div><div class="line">        </div><div class="line">        <span class="comment">// Where right end of child should go</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</div><div class="line">        <span class="keyword">int</span> childRight = width - mPaddingRight;</div><div class="line">        </div><div class="line">        <span class="comment">// Space available for child</span></div><div class="line">        <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</div><div class="line">        </div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (majorGravity) &#123;</div><div class="line">           <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">           <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">           <span class="keyword">case</span> Gravity.TOP:</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                childTop += measureNullChild(i);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">                </div><div class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> gravity = lp.gravity;</div><div class="line">                <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</div><div class="line">                    gravity = minorGravity;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</div><div class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</div><div class="line">                                + lp.leftMargin - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</div><div class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">case</span> Gravity.LEFT:</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        childLeft = paddingLeft + lp.leftMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                    childTop += mDividerHeight;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                childTop += lp.topMargin;</div><div class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                        childWidth, childHeight);</div><div class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line"></div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此方法会遍历所有子元素并调用setChildFrame来为子元素指定相应的位置，该方法中调用了子元素的layout方法，这样就实现了View的一层层测量。</p>
<ul>
<li><p>分析完了layout，我们来看看哪些需要注意的地方：</p>
<ul>
<li>View的getMeasureWidth和getWidth有什么区别：我们首先来看看getWidth的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> mRight - mLeft;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在View的默认实现过程中，View的测量宽高和最终宽高时相等的，只不过两者的赋值时机不同而已，测量宽高是在measure，而最终宽高是在layout。</p>
</li>
</ul>
<hr>
<h5 id="draw过程："><a href="#draw过程：" class="headerlink" title="draw过程："></a>draw过程：</h5><ul>
<li><p>View的绘制过程遵循下面这几步：</p>
<ul>
<li>绘制自己的背景（bakcground.draw(canvas)）</li>
<li>绘制自己（onDraw）</li>
<li>绘制children（dispatchDraw）</li>
<li>绘制装饰（onDrawScrollBars）</li>
</ul>
</li>
<li><p>上面的这个步骤可以在draw源码中看出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">               (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">       <span class="comment">/*</span></div><div class="line">        * Draw traversal performs several drawing steps which must be executed</div><div class="line">        * in the appropriate order:</div><div class="line">        *</div><div class="line">        *      1. Draw the background</div><div class="line">        *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">        *      3. Draw view's content</div><div class="line">        *      4. Draw children</div><div class="line">        *      5. If necessary, draw the fading edges and restore layers</div><div class="line">        *      6. Draw decorations (scrollbars for instance)</div><div class="line">        */</div><div class="line"></div><div class="line">       <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">       <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">           drawBackground(canvas);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">       <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">           <span class="comment">// Step 3, draw the content</span></div><div class="line">           <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Step 4, draw the children</span></div><div class="line">           dispatchDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">           <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">               mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">           onDrawForeground(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// we're done...</span></div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>View的绘制过程的传递时通过dispatchDraw来实现的，该方法回遍历所有子元素的draw（具体的实现实在ViewGroup的子类中），这样draw就可以一层层传递下去。View中的一个特殊方法：setWillNotDraw:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</div><div class="line">       setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>如果一个View不需要绘制任何内容的话，我们就可以把这个标记设为true。默认情况下View没有启动这个标志，但是ViewGroup会默认启动。如果我们自定义控件的时候需要继承ViewGroup时，我们就可以开启这个标记来便于系统的后续优化。</p>
<blockquote>
<p>以上的笔记来源于安卓开发艺术探索</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>http://yoursite.com/2016/10/08/android/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/10/07/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
